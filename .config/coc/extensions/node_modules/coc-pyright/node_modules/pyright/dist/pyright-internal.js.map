{"version":3,"sources":["../../pyright-internal/src/analyzer/aliasDeclarationUtils.ts","../../pyright-internal/src/analyzer/analysis.ts","../../pyright-internal/src/analyzer/analyzerNodeInfo.ts","../../pyright-internal/src/analyzer/backgroundAnalysisProgram.ts","../../pyright-internal/src/analyzer/binder.ts","../../pyright-internal/src/analyzer/checker.ts","../../pyright-internal/src/analyzer/circularDependency.ts","../../pyright-internal/src/analyzer/codeFlow.ts","../../pyright-internal/src/analyzer/commentUtils.ts","../../pyright-internal/src/analyzer/declarationUtils.ts","../../pyright-internal/src/analyzer/docStringToMarkdown.ts","../../pyright-internal/src/analyzer/docStringUtils.ts","../../pyright-internal/src/analyzer/importResolver.ts","../../pyright-internal/src/analyzer/importStatementUtils.ts","../../pyright-internal/src/analyzer/parseTreeCleaner.ts","../../pyright-internal/src/analyzer/parseTreeUtils.ts","../../pyright-internal/src/analyzer/parseTreeWalker.ts","../../pyright-internal/src/analyzer/program.ts","../../pyright-internal/src/analyzer/pythonPathUtils.ts","../../pyright-internal/src/analyzer/scope.ts","../../pyright-internal/src/analyzer/scopeUtils.ts","../../pyright-internal/src/analyzer/service.ts","../../pyright-internal/src/analyzer/sourceFile.ts","../../pyright-internal/src/analyzer/sourceMapper.ts","../../pyright-internal/src/analyzer/staticExpressions.ts","../../pyright-internal/src/analyzer/symbol.ts","../../pyright-internal/src/analyzer/symbolNameUtils.ts","../../pyright-internal/src/analyzer/symbolUtils.ts","../../pyright-internal/src/analyzer/testWalker.ts","../../pyright-internal/src/analyzer/typeCache.ts","../../pyright-internal/src/analyzer/typeDocStringUtils.ts","../../pyright-internal/src/analyzer/typeEvaluator.ts","../../pyright-internal/src/analyzer/typeStubWriter.ts","../../pyright-internal/src/analyzer/typeUtils.ts","../../pyright-internal/src/analyzer/typeVarMap.ts","../../pyright-internal/src/analyzer/types.ts","../../pyright-internal/src/backgroundAnalysis.ts","../../pyright-internal/src/backgroundAnalysisBase.ts","../../pyright-internal/src/backgroundThreadBase.ts","../../pyright-internal/src/commands/commandController.ts","../../pyright-internal/src/commands/createTypeStub.ts","../../pyright-internal/src/commands/quickActionCommand.ts","../../pyright-internal/src/commands/restartServer.ts","../../pyright-internal/src/common/cancellationUtils.ts","../../pyright-internal/src/common/collectionUtils.ts","../../pyright-internal/src/common/commandLineOptions.ts","../../pyright-internal/src/common/configOptions.ts","../../pyright-internal/src/common/console.ts","../../pyright-internal/src/common/core.ts","../../pyright-internal/src/common/debug.ts","../../pyright-internal/src/common/deferred.ts","../../pyright-internal/src/common/diagnostic.ts","../../pyright-internal/src/common/diagnosticRules.ts","../../pyright-internal/src/common/diagnosticSink.ts","../../pyright-internal/src/common/extensions.ts","../../pyright-internal/src/common/fileSystem.ts","../../pyright-internal/src/common/logTracker.ts","../../pyright-internal/src/common/pathConsts.ts","../../pyright-internal/src/common/pathUtils.ts","../../pyright-internal/src/common/positionUtils.ts","../../pyright-internal/src/common/progressReporter.ts","../../pyright-internal/src/common/pythonVersion.ts","../../pyright-internal/src/common/stringUtils.ts","../../pyright-internal/src/common/textEditUtils.ts","../../pyright-internal/src/common/textRange.ts","../../pyright-internal/src/common/textRangeCollection.ts","../../pyright-internal/src/common/timing.ts","../../pyright-internal/src/languageServerBase.ts","../../pyright-internal/src/languageService/analyzerServiceExecutor.ts","../../pyright-internal/src/languageService/autoImporter.ts","../../pyright-internal/src/languageService/callHierarchyProvider.ts","../../pyright-internal/src/languageService/codeActionProvider.ts","../../pyright-internal/src/languageService/completionProvider.ts","../../pyright-internal/src/languageService/definitionProvider.ts","../../pyright-internal/src/languageService/documentHighlightProvider.ts","../../pyright-internal/src/languageService/documentSymbolProvider.ts","../../pyright-internal/src/languageService/hoverProvider.ts","../../pyright-internal/src/languageService/importSorter.ts","../../pyright-internal/src/languageService/quickActions.ts","../../pyright-internal/src/languageService/referencesProvider.ts","../../pyright-internal/src/languageService/signatureHelpProvider.ts","../../pyright-internal/src/localization/localize.ts","../../pyright-internal/src/parser/characterStream.ts","../../pyright-internal/src/parser/characters.ts","../../pyright-internal/src/parser/parseNodes.ts","../../pyright-internal/src/parser/parser.ts","../../pyright-internal/src/parser/stringTokenUtils.ts","../../pyright-internal/src/parser/tokenizer.ts","../../pyright-internal/src/parser/tokenizerTypes.ts","../../pyright-internal/src/parser/unicode.ts","../../pyright-internal/src/pyright.ts","../../pyright-internal/src/server.ts","../../pyright-internal/src/workspaceMap.ts"],"names":["resolveAliasDeclaration","importLookup","declaration","resolveLocalNames","curDeclaration","alreadyVisited","type","symbolName","usesLocalName","lookupResult","path","symbol","symbolTable","get","undefined","submoduleFallback","declarations","getTypedDeclarations","length","getDeclarations","find","decl","push","nullCallback","_","program","maxTime","configOptions","callback","console","token","moreToAnalyze","throwIfCancellationRequested","duration","Duration","analyze","filesLeftToAnalyze","getFilesToAnalyzeCount","debug","assert","diagnostics","getDiagnostics","diagnosticFileCount","elapsedTime","getDurationInSeconds","filesInProgram","getFileCount","filesRequiringAnalysis","checkingOnlyOpenFiles","isCheckingOnlyOpenFiles","fatalErrorOccurred","configParseErrorOccurred","e","OperationCanceledException","is","message","getErrorString","error","getFlowNode","node","flowNode","analyzerNode","scope","afterFlowNode","fileInfo","importInfo","codeFlowExpressions","map","curNode","flags","FlowFlags","Unreachable","parent","_console","_configOptions","_importResolver","extension","backgroundAnalysis","maxAnalysisTime","this","_program","Program","_backgroundAnalysis","_maxAnalysisTime","setConfigOptions","importResolver","setImportResolver","filePaths","setTrackedFiles","_reportDiagnosticsForRemovedFiles","importNames","setAllowedThirdPartyImports","filePath","version","contents","setFileOpened","markFilesDirty","setFileClosed","evenIfContentsAreSame","markAllFilesDirty","_onAnalysisCompletion","setCompletionCallback","startAnalysis","_indices","analyzeProgram","workspaceIndices","libraryIndices","indices","_getIndices","indexResults","setWorkspaceIndex","execEnvRoot","libraryPath","setIndex","indexing","startIndexing","refreshIndexing","cancelIndexing","getIndex","findExecEnvironment","root","range","getDiagnosticsForRange","targetImportPath","targetIsSingleFile","stubPath","writeTypeStub","invalidateAndForceReanalysis","invalidateCache","restart","Map","getSourceFile","cacheIndexResults","execEnv","indicesMap","set","clear","fileDiags","Binder","ParseTreeWalker","super","_deferredBindingTasks","_notLocalBindings","_nestedExceptDepth","_finallyTargets","_typingImportAliases","_typingSymbolAliases","_fileInfo","isBuiltInModule","builtinsScope","_createNewScope","AnalyzerNodeInfo","setScope","_currentScope","setFlowNode","_currentFlowNode","_addBuiltInSymbolToCurrentScope","_createStartFlowNode","_walkStatementsAndReportUnreachable","statements","setCodeFlowExpressions","_currentExecutionScopeReferenceMap","setAfterFlowNode","_bindDeferred","moduleDocString","ParseTreeUtils","getDocString","fail","importResult","getImportInfo","isImportFound","isStubFile","importType","isPyTypedPresent","diagnostic","_addDiagnostic","diagnosticRuleSet","reportMissingTypeStubs","DiagnosticRule","Localizer","Diagnostic","stubFileMissing","format","importName","createTypeStubAction","action","moduleName","addAction","nonStubImportResult","reportMissingModuleSource","importSourceResolveFailure","reportMissingImports","importResolveFailure","walkMultiple","decorators","classDeclaration","convertOffsetsToRange","name","start","TextRange","getEnd","lines","_bindNameToScope","value","addDeclaration","setDeclaration","arguments","parentScope","walk","suite","_addSymbolToCurrentScope","_createAssignmentTargetFlowNodes","containingClassNode","getEnclosingClass","functionDeclaration","isMethod","isGenerator","parameters","forEach","param","defaultValue","typeAnnotation","typeAnnotationComment","returnTypeAnnotation","functionAnnotationComment","functionOrModuleNode","nodeType","functionOrModuleScope","getScope","_deferBinding","paramNode","paramDeclaration","_createFlowAssignment","_targetFunctionDeclaration","_currentReturnTarget","_createBranchLabel","_addAntecedent","returnFlowNode","_finishFlowLabel","expression","leftExpression","_createCallFlowNode","_handleTypingStubAssignmentOrAnnotation","_bindPossibleTupleNamedTarget","_addTypeDeclarationForVariable","rightExpression","isPossibleTypeAlias","getEnclosingFunction","_addInferredTypeAssignmentForVariable","evaluationNode","getEvaluationNodeForAssignmentExpression","containerScope","curScope","lookUpSymbol","_addError","assignmentExprComprehension","assignmentExprContext","destExpression","expressions","expr","valueExpression","expressionList","_isNarrowingExpression","referenceKey","createKeyForReference","targetExpression","iterableExpression","preForLabel","_createLoopLabel","preElseLabel","postForLabel","_bindLoopStatement","forSuite","elseSuite","_currentContinueTarget","_unreachableFlowNode","_currentBreakTarget","returnStatements","returnExpression","target","_bindYield","thenLabel","elseLabel","postIfLabel","constExprValue","StaticExpressions","evaluateStaticBoolLikeExpression","testExpression","executionEnvironment","_bindConditional","ifSuite","postWhileLabel","preLoopLabel","whileSuite","assertTrueLabel","assertFalseLabel","exceptionExpression","typeExpression","isConstant","isConstantName","inferredTypeSource","exceptSuite","raiseStatements","raiseParams","tracebackExpression","curExceptTargets","exceptClauses","preFinallyLabel","preFinallyReturnOrRaiseLabel","isAfterElseAndExceptsReachable","preFinallyGate","PreFinallyGate","id","getUniqueFlowNodeId","antecedent","isGateClosed","finallySuite","exceptLabel","prevExceptTargets","_currentExceptTargets","trySuite","_isCodeUnreachable","exceptNode","index","pop","postFinallyNode","PostFinally","enclosingFunction","isAsync","awaitNotInAsync","stringNode","strings","hasUnescapeErrors","StringTokenUtils","getUnescapedString","unescapeErrors","textRange","prefixLength","quoteMarkLength","offset","errorType","reportInvalidStringEscapeSequence","stringUnsupportedEscape","formatStringEscape","formatStringBrace","formatStringUnterminated","globalScope","getGlobalScope","nameList","nameValue","nonLocalRedefinition","valueWithScope","lookUpSymbolRecursive","globalReassignment","nonLocalInModule","globalRedefinition","nonLocalReassignment","nonLocalNoBinding","module","nameParts","firstNamePartValue","alias","setIsExternallyHidden","_createAliasDeclarationForMultipartImportName","typingSymbolsOfInterest","resolvedPath","resolvedPaths","isModuleInitFile","stripFileExtension","getFileName","leadingDots","isTypingImport","isWildcardImport","wildcardInFunction","names","lookupInfo","wildcardNames","_getWildcardImportNames","some","_addImplicitFromImport","isIgnoredForProtocolMatch","aliasDecl","getEmptyRange","_createFlowWildcardImport","s","imports","importSymbolNode","importedName","nameNode","implicitImport","implicitImports","imp","withItems","item","trueLabel","falseLabel","postExpressionLabel","ifExpression","elseExpression","operator","_currentFalseTarget","_currentTrueTarget","savedTrueTarget","savedFalseTarget","postRightLabel","trueTarget","falseTarget","preRightLabel","boundSymbols","i","comprehensions","compr","addedSymbols","addedSymbol","aliasSymbol","_createAssignmentAliasFlowNode","importAlias","isNativeLib","existingDecl","firstNamePart","newDecl","_addImplicitImportsToLoaderActions","curLoaderActions","namePartValue","loaderActions","namesToImport","getNamesInDunderAll","startsWith","foundUnreachableStatement","statement","YieldFinder","checkContainsYield","Start","BranchLabel","antecedents","LoopLabel","_isLogicalExpression","_createFlowConditional","TrueCondition","FalseCondition","staticValue","conditionalFlowNode","_addExceptTargets","isCodeFlowSupportedForReference","isOrIsNotOperator","equalsOrNotEqualsOperator","constType","argumentCategory","isLeftNarrowing","isRightNarrowing","walkTargets","unbound","entries","entry","Call","targetSymbolId","aliasSymbolId","AssignmentAlias","indeterminateSymbolId","symbolWithScope","prevFlowNode","Assignment","Unbind","WildcardImport","label","postLoopLabel","savedContinueTarget","savedBreakTarget","existing","addSymbol","isPrivateOrProtectedName","intrinsicType","setIsIgnoredForProtocolMatch","isInitiallyUnbound","symbolFlags","scopeType","prevScope","Scope","isExecutionScope","prevReferenceMap","prevNonLocalBindings","source","typeAliasName","memberAccessInfo","_getMemberAccessInfo","memberName","classScope","honorPrivateNaming","reportPrivateUsage","setIsPrivateMember","isInstanceMember","isClassMember","setIsInstanceMember","setIsClassMember","isDefinedByMemberAccess","declarationHandled","finalInfo","_isAnnotationFinal","isExplicitTypeAlias","_isAnnotationTypeAlias","typeAnnotationNode","typeAliasNotInModule","isFinal","finalTypeNode","typeAliasAnnotation","baseExpression","setIsClassVar","annotationNotSupported","baseName","_isTypingAnnotation","items","pythonVersion","PythonVersion","V3_10","leftSymbolName","methodNode","classNode","className","firstParamName","decorator","decoratorName","existingLoaderAction","isTypingStubFile","annotationNode","assignedName","Tuple","Generic","Protocol","Callable","Type","ClassVar","Final","Literal","TypedDict","Union","Optional","Annotated","TypeAlias","OrderedDict","Concatenate","nonLocalBindingsMap","codeFlowExpressionMap","nextItem","shift","functionNode","yieldFromOutsideAsync","getEnclosingLambda","yieldOutsideFunction","yieldStatements","diagLevel","rule","_addWarning","_addInformation","assertNever","setRule","diagnosticSink","addDiagnosticWithTextRange","_containsYield","Checker","evaluator","_scopedNodes","_moduleNode","getFileInfo","_evaluator","_validateSymbolTables","_reportDuplicateImports","isCodeUnreachable","suppressDiagnostics","isExpressionNode","getType","classTypeResult","getTypeOfClass","_validateClassMethods","classType","_validateFinalMemberOverrides","ClassType","isTypedDictClass","_validateTypedDictClassSuite","functionTypeResult","getTypeOfFunction","paramType","functionType","details","isUnknown","isTypeVar","isSynthesized","boundType","addDiagnostic","reportUnknownParameterType","paramTypeUnknown","paramName","isPartlyUnknown","diagAddendum","DiagnosticAddendum","addMessage","printType","paramTypePartiallyUnknown","getString","defaultValueType","isEllipsisType","reportInvalidStubStatement","defaultValueNotEllipsis","returnTypeUnknown","_validateMethod","_validateFunctionReturn","getScopeForNode","reportUnknownMemberType","stubUsesGetAttr","decoratedType","category","overloads","_validateOverloadConsistency","slice","reportUnknownLambdaType","returnType","lambdaReturnTypeUnknown","lambdaReturnTypePartiallyUnknown","_validateIsInstanceCall","isWithinDefaultParamInitializer","reportCallInDefaultInitializer","defaultValueContainsCall","evaluateTypesForStatement","enclosingFunctionNode","declaredReturnType","getFunctionDeclaredReturnType","UnknownType","create","NoneType","createInstance","isNodeReachable","isNoReturnType","reportGeneralTypeIssues","noReturnContainsReturn","specializedDeclaredType","specializeType","canAssignType","returnTypeMismatch","exprType","reportUnknownVariableType","returnTypePartiallyUnknown","yieldType","adjYieldType","iteratorType","getBuiltInType","isClass","ObjectType","cloneForSpecialization","_validateYieldType","verifyRaiseExceptionType","baseExceptionType","exceptionType","doForSubtypes","subtype","isAnyOrUnknown","isNone","isObject","derivesFromClassRecursive","exceptionTypeIncorrect","isEmpty","addError","expectedExceptionObj","_validateExceptionType","isTupleClass","typeArguments","lastTypeArg","addDiagnosticForTextRange","reportAssertAlwaysTrue","assertAlwaysTrue","reportImplicitStringConcatenation","implicitStringConcat","formatExpr","_conditionallyReportPrivateUsage","verifyDeleteExpression","reportWildcardImportFromLibrary","wildcardLibraryImport","wildcardToken","importAs","child","prevOverloads","prevOverload","_isOverlappingOverload","overlappingOverload","obscured","obscuredBy","prevReturnType","FunctionType","getSpecializedReturnType","altNode","_findNodeForOverload","overloadReturnTypeMismatch","newIndex","prevIndex","overloadType","decls","getDeclarationsForNameNode","reportedUnreachable","lastStatement","end","addUnusedCode","_validateStubStatement","invalidStubStatement","substatement","errorNode","derivesFromBaseException","resultingExceptionType","transformTypeObjectToClass","iterableType","getTypeFromIterable","transformedSubtype","exceptionTypeNotClass","scopedNode","_conditionallyReportUnusedSymbol","_reportIncompatibleDeclarations","_reportMultipleFinalDeclarations","_reportMultipleTypeAliasDeclarations","_reportInvalidOverload","typedDecls","primaryDecl","getEffectiveTypeOfSymbol","isOverloaded","singleOverload","isFinalVariable","sawFinal","sawAssignment","isFinalVariableDeclaration","finalRedeclaration","finalReassigned","firstDecl","finalUnassigned","typeAliasDecl","isExplicitTypeAliasDeclaration","typeAliasRedeclared","getLastTypedDeclaredForSymbol","primaryDeclInfo","otherDecls","filter","seeMethodDeclaration","seeFunctionDeclaration","seeClassDeclaration","seeParameterDeclaration","seeVariableDeclaration","seeDeclaration","addPrimaryDeclInfo","diag","primaryDeclNode","addRelatedInfo","otherDecl","obscuredClassDeclaration","obscuredFunctionDeclaration","obscuredParameterDeclaration","primaryType","getTypeForDeclaration","duplicateIsOk","otherType","isTypeSame","obscuredVariableDeclaration","isProperty","accessedSymbolMap","has","SymbolNameUtils","isDunderName","_conditionallyReportUnusedDeclaration","_isSymbolPrivate","isPrivate","diagnosticLevel","reportUnusedImport","multipartName","np","join","extend","addUnusedCodeWithTextRange","unaccessedSymbol","unaccessedImport","importFrom","isReexport","isFuture","reportUnusedVariable","unaccessedVariable","reportUnusedClass","unaccessedClass","reportUnusedFunction","unaccessedFunction","callName","isInstanceCheck","arg0Type","derivesFromAnyOrUnknown","arg1Type","isSupportedTypeForIsInstance","isSupported","makeTypeVarsConcrete","isTypeArgumentExplicit","TypeBase","isInstantiable","isValidType","typeArg","typeVarNotAllowed","isInstanceInvalidType","isSubclassInvalidType","nonstandardClassTypes","classTypeList","isBuiltIn","objClass","isProtocolClass","isRuntimeCheckable","protocolUsedInCall","finalizeFilteredTypeList","types","combineTypes","filterType","varType","filteredTypes","filterIsSuperclass","isDerivedFrom","filterIsSubclass","isSameGenericClass","t","filteredType","remainingTypes","foundAnyType","subtypes","concat","getTestType","objTypeList","isNever","reportUnnecessaryIsInstance","unnecessaryIsInstanceNever","testType","unnecessaryIsSubclassNever","unnecessaryIsInstanceAlways","unnecessaryIsSubclassAlways","isPrivateName","isProtectedName","classOrModuleNode","primaryDeclaration","getEnclosingClassOrModule","isProtectedAccess","declClassTypeInfo","enclosingClassNode","enclosingClassTypeInfo","isNodeContainedWithin","protectedUsedOutsideOfClass","privateUsedOutsideOfClass","privateUsedOutsideOfModule","suiteNode","emitBadStatementError","typedDictBadVar","returnAnnotation","functionNeverReturns","isAfterNodeReachable","implicitlyReturnsNone","declaredReturnTypeUnknown","declaredReturnTypePartiallyUnknown","getDeclaredGeneratorReturnType","isSuiteEmpty","noReturnReturnsNone","isAbstractMethod","returnMissing","inferredReturnType","getFunctionInferredReturnType","fields","localSymbol","parentSymbol","lookUpClassMember","finalRedeclarationBySubclass","_validateBaseClassOverrides","typeOfSymbol","baseClassAndSymbol","hasTypedDeclarations","baseClassSymbolType","partiallySpecializeType","canOverrideMethod","reportIncompatibleMethodOverride","incompatibleMethodOverride","origDecl","overriddenMethod","finalMethodOverride","finalMethod","lastDecl","methodOverridden","reportIncompatibleVariableOverride","symbolOverridden","overriddenSymbol","reportSelfClsParameterName","newClsParam","initSubclassClsParam","classGetItemClsParam","isStaticMethod","staticClsSelfParam","isClassMethod","classMethodClsParam","firstParamIsSimple","isLegalMetaclassName","classTypeInfo","typeType","instanceMethodSelfParam","adjustedYieldType","declaredYieldType","getDeclaredGeneratorYieldType","noReturnContainsYield","yieldTypeMismatch","importStatements","getTopLevelImports","importModuleMap","orderedImports","importStatement","symbolMap","importFromAs","reportDuplicateImport","duplicateImport","subnode","_paths","firstIndex","circDependency","_nextFlowNodeId","reference","key","leftNode","_applyStrictRules","ruleSet","strictRuleSet","getStrictDiagnosticRuleSet","boolRuleNames","getBooleanDiagnosticRules","diagRuleNames","getDiagLevelDiagnosticRules","skipRuleNames","getStrictModeNotOverriddenRules","ruleName","r","strictValue","prevValue","_parsePyrightComment","commentValue","prefix","p","operandList","substr","trim","split","operand","_parsePyrightOperand","operandSplit","boolRules","diagLevelValue","_parseDiagLevel","boolValue","tokens","defaultRuleSet","useStrict","cloneDiagnosticRuleSet","count","getItemAt","comments","comment","parameterParent","isParamListEllipsis","decl1","decl2","line","character","Error","docString","DocStringConverter","convert","LeadingSpaceCountRegEx","CrLfRegEx","NonWhitespaceRegEx","TildaHeaderRegex","PlusHeaderRegex","LeadingAsteriskRegex","SpaceDotDotRegex","DirectiveLikeRegex","DoctestRegex","DirectivesExtraNewlineRegex","PotentialHeaders","exp","replacement","WhitespaceRegex","DoubleTickRegEx","TabRegEx","TildeRegEx","PlusRegEx","UnescapedMarkdownCharsRegex","LiteralBlockEmptyRegex","LiteralBlockReplacements","input","_builder","_skipAppendEmptyLine","_insideInlineCode","_appendDirectiveBlock","_stateStack","_lineNum","_blockIndent","_state","_parseText","_lines","docstring","replace","repeat","v","trimRight","first","trimLeft","splice","amount","counts","_isUndefinedOrWhitespace","_countLeadingSpaces","Math","min","_largestTrim","_stripLeadingWhitespace","_splitDocString","_currentLineOrUndefined","before","beforeLine","_parseBacktickBlock","_parseDocTest","_parseLiteralBlock","_trimOutputAndAppendLine","_currentLine","_currentIndent","next","_parseEmpty","_beginBacktickBlock","_beginLiteralBlock","_beginDocTest","_beginDirective","_appendTextLine","_eatLine","_preprocessTextLine","test","_appendLine","parts","part","_append","expReplacement","match","exec","state","_pushAndSetState","_popState","_beginMinIndentCodeBlock","_currentLineWithinBlock","_currentLineIsOutsideBlock","prev","_lineAt","endsWith","_parseLiteralBlockSingleLine","_parseDirective","_nextBlockIndent","directiveType","directive","_parseDirectiveBlock","text","noNewLine","search","rawString","leftSpacesToRemove","Number","MAX_VALUE","trimmed","trimmedLines","functionDocString","docStringLines","trimmedLine","paramOffset","indexOf","supportedNativeLibExtensions","supportedFileExtensions","stubsSuffix","fs","_cachedPythonSearchPaths","_cachedImportResults","fileSystem","sourceFilePath","moduleDescriptor","_formatImportName","importFailureInfo","notFoundResult","isRelative","isNamespacePackage","relativeImport","_resolveRelativeImport","cachedResults","_lookUpResultsInCache","importedSymbols","bestImport","_resolveBestAbsoluteImport","addResultsToCache","similarityLimit","suggestions","_getCompletionSuggestionsRelative","_getCompletionSuggestionsTypeshedPath","_getCompletionSuggestionsAbsolute","extraPath","extraPaths","pythonSearchPaths","_getPythonSearchPaths","searchPath","stubFilePath","sourceFilePaths","env","result","f","nonEmptyPaths","changeAnyExtension","existsSync","importRootPaths","getImportRoots","relativeStubPaths","importRootPath","containsPath","getRelativePathComponentsFromDirectory","relativeStubPath","combinePathComponents","absoluteStubPath","resolvePaths","absoluteSourcePath","filePathWithoutExtension","combinePaths","isLocalTypingsFile","stdLibTypeshedPath","_getTypeshedPath","_getModuleNameFromPath","candidateModuleName","thirdPartyTypeshedPath","thirdPartyTypeshedPathEx","getTypeshedPathEx","useTypeshedVersionedFolders","roots","minorVersion","versionFolders","versionToString","stdTypeshed","vf","typeshedPath","typeshedPathEx","cacheForExecEnv","_filterImplicitImports","rootPath","allowPartial","allowNativeLib","useStubPackage","allowPyi","packageDirectory","importFound","dirPath","fileNameWithoutExtension","pyFilePath","pyiFilePath","isFile","_findImplicitImports","isFirstPart","isLastPart","foundDirectory","isDirectory","foundInit","fileDirectory","stripTrailingDirectorySeparator","getDirectoryPath","nativeLibFileName","_getFilesInDirectory","fileExtension","getFileExtension","toLowerCase","withoutExtension","ext","equateStringsCaseInsensitive","nativeLibPath","isPartiallyTyped","pyTypedPath","fileStats","statSync","size","pyTypedContents","readFileSync","cachedEntry","containerPath","stripTopContainerDir","ensureTrailingDirectorySeparator","relativeFilePath","getPathComponents","_isIdentifier","builtInImport","_findTypeshedPath","isTypeshedFile","typingsImport","resolveAbsoluteImport","bestResultSoFar","localImport","pyTypedInfo","thirdPartyImport","_getPyTypedInfo","extraResults","resolveImportEx","typeshedImport","isIdentifierStartChar","charCodeAt","isIdentifierChar","cacheKey","venv","PythonPathUtils","findPythonSearchPaths","isStdLib","stdLibFolderName","thirdPartyFolderName","pythonVersionString","testPath","_cachedTypeshedStdLibPath","_cachedTypeshedThirdPartyPath","possibleTypeshedPath","getTypeShedFallbackPath","getTypeshedSubdirectory","curDir","absImport","readdirEntriesSync","hasTrailingDot","_addFilteredSuggestions","getFileSystemEntries","files","file","fileWithoutExtension","StringUtils","computeCompletionSimilarity","_addUniqueSuggestion","directories","dir","suggestionToAdd","newImportResult","Object","assign","filteredImplicitImports","sym","exclusions","implicitImportMap","fileName","exclusion","strippedFileName","dirName","values","getImportGroup","_formatModuleName","a","b","aImportGroup","bImportGroup","parseTree","localImports","mapByFilePath","followsNonImportStatement","foundFirstImportStatement","subStatement","list","importAsNode","_processImportNode","prevEntry","_processImportFromNode","parseResults","aliasName","textEditList","priorImport","curImport","insertionOffset","insertionPosition","convertOffsetToPosition","tokenizerOutput","insertText","replacementText","importGroup","invocationPosition","importText","importTextWithAlias","newImportStatement","invocation","convertPositionToOffset","insertBefore","insertionImport","prevImportGroup","curImportGroup","predominantEndOfLineSequence","addNewLineBefore","stopHere","simpleStatement","ParseTreeCleanerWalker","_parseTree","cleanNodeAnalysisInfo","visitNode","findNodeByOffset","children","containingChild","printOperator","operatorMap","stopAtFunction","getEvaluationScopeNode","prevNode","isParamNameNode","depth","position","printExpression","arg","argStr","toString","isImaginary","str","exprString","escapedValue","listStr","keyExpression","startValue","endValue","stepValue","paramStr","expandExpression","evaluationScope","targetNode","potentialContainer","isMatchingExpression","expression1","expression2","requireQuotedAnnotation","isQuoted","statementList","docStringNode","decodeDocString","callNode","namedTupleAssignedName","moduleOrSuite","statementIndex","findIndex","nextStatement","assignNode","defaultTarget","childrenToWalk","nodes","visitArgument","visitAssert","visitAssignment","visitAssignmentExpression","visitAugmentedAssignment","visitAwait","visitBinaryOperation","visitBreak","visitCall","visitClass","visitTernary","visitConstant","visitContinue","visitDecorator","visitDel","visitDictionary","visitDictionaryKeyEntry","visitDictionaryExpandEntry","visitError","visitIf","visitImport","visitImportAs","visitImportFrom","visitImportFromAs","visitIndex","visitIndexItems","visitEllipsis","visitExcept","visitFor","visitFormatString","visitFunction","visitFunctionAnnotation","paramTypeAnnotations","visitGlobal","visitLambda","visitList","visitListComprehension","visitListComprehensionFor","visitListComprehensionIf","visitMemberAccess","visitModule","visitModuleName","visitName","visitNonlocal","visitNumber","visitParameter","visitPass","visitRaise","visitReturn","visitSet","visitSlice","visitStatementList","visitString","visitStringList","visitSuite","visitTuple","visitTry","visitTypeAnnotation","visitUnaryOperation","visitUnpack","visitWhile","visitWith","visitWithItem","visitYield","visitYieldFrom","initialImportResolver","initialConfigOptions","_extension","logPrefix","_sourceFileList","_sourceFileMap","_parsedFileCount","_lookUpImport","sourceFileInfo","_getSourceFileInfoFromPath","sourceFile","isBindingRequired","timingStats","typeCheckerTime","subtractFromTime","_bindFile","getModuleSymbolTable","getModuleDocString","StandardConsole","_logTracker","LogTracker","_createNewEvaluator","newFileMap","normalizePathCase","_fs","oldFile","getFilePath","isTracked","addTrackedFiles","_removeUnneededFiles","_allowedThirdPartyImports","addTrackedFile","_getImportNameForFile","SourceFile","isOpenByClient","isThirdPartyImport","isThirdPartyPyTypedPresent","diagnosticsVersion","importedBy","shadows","shadowedBy","_addToSourceFileListAndMap","setClientVersion","markDirtyMap","markDirty","didContentsChangeOnDisk","_markFileDirtyRecursive","sourceFileCount","isCheckingRequired","_shouldCheckFile","checkOnlyOpenFiles","CancellationToken","None","_runEvaluatorWithCancellationToken","openFiles","sf","effectiveMaxTime","openFilesTimeInMs","_checkTypes","getDurationInMilliseconds","noOpenFilesTimeInMs","_isUserCode","results","_handleMemoryHighUsage","projectRootDir","verbose","sortedFiles","sort","zeroImportFiles","sfInfo","info","relPath","getRelativePath","importFile","relativePath","typeStubPath","normalizePath","typeStubDir","makeDirectories","TypeStubWriter","write","printUnknownAsAny","omitTypeArgsIfAny","omitUnannotatedParamType","pep604Printing","getModuleNameForImport","getDefaultExecEnvironment","stubFile","shadowImplPath","shadowFileInfo","includes","createTypeEvaluator","disableInferenceForPyTypedSources","printTypeFlags","_getPrintTypeFlags","fileToParse","_isFileNeeded","isParseRequired","parse","_updateSourceFileImports","isFileDeleted","fileToAnalyze","_parseFile","builtinsImport","getParseResults","bind","sourceFileToExclude","buildModuleSymbolsMap","fileToCheck","log","logState","suppress","check","reportImportCycles","closureMap","_getImportsRecursive","cycleDetectionTime","timeOperation","_detectAndReportImportCycles","recursionCount","setHitMaxImportDepth","importedFileInfo","dependencyChain","dependencyMap","_logImportCycle","circDep","CircularDependency","appendPath","normalizeOrder","firstFilePath","getPaths","firstSourceFile","addCircularDependency","markMap","markReanalysisRequired","dep","fileContents","getFileContents","convertRangeToTextRange","nameMap","libraryMap","currentNode","writtenWord","_buildModuleSymbolsMap","autoImporter","AutoImporter","currentScope","translatedWord","exactMatch","getAutoImportCandidates","options","fileDiagnostics","getDiagnosticVersion","unfilteredDiagnostics","doRangesIntersect","getDefinitionsForPosition","_createSourceMapper","includeDeclaration","invokedFromUserFile","referencesResult","getDeclarationForPosition","requiresGlobalSearch","curSourceFileInfo","addReferences","locations","l","declFileInfo","tempResult","nodeAtOffset","loc","doesRangeContain","importSymbolsOnly","symbolList","getCachedIndexResults","addHierarchicalSymbolsForDocument","query","addSymbolsForDocument","getHoverForPosition","getDocumentHighlight","getSignatureHelpForPosition","workspacePath","completionResult","getCompletionsForPosition","completionList","completionListExtension","pr","content","updateCompletionList","completionItem","resolveCompletionItem","newName","d","editActions","targetDecl","CallHierarchyProvider","getTargetDeclaration","getCallForDeclaration","itemsToAdd","getIncomingCallsForDeclaration","getOutgoingCallsForDeclaration","command","args","performQuickAction","getTypeCacheSize","heapSizeInMb","round","process","memoryUsage","heapUsed","_discardCachedParseResults","dropParseAndBindInfo","isDebugMode","runWithCancellationToken","prepareForClose","_removeSourceFileFromListAndMap","importedFile","indexToRemove","fi","shadowedFile","_isImportNeededRecursive","recursionMap","importerInfo","SourceMapper","implFilePath","stubFileInfo","_addShadowedFile","getBoundSourceFile","importer","isImportStubFile","thirdPartyImportAllowed","useLibraryCodeForTypes","filesAdded","getImports","getThirdPartyImportInfo","newImportPathMap","_isImportAllowed","thirdPartyTypeInfo","verboseOutput","updatedImportMap","oldFilePath","normalizedImportPath","getBuiltinsImport","resolvedBuiltinsPath","delete","cachedSearchPaths","getPathResultFromInterpreter","interpreter","paths","commandLineArgs","execOutput","child_process","execFileSync","encoding","execSplit","JSON","execSplitEntry","normalizedPath","err","getPythonPathFromPythonInterpreter","interpreterPath","searchKey","cachedPath","platform","moduleDirectory","getModulePath","pathConsts","typeshedFallback","debugTypeshedPath","includeWatchPathsOnly","workspaceRoot","venvPath","defaultVenv","libPath","lib","sitePackages","sitePackagesPath","pathResult","pythonPath","_lookUpSymbolRecursiveInternal","Symbol","isOutsideCallerModule","isBeyondExecutionScope","isExternallyHidden","isIndependentlyExecutable","builtInScope","scopeNode","configFileNames","AnalyzerService","instanceName","importResolverFactory","backgroundAnalysisProgramFactory","_typeStubTargetIsSingleFile","_requireTrackedFileUpdate","_lastUserInteractionTime","Date","now","_disposed","_instanceName","_executionRootPath","_importResolverFactory","createImportResolver","_maxAnalysisTimeInForeground","_backgroundAnalysisProgramFactory","ConfigOptions","cwd","_backgroundAnalysisProgram","BackgroundAnalysisProgram","_removeSourceFileWatchers","_removeConfigFileWatcher","_removeLibraryFileWatcher","_clearReloadConfigTimer","_clearReanalysisTimer","_clearLibraryReanalysisTimer","ImportResolver","_onCompletionCallback","commandLineOptions","reanalyze","_commandLineOptions","_getConfigOptions","ensureDefaultPythonVersion","ensureDefaultPythonPlatform","executionRoot","projectRoot","_applyConfigOptions","_scheduleReanalysis","updateOpenFileContents","test_setIndexing","getTextOnRange","getAutoImports","getIndexing","getReferencesForPosition","addSymbolsForWorkspace","renameSymbolAtPosition","getCallForPosition","getIncomingCallsForPosition","getOutgoingCallsForPosition","fileCount","printDependencies","_analyzeTimer","_getFileNamesFromFileSpecs","configFilePath","_findConfigFile","_findConfigFileHereOrUp","_typeCheckingMode","defaultExcludes","fileSpecs","fileSpec","include","getFileSpec","exclude","_configFilePath","configJsonObj","_parseConfigFile","initializeFromJson","diagnosticSeverityOverrides","configFileDir","autoExcludeVenv","executionEnvironments","addExecEnvironmentForExtraPaths","autoSearchPaths","applyDiagnosticOverrides","reportDuplicateSetting","settingName","configValue","settingSource","fromVsCodeExtension","warn","autoImportCompletions","fullVenvPath","pythonPaths","typingsSubdirPath","_getTypeStubFolder","_typeStubTargetPath","watchForSourceChanges","watchForLibraryChanges","typeCheckingMode","typeStubTargetImportName","_typeStubTargetImportName","errMsg","typeStubInputTargetParts","mkdirSync","forEachAncestorDirectory","ancestor","configPath","configContents","parseAttemptCount","_reportConfigParseError","configObj","parseFailed","fileMap","findFilesTime","matchedFiles","_matchFiles","markFilesDirtyUnconditionally","resolveImport","filesToImport","targetPath","prevResolvedPath","fileList","excludePaths","excl","regExp","includeFileRegex","envMarkers","visitDirectory","absolutePath","includeRegExp","_isInExcludePath","directory","includeSpec","foundFileSpec","wildcardRoot","stat","_sourceFileWatcher","close","_watchForSourceChanges","spec","_verboseOutput","isIgnored","ignoredWatchEventFunction","createFileSystemWatcher","event","fileNameSplit","isTemporaryFile","_libraryFileWatcher","_watchForLibraryChanges","watchList","_scheduleLibraryAnalysis","_libraryReanalysisTimer","clearTimeout","setTimeout","_configFileWatcher","_scheduleReloadConfigFile","setOptions","_reloadConfigTimer","_reloadConfigFile","_updateConfigFileWatcher","_updateLibraryFileWatcher","_updateSourceFileWatchers","_updateTrackedFileList","requireTrackedFileUpdate","_backgroundAnalysisCancellationSource","cancel","timeSinceLastUserInteractionInMs","timeUntilNextAnalysisInMs","max","createBackgroundThreadCancellationTokenSource","logTracker","_isFileDeleted","_diagnosticVersion","_fileContentsVersion","_lastFileContentLength","_lastFileContentHash","_clientVersion","_analyzedFileContentsVersion","_parseTreeNeedsCleaning","_isBindingInProgress","_parseDiagnostics","_bindDiagnostics","_checkerDiagnostics","_diagnosticRuleSet","getBasicDiagnosticRuleSet","_circularDependencies","_isBindingNeeded","_isCheckingNeeded","_indexingNeeded","_filePath","_moduleName","_isStubFile","_isThirdPartyImport","_isThirdPartyPyTypedPresent","_isTypingStubFile","_isTypingExtensionsStubFile","_isBuiltInStubFile","normalizeSlashes","isMainThread","prevDiagnosticVersion","includeWarningsAndErrors","diagList","enableTypeIgnoreComments","typeIgnoreLines","_parseResults","keys","convertLevelToCategory","cirDep","importCycleDetected","_hitMaxImportDepth","importDepthExceeded","ignore","ignoreFileSpec","typeIgnoreAll","_imports","_builtinsImport","_moduleSymbolTable","_binderResults","hashString","_cachedIndexResults","containsWildcardImport","_fileContents","updatedDependencyList","isEqual","maxImportDepth","diagSink","DiagnosticSink","readFileTime","execEnvironment","parseOptions","ParseOptions","Parser","parseSourceFile","resolveImportsTime","_typingModulePath","_collectionsModulePath","_resolveImports","importedModules","fetchAndClear","strict","strictFileSpec","CommentUtils","getFileLevelDirectives","stack","stringify","internalParseError","ModuleNode","futureImports","TextRangeCollection","predominantTabSequence","predominantSingleQuoteCharacter","isIndexingRequired","symbols","DocumentSymbolProvider","indexSymbols","privateOrProtected","sourceMapper","DefinitionProvider","ReferencesProvider","HoverProvider","DocumentHighlightProvider","SignatureHelpProvider","moduleSymbolsCallback","CompletionProvider","completionData","data","bindTime","_cleanParseTreeIfRequired","_buildFileInfo","setFileInfo","binder","bindModule","internalTestMode","TestWalker","moduleScope","internalBindError","internalTypeCheckingError","analysisDiagnostics","TextRangeDiagnosticSink","typingModulePath","collectionsModulePath","isTypingExtensionsStubFile","isBuiltInStubFile","isInPyTypedPackage","clean","moduleImports","builtinsImportResult","typingImportResult","moduleImport","setImportInfo","getAnyExtensionFromPath","_isDefined","element","_execEnv","_fileBinder","_getBoundSourceFiles","stubDecl","findClassDeclarations","findFunctionDeclarations","_getFullClassName","flatMap","_findClassDeclarations","functionName","sourceFiles","_findMethodDeclarations","_findFunctionDeclarations","classDecls","classDecl","methodDecls","_lookUpSymbolDeclarations","methodDecl","functionDecls","functionDecl","resolvedDecl","fullClassName","parentNode","classNameParts","_findClassDeclarationsUnderNode","classNamePart","_findClassDeclarationsUnderClass","parentClassDecls","parentDecl","fullName","current","reverse","getSourceFilesFromStub","fp","evaluateStaticBoolExpression","leftValue","rightValue","_isSysVersionInfoExpression","comparisonVersion","majorVersion","_convertTupleToVersion","_evaluateNumericBinaryOperation","floor","_isSysPlatformInfoExpression","comparisonPlatform","expectedPlatformName","pythonPlatform","_getExpectedPlatformNameFromPlatform","_evaluateStringBinaryOperation","_isOsNameInfoExpression","comparisonOsName","expectedOsName","_getExpectedOsNameFromPlatform","operatorType","nextSymbolId","_flags","newSymbol","_synthesizedType","_declarations","declIndex","areDeclarationsSame","curDecl","hasTypeForDeclaration","_constantRegEx","_underscoreOnlyRegEx","allSymbol","listEntryNode","entryName","_verifyParentChildLinks","_verifyChildRanges","skipCheck","cachedType","isIncompleteType","_speculativeContextStack","speculativeRootNode","entriesToUndo","cache","stackDepth","stackSize","_entriesToUndo","_requiresUndo","getFunctionDocStringFromDeclaration","_getFunctionOrClassDeclDocString","docStrings","o","overload","modules","_getModuleNodeDocString","findModules","arithmeticOperatorMap","bitwiseOperatorMap","comparisonOperatorMap","booleanOperatorMap","nonSubscriptableBuiltinTypes","V3_9","evaluatorOptions","symbolResolutionStack","isReachableRecursionMap","functionRecursionMap","callIsNoReturnCache","codeFlowAnalyzerCache","typeCache","speculativeTypeTracker","SpeculativeTypeTracker","incompleteTypeTracker","IncompleteTypeTracker","cancellationToken","isDiagnosticSuppressed","flowIncompleteGeneration","returnTypeInferenceContextStack","returnTypeInferenceTypeCache","checkForCancellation","readTypeCache","isNodeInReturnTypeInferenceContext","writeTypeCache","typeCacheToUse","speculativeNode","getSpeculativeRootNode","trackEntry","contextNode","getIndexOfSymbolResolution","symbolId","pushSymbolResolution","isResultValid","popSymbolResolution","poppedEntry","setSymbolResolutionPartialType","partialType","getSymbolResolutionPartialType","evaluateTypesForExpressionInContext","getTypeOfExpression","expectedType","typeResult","transformPossibleRecursiveTypeAlias","reportExpectingTypeErrors","isResolutionCyclical","allowForwardReferences","useCodeFlowAnalysis","effectiveTypeInfo","getEffectiveTypeOfSymbolForUsage","effectiveType","isSpecialBuiltIn","typeAtStart","UnboundType","codeFlowType","getFlowTypeOfReference","requiresTypeArguments","reportMissingTypeArgument","typeArgsMissingForClass","createSpecializedClassType","getClassFromPotentialTypeObject","typeAliasInfo","typeParameters","typeArgsMissingForAlias","isUnbound","reportUnboundVariable","symbolIsUnbound","isPossiblyUnbound","symbolIsPossiblyUnbound","setSymbolAccessed","reportUndefinedVariable","symbolIsUndefined","isParamSpec","paramSpecContext","genericNotAllowed","getTypeVarScopeNode","typeVarsForScope","functionTypeInfo","hasDeclaredType","addTypeVarsToListIfUnique","getTypeVarArgumentsRecursive","typeVar","convertToInstantiable","findScopedTypeVar","scopeId","typeVarUsedByOuterScope","enclosingScope","getEnclosingClassOrFunction","TypeVarType","cloneForScopeId","typeVarNotUsedByOuterScope","getTypeFromName","baseTypeFlags","baseTypeResult","memberTypeResult","getTypeFromMemberAccessWithBaseType","method","initialType","baseType","classMemberInfo","lookUpObjectMember","getTypeOfMember","getTypeFromMemberAccess","minPythonVersion","classNotRuntimeSubscriptable","getTypeFromIndexWithBaseType","getTypeFromIndex","getTypeFromSuperCall","typeString","addInformation","strType","cloneWithLiteral","AnyType","argList","getTypeFromCallWithBaseType","getTypeFromCall","expectedTypes","tupleClass","entryTypeResults","builtInTupleType","tupleTypes","unpackedType","typeArgs","convertToInstance","cloneTupleForSpecialization","getTypeFromTuple","createType","getBuiltInObject","getTypeFromConstant","indexItemsNode","isAnnotationLiteralValue","isBytes","cloneBuiltinObjectWithLiteral","parser","textValue","valueOffset","parseTextExpression","parseStringAsTypeAnnotation","expectedTypeNotString","builtInType","isInteger","unaryOperatorMap","isOptionalType","reportOptionalOperand","noneOperator","removeNoneFromUnion","getTypeFromMagicMethodReturn","typeNotSupportUnaryOperator","literalValue","getTypeFromUnaryOperation","getTypeFromBinaryOperation","parenthesized","leftType","rightType","adjustedRightType","isInstance","isUnionableType","unionSyntaxIllegal","operatorToken","validateBinaryOperation","getTypeFromAugmentedAssignment","assignTypeToExpression","getListTypeArg","potentialList","classAlias","aliasClass","expectedEntryType","entryTypes","getElementTypeFromListComprehension","narrowedExpectedType","expectedListElementType","typeVarMap","TypeVarMap","entryType","assignedNonLiteral","nonLiteralEntryType","stripLiteralValue","inferredEntryType","strictListInference","areTypesSame","getTypeFromList","getTypeFromSlice","getTypeFromAwaitable","ifType","elseType","getTypeFromTernary","elementType","comp","builtInIteratorType","getTypingType","getTypeFromListComprehension","expectedKeyType","expectedValueType","expectedTypedDictEntries","keyType","valueType","keyTypes","valueTypes","expectedClass","getTypedDictMembersForClass","entryNode","addUnknown","adjExpectedKeyType","unexpandedType","aliasType","dictEntryType","isMatch","keyValue","symbolEntry","assignDiag","typedDictFieldTypeMismatch","isProvided","typedDictFieldUndefined","isRequired","typedDictFieldRequired","canAssignToTypedDict","typeArg0","typeArg1","strictDictionaryInference","expectedTypeDiagAddendum","getTypeFromDictionary","expectedFunctionType","getEffectiveParameterType","functionParam","hasDefault","addParameter","expectedReturnType","getFunctionEffectiveReturnType","getTypeFromLambda","getTypeFromSet","sentType","getDeclaredGeneratorSendType","getTypeFromYield","getTypeFromYieldFrom","iterType","resultType","isEmptyTuple","addExpectedClassDiagnostic","isAnnotationEvaluationPostponed","getTypeOfAnnotation","allowFinal","associateTypeVarsWithScope","specialType","aliasMapEntry","createSpecialBuiltInClass","handleTypingStubTypeAnnotation","evaluatorFlags","n","getTypeFromDecorator","functionOrClassType","decoratorCall","getTypeFromObjectMember","objectType","usage","memberAccessFlags","bindToClass","memberInfo","getTypeFromClassMemberName","bindFunctionToClassOrObject","getTypeFromClassMember","isMetaclassMember","metaclass","effectiveMetaclass","getBoundMethod","treatAsClassMember","unboundMethodType","boundMethod","getTypeAnnotationForParameter","paramIndex","functionFlags","getFunctionFlagsFromDecorators","firstCommentAnnotationIndex","paramAnnotations","adjIndex","isDeclaredTypeAlias","getDeclaredTypeForExpression","classOrObjectBase","setItemMember","setItemType","boundFunction","declaredType","getDeclaredTypeOfSymbol","setterInfo","setter","generatorReturnType","getReturnTypeFromGenerator","awaitReturnType","typeNotAwaitable","supportGetItem","iterMethodName","nextMethodName","getItemMethodName","reportOptionalIterable","noneNotIterable","getIteratorReturnType","objType","iterReturnType","classMember","memberType","methodType","getSpecializedReturnTypeForMetaclassMethod","nextReturnType","methodNotDefinedOnType","methodReturnsNonObject","getItemReturnType","methodNotDefined","metaclassType","typeNotIterable","synthesizeTypedDictClassMethods","newType","addDefaultParameters","initType","createWithType","strClass","selfParam","defaultTypeVar","createGetMethod","getOverload","createPopMethods","keyParam","popOverload1","popOverload2","createSetDefaultMethod","setDefaultOverload","createDelItemMethod","delItemOverload","getOverloads","popOverloads","setDefaultOverloads","nameLiteralType","OverloadedFunctionType","typingImportPath","isFlowNodeReachable","getAfterFlowNode","isFlowPathBetweenNodes","sourceNode","sinkNode","sourceFlowNode","sinkFlowNode","addDiagnosticWithSuppressionCheck","isDiagnosticSuppressedForNode","isSpeculativeMode","isIncompleteTypeMode","typeNotClass","typeExpectedClass","assignTypeToNameNode","srcExpression","destType","narrowTypeBasedOnAssignment","typeAssignmentMismatch","sourceType","ScopeUtils","varDecl","reportConstantRedefinition","constantRedefinition","assignTypeToMemberVariable","srcType","srcExprNode","classDef","memberFields","isFinalVar","reportPossibleUnknownAssignment","srcExpr","callType","paramSpecAssignedName","typeVarAssignedName","removeUnboundFromUnion","entryExpr","symbolInScope","classTypeResults","assignmentInProtocol","setType","setErrorNode","setExpectedTypeDiag","assignTypeToMemberAccessNode","indexTypeResult","targetTypes","Array","unpackIndex","tupleType","getSpecializedTupleType","sourceEntryTypes","sourceEntryCount","sourceIndex","targetIndex","remainingTargetEntries","remainingSourceEntries","entriesToPack","expectedEntryCount","tupleSizeMismatch","expected","received","typeList","targetType","listType","assignTypeToTupleNode","typeHintType","isFinalAllowedForAssignmentTarget","isEnumClass","iteratedType","assignmentTargetExpr","paramSpecUnknownMember","classFromTypeObject","ModuleType","getField","getAttrSymbol","getAttrType","moduleUnknownMember","reportOptionalMemberAccess","noneUnknownMember","typeUnsupported","diagMessage","memberAccess","memberSet","memberDelete","potentialTypeObject","objectClass","firstTypeArg","getConcreteTypeFromTypeVar","classLookupFlags","isClassVar","memberSetClassVar","memberUnknown","objectAccessType","isAccessedThroughObject","isTypeValid","accessMethodName","memberClassType","accessMethod","isPropertyClass","propertyMissingSetter","propertyMissingDeleter","accessMethodType","findOverloadedFunctionType","boundMethodType","validateFunctionArguments","enforceTargetType","isInstanceMethod","stripFirstParameter","applyObjectAccessMethod","createAddendum","memberAssignment","printObjectTypeForClass","generalAttrType","getAttribType","applyGeneralAttributeAccess","getTypeArgs","typeArgsTooMany","assignTypeToTypeVar","typeNotSpecializable","typeParam","getTypeVar","cloneForTypeAlias","genericClassAssigned","genericClassDeleted","literalEmptyArgs","literalTypes","cloneBuiltinClassWithLiteral","isLiteralType","literalUnsupportedType","createLiteralType","typeArgsMismatchOne","adjustedFlags","isAnnotatedClass","indexType","resultingType","keyRequiredDeleted","keyUndefined","typeNotStringLiteral","typedDictDiag","typedDictSet","typedDictDelete","typedDictAccess","magicMethodName","itemMethodType","indexTypeList","baseTypeClass","numberNode","validateCallArguments","getTypeFromIndexedObject","reportOptionalSubscript","noneNotSubscriptable","typeNotSubscriptable","adjFlags","getTypeArg","combinedTupleType","effectiveTypeArguments","specializedTuple","mro","updateNamedTupleBaseClass","namedTupleIndex","c","namedTupleClass","typedTupleClass","updatedTupleClass","clonedNamedTupleClass","targetClassType","narrowedClassType","superCallArgCount","superCallFirstArg","enclosingClass","superCallZeroArgForm","reportError","childClassType","superCallSecondArg","lookupResults","mroBase","baseClasses","baseClassType","skipUnknownArgCheck","validateConstructorArguments","argType","getTypeForArgument","getClassFullName","baseClass","computeMroLinearization","methodOrdering","createTypeVarType","createNamedTupleType","typeNotIntantiable","enumClass","enumFirstArg","nameArg","classFields","enumSecondArg","entriesArg","createEnumType","typedDictClass","typedDictFirstArg","usingDictSyntax","typedDictSecondArgDict","entryMap","typedDictSecondArgDictEntry","typedDictEntryName","typedDictEmptyName","typedDictEntryUnique","typedDictTotalParam","typedDictExtraArgs","createTypedDictType","hasAbstractMethods","abstractMethods","getAbstractMethods","errorsToDisplay","abstractMethod","memberIsAbstractMore","memberIsAbstract","typeAbstract","newClassName","builtInName","reportUntypedNamedTuple","namedTupleNoTypes","callResult","argumentErrors","getTypeForArgumentExpectingType","classFlags","createNewType","castToType","castFromType","reportUnnecessaryCast","unnecessaryCast","argTypes","overloadCallName","argumentTypes","noOverload","returnTypes","typeEntry","reportOptionalCall","noneNotCallable","typeNotCallable","validOverload","useSpeculativeMode","validatedTypes","reportedErrors","skipConstructorCheck","isSkipConstructorCheck","initMethodType","expectedTypeWithoutNone","requiresSpecialization","expectedTypeArgs","genericExpectedType","synthesizedIndex","specializedType","syntheticTypeVarMap","synthTypeVar","targetTypeVar","setTypeVar","populateTypeVarMapBasedOnExpectedType","specializedClassType","applyExpectedTypeForConstructor","constructorMethodInfo","constructorMethodType","newReturnType","constructorNoArgs","isAssignable","expectedTypeArg","inferReturnTypeIfNeeded","overloadedFunctionType","objectNotCallable","subtypeCallResult","argIndex","typeParams","varArgDictParam","reportedArgError","paramMap","argsNeeded","argsReceived","positionalParamCount","positionalOnlyIndex","positionalArgCount","firstParamWithDefault","positionOnlyWithoutDefaultsCount","validateArgTypeParams","activeParam","trySetActive","active","foundUnpackedListArg","unpackedArgIndex","argPositional","adjustedCount","argPositionalExpectedOne","argPositionalExpectedCount","listElementType","advanceToNextArg","funcArg","requiresTypeVarMatching","argument","isNameSynthesized","foundUnpackedDictionaryArg","paramNameValue","paramEntry","paramAlreadyAssigned","paramInfoIndex","paramNameMissing","isDefaultParameterCheckDisabled","unassignedParams","missingParamNames","argMissingForParam","argMissingForParams","defaultType","typeVarMatchingCount","passCount","argParam","validateArgType","lock","validatedArg","specializedReturnType","skipUnknownCheck","expectedTypeDiag","argTypeText","paramTypeText","argAssignmentParamFunction","argAssignmentParam","argAssignmentFunction","argAssignment","simplifiedType","argParamFunction","reportUnknownArgumentType","argTypeUnknown","argumentType","argTypePartiallyUnknown","firstConstraintArg","typeVarName","paramSpecIllegal","paramSpecFirstArg","typeVarFirstArg","firstArg","createInstantiable","paramNameNode","paramNameMap","duplicateParam","paramSpecUnknownParam","typeVarUnknownParam","getBooleanValue","isContravariant","typeVarVariance","isCovariant","constraints","typeVarBoundAndConstrained","typeVarGeneric","paramSpecUnknownArg","addConstraint","typeVarSingleConstraint","expectedBoolLiteral","includesTypes","namedTupleFirstArg","namedTupleType","constructorType","isAssignmentToDefaultsFollowingNamedTuple","selfParameter","addGenericGetAttribute","namedTupleSecondArg","paramInfo","entryList","entryTypeNode","entryNameNode","entryTypeInfo","namedTupleNameType","namedTupleEmptyName","namedTupleNameString","namedTupleNameUnique","keysItemType","itemsItemType","lenType","leftSubtype","rightSubtype","altMagicMethodName","removeTruthinessFromType","removeFalsinessFromType","typeNotSupportBinaryOperator","magicMethodSupported","handleObjectSubtype","bindToClassType","magicMethodType","functionArgs","obj","typeUnknown","typePartiallyUnknown","expectedElementType","comprehension","itemType","createSpecialType","paramLimit","allowParamSpec","isTuple","ellipsisSecondArg","ellipsisContext","isModule","moduleContext","isParamSpecType","typeArgTypes","transformTypeForPossibleEnumClass","typeOfExpr","enumClassInfo","EnumLiteral","transformTypeForTypeAlias","recursiveTypeAliasName","specialClassType","baseClassName","evaluateTypesForAssignmentStatement","rightHandType","isResolutionCycle","TypeVar","_promote","no_type_check","NoReturn","Counter","List","Dict","DefaultDict","Set","FrozenSet","Deque","ChainMap","handleTypingStubAssignment","typeAliasNameNode","typeAliasTypeVar","isPossibleTypeAliasDeclaration","isPossibleImplicitTypeAlias","srcTypeResult","boolType","isTypeAliasRecursive","typeAliasIsRecursive","evaluateTypesForAugmentedAssignment","cachedClassType","classSymbol","getDeclaration","genericTypeParameters","sawMetaclass","initSubclassArgs","constArgValue","exprFlags","isMetaclass","metaclassDuplicate","isTypingExtensionClass","V3_7","protocolIllegal","V3_6","typedDictBaseClass","baseClassCircular","baseClassInvalid","reportUntypedBaseClass","baseClassUnknown","declaredMetaclass","prevBaseClass","duplicateBaseClass","supportsAbstractMethods","baseClassFinal","reportedMetaclassConflict","baseClassMeta","metaclassConflict","typeMetaclass","innerScope","initMethod","initDecls","initDeclNode","initParams","genericParams","foundUnknown","newDecoratedType","applyClassDecorator","reportUntypedClassDecorator","classDecoratorTypeUnknown","isDataClass","skipSynthesizedInit","isSkipSynthesizedInit","initSymbol","initSymbolType","isSynthesizedMethod","skipSynthesizeInit","localDataClassEntries","fullDataClassEntries","allAncestorsKnown","allAncestorsAreKnown","mroClass","getDataClassEntries","existingIndex","addInheritedDataClassEntries","localEntryTypeEvaluator","variableNameNode","variableTypeEvaluator","hasDefaultValue","includeInInit","initArg","variableName","variableSymbol","dataClassEntry","insertIndex","firstDefaultValueIndex","dataClassFieldWithDefault","dataClassEntries","entryEvaluator","dictType","synthesizeDataClassMethods","initSubclassMethodInfo","initSubclassMethodType","validateInitSubclassArgs","inputClassType","originalClassType","decoratorNode","decoratorType","cachedFunctionType","isFunction","containingClassType","classInfo","functionSymbol","addGenericParamTypes","isPseudoGenericClass","paramTypes","typeParamIndex","annotatedParamCountMismatch","annotatedType","concreteAnnotatedType","paramTypeNode","isNoneWithoutOptional","adjustedIndex","strictParameterNoneValue","paramAssignmentMismatch","addOptionalAction","offsetOfTypeNode","variadicParamType","transformVariadicParamType","inferredParamType","inferFirstParamType","isTypeInferred","awaitableFunctionType","clone","createAwaitableReturnType","createAsyncFunction","applyFunctionDecorator","reportUntypedFunctionDecorator","functionDecoratorTypeUnknown","overloadedTypes","declTypeInfo","unshift","lastOverload","newOverload","overloadAbstractMismatch","addOverloadsToFunctionType","clsType","makeScopeId","selfSpecializeClassType","selfType","paramCategory","isInClass","inputFunctionType","originalFunctionType","prop","fset","propertyClass","typeSourceId","propertyObject","fgetType","getGetterTypeFromProperty","fsetType","reportPropertyTypeMismatch","setterGetterTypeMismatch","fsetSymbol","setFunction","setParamType","setSymbol","clonePropertyWithSetter","fdel","fdelSymbol","delFunction","delSymbol","clonePropertyWithDeleter","fget","fgetSymbol","getFunction1","getFunction2","getFunctionOverload","getSymbol","accessorName","accessorFunction","accessorSymbol","createProperty","awaitableReturnType","asyncGeneratorType","generatorTypeArgs","coroutineType","inferFunctionReturnType","isAbstract","inferredYieldTypes","yieldNode","generatorType","raiseStatement","raiseType","methodAlwaysRaisesNotImplemented","noReturnClass","inferredReturnTypes","returnNode","evaluateTypesForForStatement","evaluateTypesForExceptStatement","exceptionTypes","getExceptionType","subType","evaluateTypesForWithStatement","reportOptionalContextManager","noneNotUsableWith","enterMethodName","scopedType","additionalHelp","enterType","memberReturnType","asyncHelp","typeNotUsableWith","exitMethodName","evaluateTypesForImportAs","symbolNameNode","symbolType","getAliasedSymbolTypeForName","cachedModuleType","evaluateTypesForImportFromAs","aliasNode","importLookupInfo","importSymbolUnknown","evaluateTypesForImportFrom","getInferredTypeOfDeclaration","lastContextualExpression","isContextual","isNodeContextual","evaluateTypeAnnotationExpression","annotationParent","annotationType","nodeToEvaluate","evaluateTypeOfParameter","listComprehension","getTypeFromWildcardImport","wildcardDecl","isCallNoReturn","callIsNoReturn","getDeclaredCallBaseType","overloadedFunction","isStubDefinition","isPyTypedDefinition","executionScope","getExecutionScopeNode","getCodeFlowExpressions","executionNode","analyzer","codeFlowAnalyzer","getCodeFlowAnalyzerForReturnTypeInferenceContext","createCodeFlowAnalyzer","wasIncompleteTypeMode","codeFlowResult","getTypeFromCodeFlow","isIncomplete","enterIncompleteTypeMode","leaveIncompleteTypeMode","flowNodeTypeCacheSet","flowNodeTypeCache","setCacheEntry","prevIncompleteType","incompleteSubtypes","generationCount","setIncompleteSubtype","incompleteEntries","getCacheEntry","deleteCacheEntry","typesToCombine","evaluateAssignmentFlowNode","nodeForCacheLookup","getTypeFromFlowNode","curFlowNode","callFlowNode","assignmentFlowNode","flowType","aliasFlowNode","sawIncomplete","flowTypeResult","labelNode","firstWasIncomplete","isFirstTimeInLoop","cacheEntry","typeNarrowingCallback","getTypeNarrowingCallback","preFinallyFlowNode","postFinallyFlowNode","wasGateClosed","wildcardImportFlowNode","visitedFlowNodeMap","isFlowNodeReachableRecursive","isPositiveTest","adjIsPositiveTest","NeverType","arg0Expr","matches","narrowTypeForLiteralComparison","referenceType","literalType","canNarrow","narrowedType","isTypeDeclared","narrowTypeForDiscriminatedFieldComparison","containerType","narrowTypeForContains","narrowTypeForCallable","arg1Expr","foundNonClassType","getIsInstanceClassTypes","foundSuperclass","isClassRelationshipIndeterminate","narrowTypeForIsInstance","canBeTruthy","canBeFalsy","literalValueMatches","isLiteralValueSame","allLiteralTypes","enumerateLiteralsForType","paramSpec","concatTypeArgs","callableFirstArg","callableExtraArgs","createCallableType","optionalExtraArgs","createOptionalType","classVarFirstArgMissing","classVarTooManyArgs","createClassVarType","createUnionType","genericTypeArgMissing","uniqueTypeVars","genericTypeArgUnique","genericTypeArgTypeVar","createGenericType","finalContext","finalTooManyArgs","createFinalType","annotatedTypeArgMissing","createAnnotatedType","concatenateParamSpecMissing","concatenateTypeArgsMissing","createConcatenateType","typeArgCount","getTypeParameters","isPartiallyConstructed","typeArgsExpectingNone","typeArgsTooFew","typeArgType","maxTypeRecursionCount","effectiveSrcType","typeBound","constraint","isSameWithoutLiteralValue","typeConstrainedTypeVar","canAssignToTypeVar","typeVarAssignmentMismatch","allowMissingTypeArgs","nameType","getBuiltInScope","honorCodeFlow","usageScope","declNode","wasSuppressed","enterSpeculativeContext","leaveSpeculativeContext","getDeclarationFromFunctionNamedParameter","functionScope","paramSymbol","intType","typeAliasNode","getTypeAnnotationNode","applyLoaderActionsToModuleType","moduleType","importedModuleSymbol","loaderFields","isSpeculativeTypeAliasFromPyTypedFile","inferredType","DeclarationUtils","usageNode","isPrivateMember","considerDecl","isTypeAlias","stripLiteralTypeArgsValue","isEnum","synthesizedType","getSynthesizedType","inferTypeIfNeeded","disableSpeculativeMode","enableSpeculativeMode","isWrapReturnTypeInAwait","hasUnannotatedParams","contextualReturnType","context","prevTypeCache","allArgTypesAreUnknown","getFunctionInferredReturnTypeUsingArguments","member","canAssignClass","reportErrorsUsingObjType","canAssignClassToProtocol","destClassFields","genericDestType","genericDestTypeVarMap","typesAreConsistent","srcClassTypeVarMap","buildTypeVarMapFromSpecializedClass","memberTypeMismatch","protocolMemberClassVar","protocolMemberMissing","specializeForBaseClass","specializedSrcProtocol","verifyTypeArgumentsAssignable","destEntries","srcEntries","destEntry","srcEntry","typedDictFieldNotRequired","typedDictFieldMissing","canAssignTypedDict","fgetDestReturnType","fgetSrcReturnType","inheritanceChain","curSrcType","curTypeVarMap","ancestorIndex","ancestorType","destTypeArgs","destArgCount","isDestHomogenousTuple","srcTypeArgs","srcArgCount","isSrcHomogeneousType","expectedDestType","expectedSrcType","entryDiag","tupleEntryTypeMismatch","isLocked","canAssignClassWithTypeArgs","destErrorType","srcErrorType","typeIncompatible","destTypeParams","srcArgIndex","srcTypeArg","destArgIndex","destTypeArg","destTypeParam","assignmentDiag","childDiag","typeVarIsCovariant","addAddendum","typeVarIsContravariant","typeVarIsInvariant","canNarrowType","curTypeVarMapping","typeParamSpec","constrainedType","constraintType","typeConstraint","isSrcTypeVar","updatedType","curTypeIsNarrowable","isNarrowable","updatedTypeIsNarrowable","reverseTypeVarMatching","typeVarSubstitution","setTypeArgumentsRecursive","specializedSrcType","isIncompatible","foundMatch","bestTypeVarMap","bestTypeVarMapScore","typeVarMapClone","typeVarMapScore","getScore","copyFromClone","destClassType","srcLiteral","literalAssignmentMismatch","printLiteralType","callbackType","getCallbackProtocolType","canAssignFunction","srcFunction","overloadIndex","noOverloadAssignable","callMember","constructorFunction","constructorInfo","overloadDiag","destOverload","overloadNotAssignable","assignToNone","canAssignFunctionParameter","specializedDestType","paramAssignment","canAssign","checkReturnType","srcParams","destParams","srcStartOfNamed","srcPositionals","srcArgsIndex","destStartOfNamed","destPositionals","destArgsIndex","positionalsToMatch","shouldSkipParamCompatibilityCheck","srcParamType","nonDefaultSrcParamCount","functionTooFewParams","destArgsType","srcArgsType","functionTooManyParams","argsParamMissing","destParamMap","destHasKwargsParam","destParam","paramDiag","specializedDestParamType","namedParamTypeMismatch","namedParamMissingInDest","namedParamMissingInSource","getTypeVars","destReturnType","srcReturnType","returnDiag","functionReturnTypeMismatch","setParamSpec","assignedType","methodList","typedDictEntries","getTypedDictMembersForClassRecursive","keyMap","isCanOmitDictValues","partiallySpecializeFunctionForBoundClassOrObject","newOverloadType","addOverload","specializedFunction","firstParam","bindTypeMismatch","methodName","objName","printFunctionParts","paramTypeStrings","paramString","defaultValueAssignment","ignoreFirstParamOfDeclaration","returnTypeString","expandTypeAlias","unionType","optionalType","isPseudoGeneric","filteredSubtypes","isLiteralObject","isLiteralClass","subtypeStrings","literals","literalValues","printLiteralValue","isEllipsis","exceptionTypeNotInstantiable","expectedExceptionClass","delTargetExpr","nonLocalDecls","localDecl","nonLocalDecl","namePartIndex","aliasDeclaration","argNode","paramDecl","isWithinTypeAnnotation","getCallSignatureInfo","exprNode","addedActive","previousCategory","addFakeArg","startTokenIndex","getItemAtPosition","endTokenIndex","tok","signatures","addOneFunctionToSignature","addFunctionToSignature","baseMethod","overrideMethod","overrideType","canOverride","baseParams","overrideParams","foundParamCountMismatch","overrideParam","overrideParamCount","baseCount","overrideCount","paramCount","positionOnlyIndex","baseParam","overrideParamName","overrideName","baseParamType","overrideParamType","baseIsSynthesizedTypeVar","overrideIsSynthesizedTypeVar","baseReturnType","overrideReturnType","addWarning","unreachableCode","TrackedImport","isAccessed","TrackedImportAs","TrackedImportFrom","ImportSymbolWalker","_accessedImportedSymbols","_treatStringsAsSymbols","_stubPath","_sourceFile","_indentAmount","_includeAllImports","_typeStubText","_lineEnd","_tab","_classNestCount","_functionNestCount","_ifNestCount","_emittedSuite","_emitDocString","_trackedImportAs","_trackedImportFrom","_writeFile","_emitDecorators","argString","_printExpression","_emitLine","_emitSuite","_printParameter","emitValue","_printModuleName","symbolInfo","trackedImportAs","trackedImportFrom","_increaseIndent","prevEmittedSuite","_printArgument","paramTypeAnnotation","isType","treatStringsAsSymbols","importStr","lineEmitted","sortedSymbols","symStr","finalText","_printHeaderDocString","_printTrackedImports","writeFileSync","singleTickRegEx","tripleTickRegEx","newTypes","transformedType","recursionLevel","contextClassType","isGeneric","makeConcrete","typeVarCount","replacementType","_specializeClassType","_specializeFunctionType","_specializeOverloadedFunctionType","declaredTypesOnly","foundUnknownBaseClass","specializedMroClass","list1","list2","type2","type1","buildTypeVarMap","cloneAsInstance","cloneAsInstantiable","newEffectiveTypeArgs","newTypeArgs","specializationNeeded","oldTypeArgType","newTypeArgType","hasTypeVar","getParamSpec","cloneForParamSpec","specializedTypes","typesRequiredSpecialization","specializedParameters","parameterTypes","specializedInferredReturnType","_getGeneratorReturnTypeArgs","literalStr","itemName","anyOrUnknown","hasUnknownBaseClass","enumList","strippedTypeArgs","skipAbstractClassTest","typeChanged","transformedUnion","strippedSpecializedTypes","strippedOverload","transformedOverload","typeAliasPlaceholder","allowLiteralUnions","getTypeVarsFromClass","combinedList","setSkipAbstractClassTest","baseClassToFind","ignoreUnknown","includeInstanceVars","isClassTypedDict","isTypedDictMemberAccessedThroughIndex","allowUnknownTypeArgsForClasses","isMroFound","classListsToMerge","baseClassesToInclude","isInTail","searchClass","classLists","classList","filterClass","classToFilter","foundValidHead","nonEmptyList","moduleList","addDeclaringModuleNamesForType","addIfUnique","_isLocked","_typeVarMap","_paramSpecMap","_isNarrowableMap","newTypeVarMap","score","_getComplexityScoreForType","_getKey","_isNarrowableByKey","minScore","subtypeScore","_getComplexityScoreForClass","typeArgScoreSum","UnionType","classType2","type1TypeArgs","type2TypeArgs","objType2","functionType2","params1","params2","param1","param2","return1Type","return2Type","unionType2","subtypes1","subtypes2","containsType","type2TypeVar","boundType1","boundType2","constraints1","constraints2","type2Module","removeFromUnion","removeFilter","expandedTypes","isNoReturn","newUnionType","addType","typeToAdd","literalStrMap","literalIntMap","_addTypeIfUnique","typeClone","_instance","treatAliasAsSame","class1Details","class2Details","dataClassEntries1","dataClassEntries2","symbolsMatch","symbol1","symbol2","newClassType","subclassType","parentClassType","aliasedSubclass","typeFlags","deleteFirstParam","newFunction","startParam","newInstance","specEntry","useUnknown","isConstructorMethod","_noneInstance","_noneType","_neverInstance","_anyInstance","_ellipsisInstance","nodeId","typeVarType","BackgroundAnalysis","BackgroundAnalysisBase","initialData","rootDirectory","global","__rootDirectory","cancellationFolderName","getCancellationFolderName","worker","Worker","__filename","workerData","setup","BackgroundAnalysisRunner","BackgroundAnalysisRunnerBase","_worker","on","msg","requestType","logData","level","convertAnalysisResults","LogLevel","enqueueRequest","_startOrResumeAnalysis","port1","port2","MessageChannel","disposeCancellationToken","cancellationId","getCancellationTokenId","port","waiter","getBackgroundWaiter","convertDiagnostics","request","postMessage","BackgroundThreadBase","Info","threadId","getConsole","parentPort","onMessage","Log","getCancellationTokenFromId","_analyzeOneChunk","run","createConfigOptionsFrom","_reportDiagnostics","_analysisPaused","processIndexing","_analysisDone","_actions","_rule","_relatedInfo","setCancellationFolderName","createFromRealFileSystem","Warn","jsonObject","RegExp","defaultPythonVersion","defaultPythonPlatform","code","kind","Promise","resolve","reject","m","ls","_createStub","CreateTypeStubCommand","_restartServer","RestartServerCommand","_quickAction","QuickActionCommand","cmdParams","execute","ResponseError","_ls","callingFile","service","_createTypeStubService","workspace","workspaceName","rootUri","convertPathToUri","serviceInstance","disableLanguageServices","disableOrganizeImports","isInitialized","createDeferred","serverSettings","getSettings","AnalyzerServiceExecutor","runWithOptions","writeTypeStubInBackground","dispose","infoMessage","window","showInformationMessage","_handlePostCreateTypeStub","errMessage","showErrorMessage","getWorkspaceForFile","createBackgroundAnalysis","params","docUri","otherArgs","convertUriToPath","convertTextEdits","CancellationThrottle","curTimestamp","valueOf","_lastCheckTimestamp","FileBasedToken","cancellationFilePath","isCancelled","_emitter","fire","_disposeEmitter","shouldCheck","_pipeExists","Emitter","OwningFileToken","_createPipe","_removePipe","flag","unlinkSync","FileBasedCancellationTokenSource","_cancellationFilePath","_ownFile","_token","Cancelled","getCancellationFilePath","folderName","os","tmpdir","getCancellationFolderPath","String","FileCancellationReceiverStrategy","ErrorCodes","RequestCancelled","isCancellationRequested","argv","receiver","createReceiverStrategyFromArgv","CancellationReceiverStrategy","Message","sender","CancellationSenderStrategy","extractCancellationFolderName","cancellationSourceId","CancellationTokenSource","disposables","onCancellationRequested","toOffset","array","addRange","to","from","selectIndex","predicate","binarySearchKey","keySelector","keyComparer","low","high","middle","emptyArray","equalityComparer","equateValues","comparer","indicesOf","x","y","compareValues","stableSortIndices","every","isArray","object","property","reduce","ExecutionEnvironment","latestStablePythonVersion","diagSettings","getDiagnosticRuleSet","envRoot","srcPath","src","diagnosticOverrides","skipIncludeSection","configTypeCheckingMode","isAbsolute","effectiveTypeCheckingMode","defaultSettings","_convertBoolean","_convertDiagnosticLevel","versionFromString","typingsPath","_initExecutionEnvironmentFromJson","_getPythonVersionFromPythonInterpreter","severity","fieldName","envObj","newExecEnv","pathIndex","versionJson","versionFromMajorMinor","major","minor","logType","logCount","infoCount","warnCount","errorCount","_levelMap","_maxLevel","maxLevel","_log","_getNumericalLevel","numericLevel","compareComparableValues","hasOwnProperty","prototype","call","trueOrFalse","toUpperCase","execArgv","stackCrawlMark","captureStackTrace","assertDefined","verboseDebugInfo","func","hasProperty","Function","enumObject","isFlags","members","stableSort","getEnumMembers","remainingFlags","enumValue","enumName","DeferredImpl","_resolved","_rejected","_promise","res","rej","_resolve","_reject","_value","apply","_reason","promises","deferred","all","then","catch","promise","_messages","_childAddenda","newAddendum","maxDepth","maxLineCount","_getLinesRecursive","_getMessageCount","addendum","messageCount","childLines","maxDepthRemaining","extraSpace","_diagnosticList","_diagnosticMap","prevDiagnostics","diagsToAdd","positionRange","ignoreErrors","fileWatcherProvider","RealFileSystem","ChokidarFileWatcherProvider","NullConsole","normalizedPaths","_isMacintosh","_isLinux","_fileWatcherProvider","chdir","readdirSync","withFileTypes","realpathSync","listener","createFileWatcher","createReadStream","createWriteStream","dst","copyFileSync","readFile","_createFileSystemWatcher","watcherOptions","ignoreInitial","ignorePermissionErrors","followSymlinks","interval","binaryInterval","disableGlobbing","awaitWriteFinish","stabilityThreshold","pollInterval","usePolling","excludes","ignored","watcher","chokidar","watch","useFsEvents","_prefix","_dummyState","State","_indentation","_previousTitles","title","_printPreviousTitles","msDuration","isSuppressed","previousTitle","_addendum","_suppress","_fsCaseSensitivity","pathString","getRootLength","lastIndexOf","sep","charAt","p1","p2","rootLength","substring","rest","reducePathComponents","components","reduced","component","extensions","ignoreCase","stringEqualityComparer","tryGetExtensionFromPath","getAnyExtensionFromPathWorker","equateStringsCaseSensitive","baseFileName","getBaseFileName","extensionIndex","fromDirectory","getCanonicalFileNameOrIgnoreCase","getCanonicalFileName","identity","fromComponents","toComponents","fromComponent","toComponent","relative","getPathComponentsRelativeTo","hasTrailingDirectorySeparator","ch","multiDotExtension","extname","firstDotIndex","basename","normalize","getWildcardRegexPattern","pathComponents","escapedSeparator","getRegexEscapedSeparator","doubleAsteriskRegexFragment","reservedCharacterPattern","regExPattern","firstComponent","getWildcardRoot","comparePathsWorker","componentComparer","aRoot","bRoot","compareStringsCaseInsensitive","relativePathSegmentRegExp","aRest","bRest","aComponents","bComponents","sharedLength","pathExtension","fileSystemEntryExists","entryKind","isFileSystemCaseSensitive","isFileSystemCaseSensitiveInternal","mangledFilePath","recursive","randomBytes","FileSpec","candidate","parentPath","relativeTo","startingFromDirPath","curPath","currentDirectory","getStringComparer","parentComponents","childComponents","componentEqualityComparer","pathExt","compareStringsCaseSensitive","isSymbolicLink","uriString","convertedPath","URI","offsetAdjustment","itemIndex","getItemContaining","lineRange","startOffset","endOffset","fromBounds","_reporter","_isDisplayingProgress","isEnabled","begin","report","isNaN","is3x","latestPythonVersion","verString","parseInt","typedValue","symbolLower","toLocaleLowerCase","typedLower","symbolSubstrLength","smallestEditDistance","editDistance","hash","uri","edits","editAction","newText","changes","workspaceEdits","edit","Position","Range","comparePositions","contains","positionOrRange","_items","lastItem","mid","_startTime","TimingStat","totalTime","isTiming","totalTimeInSec","TimingStats","totalDuration","tokenizeFileTime","parseFileTime","printTime","_serverOptions","_connection","createConnection","_GetConnectionOptions","_hasConfigurationCapability","_hasVisualStudioExtensionsCapability","_hasWorkspaceFoldersCapability","_hasWatchFileCapability","_hasActiveParameterCapability","_hasSignatureLabelOffsetCapability","_supportsUnnecessaryDiagnosticTag","_fileWatchers","_lastTriggerKind","CompletionTriggerKind","Invoked","ConsoleWithLogLevel","productName","_workspaceMap","WorkspaceMap","setupConnection","supportedCommands","supportedCodeActions","_progressReporter","ProgressReportTracker","progressReporterFactory","listen","scopeUri","section","getConfiguration","_defaultClientConfig","getNestedProperty","diagnosticMode","getDiagnosticSeverityOverrides","maxAnalysisTimeInForeground","createBackgroundAnalysisProgram","onAnalysisCompletedHandler","lsBase","workspacePaths","nonWorkspacePaths","workspaces","getNonDefaultWorkspaces","nodeWatchers","filename","fileWatcher","eventHandler","onInitialize","initialize","onDidChangeConfiguration","settings","updateSettingsForAllWorkspaces","onCodeAction","executeCodeAction","onDefinition","recordUserInteractionTime","textDocument","getDefinitionForPosition","Location","onReferences","reporter","_pendingFindAllRefsCancellationSource","progress","_getProgressReporter","workDoneToken","CodeAction","findingReferences","CancelAfter","done","onDocumentSymbol","onWorkspaceSymbol","onHover","hoverResults","convertHoverResults","onDocumentHighlight","onSignatureHelp","signatureHelpResults","sig","ParameterInformation","documentation","sigInfo","SignatureInformation","activeParameter","isActive","callHasParameters","activeSignature","isRetrigger","triggerKind","SignatureHelpTriggerKind","prevActiveSignature","activeSignatureHelp","onCompletion","onCompletionResolve","completionItemData","onRenameRequest","convertWorkspaceEdits","languages","callHierarchy","onPrepare","callItem","onIncomingCalls","callItems","onOutgoingCalls","onDidOpenTextDocument","onDidChangeTextDocument","contentChanges","onDidCloseTextDocument","onDidChangeWatchedFiles","change","eventType","onInitialized","onDidChangeWorkspaceFolders","removed","added","newWorkspace","createWorkspaceServiceInstance","updateSettingsForWorkspace","client","register","DidChangeWatchedFilesNotification","watchers","globPattern","WatchKind","Create","Change","Delete","onExecuteCommand","_pendingCommandCancellationSource","executeCommand","WorkspaceEdit","applyEdit","isLongRunningCommand","executingCommand","capabilities","configuration","didChangeWatchedFiles","dynamicRegistration","workspaceFolders","supportsVisualStudioExtensions","signatureHelp","signatureInformation","activeParameterSupport","parameterInformation","labelOffsetSupport","supportedDiagnosticTags","publishDiagnostics","tagSupport","valueSet","tag","DiagnosticTag","Unnecessary","folder","textDocumentSync","TextDocumentSyncKind","Full","definitionProvider","workDoneProgress","referencesProvider","documentSymbolProvider","workspaceSymbolProvider","hoverProvider","documentHighlightProvider","renameProvider","completionProvider","triggerCharacters","resolveProvider","signatureHelpProvider","codeActionProvider","codeActionKinds","executeCommandProvider","commands","callHierarchyProvider","createAnalyzerService","fileDiag","sendDiagnostics","_convertDiagnostics","progressMessage","filesToAnalyzeOne","filesToAnalyzeCount","logLevel","updateOptionsAndRestartService","completionIncomplete","TriggerForIncompleteCompletions","completions","getWorkspaceCompletionsForPosition","logLevelValue","clientReporter","serverInitiatedReporter","createWorkDoneProgress","cancellationStrategy","getCancellationStrategyFromArgv","diags","convertedDiags","DiagnosticSeverity","Warning","Information","Hint","convertCategoryToSeverity","getRule","vsDiag","tags","relatedInfo","getRelatedInfo","relatedInformation","DiagnosticRelatedInformation","_expandPathVariables","languageServiceRootPath","trackFiles","workspaceRootPath","CommandLineOptions","openFilesOnly","getEffectiveCommandLineOptions","createModuleSymbolTableFromIndexResult","callbackfn","externallyVisible","convertSymbolKindToCompletionItemKind","SymbolKind","File","CompletionItemKind","Module","Namespace","Package","Folder","Class","Method","Property","Field","Constructor","Enum","Interface","Variable","Text","Boolean","Value","Constant","Null","Key","EnumMember","Struct","Event","Operator","TypeParameter","moduleSymbolMap","includeAliasDeclarationInIndex","getIndexAliasData","variableKind","_invocationPosition","_excludes","_moduleSymbolMap","_libraryMap","_importStatements","word","importAliasMap","_addImportsFromModuleMap","_addImportsFromLibraryMap","_addImportsFromImportAliasMap","aliasMap","isStubFileOrHasInit","_isStubFileOrHasInit","_processModuleSymbolTable","topLevelSymbols","fileDir","initPathPy","initPathPyi","isStub","hasInit","isStubOrHasInit","importSource","moduleNameAndType","_getImportPartsForSymbols","dotCount","getCharacterCount","autoImportSymbol","_isSimilar","_containsName","_addToImportAliasMap","importParts","autoImportTextEdits","_getTextEditsForAutoImportByFilePath","_getImportParts","modulePath","originalName","mapPerSymbolName","importAliasData","existingData","_compareImportAliasData","left","right","groupComparison","dotComparison","_getModuleNameAndTypeFromFilePath","_getImportGroupFromModuleNameAndType","importNamePart","createImportParts","getTextEditsForAutoImportSymbolAddition","getTextEditsForAutoImportInsertion","getSymbolKind","selectionRange","incomingCalls","FindIncomingCallTreeWalker","findCalls","parseRoot","initMethodMember","primaryInitDecl","outgoingCalls","FindOutgoingCallTreeWalker","_parseRoot","_cancellationToken","_outgoingCalls","_addOutgoingCallForDeclaration","leftHandType","propertyDecls","callDest","outgoingCall","outgoing","rangesAreEqual","fromRanges","fromRange","_symbolName","_declaration","_incomingCalls","_addIncomingCallForDeclaration","callSource","moduleRange","lambdaRange","functionRange","incomingCall","incoming","symbolKind","declType","codeActions","typeStubDiag","actions","getActions","createTypeStubFor","Command","createTypeStub","CodeActionKind","QuickFix","addOptionalDiag","addMissingOptionalAction","addOptionalToAnnotation","_keywords","SortCategory","_workspacePath","_position","_importLookup","_sourceMapper","_moduleSymbolsCallback","initialNode","initialDepth","getNodeDepth","curOffset","curChar","lineTextRange","textOnLine","priorText","postText","priorWordIndex","priorWord","_isWithinComment","_getStringLiteralCompletions","_getImportModuleCompletions","_getExpressionErrorCompletions","_getMemberAccessCompletions","_getImportFromCompletions","_getExpressionCompletions","_getStatementCompletions","autoImportText","curIndex","_mostRecentCompletions","_itemToResolve","tokenIndex","_createSingleKeywordCompletionList","_getMethodOverrideCompletions","keyword","CompletionItem","Keyword","sortText","_makeSortText","LikelyKeyword","CompletionList","partialName","classResults","getMembersForClass","methodSignature","_printMethodSignature","textEdit","TextEdit","_addSymbol","paramList","leftExprNode","lastKnownModule","specializedSubtype","getMembersForModule","functionClass","specializedLeftType","objectThrough","_addSymbolsForSymbolTable","_getLastKnownModule","curType","unknownMemberName","moduleNamesForType","getDeclaringModulesForType","lastKnownMemberName","parseNode","_addCallArgumentCompletions","_addSymbols","_findMatchingKeywords","_getAutoImportCompletions","_getIndexStringLiteral","declaredTypeOfTarget","_addLiteralValuesForTargetType","signatureInfo","callNameEnd","_addNamedParameters","_addLiteralValuesForArgument","signature","quoteValue","_getQuoteValueFromPriorText","_addStringLiteralToCompletionList","stringValue","quoteCharacter","lastSingleQuote","lastDoubleQuote","priorString","valueWithQuotes","LiteralValue","rangeStartCol","rangeEndCol","autoImport","_addNameToCompletionList","importFromNode","implImport","keywordList","partialMatch","argNameMap","_addNamedParametersToMap","argName","NamedParameter","includeSymbolCallback","autoImportSource","additionalTextEdits","itemKind","_convertDeclarationTypeToItemKind","typeDetail","propertyType","getClassDocString","getFunctionDocStringFromType","getOverloadedFunctionDocStrings","doc","markdownString","convertDocStringToMarkdown","MarkupKind","Markdown","AutoImport","DunderSymbol","PrivateSymbol","NormalSymbol","trimEnd","te","sortCategory","recentListIndex","_getRecentListIndex","RecentAutoImport","ImportModuleName","RecentImportModuleName","RecentKeywordOrSymbol","_formatInteger","val","digits","charCodeZero","digit","fromCharCode","resolvedDeclaration","getCompletionSuggestions","missingImportKeyword","completionName","definitions","_addIfUnique","implDecls","findDeclarations","implDecl","itemToAdd","def","HighlightSymbolTreeWalker","_highlightResults","_resultsContainsDeclaration","_addResult","_isWriteAccess","DocumentHighlightKind","Write","Read","resolvedDeclNonlocal","HighlightStringTreeWalker","_stringValue","resolvedDeclarations","findHighlights","aliasData","resolved","getNameFromDeclaration","appendWorkspaceSymbolsRecursive","indexSymbolData","container","symbolData","location","containerName","getContainerName","appendDocumentSymbolsRecursive","collectSymbolIndexData","autoImportMode","allNameTable","hasDeclarations","collectSymbolIndexDataForName","_addResultsForDeclaration","typeText","_addResultsPart","_addDocumentationPart","_getTypeText","typeNode","_addInitMethodInsteadIfCallNode","callLeftNode","instanceType","functionParts","classText","_addDocumentationPartForType","_addDocumentationResultsPart","python","markupString","sortedStatements","compareImportStatements","primaryRange","_getPrimaryReplacementRange","_generateSortedImportText","_addSecondaryReplacementRanges","statementLimit","secondaryBlockStart","secondaryBlockLimit","curImportType","importLine","_formatImportNode","_formatImportFromNode","_compareSymbols","symbolText","cumulativeText","ImportSorter","startPos","endPos","additionalEditActions","_addMissingOptionalToParam","FindReferencesTreeWalker","_referencesResult","_includeDeclaration","evalScope","findReferences","callSignatureInfo","_makeSignature","stringParts","extractParameterDocumentation","ParameterizedString","_formatString","defaultLocale","stringMapsByLocale","de","deStrings","enUsStrings","es","esStrings","fr","frStrings","ja","jaStrings","ru","ruStrings","zhCnStrings","zhTwStrings","localizedStrings","defaultStrings","getRawString","loadStringsFromJsonFile","loadDefaultStrings","locale","override","localeSplit","loadStringsForLocale","vscodeConfigString","VSCODE_NLS_CONFIG","localeString","LC_ALL","LC_MESSAGES","LANG","LANGUAGE","localeStringSplit","getLocaleFromEnv","keyParts","getRawStringFromMap","curObj","keyPart","annotationFormatString","annotationSpansStrings","annotationStringEscape","annotationTripleQuote","awaitIllegal","backticksIllegal","breakOutsideLoop","comprehensionInDict","comprehensionInSet","continueInFinally","continueOutsideLoop","defaultValueNotAllowed","dictInAnnotation","dictKeyValuePairs","dictExpandIllegalInComprehension","duplicateArgsParam","duplicateCatchAll","duplicateKwargsParam","duplicateNameOnly","duplicatePositionOnly","duplicateUnpack","expectedAfterDecorator","expectedArrow","expectedAsAfterException","expectedAssignRightHandExpr","expectedBinaryRightHandExpr","expectedClassName","expectedCloseBracket","expectedCloseBrace","expectedCloseParen","expectedColon","expectedDecoratorName","expectedDecoratorNewline","expectedDelExpr","expectedElse","expectedExpr","expectedImport","expectedImportAlias","expectedImportSymbols","expectedIdentifier","expectedIndentedBlock","expectedIn","expectedInExpr","expectedFunctionAfterAsync","expectedFunctionName","expectedMemberName","expectedModuleName","expectedNameAfterAs","expectedNamedArgument","expectedNewlineOrSemicolon","expectedOpenParen","expectedParamName","expectedReturnExpr","expectedSliceIndex","expectedYieldExpr","formatStringBytes","formatStringIllegal","formatStringUnicode","inconsistentIndent","inconsistentTabs","invalidIdentifierChar","invalidTokenChars","keyValueInSet","listInAnnotation","namedExceptAfterCatchAll","nonDefaultAfterDefault","operatorLessOrGreaterDeprecated","paramAfterKwargsParam","positionArgAfterNamedArg","positionOnlyAfterNameOnly","positionOnlyIncompatible","relativeImportNotAllowed","returnOutsideFunction","stringNonAsciiBytes","stringUnterminated","sublistParamsIncompatible","tupleInAnnotation","typeCallNotAllowed","unexpectedAsyncToken","unexpectedExprToken","unexpectedIndent","unexpectedUnindent","unpackIllegalInComprehension","unpackInDict","unpackInSet","unpackTuplesIllegal","varAnnotationIllegal","walrusIllegal","walrusNotAllowed","yieldFromIllegal","useDictInstead","useListInstead","useTupleInstead","useTypeInstead","organizeImports","_text","_currentChar","_isEndOfStream","_checkBounds","pos","advance","isEndOfStream","isWhiteSpace","currentChar","isLineBreak","moveNext","isAtWhiteSpace","isAtLineBreak","CharCategory","_identifierCharFastTableSize","_identifierCharFastTable","_identifierCharMap","_identifierCharMapInitialized","isDecimal","StartIdentifierChar","_buildIdentifierLookupTable","IdentifierChar","_startIdentifierCharRanges","unicode","unicodeLu","unicodeLl","unicodeLt","unicodeLo","unicodeLm","unicodeNl","_identifierCharRanges","unicodeMn","unicodeMc","unicodeNd","unicodePc","_buildIdentifierLookupTableFromUnicodeRangeTable","table","fastTableOnly","entryIndex","rangeStart","rangeEnd","fill","NotIdentifierChar","_nextNodeId","extendRange","newRange","ClassNode","SuiteNode","IfNode","ifOrElifToken","WhileNode","whileToken","ForNode","forToken","ListComprehensionForNode","startToken","ListComprehensionIfNode","ifToken","TryNode","tryToken","ExceptNode","exceptToken","FunctionNode","defToken","ParameterNode","classToken","createDummyForDecorators","WithNode","withToken","WithItemNode","DecoratorNode","atToken","StatementListNode","ErrorNode","initialRange","UnaryOperationNode","BinaryOperationNode","AssignmentExpressionNode","AssignmentNode","TypeAnnotationNode","FunctionAnnotationNode","openParenToken","AugmentedAssignmentNode","AwaitNode","awaitToken","TernaryNode","UnpackNode","starToken","TupleNode","enclosedInParens","CallNode","ListComprehensionNode","IndexItemsNode","openBracketToken","closeBracketToken","IndexNode","SliceNode","YieldNode","yieldToken","YieldFromNode","MemberAccessNode","LambdaNode","lambdaToken","NameNode","nameToken","ConstantNode","keywordType","EllipsisNode","NumberNode","StringNode","unescapedValue","FormatStringNode","StringListNode","DictionaryNode","DictionaryKeyEntryNode","DictionaryExpandEntryNode","SetNode","ListNode","ArgumentNode","argCategory","DelNode","delToken","PassNode","passToken","ImportNode","ModuleNameNode","ImportAsNode","ImportFromNode","fromToken","usesParens","ImportFromAsNode","GlobalNode","NonlocalNode","AssertNode","assertToken","BreakNode","ContinueNode","ReturnNode","RaiseNode","_tokenIndex","_parseOptions","_diagSink","_isInLoop","_isInFunction","_isInFinally","_isParsingTypeAnnotation","_isParsingIndexTrailer","_futureImportMap","_importedModules","_containsWildcardImport","_assignmentExpressionsAllowed","_startNewParse","moduleNode","_atEof","_consumeTokenIfType","nextToken","_peekToken","_getNextToken","indentToken","isIndentAmbiguous","_parseStatement","_consumeTokensUntilType","_tokenizerOutput","textOffset","textLength","parseTextMode","initialParenDepth","_parseTypeAnnotation","_parseFunctionTypeAnnotation","_parseTestExpression","_peekTokenType","tokenizer","Tokenizer","tokenize","_peekKeywordType","_parseIfStatement","_parseWhileStatement","_parseForStatement","_parseTryStatement","_parseWithStatement","_parseFunctionDef","_parseClassDef","_parseAsyncStatement","_peekOperatorType","_parseDecorated","_parseSimpleStatement","asyncToken","_getKeywordToken","_parseSuite","ifNode","_consumeTokenIfKeyword","wasInLoop","wasInFinally","postColonCallback","wasFunction","possibleIndent","dedentToken","matchesIndent","exprListResult","_parseExpressionList","targetExpr","_makeExpressionOrTuple","seqExpr","_parseTestListAsExpression","_parseLoopSuite","_handleExpressionParseError","forNode","compFor","_tryParseCompForStatement","listCompNode","compList","compIter","_tryParseCompIfStatement","startTokenKeywordType","_disallowAssignmentExpression","_parseOrTest","compForNode","ifExpr","_tryParseLambdaExpression","_parseAssignmentExpression","whileNode","tryNode","sawCatchAllExcept","typeExpr","_getTokenIfIdentifier","peekToken","_parseVarArgsList","functionTypeAnnotationToken","_getTypeAnnotationCommentText","_parseFunctionTypeAnnotationComment","terminator","allowAnnotations","sawDefaultParam","reportedNonDefaultParamErr","sawKwSeparator","sawPositionOnlySeparator","sawVarArgs","sawKwArgs","_parseParameter","foundComma","_parseVariableTypeAnnotationComment","lastParam","starCount","slashCount","firstToken","_consumeTokenIfOperator","_getLanguageVersion","V3_8","sublistStart","withItemList","_parseWithItem","withSuite","withNode","withItem","itemNode","_parseExpression","decoratorList","_parseDecorator","atOperator","callNameExpr","namePart","namePartNode","_parseArgList","IdentifierToken","breakToken","continueToken","returnToken","_isNextTokenNeverExpression","returnExpr","_parseTestOrStarListAsExpression","_reportConditionalErrorForStarTupleElement","modName","_parseDottedModuleName","isFutureImport","possibleInputToken","possibleStarToken","inParen","importFromAsNode","importToken","importNode","aliasToken","allowJustDots","moduleNameNode","identifier","globalToken","globalNode","_parseNameList","nonlocalToken","nonlocalNode","raiseToken","raiseNode","assertNode","exceptionExpr","parseError","delNode","V3_3","exprList","_parseYieldExpression","invalidToken","cleanedText","smallStatement","_parseSmallStatement","nextTokenType","_parsePassStatement","_parseBreakStatement","_parseContinueStatement","_parseReturnStatement","_parseFromStatement","_parseImportStatement","_parseGlobalStatement","_parseNonlocalStatement","_parseRaiseStatement","_parseAssertStatement","_parseDelStatement","_parseExpressionStatement","trailingComma","tupleStartRange","tupleNode","errorCategory","errorString","_parseTestExpressionList","allowAssignmentExpression","_parseTestOrStarExpressionList","allowStar","_parseExpressionListGeneric","_parseTestOrStarExpression","sawStar","allowUnpack","_parseBitwiseOrExpression","_parseLambdaExpression","testExpr","elseExpr","leftExpr","walrusToken","rightExpr","_parseAndTest","_parseNotTest","notToken","notExpr","_parseComparison","comparisonOperator","isOperatorComparison","tokenAfterNot","_parseBitwiseXorExpression","_parseBitwiseAndExpression","_parseShiftExpression","_parseArithmeticExpression","nextOperator","_parseArithmeticTerm","_parseArithmeticFactor","_parseAtomExpression","V3_5","atomExpression","_parseAtom","wasParsingTypeAnnotation","isArgListTerminated","isLiteralSubscript","wasParsingIndexTrailer","indexExpressions","_parseSubscriptList","closingToken","indexNode","listResult","_parseSubscript","sliceExpressions","sliceIndex","sawColon","sliceNode","sawKeywordArg","_parseArgument","nameIdentifier","valueExpr","nameExpr","listComp","_tryParseListComprehension","_parseStringList","expressionNode","possibleTupleNode","_parseTupleAtom","listNode","_parseListAtom","dictNode","_parseDictionaryOrSetAtom","keywordToken","keywordAsIdentifier","errorMsg","childNode","allowConditional","lambdaNode","startParen","yieldExpr","_tryParseYieldExpression","_parseTestListWithComprehension","tupleOrExpression","startBracket","closeBracket","listAtom","sawComprehension","startBrace","dictionaryEntries","setEntries","isDictionary","isSet","sawListComprehension","isFirstEntry","doubleStarExpression","doubleStar","keyEntryNode","dictEntry","expandEntryNode","closeCurlyBrace","setAtom","dictionaryAtom","terminalCheck","finalEntryCheck","annotationExpr","isTypeAliasDeclaration","_parseChainAssignments","isOperatorAssignment","destExpr","getNextNodeId","assignmentNode","paramAnnotation","allowUnionNotation","stringToken","unescapedResult","nonAsciiInBytes","_reportStringTokenErrors","curToken","tokenOffset","StringToken","_makeStringNode","stringListNode","functionAnnotation","segment","segmentOffset","segmentLength","isExpression","textRangeStart","formatExpressions","formatStringSegments","segmentExprLength","_getFormatStringExpressionLength","_parseFormatStringSegment","formatDirective","braceDepth","startOfExprOffset","segmentValue","quoteStack","braceCount","parenCount","bracketCount","prevCharWasEqual","ignoreSeparator","inString","quoteSequence","stringList","_parseFormatString","unescapedString","possibleTupleExpr","wasAllowed","disallowedKeywords","keywordText","terminators","term","tokenType","_isAlphaNumericChar","charCode","_isOctalCharCode","_isHexCharCode","_getHexDigitValue","escapedString","isRaw","isFormat","formatExpressionNestCount","formatSegment","strOffset","output","addInvalidEscapeOffset","getEscapedCharacter","scanHexEscape","digitCount","foundIllegalHexDigit","hexValue","localValue","appendOutputChar","char","foundIllegalChar","charCount","lookaheadChar","octalCode","quoteChar","isTriplicate","strChar","and","as","async","await","break","class","continue","__debug__","del","elif","else","except","finally","for","if","import","in","lambda","nonlocal","not","or","pass","raise","return","try","while","with","yield","False","True","_operatorInfo","_cs","CharacterStream","_tokens","_prevLineStart","_parenDepth","_lineRanges","_indentAmounts","_typeIgnoreAll","_typeIgnoreLines","_crCount","_crLfCount","_lfCount","_indentCount","_indentTabCount","_indentSpacesTotal","_singleQuoteCount","_doubleQuoteCount","_addNextToken","NewLineToken","_getComments","_setIndent","Token","_addLineRange","averageSpacePerIndent","skipWhitespace","_handleCharacter","stringPrefixLength","_getStringPrefixLength","stringPrefix","getText","quoteTypeFlags","_getQuoteTypeFlags","_handleString","_handleComment","_handleInvalid","nextChar","newLineType","_handleNewLine","lookAhead","OperatorToken","_isPossibleNumber","_tryNumber","_tryIdentifier","_tryOperator","lineLength","_readIndentationAfterNewLine","tab1Spaces","tab8Spaces","isTabPresent","isSpacePresent","IndentToken","prevTabInfo","dedentPoints","dedentAmount","actualDedentAmount","DedentToken","KeywordToken","radix","leadingChars","isHex","isBinary","isOctal","NumberToken","isDecimalInteger","mightBeFloatingPoint","_skipFloatingPointCandidate","parseFloat","prevComments","_comments","skipToEol","Comment","stringLiteralInfo","_skipToEndOfStringLiteral","getCurrentChar","_skipFractionalNumber","_skipDecimalNumber","allowSign","indentAmount","ExitStatus","cancellationNone","freeze","getVersionString","optionDefinitions","multiple","defaultOption","argErr","optionName","help","outputjson","incompatibleArgs","project","createstub","exit","FatalError","ConfigFileParseError","timeInSec","time","summary","filesAnalyzed","warningCount","informationCount","diagnosticCount","reportDiagnosticsAsJson","fileErrorsAndWarnings","yellow","red","green","blue","gray","reportDiagnosticsAsText","NoErrors","printSummary","stats","printStats","printDetails","dependencies","ErrorsReported","processArgs","PyrightServer","LanguageServerBase","__dirname","reporterFactory","SourceOrganizeImports","_controller","CommandController","pythonSection","pythonAnalysisSection","typeshedPaths","isString","getDiagnosticRuleName","getSeverityOverrides","isOpenFilesOnly","convertLogLevel","pyrightSection","CodeActionProvider","getCodeActionsForPosition","connection","sendNotification","_defaultWorkspacePath","bestRootPath","bestInstance","defaultWorkspace","workspaceNames"],"mappings":"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ACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,CAAC,IAAK,KACN,IACA,IACA,CAAC,IAAK,KACN,IACA,CAAC,IAAK,KACN,CAAC,IAAK,KACN,CAAC,IAAK,KACN,CAAC,IAAK,KACN,CAAC,IAAK,KACN,CAAC,IAAK,KACN,CAAC,IAAK,KACN,IACA,IACA,CAAC,IAAK,KACN,IACA,IACA,CAAC,IAAK,KACN,CAAC,IAAK,KACN,IACA,CAAC,IAAK,KACN,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,CAAC,IAAK,KACN,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,CAAC,IAAK,KACN,CAAC,IAAK,KACN,IACA,CAAC,IAAK,KACN,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,CAAC,IAAK,KACN,IACA,CAAC,IAAK,KACN,CAAC,IAAK,KACN,CAAC,IAAK,KACN,IACA,CAAC,IAAK,KACN,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,KACA,KACA,KACA,KACA,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,CAAC,KAAM,MACP,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,KACA,CAAC,KAAM,MACP,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,KACA,KACA,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,KACA,KACA,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,KACA,CAAC,MAAO,OACR,MACA,CAAC,MAAO,OACR,MACA,MACA,MACA,CAAC,MAAO,OACR,MACA,MACA,CAAC,MAAO,OACR,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,CAAC,MAAO,OACR,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,CAAC,MAAO,OACR,CAAC,MAAO,OACR,MACA,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,OACA,CAAC,OAAQ,QACT,OACA,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,OACA,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,OACA,CAAC,OAAQ,SAGA,EAAAC,UAA+B,CACxC,CAAC,GAAI,KACL,IACA,CAAC,IAAK,KACN,CAAC,IAAK,KACN,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,CAAC,IAAK,KACN,IACA,IACA,IACA,IACA,IACA,IACA,IACA,CAAC,IAAK,KACN,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,CAAC,IAAK,KACN,IACA,IACA,IACA,CAAC,IAAK,KACN,IACA,IACA,CAAC,IAAK,KACN,IACA,IACA,IACA,IACA,IACA,CAAC,IAAK,KACN,IACA,IACA,IACA,IACA,CAAC,IAAK,KACN,CAAC,IAAK,KACN,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,CAAC,IAAK,KACN,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,CAAC,IAAK,KACN,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,CAAC,IAAK,KACN,IACA,CAAC,IAAK,KACN,IACA,IACA,IACA,IACA,IACA,CAAC,IAAK,KACN,CAAC,IAAK,KACN,IACA,IACA,IACA,CAAC,IAAK,KACN,IACA,CAAC,IAAK,KACN,CAAC,IAAK,KACN,CAAC,IAAK,KACN,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,KACA,KACA,KACA,CAAC,KAAM,MACP,KACA,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,CAAC,KAAM,MACP,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,CAAC,KAAM,MACP,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,IAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,KACA,KACA,KACA,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,KACA,CAAC,MAAO,OACR,MACA,CAAC,MAAO,OACR,MACA,MACA,MACA,MACA,CAAC,MAAO,OACR,CAAC,MAAO,OACR,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,CAAC,MAAO,OACR,MACA,MACA,MACA,CAAC,MAAO,OACR,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,KACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,CAAC,MAAO,OACR,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,CAAC,MAAO,OACR,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,CAAC,MAAO,OACR,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,OACA,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,CAAC,OAAQ,QACT,OACA,CAAC,OAAQ,SAGA,EAAAC,UAA+B,CACxC,IACA,IACA,IACA,IACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,KACA,MAGS,EAAAC,UAA+B,CACxC,IACA,IACA,IACA,CAAC,IAAK,KACN,IACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,KACA,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,KACA,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,KACA,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,KACP,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,MACA,MACA,CAAC,MAAO,OACR,MACA,CAAC,MAAO,OACR,MACA,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,MACA,CAAC,MAAO,OACR,MACA,MACA,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,MACA,MACA,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,MACA,CAAC,MAAO,OACR,MACA,CAAC,MAAO,OACR,CAAC,MAAO,OACR,MACA,MACA,CAAC,MAAO,OACR,CAAC,MAAO,OACR,MACA,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,MACA,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,MACA,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,MACA,CAAC,MAAO,OACR,CAAC,MAAO,OACR,MACA,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,MACA,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,MACA,CAAC,MAAO,OACR,CAAC,MAAO,OACR,MACA,MACA,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,MACA,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,MACA,MACA,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,MACA,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,MACA,CAAC,MAAO,OACR,CAAC,MAAO,OACR,MACA,MA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A,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,KACA,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,KACA,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,KACA,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,KACA,CAAC,KAAM,MACP,KACA,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,KACA,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,KACA,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,CAAC,KAAM,MACP,KACA,CAAC,KAAM,MACP,CAAC,MAAO,OACR,MACA,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,MACA,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,MACA,MACA,MACA,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,MACA,CAAC,MAAO,OACR,MACA,MACA,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,MACA,MACA,MACA,MACA,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,MACA,CAAC,MAAO,OACR,MACA,MACA,MACA,MACA,MACA,CAAC,MAAO,OACR,CAAC,MAAO,OACR,MACA,MACA,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,MACA,CAAC,MAAO,OACR,MACA,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,MACA,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,MACA,CAAC,MAAO,OACR,MACA,MACA,CAAC,MAAO,OACR,CAAC,MAAO,OACR,MACA,MACA,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,MACA,CAAC,MAAO,OACR,MACA,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,MACA,CAAC,MAAO,OACR,MACA,MACA,CAAC,MAAO,OACR,MACA,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,MACA,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,MACA,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OACR,CAAC,MAAO,OAC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","file":"pyright-internal.js","sourcesContent":["/*\n * aliasDeclarationUtils.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * Helper functions around alias declarations.\n */\n\nimport { ImportLookup, ImportLookupResult } from './analyzerFileInfo';\nimport { Declaration, DeclarationType } from './declaration';\nimport { Symbol } from './symbol';\n\n// If the specified declaration is an alias declaration that points to a symbol,\n// it resolves the alias and looks up the symbol, then returns the first declaration\n// associated with that symbol. It does this recursively if necessary. If a symbol\n// lookup fails, undefined is returned. If resolveLocalNames is true, the method\n// resolves aliases through local renames (\"as\" clauses found in import statements).\nexport function resolveAliasDeclaration(\n    importLookup: ImportLookup,\n    declaration: Declaration,\n    resolveLocalNames: boolean\n): Declaration | undefined {\n    let curDeclaration: Declaration | undefined = declaration;\n    const alreadyVisited: Declaration[] = [];\n\n    while (true) {\n        if (curDeclaration.type !== DeclarationType.Alias) {\n            return curDeclaration;\n        }\n\n        if (!curDeclaration.symbolName) {\n            return curDeclaration;\n        }\n\n        // If we are not supposed to follow local alias names and this\n        // is a local name, don't continue to follow the alias.\n        if (!resolveLocalNames && curDeclaration.usesLocalName) {\n            return curDeclaration;\n        }\n\n        let lookupResult: ImportLookupResult | undefined;\n        if (curDeclaration.path) {\n            lookupResult = importLookup(curDeclaration.path);\n            if (!lookupResult) {\n                return undefined;\n            }\n        }\n\n        const symbol: Symbol | undefined = lookupResult\n            ? lookupResult.symbolTable.get(curDeclaration.symbolName)\n            : undefined;\n        if (!symbol) {\n            if (curDeclaration.submoduleFallback) {\n                return resolveAliasDeclaration(importLookup, curDeclaration.submoduleFallback, resolveLocalNames);\n            }\n            return undefined;\n        }\n\n        // Prefer declarations with specified types. If we don't have any of those,\n        // fall back on declarations with inferred types.\n        let declarations = symbol.getTypedDeclarations();\n        if (declarations.length === 0) {\n            declarations = symbol.getDeclarations();\n\n            if (declarations.length === 0) {\n                return undefined;\n            }\n        }\n\n        // Prefer the last declaration in the list. This ensures that\n        // we use all of the overloads if it's an overloaded function.\n        curDeclaration = declarations[declarations.length - 1];\n\n        // Make sure we don't follow a circular list indefinitely.\n        if (alreadyVisited.find((decl) => decl === curDeclaration)) {\n            return declaration;\n        }\n        alreadyVisited.push(curDeclaration);\n    }\n}\n","/*\n * analysis.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * Various analysis helper types and functions\n */\n\nimport { CancellationToken } from 'vscode-languageserver';\n\nimport { OperationCanceledException, throwIfCancellationRequested } from '../common/cancellationUtils';\nimport { ConfigOptions } from '../common/configOptions';\nimport { ConsoleInterface } from '../common/console';\nimport * as debug from '../common/debug';\nimport { FileDiagnostics } from '../common/diagnosticSink';\nimport { Duration } from '../common/timing';\nimport { MaxAnalysisTime, Program } from './program';\n\nexport const nullCallback: AnalysisCompleteCallback = (_) => {\n    /* empty */\n};\n\nexport interface AnalysisResults {\n    diagnostics: FileDiagnostics[];\n    filesInProgram: number;\n    checkingOnlyOpenFiles: boolean;\n    filesRequiringAnalysis: number;\n    fatalErrorOccurred: boolean;\n    configParseErrorOccurred: boolean;\n    elapsedTime: number;\n}\n\nexport type AnalysisCompleteCallback = (results: AnalysisResults) => void;\n\nexport function analyzeProgram(\n    program: Program,\n    maxTime: MaxAnalysisTime | undefined,\n    configOptions: ConfigOptions,\n    callback: AnalysisCompleteCallback | undefined,\n    console: ConsoleInterface,\n    token: CancellationToken\n): boolean {\n    let moreToAnalyze = false;\n\n    callback = callback ?? nullCallback;\n\n    try {\n        throwIfCancellationRequested(token);\n\n        const duration = new Duration();\n        moreToAnalyze = program.analyze(maxTime, token);\n\n        const filesLeftToAnalyze = program.getFilesToAnalyzeCount();\n        debug.assert(filesLeftToAnalyze === 0 || moreToAnalyze);\n\n        const diagnostics = program.getDiagnostics(configOptions);\n        const diagnosticFileCount = diagnostics.length;\n        const elapsedTime = duration.getDurationInSeconds();\n\n        // Report any diagnostics or completion.\n        if (diagnosticFileCount > 0 || !moreToAnalyze) {\n            callback({\n                diagnostics,\n                filesInProgram: program.getFileCount(),\n                filesRequiringAnalysis: filesLeftToAnalyze,\n                checkingOnlyOpenFiles: program.isCheckingOnlyOpenFiles(),\n                fatalErrorOccurred: false,\n                configParseErrorOccurred: false,\n                elapsedTime,\n            });\n        }\n    } catch (e) {\n        if (OperationCanceledException.is(e)) {\n            return false;\n        }\n\n        const message = debug.getErrorString(e);\n        console.error('Error performing analysis: ' + message);\n\n        callback({\n            diagnostics: [],\n            filesInProgram: 0,\n            filesRequiringAnalysis: 0,\n            checkingOnlyOpenFiles: true,\n            fatalErrorOccurred: true,\n            configParseErrorOccurred: false,\n            elapsedTime: 0,\n        });\n    }\n\n    return moreToAnalyze;\n}\n","/*\n * analyzerNodeInfo.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Defines objects that hang off the parse nodes in the parse tree.\n * It contains information collected during the binder phase that\n * can be used for later analysis steps or for language services\n * (e.g. hover information).\n */\n\nimport {\n    ClassNode,\n    ExecutionScopeNode,\n    FunctionNode,\n    LambdaNode,\n    ListComprehensionNode,\n    ModuleNode,\n    ParseNode,\n} from '../parser/parseNodes';\nimport { AnalyzerFileInfo } from './analyzerFileInfo';\nimport { FlowFlags, FlowNode } from './codeFlow';\nimport { Declaration } from './declaration';\nimport { ImportResult } from './importResult';\nimport { Scope } from './scope';\n\ninterface AnalyzerNodeInfo {\n    //---------------------------------------------------------------\n    // Set as part of import resolution\n\n    // Information about an import; used for import nodes only.\n    importInfo?: ImportResult;\n\n    //---------------------------------------------------------------\n    // Set by Binder\n\n    // Scope for nodes that introduce scopes: modules, functions,\n    // classes, lambdas, and list comprehensions. A scope is used\n    // to store symbol names and their associated types and declarations.\n    scope?: Scope;\n\n    // Declaration (for functions and classes only).\n    declaration?: Declaration;\n\n    // Control flow information for this node.\n    flowNode?: FlowNode;\n\n    // Control flow information at the end of this node.\n    afterFlowNode?: FlowNode;\n\n    // Info about the source file, used only on module nodes.\n    fileInfo?: AnalyzerFileInfo;\n\n    // Map of expressions used within an execution scope (module,\n    // function or lambda) that requires code flow analysis.\n    codeFlowExpressions?: Map<string, string>;\n}\n\nexport type ScopedNode = ModuleNode | ClassNode | FunctionNode | LambdaNode | ListComprehensionNode;\n\n// Cleans out all fields that are added by the analyzer phases\n// (after the post-parse walker).\nexport function cleanNodeAnalysisInfo(node: ParseNode) {\n    const analyzerNode = node as AnalyzerNodeInfo;\n    delete analyzerNode.scope;\n    delete analyzerNode.declaration;\n    delete analyzerNode.flowNode;\n    delete analyzerNode.afterFlowNode;\n    delete analyzerNode.fileInfo;\n}\n\nexport function getImportInfo(node: ParseNode): ImportResult | undefined {\n    const analyzerNode = node as AnalyzerNodeInfo;\n    return analyzerNode.importInfo;\n}\n\nexport function setImportInfo(node: ParseNode, importInfo: ImportResult) {\n    const analyzerNode = node as AnalyzerNodeInfo;\n    analyzerNode.importInfo = importInfo;\n}\n\nexport function getScope(node: ParseNode): Scope | undefined {\n    const analyzerNode = node as AnalyzerNodeInfo;\n    return analyzerNode.scope;\n}\n\nexport function setScope(node: ParseNode, scope: Scope) {\n    const analyzerNode = node as AnalyzerNodeInfo;\n    analyzerNode.scope = scope;\n}\n\nexport function getDeclaration(node: ParseNode): Declaration | undefined {\n    const analyzerNode = node as AnalyzerNodeInfo;\n    return analyzerNode.declaration;\n}\n\nexport function setDeclaration(node: ParseNode, decl: Declaration) {\n    const analyzerNode = node as AnalyzerNodeInfo;\n    analyzerNode.declaration = decl;\n}\n\nexport function getFlowNode(node: ParseNode): FlowNode | undefined {\n    const analyzerNode = node as AnalyzerNodeInfo;\n    return analyzerNode.flowNode;\n}\n\nexport function setFlowNode(node: ParseNode, flowNode: FlowNode) {\n    const analyzerNode = node as AnalyzerNodeInfo;\n    analyzerNode.flowNode = flowNode;\n}\n\nexport function getAfterFlowNode(node: ParseNode): FlowNode | undefined {\n    const analyzerNode = node as AnalyzerNodeInfo;\n    return analyzerNode.afterFlowNode;\n}\n\nexport function setAfterFlowNode(node: ParseNode, flowNode: FlowNode) {\n    const analyzerNode = node as AnalyzerNodeInfo;\n    analyzerNode.afterFlowNode = flowNode;\n}\n\nexport function getFileInfo(node: ModuleNode): AnalyzerFileInfo | undefined {\n    const analyzerNode = node as AnalyzerNodeInfo;\n    return analyzerNode.fileInfo;\n}\n\nexport function setFileInfo(node: ModuleNode, fileInfo: AnalyzerFileInfo) {\n    const analyzerNode = node as AnalyzerNodeInfo;\n    analyzerNode.fileInfo = fileInfo;\n}\n\nexport function getCodeFlowExpressions(node: ExecutionScopeNode): Map<string, string> | undefined {\n    const analyzerNode = node as AnalyzerNodeInfo;\n    return analyzerNode.codeFlowExpressions;\n}\n\nexport function setCodeFlowExpressions(node: ExecutionScopeNode, map: Map<string, string>) {\n    const analyzerNode = node as AnalyzerNodeInfo;\n    analyzerNode.codeFlowExpressions = map;\n}\n\nexport function isCodeUnreachable(node: ParseNode): boolean {\n    let curNode: ParseNode | undefined = node;\n\n    // Walk up the parse tree until we find a node with\n    // an associated flow node.\n    while (curNode) {\n        const flowNode = getFlowNode(curNode);\n        if (flowNode) {\n            return !!(flowNode.flags & FlowFlags.Unreachable);\n        }\n        curNode = curNode.parent;\n    }\n\n    return false;\n}\n","/*\n * BackgroundAnalysisProgram.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * Applies operations to both the foreground program and a background\n * analysis running in a worker process.\n */\n\nimport { CancellationToken } from 'vscode-languageserver';\n\nimport { BackgroundAnalysisBase } from '../backgroundAnalysisBase';\nimport { ConfigOptions } from '../common/configOptions';\nimport { ConsoleInterface } from '../common/console';\nimport { Diagnostic } from '../common/diagnostic';\nimport { FileDiagnostics } from '../common/diagnosticSink';\nimport { LanguageServiceExtension } from '../common/extensibility';\nimport { Range } from '../common/textRange';\nimport { IndexResults } from '../languageService/documentSymbolProvider';\nimport { AnalysisCompleteCallback, analyzeProgram } from './analysis';\nimport { ImportResolver } from './importResolver';\nimport { Indices, MaxAnalysisTime, Program } from './program';\n\nexport class BackgroundAnalysisProgram {\n    private _program: Program;\n    private _backgroundAnalysis?: BackgroundAnalysisBase;\n    private _onAnalysisCompletion?: AnalysisCompleteCallback;\n    private _maxAnalysisTime?: MaxAnalysisTime;\n    private _indices: Indices | undefined;\n\n    constructor(\n        private _console: ConsoleInterface,\n        private _configOptions: ConfigOptions,\n        private _importResolver: ImportResolver,\n        extension?: LanguageServiceExtension,\n        backgroundAnalysis?: BackgroundAnalysisBase,\n        maxAnalysisTime?: MaxAnalysisTime\n    ) {\n        this._program = new Program(this._importResolver, this._configOptions, this._console, extension);\n        this._backgroundAnalysis = backgroundAnalysis;\n        this._maxAnalysisTime = maxAnalysisTime;\n    }\n\n    get configOptions() {\n        return this._configOptions;\n    }\n\n    get importResolver() {\n        return this._importResolver;\n    }\n\n    get program() {\n        return this._program;\n    }\n\n    get backgroundAnalysis() {\n        return this._backgroundAnalysis;\n    }\n\n    setConfigOptions(configOptions: ConfigOptions) {\n        this._configOptions = configOptions;\n        this._backgroundAnalysis?.setConfigOptions(configOptions);\n        this._program.setConfigOptions(configOptions);\n    }\n\n    setImportResolver(importResolver: ImportResolver) {\n        this._importResolver = importResolver;\n        this._program.setImportResolver(importResolver);\n\n        // Do nothing for background analysis.\n        // Background analysis updates importer when configOptions is changed rather than\n        // having two APIs to reduce the chance of the program and importer pointing to\n        // two different configOptions.\n    }\n\n    setTrackedFiles(filePaths: string[]) {\n        this._backgroundAnalysis?.setTrackedFiles(filePaths);\n        const diagnostics = this._program.setTrackedFiles(filePaths);\n        this._reportDiagnosticsForRemovedFiles(diagnostics);\n    }\n\n    setAllowedThirdPartyImports(importNames: string[]) {\n        this._backgroundAnalysis?.setAllowedThirdPartyImports(importNames);\n        this._program.setAllowedThirdPartyImports(importNames);\n    }\n\n    setFileOpened(filePath: string, version: number | null, contents: string) {\n        this._backgroundAnalysis?.setFileOpened(filePath, version, contents);\n        this._program.setFileOpened(filePath, version, contents);\n    }\n\n    updateOpenFileContents(path: string, version: number | null, contents: string) {\n        this.setFileOpened(path, version, contents);\n        this.markFilesDirty([path], true);\n    }\n\n    setFileClosed(filePath: string) {\n        this._backgroundAnalysis?.setFileClosed(filePath);\n        const diagnostics = this._program.setFileClosed(filePath);\n        this._reportDiagnosticsForRemovedFiles(diagnostics);\n    }\n\n    markAllFilesDirty(evenIfContentsAreSame: boolean) {\n        this._backgroundAnalysis?.markAllFilesDirty(evenIfContentsAreSame);\n        this._program.markAllFilesDirty(evenIfContentsAreSame);\n    }\n\n    markFilesDirty(filePaths: string[], evenIfContentsAreSame: boolean) {\n        this._backgroundAnalysis?.markFilesDirty(filePaths, evenIfContentsAreSame);\n        this._program.markFilesDirty(filePaths, evenIfContentsAreSame);\n    }\n\n    setCompletionCallback(callback?: AnalysisCompleteCallback) {\n        this._onAnalysisCompletion = callback;\n        this._backgroundAnalysis?.setCompletionCallback(callback);\n    }\n\n    startAnalysis(token: CancellationToken): boolean {\n        if (this._backgroundAnalysis) {\n            this._backgroundAnalysis.startAnalysis(this._indices, token);\n            return false;\n        }\n\n        return analyzeProgram(\n            this._program,\n            this._maxAnalysisTime,\n            this._configOptions,\n            this._onAnalysisCompletion,\n            this._console,\n            token\n        );\n    }\n\n    test_setIndexing(\n        workspaceIndices: Map<string, IndexResults>,\n        libraryIndices: Map<string, Map<string, IndexResults>>\n    ) {\n        const indices = this._getIndices();\n        for (const [filePath, indexResults] of workspaceIndices) {\n            indices.setWorkspaceIndex(filePath, indexResults);\n        }\n\n        for (const [execEnvRoot, map] of libraryIndices) {\n            for (const [libraryPath, indexResults] of map) {\n                indices.setIndex(execEnvRoot, libraryPath, indexResults);\n            }\n        }\n    }\n\n    startIndexing() {\n        if (!this._configOptions.indexing) {\n            return;\n        }\n\n        this._backgroundAnalysis?.startIndexing(this._configOptions, this._getIndices());\n    }\n\n    refreshIndexing() {\n        if (!this._configOptions.indexing) {\n            return;\n        }\n\n        this._backgroundAnalysis?.refreshIndexing(this._configOptions, this._indices);\n    }\n\n    cancelIndexing() {\n        this._backgroundAnalysis?.cancelIndexing(this._configOptions);\n    }\n\n    getIndexing(filePath: string) {\n        return this._indices?.getIndex(this._configOptions.findExecEnvironment(filePath).root);\n    }\n\n    async getDiagnosticsForRange(filePath: string, range: Range, token: CancellationToken): Promise<Diagnostic[]> {\n        if (this._backgroundAnalysis) {\n            return this._backgroundAnalysis.getDiagnosticsForRange(filePath, range, token);\n        }\n\n        return this._program.getDiagnosticsForRange(filePath, range);\n    }\n\n    async writeTypeStub(\n        targetImportPath: string,\n        targetIsSingleFile: boolean,\n        stubPath: string,\n        token: CancellationToken\n    ): Promise<any> {\n        if (this._backgroundAnalysis) {\n            return this._backgroundAnalysis.writeTypeStub(targetImportPath, targetIsSingleFile, stubPath, token);\n        }\n\n        analyzeProgram(this._program, undefined, this._configOptions, this._onAnalysisCompletion, this._console, token);\n        return this._program.writeTypeStub(targetImportPath, targetIsSingleFile, stubPath, token);\n    }\n\n    invalidateAndForceReanalysis() {\n        this.refreshIndexing();\n\n        this._backgroundAnalysis?.invalidateAndForceReanalysis();\n\n        // Make sure the import resolver doesn't have invalid\n        // cached entries.\n        this._importResolver.invalidateCache();\n\n        // Mark all files with one or more errors dirty.\n        this._program.markAllFilesDirty(true);\n    }\n\n    invalidateCache() {\n        // Invalidate import resolver because it could have cached\n        // imports that are no longer valid because a source file has\n        // been deleted or added.\n        this._importResolver.invalidateCache();\n    }\n\n    restart() {\n        this._backgroundAnalysis?.restart();\n    }\n\n    private _getIndices(): Indices {\n        if (!this._indices) {\n            const program = this._program;\n\n            // The map holds onto index results of library files per execution root.\n            // The map will be refreshed together when library files are re-scanned.\n            // It can't be cached by sourceFile since some of library files won't have\n            // corresponding sourceFile created.\n            const map = new Map<string, Map<string, IndexResults>>();\n            this._indices = {\n                setWorkspaceIndex(path: string, indexResults: IndexResults): void {\n                    // Index result of workspace file will be cached by each sourceFile\n                    // and it will go away when the source file goes away.\n                    program.getSourceFile(path)?.cacheIndexResults(indexResults);\n                },\n                getIndex(execEnv: string): Map<string, IndexResults> | undefined {\n                    return map.get(execEnv);\n                },\n                setIndex(execEnv: string, path: string, indexResults: IndexResults): void {\n                    let indicesMap = map.get(execEnv);\n                    if (!indicesMap) {\n                        indicesMap = new Map<string, IndexResults>();\n                        map.set(execEnv, indicesMap);\n                    }\n\n                    indicesMap.set(path, indexResults);\n                },\n                reset(): void {\n                    map.clear();\n                },\n            };\n        }\n\n        return this._indices!;\n    }\n\n    private _reportDiagnosticsForRemovedFiles(fileDiags: FileDiagnostics[]) {\n        if (fileDiags.length > 0) {\n            // If analysis is running in the foreground process, report any\n            // diagnostics that resulted from the close operation (used to\n            // clear diagnostics that are no longer of interest).\n            if (!this._backgroundAnalysis && this._onAnalysisCompletion) {\n                this._onAnalysisCompletion({\n                    diagnostics: fileDiags,\n                    filesInProgram: this._program.getFileCount(),\n                    filesRequiringAnalysis: this._program.getFilesToAnalyzeCount(),\n                    checkingOnlyOpenFiles: this._program.isCheckingOnlyOpenFiles(),\n                    fatalErrorOccurred: false,\n                    configParseErrorOccurred: false,\n                    elapsedTime: 0,\n                });\n            }\n        }\n    }\n}\n\nexport type BackgroundAnalysisProgramFactory = (\n    console: ConsoleInterface,\n    configOptions: ConfigOptions,\n    importResolver: ImportResolver,\n    extension?: LanguageServiceExtension,\n    backgroundAnalysis?: BackgroundAnalysisBase,\n    maxAnalysisTime?: MaxAnalysisTime\n) => BackgroundAnalysisProgram;\n","/*\n * binder.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * A parse tree walker that performs basic name binding (creation of\n * scopes and associated symbol tables).\n * The binder walks the parse tree by scopes starting at the module\n * level. When a new scope is detected, it is pushed onto a list and\n * walked separately at a later time. (The exception is a class scope,\n * which is immediately walked.) Walking the tree in this manner\n * simulates the order in which execution normally occurs in a Python\n * file. The binder attempts to statically detect runtime errors that\n * would be reported by the python interpreter when executing the code.\n * This binder doesn't perform any static type checking.\n */\n\nimport { Commands } from '../commands/commands';\nimport { DiagnosticLevel } from '../common/configOptions';\nimport { assert, assertNever, fail } from '../common/debug';\nimport { CreateTypeStubFileAction, Diagnostic } from '../common/diagnostic';\nimport { DiagnosticRule } from '../common/diagnosticRules';\nimport { getFileName, stripFileExtension } from '../common/pathUtils';\nimport { convertOffsetsToRange } from '../common/positionUtils';\nimport { PythonVersion } from '../common/pythonVersion';\nimport { getEmptyRange } from '../common/textRange';\nimport { TextRange } from '../common/textRange';\nimport { Localizer } from '../localization/localize';\nimport {\n    ArgumentCategory,\n    AssertNode,\n    AssignmentExpressionNode,\n    AssignmentNode,\n    AugmentedAssignmentNode,\n    AwaitNode,\n    BinaryOperationNode,\n    BreakNode,\n    CallNode,\n    ClassNode,\n    ContinueNode,\n    DelNode,\n    ExceptNode,\n    ExpressionNode,\n    ForNode,\n    FunctionNode,\n    GlobalNode,\n    IfNode,\n    ImportAsNode,\n    ImportFromNode,\n    LambdaNode,\n    ListComprehensionNode,\n    MemberAccessNode,\n    ModuleNameNode,\n    ModuleNode,\n    NameNode,\n    NonlocalNode,\n    ParseNode,\n    ParseNodeType,\n    RaiseNode,\n    ReturnNode,\n    StatementNode,\n    StringListNode,\n    SuiteNode,\n    TernaryNode,\n    TryNode,\n    TypeAnnotationNode,\n    UnaryOperationNode,\n    WhileNode,\n    WithNode,\n    YieldFromNode,\n    YieldNode,\n} from '../parser/parseNodes';\nimport * as StringTokenUtils from '../parser/stringTokenUtils';\nimport { KeywordType, OperatorType } from '../parser/tokenizerTypes';\nimport { AnalyzerFileInfo, ImportLookupResult } from './analyzerFileInfo';\nimport * as AnalyzerNodeInfo from './analyzerNodeInfo';\nimport {\n    createKeyForReference,\n    FlowAssignment,\n    FlowAssignmentAlias,\n    FlowCall,\n    FlowCondition,\n    FlowFlags,\n    FlowLabel,\n    FlowNode,\n    FlowPostFinally,\n    FlowPreFinallyGate,\n    FlowWildcardImport,\n    getUniqueFlowNodeId,\n    isCodeFlowSupportedForReference,\n} from './codeFlow';\nimport {\n    AliasDeclaration,\n    ClassDeclaration,\n    DeclarationType,\n    FunctionDeclaration,\n    IntrinsicType,\n    ModuleLoaderActions,\n    ParameterDeclaration,\n    VariableDeclaration,\n} from './declaration';\nimport { ImplicitImport, ImportResult, ImportType } from './importResult';\nimport * as ParseTreeUtils from './parseTreeUtils';\nimport { ParseTreeWalker } from './parseTreeWalker';\nimport { Scope, ScopeType } from './scope';\nimport * as StaticExpressions from './staticExpressions';\nimport { indeterminateSymbolId, Symbol, SymbolFlags } from './symbol';\nimport { isConstantName, isPrivateOrProtectedName } from './symbolNameUtils';\nimport { getNamesInDunderAll } from './symbolUtils';\n\nexport const enum NameBindingType {\n    // With \"nonlocal\" keyword\n    Nonlocal,\n\n    // With \"global\" keyword\n    Global,\n}\n\ninterface MemberAccessInfo {\n    classNode: ClassNode;\n    methodNode: FunctionNode;\n    classScope: Scope;\n    isInstanceMember: boolean;\n}\n\ninterface DeferredBindingTask {\n    scope: Scope;\n    nonLocalBindingsMap: Map<string, NameBindingType>;\n    codeFlowExpressionMap: Map<string, string>;\n    callback: () => void;\n}\n\ninterface FinalInfo {\n    isFinal: boolean;\n    finalTypeNode?: ExpressionNode;\n}\n\ntype NarrowingExpressionNode = NameNode | MemberAccessNode;\n\nexport interface BinderResults {\n    moduleDocString?: string;\n}\n\nexport class Binder extends ParseTreeWalker {\n    private readonly _fileInfo: AnalyzerFileInfo;\n\n    // A queue of deferred analysis operations.\n    private _deferredBindingTasks: DeferredBindingTask[] = [];\n\n    // The current scope in effect.\n    private _currentScope: Scope | undefined;\n\n    // Name bindings that are not local to the current scope.\n    private _notLocalBindings = new Map<string, NameBindingType>();\n\n    // Number of nested except statements at current point of analysis.\n    // Used to determine if a naked \"raise\" statement is allowed.\n    private _nestedExceptDepth = 0;\n\n    // Current control-flow node.\n    private _currentFlowNode: FlowNode | undefined;\n\n    // Current target function declaration, if currently binding\n    // a function. This allows return and yield statements to be\n    // added to the function declaration.\n    private _targetFunctionDeclaration: FunctionDeclaration | undefined;\n\n    // Flow node label that is the target of a \"break\" statement.\n    private _currentBreakTarget?: FlowLabel;\n\n    // Flow node label that is the target of a \"continue\" statement.\n    private _currentContinueTarget?: FlowLabel;\n\n    // Flow nodes used for if/else and while/else statements.\n    private _currentTrueTarget?: FlowLabel;\n    private _currentFalseTarget?: FlowLabel;\n\n    // Flow nodes used within try blocks.\n    private _currentExceptTargets?: FlowLabel[];\n\n    // Flow nodes used within try/finally flows.\n    private _finallyTargets: FlowLabel[] = [];\n\n    // Flow nodes used for return statements.\n    private _currentReturnTarget?: FlowLabel;\n\n    // Map of symbols within the current execution scope\n    // and require code flow analysis to resolve.\n    private _currentExecutionScopeReferenceMap: Map<string, string> | undefined;\n\n    // Aliases of \"typing\" and \"typing_extensions\".\n    private _typingImportAliases: string[] = [];\n\n    // Map of imports of specific symbols imported from \"typing\" and \"typing_extensions\"\n    // and the names they alias to.\n    private _typingSymbolAliases: Map<string, string> = new Map<string, string>();\n\n    // Flow node that is used for unreachable code.\n    private static _unreachableFlowNode: FlowNode = {\n        flags: FlowFlags.Unreachable,\n        id: getUniqueFlowNodeId(),\n    };\n\n    constructor(fileInfo: AnalyzerFileInfo) {\n        super();\n\n        this._fileInfo = fileInfo;\n    }\n\n    bindModule(node: ModuleNode): BinderResults {\n        // We'll assume that if there is no builtins scope provided, we must be\n        // binding the builtins module itself.\n        const isBuiltInModule = this._fileInfo.builtinsScope === undefined;\n\n        this._createNewScope(\n            isBuiltInModule ? ScopeType.Builtin : ScopeType.Module,\n            this._fileInfo.builtinsScope,\n            () => {\n                AnalyzerNodeInfo.setScope(node, this._currentScope!);\n                AnalyzerNodeInfo.setFlowNode(node, this._currentFlowNode!);\n\n                // Bind implicit names.\n                // List taken from https://docs.python.org/3/reference/import.html#__name__\n                this._addBuiltInSymbolToCurrentScope('__doc__', node, 'str');\n                this._addBuiltInSymbolToCurrentScope('__name__', node, 'str');\n                this._addBuiltInSymbolToCurrentScope('__loader__', node, 'Any');\n                this._addBuiltInSymbolToCurrentScope('__package__', node, 'str');\n                this._addBuiltInSymbolToCurrentScope('__spec__', node, 'Any');\n                this._addBuiltInSymbolToCurrentScope('__path__', node, 'List[str]');\n                this._addBuiltInSymbolToCurrentScope('__file__', node, 'str');\n                this._addBuiltInSymbolToCurrentScope('__cached__', node, 'str');\n                this._addBuiltInSymbolToCurrentScope('__dict__', node, 'Dict[str, Any]');\n\n                // Create a start node for the module.\n                this._currentFlowNode = this._createStartFlowNode();\n\n                this._walkStatementsAndReportUnreachable(node.statements);\n\n                AnalyzerNodeInfo.setCodeFlowExpressions(node, this._currentExecutionScopeReferenceMap!);\n\n                // Associate the code flow node at the end of the module with the module.\n                AnalyzerNodeInfo.setAfterFlowNode(node, this._currentFlowNode);\n            }\n        );\n\n        // Perform all analysis that was deferred during the first pass.\n        this._bindDeferred();\n\n        return {\n            moduleDocString: ParseTreeUtils.getDocString(node.statements),\n        };\n    }\n\n    visitModule(node: ModuleNode): boolean {\n        // Tree walking should start with the children of\n        // the node, so we should never get here.\n        fail('We should never get here');\n        return false;\n    }\n\n    visitSuite(node: SuiteNode): boolean {\n        this._walkStatementsAndReportUnreachable(node.statements);\n        return false;\n    }\n\n    visitModuleName(node: ModuleNameNode): boolean {\n        const importResult = AnalyzerNodeInfo.getImportInfo(node);\n        assert(importResult !== undefined);\n\n        if (importResult) {\n            if (!importResult.isImportFound) {\n                this._addDiagnostic(\n                    this._fileInfo.diagnosticRuleSet.reportMissingImports,\n                    DiagnosticRule.reportMissingImports,\n                    Localizer.Diagnostic.importResolveFailure().format({ importName: importResult.importName }),\n                    node\n                );\n            } else {\n                // Source found, but type stub is missing\n                if (\n                    !importResult.isStubFile &&\n                    importResult.importType === ImportType.ThirdParty &&\n                    !importResult.isPyTypedPresent\n                ) {\n                    const diagnostic = this._addDiagnostic(\n                        this._fileInfo.diagnosticRuleSet.reportMissingTypeStubs,\n                        DiagnosticRule.reportMissingTypeStubs,\n                        Localizer.Diagnostic.stubFileMissing().format({ importName: importResult.importName }),\n                        node\n                    );\n                    if (diagnostic) {\n                        // Add a diagnostic action for resolving this diagnostic.\n                        const createTypeStubAction: CreateTypeStubFileAction = {\n                            action: Commands.createTypeStub,\n                            moduleName: importResult.importName,\n                        };\n                        diagnostic.addAction(createTypeStubAction);\n                    }\n                }\n\n                // Type stub found, but source is missing.\n                if (\n                    importResult.isStubFile &&\n                    importResult.importType !== ImportType.BuiltIn &&\n                    importResult.nonStubImportResult &&\n                    !importResult.nonStubImportResult.isImportFound\n                ) {\n                    // Don't report this for stub files.\n                    if (!this._fileInfo.isStubFile) {\n                        this._addDiagnostic(\n                            this._fileInfo.diagnosticRuleSet.reportMissingModuleSource,\n                            DiagnosticRule.reportMissingModuleSource,\n                            Localizer.Diagnostic.importSourceResolveFailure().format({\n                                importName: importResult.importName,\n                            }),\n                            node\n                        );\n                    }\n                }\n            }\n        }\n\n        return true;\n    }\n\n    visitClass(node: ClassNode): boolean {\n        this.walkMultiple(node.decorators);\n\n        const classDeclaration: ClassDeclaration = {\n            type: DeclarationType.Class,\n            node,\n            path: this._fileInfo.filePath,\n            range: convertOffsetsToRange(node.name.start, TextRange.getEnd(node.name), this._fileInfo.lines),\n            moduleName: this._fileInfo.moduleName,\n        };\n\n        const symbol = this._bindNameToScope(this._currentScope!, node.name.value);\n        if (symbol) {\n            symbol.addDeclaration(classDeclaration);\n        }\n\n        // Stash the declaration in the parse node for later access.\n        AnalyzerNodeInfo.setDeclaration(node, classDeclaration);\n\n        this.walkMultiple(node.arguments);\n\n        // For nested classes, use the scope that contains the outermost\n        // class rather than the immediate parent.\n        let parentScope = this._currentScope!;\n        while (parentScope.type === ScopeType.Class) {\n            parentScope = parentScope.parent!;\n        }\n\n        this._createNewScope(ScopeType.Class, parentScope, () => {\n            AnalyzerNodeInfo.setScope(node, this._currentScope!);\n\n            // Analyze the suite.\n            this.walk(node.suite);\n        });\n\n        this._addSymbolToCurrentScope(node.name.value, /* isInitiallyUnbound */ true);\n\n        this._createAssignmentTargetFlowNodes(node.name, /* walkTargets */ false, /* unbound */ false);\n\n        return false;\n    }\n\n    visitFunction(node: FunctionNode): boolean {\n        const symbol = this._bindNameToScope(this._currentScope!, node.name.value);\n        const containingClassNode = ParseTreeUtils.getEnclosingClass(node, true);\n        const functionDeclaration: FunctionDeclaration = {\n            type: DeclarationType.Function,\n            node,\n            isMethod: !!containingClassNode,\n            isGenerator: false,\n            path: this._fileInfo.filePath,\n            range: convertOffsetsToRange(node.name.start, TextRange.getEnd(node.name), this._fileInfo.lines),\n            moduleName: this._fileInfo.moduleName,\n        };\n\n        if (symbol) {\n            symbol.addDeclaration(functionDeclaration);\n        }\n\n        // Stash the declaration in the parse node for later access.\n        AnalyzerNodeInfo.setDeclaration(node, functionDeclaration);\n\n        this.walkMultiple(node.decorators);\n        node.parameters.forEach((param) => {\n            if (param.defaultValue) {\n                this.walk(param.defaultValue);\n            }\n\n            if (param.typeAnnotation) {\n                this.walk(param.typeAnnotation);\n            }\n\n            if (param.typeAnnotationComment) {\n                this.walk(param.typeAnnotationComment);\n            }\n        });\n\n        if (node.returnTypeAnnotation) {\n            this.walk(node.returnTypeAnnotation);\n        }\n\n        if (node.functionAnnotationComment) {\n            this.walk(node.functionAnnotationComment);\n        }\n\n        // Find the function or module that contains this function and use its scope.\n        // We can't simply use this._currentScope because functions within a class use\n        // the scope of the containing function or module when they execute.\n        let functionOrModuleNode: ParseNode | undefined = node.parent;\n        while (functionOrModuleNode) {\n            if (\n                functionOrModuleNode.nodeType === ParseNodeType.Module ||\n                functionOrModuleNode.nodeType === ParseNodeType.Function\n            ) {\n                break;\n            }\n\n            functionOrModuleNode = functionOrModuleNode.parent;\n        }\n        assert(functionOrModuleNode !== undefined);\n\n        const functionOrModuleScope = AnalyzerNodeInfo.getScope(functionOrModuleNode!);\n        assert(functionOrModuleScope !== undefined);\n\n        // Don't walk the body of the function until we're done analyzing\n        // the current scope.\n        this._createNewScope(ScopeType.Function, functionOrModuleScope, () => {\n            AnalyzerNodeInfo.setScope(node, this._currentScope!);\n\n            const enclosingClass = ParseTreeUtils.getEnclosingClass(node);\n            if (enclosingClass) {\n                // Add the implicit \"__class__\" symbol described in PEP 3135.\n                this._addBuiltInSymbolToCurrentScope('__class__', node, 'class');\n            }\n\n            this._deferBinding(() => {\n                // Create a start node for the function.\n                this._currentFlowNode = this._createStartFlowNode();\n\n                node.parameters.forEach((paramNode) => {\n                    if (paramNode.name) {\n                        const symbol = this._bindNameToScope(this._currentScope!, paramNode.name.value);\n                        if (symbol) {\n                            const paramDeclaration: ParameterDeclaration = {\n                                type: DeclarationType.Parameter,\n                                node: paramNode,\n                                path: this._fileInfo.filePath,\n                                range: convertOffsetsToRange(\n                                    paramNode.start,\n                                    TextRange.getEnd(paramNode),\n                                    this._fileInfo.lines\n                                ),\n                                moduleName: this._fileInfo.moduleName,\n                            };\n\n                            symbol.addDeclaration(paramDeclaration);\n                            AnalyzerNodeInfo.setDeclaration(paramNode.name, paramDeclaration);\n                        }\n\n                        this._createFlowAssignment(paramNode.name);\n                    }\n                });\n\n                this._targetFunctionDeclaration = functionDeclaration;\n                this._currentReturnTarget = this._createBranchLabel();\n\n                // Walk the statements that make up the function.\n                this.walk(node.suite);\n\n                // Associate the code flow node at the end of the suite with\n                // the suite.\n                AnalyzerNodeInfo.setAfterFlowNode(node.suite, this._currentFlowNode);\n\n                // Compute the final return flow node and associate it with\n                // the function's parse node. If this node is unreachable, then\n                // the function never returns.\n                this._addAntecedent(this._currentReturnTarget, this._currentFlowNode);\n                const returnFlowNode = this._finishFlowLabel(this._currentReturnTarget);\n                AnalyzerNodeInfo.setAfterFlowNode(node, returnFlowNode);\n            });\n\n            AnalyzerNodeInfo.setCodeFlowExpressions(node, this._currentExecutionScopeReferenceMap!);\n        });\n\n        this._createAssignmentTargetFlowNodes(node.name, /* walkTargets */ false, /* unbound */ false);\n\n        // We'll walk the child nodes in a deferred manner, so don't walk them now.\n        return false;\n    }\n\n    visitLambda(node: LambdaNode): boolean {\n        // Analyze the parameter defaults in the context of the parent's scope\n        // before we add any names from the function's scope.\n        node.parameters.forEach((param) => {\n            if (param.defaultValue) {\n                this.walk(param.defaultValue);\n            }\n        });\n\n        this._createNewScope(ScopeType.Function, this._currentScope!, () => {\n            AnalyzerNodeInfo.setScope(node, this._currentScope!);\n\n            this._deferBinding(() => {\n                // Create a start node for the lambda.\n                this._currentFlowNode = this._createStartFlowNode();\n\n                node.parameters.forEach((paramNode) => {\n                    if (paramNode.name) {\n                        const symbol = this._bindNameToScope(this._currentScope!, paramNode.name.value);\n                        if (symbol) {\n                            const paramDeclaration: ParameterDeclaration = {\n                                type: DeclarationType.Parameter,\n                                node: paramNode,\n                                path: this._fileInfo.filePath,\n                                range: convertOffsetsToRange(\n                                    paramNode.start,\n                                    TextRange.getEnd(paramNode),\n                                    this._fileInfo.lines\n                                ),\n                                moduleName: this._fileInfo.moduleName,\n                            };\n\n                            symbol.addDeclaration(paramDeclaration);\n                            AnalyzerNodeInfo.setDeclaration(paramNode.name, paramDeclaration);\n                        }\n\n                        this._createFlowAssignment(paramNode.name);\n                        this.walk(paramNode.name);\n                    }\n                });\n\n                // Walk the expression that make up the lambda body.\n                this.walk(node.expression);\n\n                AnalyzerNodeInfo.setCodeFlowExpressions(node, this._currentExecutionScopeReferenceMap!);\n            });\n        });\n\n        // We'll walk the child nodes in a deferred manner.\n        return false;\n    }\n\n    visitCall(node: CallNode): boolean {\n        this.walk(node.leftExpression);\n        this.walkMultiple(node.arguments);\n        this._createCallFlowNode(node);\n        return false;\n    }\n\n    visitAssignment(node: AssignmentNode): boolean {\n        if (this._handleTypingStubAssignmentOrAnnotation(node)) {\n            return false;\n        }\n\n        this._bindPossibleTupleNamedTarget(node.leftExpression);\n\n        if (node.typeAnnotationComment) {\n            this.walk(node.typeAnnotationComment);\n            this._addTypeDeclarationForVariable(node.leftExpression, node.typeAnnotationComment);\n        }\n\n        this.walk(node.rightExpression);\n\n        let isPossibleTypeAlias = true;\n        if (ParseTreeUtils.getEnclosingClass(node) || ParseTreeUtils.getEnclosingFunction(node)) {\n            // We will assume that type aliases are defined only at the module level.\n            isPossibleTypeAlias = false;\n        } else if (node.rightExpression.nodeType === ParseNodeType.Call) {\n            // Some special built-in types defined in typing.pyi use\n            // assignments of the form List = _Alias(). We don't want to\n            // treat these as type aliases.\n            isPossibleTypeAlias = false;\n        }\n\n        this._addInferredTypeAssignmentForVariable(node.leftExpression, node.rightExpression, isPossibleTypeAlias);\n\n        this._createAssignmentTargetFlowNodes(node.leftExpression, /* walkTargets */ true, /* unbound */ false);\n\n        return false;\n    }\n\n    visitAssignmentExpression(node: AssignmentExpressionNode) {\n        this.walk(node.rightExpression);\n\n        const evaluationNode = ParseTreeUtils.getEvaluationNodeForAssignmentExpression(node);\n        if (!evaluationNode) {\n            this._addError(Localizer.Diagnostic.assignmentExprContext(), node);\n        } else {\n            // Bind the name to the containing scope. This special logic is required\n            // because of the behavior defined in PEP 572. Targets of assignment\n            // expressions don't bind to a list comprehension's scope but instead\n            // bind to its containing scope.\n            const containerScope = AnalyzerNodeInfo.getScope(evaluationNode)!;\n\n            // If we're in a list comprehension (possibly nested), make sure that\n            // local for targets don't collide with the target of the assignment\n            // expression.\n            let curScope: Scope | undefined = this._currentScope;\n            while (curScope && curScope !== containerScope) {\n                const localSymbol = curScope.lookUpSymbol(node.name.value);\n                if (localSymbol) {\n                    this._addError(\n                        Localizer.Diagnostic.assignmentExprComprehension().format({ name: node.name.value }),\n                        node.name\n                    );\n                    break;\n                }\n\n                curScope = curScope.parent;\n            }\n\n            this._bindNameToScope(containerScope, node.name.value);\n            this._addInferredTypeAssignmentForVariable(node.name, node.rightExpression);\n        }\n\n        this._createAssignmentTargetFlowNodes(node.name, /* walkTargets */ true, /* unbound */ false);\n\n        return false;\n    }\n\n    visitAugmentedAssignment(node: AugmentedAssignmentNode) {\n        this.walk(node.leftExpression);\n        this.walk(node.rightExpression);\n\n        this._addInferredTypeAssignmentForVariable(node.destExpression, node.rightExpression);\n\n        this._bindPossibleTupleNamedTarget(node.destExpression);\n        this._createAssignmentTargetFlowNodes(node.destExpression, /* walkTargets */ false, /* unbound */ false);\n\n        return false;\n    }\n\n    visitDel(node: DelNode) {\n        node.expressions.forEach((expr) => {\n            this._bindPossibleTupleNamedTarget(expr);\n            this.walk(expr);\n            this._createAssignmentTargetFlowNodes(expr, /* walkTargets */ false, /* unbound */ true);\n        });\n\n        return false;\n    }\n\n    visitTypeAnnotation(node: TypeAnnotationNode): boolean {\n        if (this._handleTypingStubAssignmentOrAnnotation(node)) {\n            return false;\n        }\n\n        this._bindPossibleTupleNamedTarget(node.valueExpression);\n        this._addTypeDeclarationForVariable(node.valueExpression, node.typeAnnotation);\n\n        // For type annotations that are not part of assignments (e.g. simple variable\n        // annotations), we need to populate the reference map. Otherwise the type\n        // analyzer's code flow engine won't run and detect cases where the variable\n        // is unbound.\n        const expressionList: NarrowingExpressionNode[] = [];\n        if (this._isNarrowingExpression(node.valueExpression, expressionList)) {\n            expressionList.forEach((expr) => {\n                const referenceKey = createKeyForReference(expr);\n                this._currentExecutionScopeReferenceMap!.set(referenceKey, referenceKey);\n            });\n        }\n        return true;\n    }\n\n    visitFor(node: ForNode) {\n        this._bindPossibleTupleNamedTarget(node.targetExpression);\n        this._addInferredTypeAssignmentForVariable(node.targetExpression, node);\n\n        this.walk(node.iterableExpression);\n\n        const preForLabel = this._createLoopLabel();\n        const preElseLabel = this._createBranchLabel();\n        const postForLabel = this._createBranchLabel();\n\n        this._addAntecedent(preForLabel, this._currentFlowNode!);\n        this._currentFlowNode = preForLabel;\n        this._addAntecedent(preElseLabel, this._currentFlowNode);\n        this._createAssignmentTargetFlowNodes(node.targetExpression, /* walkTargets */ true, /* unbound */ false);\n\n        this._bindLoopStatement(preForLabel, postForLabel, () => {\n            this.walk(node.forSuite);\n            this._addAntecedent(preForLabel, this._currentFlowNode!);\n        });\n\n        this._currentFlowNode = this._finishFlowLabel(preElseLabel);\n        if (node.elseSuite) {\n            this.walk(node.elseSuite);\n        }\n        this._addAntecedent(postForLabel, this._currentFlowNode);\n\n        this._currentFlowNode = this._finishFlowLabel(postForLabel);\n\n        return false;\n    }\n\n    visitContinue(node: ContinueNode): boolean {\n        if (this._currentContinueTarget) {\n            this._addAntecedent(this._currentContinueTarget, this._currentFlowNode!);\n        }\n        this._currentFlowNode = Binder._unreachableFlowNode;\n\n        // Continue nodes don't have any children.\n        return false;\n    }\n\n    visitBreak(node: BreakNode): boolean {\n        if (this._currentBreakTarget) {\n            this._addAntecedent(this._currentBreakTarget, this._currentFlowNode!);\n        }\n        this._currentFlowNode = Binder._unreachableFlowNode;\n\n        // Break nodes don't have any children.\n        return false;\n    }\n\n    visitReturn(node: ReturnNode): boolean {\n        if (this._targetFunctionDeclaration) {\n            if (!this._targetFunctionDeclaration.returnStatements) {\n                this._targetFunctionDeclaration.returnStatements = [];\n            }\n            this._targetFunctionDeclaration.returnStatements.push(node);\n        }\n\n        if (node.returnExpression) {\n            this.walk(node.returnExpression);\n        }\n\n        AnalyzerNodeInfo.setFlowNode(node, this._currentFlowNode!);\n        if (this._currentReturnTarget) {\n            this._addAntecedent(this._currentReturnTarget, this._currentFlowNode!);\n        }\n        this._finallyTargets.forEach((target) => {\n            this._addAntecedent(target, this._currentFlowNode!);\n        });\n        this._currentFlowNode = Binder._unreachableFlowNode;\n        return false;\n    }\n\n    visitYield(node: YieldNode): boolean {\n        this._bindYield(node);\n        return false;\n    }\n\n    visitYieldFrom(node: YieldFromNode): boolean {\n        this._bindYield(node);\n        return false;\n    }\n\n    visitMemberAccess(node: MemberAccessNode): boolean {\n        AnalyzerNodeInfo.setFlowNode(node, this._currentFlowNode!);\n        return true;\n    }\n\n    visitName(node: NameNode): boolean {\n        AnalyzerNodeInfo.setFlowNode(node, this._currentFlowNode!);\n\n        // Name nodes have no children.\n        return false;\n    }\n\n    visitIf(node: IfNode): boolean {\n        const thenLabel = this._createBranchLabel();\n        const elseLabel = this._createBranchLabel();\n        const postIfLabel = this._createBranchLabel();\n\n        // Determine if the test condition is always true or always false. If so,\n        // we can treat either the then or the else clause as unconditional.\n        const constExprValue = StaticExpressions.evaluateStaticBoolLikeExpression(\n            node.testExpression,\n            this._fileInfo.executionEnvironment\n        );\n\n        this._bindConditional(node.testExpression, thenLabel, elseLabel);\n\n        // Handle the if clause.\n        this._currentFlowNode =\n            constExprValue === false ? Binder._unreachableFlowNode : this._finishFlowLabel(thenLabel);\n        this.walk(node.ifSuite);\n        this._addAntecedent(postIfLabel, this._currentFlowNode);\n\n        // Now handle the else clause if it's present. If there\n        // are chained \"else if\" statements, they'll be handled\n        // recursively here.\n        this._currentFlowNode =\n            constExprValue === true ? Binder._unreachableFlowNode : this._finishFlowLabel(elseLabel);\n        if (node.elseSuite) {\n            this.walk(node.elseSuite);\n        }\n        this._addAntecedent(postIfLabel, this._currentFlowNode);\n        this._currentFlowNode = this._finishFlowLabel(postIfLabel);\n\n        return false;\n    }\n\n    visitWhile(node: WhileNode): boolean {\n        const thenLabel = this._createBranchLabel();\n        const elseLabel = this._createBranchLabel();\n        const postWhileLabel = this._createBranchLabel();\n\n        // Determine if the test condition is always true or always false. If so,\n        // we can treat either the while or the else clause as unconditional.\n        const constExprValue = StaticExpressions.evaluateStaticBoolLikeExpression(\n            node.testExpression,\n            this._fileInfo.executionEnvironment\n        );\n\n        const preLoopLabel = this._createLoopLabel();\n        this._addAntecedent(preLoopLabel, this._currentFlowNode!);\n        this._currentFlowNode = preLoopLabel;\n\n        this._bindConditional(node.testExpression, thenLabel, elseLabel);\n\n        // Handle the while clause.\n        this._currentFlowNode =\n            constExprValue === false ? Binder._unreachableFlowNode : this._finishFlowLabel(thenLabel);\n        this._bindLoopStatement(preLoopLabel, postWhileLabel, () => {\n            this.walk(node.whileSuite);\n        });\n        this._addAntecedent(preLoopLabel, this._currentFlowNode);\n\n        this._currentFlowNode =\n            constExprValue === true ? Binder._unreachableFlowNode : this._finishFlowLabel(elseLabel);\n        if (node.elseSuite) {\n            this.walk(node.elseSuite);\n        }\n        this._addAntecedent(postWhileLabel, this._currentFlowNode);\n        this._currentFlowNode = this._finishFlowLabel(postWhileLabel);\n        return false;\n    }\n\n    visitAssert(node: AssertNode): boolean {\n        const assertTrueLabel = this._createBranchLabel();\n        const assertFalseLabel = this._createBranchLabel();\n\n        this._bindConditional(node.testExpression, assertTrueLabel, assertFalseLabel);\n\n        if (node.exceptionExpression) {\n            this._currentFlowNode = this._finishFlowLabel(assertFalseLabel);\n            this.walk(node.exceptionExpression);\n        }\n\n        this._currentFlowNode = this._finishFlowLabel(assertTrueLabel);\n        return false;\n    }\n\n    visitExcept(node: ExceptNode): boolean {\n        if (node.typeExpression) {\n            this.walk(node.typeExpression);\n        }\n\n        if (node.name) {\n            this.walk(node.name);\n            const symbol = this._bindNameToScope(this._currentScope!, node.name.value);\n            this._createAssignmentTargetFlowNodes(node.name, /* walkTargets */ true, /* unbound */ false);\n\n            if (symbol) {\n                const declaration: VariableDeclaration = {\n                    type: DeclarationType.Variable,\n                    node: node.name,\n                    isConstant: isConstantName(node.name.value),\n                    inferredTypeSource: node,\n                    path: this._fileInfo.filePath,\n                    range: convertOffsetsToRange(node.name.start, TextRange.getEnd(node.name), this._fileInfo.lines),\n                    moduleName: this._fileInfo.moduleName,\n                };\n                symbol.addDeclaration(declaration);\n            }\n        }\n\n        this.walk(node.exceptSuite);\n\n        if (node.name) {\n            // The exception name is implicitly unbound at the end of\n            // the except block.\n            this._createFlowAssignment(node.name, /* unbound */ true);\n        }\n\n        return false;\n    }\n\n    visitRaise(node: RaiseNode): boolean {\n        if (this._targetFunctionDeclaration) {\n            if (!this._targetFunctionDeclaration.raiseStatements) {\n                this._targetFunctionDeclaration.raiseStatements = [];\n            }\n            this._targetFunctionDeclaration.raiseStatements.push(node);\n        }\n\n        if (!node.typeExpression && this._nestedExceptDepth === 0) {\n            this._addError(Localizer.Diagnostic.raiseParams(), node);\n        }\n\n        if (node.typeExpression) {\n            this.walk(node.typeExpression);\n        }\n        if (node.valueExpression) {\n            this.walk(node.valueExpression);\n        }\n        if (node.tracebackExpression) {\n            this.walk(node.tracebackExpression);\n        }\n\n        this._finallyTargets.forEach((target) => {\n            this._addAntecedent(target, this._currentFlowNode!);\n        });\n\n        this._currentFlowNode = Binder._unreachableFlowNode;\n        return false;\n    }\n\n    visitTry(node: TryNode): boolean {\n        // The try/except/else/finally statement is tricky to model using static code\n        // flow rules because the finally clause is executed regardless of whether an\n        // exception is raised or a return statement is executed. Code within the finally\n        // clause needs to be reachable always, and we conservatively assume that any\n        // statement within the try block can generate an exception, so we assume that its\n        // antecedent is the pre-try flow. We implement this with a \"gate\" node in the\n        // control flow graph. If analysis starts within the finally clause, the gate is\n        // opened, and all raise/return statements within try/except/else blocks are\n        // considered antecedents. If analysis starts outside (after) the finally clause,\n        // the gate is closed, and only paths that don't hit a raise/return statement\n        // in try/except/else blocks are considered.\n        //\n        //\n        //                               1. PostElse\n        //                                    ^\n        //                                    |\n        // 3. TryExceptElseReturnOrExcept     |\n        //       ^                            |\n        //       |                            |     2. PostExcept (for each except)\n        //       |                            |            ^\n        // 4. ReturnOrRaiseLabel              |            |\n        //       ^                            |            |\n        //       |                            |   |---------\n        // 5. PreFinallyGate                  |   |\n        //       ^                            |   |\n        //       |------------------          |   |\n        //                         |          |   |\n        //                        6. PreFinallyLabel\n        //                                ^\n        //                         (finally block)\n        //                                ^\n        //                        7. PostFinally\n        //                                ^    (only if isAfterElseAndExceptsReachable)\n        //                         (after finally)\n\n        // Create one flow label for every except clause.\n        const curExceptTargets = node.exceptClauses.map(() => this._createBranchLabel());\n        const preFinallyLabel = this._createBranchLabel();\n\n        // Create a label for all of the return or raise labels that are\n        // encountered within the try/except/else blocks. This conditionally\n        // connects the return/raise statement to the finally clause.\n        const preFinallyReturnOrRaiseLabel = this._createBranchLabel();\n        let isAfterElseAndExceptsReachable = false;\n\n        const preFinallyGate: FlowPreFinallyGate = {\n            flags: FlowFlags.PreFinallyGate,\n            id: getUniqueFlowNodeId(),\n            antecedent: preFinallyReturnOrRaiseLabel,\n            isGateClosed: false,\n        };\n        if (node.finallySuite) {\n            this._addAntecedent(preFinallyLabel, preFinallyGate);\n        }\n\n        // An exception may be generated before the first flow node\n        // added by the try block, so all of the exception targets\n        // must have the pre-try flow node as an antecedent.\n        curExceptTargets.forEach((exceptLabel) => {\n            this._addAntecedent(exceptLabel, this._currentFlowNode!);\n        });\n\n        // We don't perfectly handle nested finally clauses, which are not\n        // possible to model fully within a static analyzer, but we do handle\n        // a single level of finally statements, and we handle most cases\n        // involving nesting. Returns or raises within the try/except/raise\n        // block will execute the finally target(s).\n        if (node.finallySuite) {\n            this._finallyTargets.push(preFinallyReturnOrRaiseLabel);\n        }\n\n        // Handle the try block.\n        const prevExceptTargets = this._currentExceptTargets;\n        this._currentExceptTargets = curExceptTargets;\n        this.walk(node.trySuite);\n        this._currentExceptTargets = prevExceptTargets;\n\n        // Handle the else block, which is executed only if\n        // execution falls through the try block.\n        if (node.elseSuite) {\n            this.walk(node.elseSuite);\n        }\n        this._addAntecedent(preFinallyLabel, this._currentFlowNode!);\n        if (!this._isCodeUnreachable()) {\n            isAfterElseAndExceptsReachable = true;\n        }\n\n        // Handle the except blocks.\n        this._nestedExceptDepth++;\n        node.exceptClauses.forEach((exceptNode, index) => {\n            this._currentFlowNode = this._finishFlowLabel(curExceptTargets[index]);\n            this.walk(exceptNode);\n            this._addAntecedent(preFinallyLabel, this._currentFlowNode);\n            if (!this._isCodeUnreachable()) {\n                isAfterElseAndExceptsReachable = true;\n            }\n        });\n        this._nestedExceptDepth--;\n\n        if (node.finallySuite) {\n            this._finallyTargets.pop();\n        }\n\n        // Handle the finally block.\n        this._currentFlowNode = this._finishFlowLabel(preFinallyLabel);\n        if (node.finallySuite) {\n            this.walk(node.finallySuite);\n\n            // Add a post-finally node at the end. If we traverse this node,\n            // we'll set the \"ignore\" flag in the pre-finally node.\n            const postFinallyNode: FlowPostFinally = {\n                flags: FlowFlags.PostFinally,\n                id: getUniqueFlowNodeId(),\n                antecedent: this._currentFlowNode,\n                preFinallyGate,\n            };\n            this._currentFlowNode = isAfterElseAndExceptsReachable ? postFinallyNode : Binder._unreachableFlowNode;\n        }\n\n        return false;\n    }\n\n    visitAwait(node: AwaitNode) {\n        // Make sure this is within an async lambda or function.\n        const enclosingFunction = ParseTreeUtils.getEnclosingFunction(node);\n        if (enclosingFunction === undefined || !enclosingFunction.isAsync) {\n            this._addError(Localizer.Diagnostic.awaitNotInAsync(), node);\n        }\n\n        return true;\n    }\n\n    visitStringList(node: StringListNode): boolean {\n        for (const stringNode of node.strings) {\n            if (stringNode.hasUnescapeErrors) {\n                const unescapedResult = StringTokenUtils.getUnescapedString(stringNode.token);\n\n                unescapedResult.unescapeErrors.forEach((error: StringTokenUtils.UnescapeError) => {\n                    const start =\n                        stringNode.token.start +\n                        stringNode.token.prefixLength +\n                        stringNode.token.quoteMarkLength +\n                        error.offset;\n                    const textRange = { start, length: error.length };\n\n                    if (error.errorType === StringTokenUtils.UnescapeErrorType.InvalidEscapeSequence) {\n                        this._addDiagnostic(\n                            this._fileInfo.diagnosticRuleSet.reportInvalidStringEscapeSequence,\n                            DiagnosticRule.reportInvalidStringEscapeSequence,\n                            Localizer.Diagnostic.stringUnsupportedEscape(),\n                            textRange\n                        );\n                    } else if (error.errorType === StringTokenUtils.UnescapeErrorType.EscapeWithinFormatExpression) {\n                        this._addError(Localizer.Diagnostic.formatStringEscape(), textRange);\n                    } else if (\n                        error.errorType === StringTokenUtils.UnescapeErrorType.SingleCloseBraceWithinFormatLiteral\n                    ) {\n                        this._addError(Localizer.Diagnostic.formatStringBrace(), textRange);\n                    } else if (error.errorType === StringTokenUtils.UnescapeErrorType.UnterminatedFormatExpression) {\n                        this._addError(Localizer.Diagnostic.formatStringUnterminated(), textRange);\n                    }\n                });\n            }\n        }\n\n        return true;\n    }\n\n    visitGlobal(node: GlobalNode): boolean {\n        const globalScope = this._currentScope!.getGlobalScope();\n\n        node.nameList.forEach((name) => {\n            const nameValue = name.value;\n\n            // Is the binding inconsistent?\n            if (this._notLocalBindings.get(nameValue) === NameBindingType.Nonlocal) {\n                this._addError(Localizer.Diagnostic.nonLocalRedefinition().format({ name: nameValue }), name);\n            }\n\n            const valueWithScope = this._currentScope!.lookUpSymbolRecursive(nameValue);\n\n            // Was the name already assigned within this scope before it was declared global?\n            if (valueWithScope && valueWithScope.scope === this._currentScope) {\n                this._addError(Localizer.Diagnostic.globalReassignment().format({ name: nameValue }), name);\n            }\n\n            // Add it to the global scope if it's not already added.\n            this._bindNameToScope(globalScope, nameValue);\n\n            if (this._currentScope !== globalScope) {\n                this._notLocalBindings.set(nameValue, NameBindingType.Global);\n            }\n        });\n\n        return true;\n    }\n\n    visitNonlocal(node: NonlocalNode): boolean {\n        const globalScope = this._currentScope!.getGlobalScope();\n\n        if (this._currentScope === globalScope) {\n            this._addError(Localizer.Diagnostic.nonLocalInModule(), node);\n        } else {\n            node.nameList.forEach((name) => {\n                const nameValue = name.value;\n\n                // Is the binding inconsistent?\n                if (this._notLocalBindings.get(nameValue) === NameBindingType.Global) {\n                    this._addError(Localizer.Diagnostic.globalRedefinition().format({ name: nameValue }), name);\n                }\n\n                const valueWithScope = this._currentScope!.lookUpSymbolRecursive(nameValue);\n\n                // Was the name already assigned within this scope before it was declared nonlocal?\n                if (valueWithScope && valueWithScope.scope === this._currentScope) {\n                    this._addError(Localizer.Diagnostic.nonLocalReassignment().format({ name: nameValue }), name);\n                } else if (!valueWithScope || valueWithScope.scope === globalScope) {\n                    this._addError(Localizer.Diagnostic.nonLocalNoBinding().format({ name: nameValue }), name);\n                }\n\n                if (valueWithScope) {\n                    this._notLocalBindings.set(nameValue, NameBindingType.Nonlocal);\n                }\n            });\n        }\n\n        return true;\n    }\n\n    visitImportAs(node: ImportAsNode): boolean {\n        if (node.module.nameParts.length > 0) {\n            const firstNamePartValue = node.module.nameParts[0].value;\n\n            let symbolName: string | undefined;\n            if (node.alias) {\n                // The symbol name is defined by the alias.\n                symbolName = node.alias.value;\n            } else {\n                // There was no alias, so we need to use the first element of\n                // the name parts as the symbol.\n                symbolName = firstNamePartValue;\n            }\n\n            const symbol = this._bindNameToScope(this._currentScope!, symbolName);\n            if (symbol && this._fileInfo.isStubFile && !node.alias) {\n                // PEP 484 indicates that imported symbols should not be\n                // considered \"reexported\" from a type stub file unless\n                // they are imported using the \"as\" form.\n                symbol.setIsExternallyHidden();\n            }\n\n            const importInfo = AnalyzerNodeInfo.getImportInfo(node.module);\n            assert(importInfo !== undefined);\n\n            if (symbol) {\n                this._createAliasDeclarationForMultipartImportName(node, node.alias, importInfo, symbol);\n            }\n\n            this._createFlowAssignment(node.alias ? node.alias : node.module.nameParts[0]);\n\n            if (node.module.nameParts.length === 1) {\n                if (firstNamePartValue === 'typing' || firstNamePartValue === 'typing_extensions') {\n                    this._typingImportAliases.push(node.alias?.value || firstNamePartValue);\n                }\n            }\n        }\n\n        return true;\n    }\n\n    visitImportFrom(node: ImportFromNode): boolean {\n        const typingSymbolsOfInterest = ['Final', 'TypeAlias'];\n        const importInfo = AnalyzerNodeInfo.getImportInfo(node.module);\n\n        let resolvedPath = '';\n        if (importInfo && importInfo.isImportFound) {\n            resolvedPath = importInfo.resolvedPaths[importInfo.resolvedPaths.length - 1];\n        }\n\n        // If this file is a module __init__.py(i), relative imports of submodules\n        // using the syntax \"from .x import y\" introduce a symbol x into the\n        // module namespace. We do this first (before adding the individual imported\n        // symbols below) in case one of the imported symbols is the same name as the\n        // submodule. In that case, we want to the symbol to appear later in the\n        // declaration list because it should \"win\" when resolving the alias.\n        const fileName = stripFileExtension(getFileName(this._fileInfo.filePath));\n        const isModuleInitFile =\n            fileName === '__init__' && node.module.leadingDots === 1 && node.module.nameParts.length > 0;\n\n        let isTypingImport = false;\n        if (node.module.nameParts.length === 1) {\n            const firstNamePartValue = node.module.nameParts[0].value;\n            if (firstNamePartValue === 'typing' || firstNamePartValue === 'typing_extensions') {\n                isTypingImport = true;\n            }\n        }\n\n        if (node.isWildcardImport) {\n            if (ParseTreeUtils.getEnclosingClass(node) || ParseTreeUtils.getEnclosingFunction(node)) {\n                this._addError(Localizer.Diagnostic.wildcardInFunction(), node);\n            }\n\n            if (importInfo) {\n                const names: string[] = [];\n\n                const lookupInfo = this._fileInfo.importLookup(resolvedPath);\n                if (lookupInfo) {\n                    const wildcardNames = this._getWildcardImportNames(lookupInfo);\n\n                    if (isModuleInitFile) {\n                        // If the symbol is going to be immediately replaced with a same-named\n                        // imported symbol, skip this.\n                        const isImmediatelyReplaced = wildcardNames.some((name) => {\n                            return name === node.module.nameParts[0].value;\n                        });\n\n                        if (!isImmediatelyReplaced) {\n                            this._addImplicitFromImport(node, importInfo);\n                        }\n                    }\n\n                    wildcardNames.forEach((name) => {\n                        const symbol = lookupInfo.symbolTable.get(name)!;\n\n                        // Don't include the ignored names in the symbol table.\n                        if (!symbol.isIgnoredForProtocolMatch()) {\n                            const symbol = this._bindNameToScope(this._currentScope!, name);\n                            if (symbol) {\n                                const aliasDecl: AliasDeclaration = {\n                                    type: DeclarationType.Alias,\n                                    node,\n                                    path: resolvedPath,\n                                    range: getEmptyRange(),\n                                    usesLocalName: false,\n                                    symbolName: name,\n                                    moduleName: this._fileInfo.moduleName,\n                                };\n                                symbol.addDeclaration(aliasDecl);\n                                names.push(name);\n                            }\n                        }\n                    });\n                }\n\n                this._createFlowWildcardImport(node, names);\n\n                if (isTypingImport) {\n                    typingSymbolsOfInterest.forEach((s) => {\n                        this._typingSymbolAliases.set(s, s);\n                    });\n                }\n            }\n        } else {\n            if (isModuleInitFile) {\n                // If the symbol is going to be immediately replaced with a same-named\n                // imported symbol, skip this.\n                const isImmediatelyReplaced = node.imports.some((importSymbolNode) => {\n                    const nameNode = importSymbolNode.alias || importSymbolNode.name;\n                    return nameNode.value === node.module.nameParts[0].value;\n                });\n\n                if (!isImmediatelyReplaced) {\n                    this._addImplicitFromImport(node, importInfo);\n                }\n            }\n\n            node.imports.forEach((importSymbolNode) => {\n                const importedName = importSymbolNode.name.value;\n                const nameNode = importSymbolNode.alias || importSymbolNode.name;\n                const symbol = this._bindNameToScope(this._currentScope!, nameNode.value);\n\n                if (symbol) {\n                    if (this._fileInfo.isStubFile && !importSymbolNode.alias) {\n                        // PEP 484 indicates that imported symbols should not be\n                        // considered \"reexported\" from a type stub file unless\n                        // they are imported using the \"as\" form.\n                        symbol.setIsExternallyHidden();\n                    }\n\n                    // Is the import referring to an implicitly-imported module?\n                    let implicitImport: ImplicitImport | undefined;\n                    if (importInfo && importInfo.implicitImports) {\n                        implicitImport = importInfo.implicitImports.find((imp) => imp.name === importedName);\n                    }\n\n                    let submoduleFallback: AliasDeclaration | undefined;\n                    if (implicitImport) {\n                        submoduleFallback = {\n                            type: DeclarationType.Alias,\n                            node: importSymbolNode,\n                            path: implicitImport.path,\n                            range: getEmptyRange(),\n                            usesLocalName: false,\n                            moduleName: this._fileInfo.moduleName,\n                        };\n\n                        // Handle the case of \"from . import X\". In this case,\n                        // we want to always resolve to the submodule rather than\n                        // the resolved path.\n                        if (node.module.nameParts.length === 0) {\n                            resolvedPath = '';\n                        }\n                    }\n\n                    const aliasDecl: AliasDeclaration = {\n                        type: DeclarationType.Alias,\n                        node: importSymbolNode,\n                        path: resolvedPath,\n                        usesLocalName: !!importSymbolNode.alias,\n                        symbolName: importedName,\n                        submoduleFallback,\n                        range: getEmptyRange(),\n                        moduleName: this._fileInfo.moduleName,\n                    };\n\n                    symbol.addDeclaration(aliasDecl);\n                    this._createFlowAssignment(importSymbolNode.alias || importSymbolNode.name);\n\n                    if (isTypingImport) {\n                        if (typingSymbolsOfInterest.some((s) => s === importSymbolNode.name.value)) {\n                            this._typingSymbolAliases.set(nameNode.value, importSymbolNode.name.value);\n                        }\n                    }\n                }\n            });\n        }\n\n        return true;\n    }\n\n    visitWith(node: WithNode): boolean {\n        node.withItems.forEach((item) => {\n            this.walk(item.expression);\n            if (item.target) {\n                this._bindPossibleTupleNamedTarget(item.target);\n                this._addInferredTypeAssignmentForVariable(item.target, item);\n                this._createAssignmentTargetFlowNodes(item.target, /* walkTargets */ true, /* unbound */ false);\n            }\n        });\n\n        this.walk(node.suite);\n\n        return false;\n    }\n\n    visitTernary(node: TernaryNode): boolean {\n        const trueLabel = this._createBranchLabel();\n        const falseLabel = this._createBranchLabel();\n        const postExpressionLabel = this._createBranchLabel();\n\n        // Handle the test expression.\n        this._bindConditional(node.testExpression, trueLabel, falseLabel);\n\n        // Handle the \"true\" portion (the \"if\" expression).\n        this._currentFlowNode = this._finishFlowLabel(trueLabel);\n        this.walk(node.ifExpression);\n        this._addAntecedent(postExpressionLabel, this._currentFlowNode);\n\n        // Handle the \"false\" portion (the \"else\" expression).\n        this._currentFlowNode = this._finishFlowLabel(falseLabel);\n        this.walk(node.elseExpression);\n        this._addAntecedent(postExpressionLabel, this._currentFlowNode);\n\n        this._currentFlowNode = this._finishFlowLabel(postExpressionLabel);\n\n        return false;\n    }\n\n    visitUnaryOperation(node: UnaryOperationNode): boolean {\n        if (node.operator === OperatorType.Not && this._currentFalseTarget && this._currentTrueTarget) {\n            // Swap the existing true/false targets.\n            this._bindConditional(node.expression, this._currentFalseTarget, this._currentTrueTarget);\n        } else {\n            const savedTrueTarget = this._currentTrueTarget;\n            const savedFalseTarget = this._currentFalseTarget;\n\n            // Temporarily set the true/false targets to undefined because\n            // this unary operation is not part of a chain of logical expressions\n            // (AND/OR/NOT subexpressions).\n            this._currentTrueTarget = undefined;\n            this._currentFalseTarget = undefined;\n\n            // Evaluate the operand expression.\n            this.walk(node.expression);\n\n            this._currentFalseTarget = savedFalseTarget;\n            this._currentTrueTarget = savedTrueTarget;\n        }\n\n        return false;\n    }\n\n    visitBinaryOperation(node: BinaryOperationNode): boolean {\n        if (node.operator === OperatorType.And || node.operator === OperatorType.Or) {\n            let trueTarget = this._currentTrueTarget;\n            let falseTarget = this._currentFalseTarget;\n            let postRightLabel: FlowLabel | undefined;\n\n            if (!trueTarget || !falseTarget) {\n                postRightLabel = this._createBranchLabel();\n                trueTarget = falseTarget = postRightLabel;\n            }\n\n            const preRightLabel = this._createBranchLabel();\n            if (node.operator === OperatorType.And) {\n                this._bindConditional(node.leftExpression, preRightLabel, falseTarget);\n            } else {\n                this._bindConditional(node.leftExpression, trueTarget, preRightLabel);\n            }\n            this._currentFlowNode = this._finishFlowLabel(preRightLabel);\n            this._bindConditional(node.rightExpression, trueTarget, falseTarget);\n            if (postRightLabel) {\n                this._currentFlowNode = this._finishFlowLabel(postRightLabel);\n            }\n        } else {\n            const savedTrueTarget = this._currentTrueTarget;\n            const savedFalseTarget = this._currentFalseTarget;\n\n            // Temporarily set the true/false targets to undefined because\n            // this binary operation is not part of a chain of logical expressions\n            // (AND/OR/NOT subexpressions).\n            this._currentTrueTarget = undefined;\n            this._currentFalseTarget = undefined;\n\n            this.walk(node.leftExpression);\n            this.walk(node.rightExpression);\n\n            this._currentFalseTarget = savedFalseTarget;\n            this._currentTrueTarget = savedTrueTarget;\n        }\n\n        return false;\n    }\n\n    visitListComprehension(node: ListComprehensionNode): boolean {\n        this._createNewScope(ScopeType.ListComprehension, this._currentScope, () => {\n            AnalyzerNodeInfo.setScope(node, this._currentScope!);\n\n            const falseLabel = this._createBranchLabel();\n\n            // We'll walk the comprehensions list twice. The first time we'll\n            // bind targets of for statements. The second time we'll walk\n            // expressions and create the control flow graph.\n            const boundSymbols: Map<string, Symbol>[] = [];\n            for (let i = 0; i < node.comprehensions.length; i++) {\n                const compr = node.comprehensions[i];\n                const addedSymbols = new Map<string, Symbol>();\n                if (compr.nodeType === ParseNodeType.ListComprehensionFor) {\n                    this._bindPossibleTupleNamedTarget(compr.targetExpression, addedSymbols);\n                    this._addInferredTypeAssignmentForVariable(compr.targetExpression, compr);\n                }\n                boundSymbols.push(addedSymbols);\n            }\n\n            for (let i = 0; i < node.comprehensions.length; i++) {\n                const compr = node.comprehensions[i];\n                if (compr.nodeType === ParseNodeType.ListComprehensionFor) {\n                    const addedSymbols = boundSymbols[i];\n\n                    // Determine if we added a new symbol to this scope. If so, see\n                    // if it's the same name as a symbol in an outer scope. If so, we'll\n                    // create an alias node in the control flow graph.\n                    for (const addedSymbol of addedSymbols) {\n                        const aliasSymbol = this._currentScope!.parent!.lookUpSymbol(addedSymbol[0]);\n                        if (aliasSymbol) {\n                            this._createAssignmentAliasFlowNode(addedSymbol[1].id, aliasSymbol.id);\n                        }\n                    }\n\n                    this.walk(compr.iterableExpression);\n\n                    this._createAssignmentTargetFlowNodes(\n                        compr.targetExpression,\n                        /* walkTargets */ true,\n                        /* unbound */ false\n                    );\n                } else {\n                    const trueLabel = this._createBranchLabel();\n                    this._bindConditional(compr.testExpression, trueLabel, falseLabel);\n                    this._currentFlowNode = this._finishFlowLabel(trueLabel);\n                }\n            }\n\n            this.walk(node.expression);\n            this._addAntecedent(falseLabel, this._currentFlowNode!);\n            this._currentFlowNode = this._finishFlowLabel(falseLabel);\n        });\n\n        return false;\n    }\n\n    private _addImplicitFromImport(node: ImportFromNode, importInfo?: ImportResult) {\n        const symbolName = node.module.nameParts[0].value;\n        const symbol = this._bindNameToScope(this._currentScope!, symbolName);\n        if (symbol) {\n            this._createAliasDeclarationForMultipartImportName(node, undefined, importInfo, symbol);\n        }\n\n        this._createFlowAssignment(node.module.nameParts[0]);\n    }\n\n    private _createAliasDeclarationForMultipartImportName(\n        node: ImportAsNode | ImportFromNode,\n        importAlias: NameNode | undefined,\n        importInfo: ImportResult | undefined,\n        symbol: Symbol\n    ) {\n        const firstNamePartValue = node.module.nameParts[0].value;\n\n        if (importInfo && importInfo.isImportFound && !importInfo.isNativeLib && importInfo.resolvedPaths.length > 0) {\n            // See if there's already a matching alias declaration for this import.\n            // if so, we'll update it rather than creating a new one. This is required\n            // to handle cases where multiple import statements target the same\n            // starting symbol such as \"import a.b.c\" and \"import a.d\". In this case,\n            // we'll build a single declaration that describes the combined actions\n            // of both import statements, thus reflecting the behavior of the\n            // python module loader.\n            const existingDecl = symbol\n                .getDeclarations()\n                .find((decl) => decl.type === DeclarationType.Alias && decl.firstNamePart === firstNamePartValue);\n\n            let newDecl: AliasDeclaration;\n            if (existingDecl) {\n                newDecl = existingDecl as AliasDeclaration;\n            } else {\n                newDecl = {\n                    type: DeclarationType.Alias,\n                    node,\n                    path: '',\n                    moduleName: importInfo.importName,\n                    range: getEmptyRange(),\n                    firstNamePart: firstNamePartValue,\n                    usesLocalName: !!importAlias,\n                };\n            }\n\n            // Add the implicit imports for this module if it's the last\n            // name part we're resolving.\n            if (importAlias || node.module.nameParts.length === 1) {\n                newDecl.path = importInfo.resolvedPaths[importInfo.resolvedPaths.length - 1];\n                this._addImplicitImportsToLoaderActions(importInfo, newDecl);\n            } else {\n                // Fill in the remaining name parts.\n                let curLoaderActions: ModuleLoaderActions = newDecl;\n\n                for (let i = 1; i < node.module.nameParts.length; i++) {\n                    if (i >= importInfo.resolvedPaths.length) {\n                        break;\n                    }\n\n                    const namePartValue = node.module.nameParts[i].value;\n\n                    // Is there an existing loader action for this name?\n                    let loaderActions = curLoaderActions.implicitImports\n                        ? curLoaderActions.implicitImports.get(namePartValue)\n                        : undefined;\n                    if (!loaderActions) {\n                        // Allocate a new loader action.\n                        loaderActions = {\n                            path: '',\n                            implicitImports: new Map<string, ModuleLoaderActions>(),\n                        };\n                        if (!curLoaderActions.implicitImports) {\n                            curLoaderActions.implicitImports = new Map<string, ModuleLoaderActions>();\n                        }\n                        curLoaderActions.implicitImports.set(namePartValue, loaderActions);\n                    }\n\n                    // If this is the last name part we're resolving, add in the\n                    // implicit imports as well.\n                    if (i === node.module.nameParts.length - 1) {\n                        loaderActions.path = importInfo.resolvedPaths[i];\n                        this._addImplicitImportsToLoaderActions(importInfo, loaderActions);\n                    }\n\n                    curLoaderActions = loaderActions;\n                }\n            }\n\n            if (!existingDecl) {\n                symbol.addDeclaration(newDecl);\n            }\n        } else {\n            // If we couldn't resolve the import, create a dummy declaration with a\n            // bogus path so it gets an unknown type (rather than an unbound type) at\n            // analysis time.\n            const newDecl: AliasDeclaration = {\n                type: DeclarationType.Alias,\n                node,\n                path: '*** unresolved ***',\n                range: getEmptyRange(),\n                usesLocalName: !!importAlias,\n                moduleName: '',\n            };\n            symbol.addDeclaration(newDecl);\n        }\n    }\n\n    private _getWildcardImportNames(lookupInfo: ImportLookupResult): string[] {\n        let namesToImport = getNamesInDunderAll(lookupInfo.symbolTable);\n        if (namesToImport) {\n            return namesToImport;\n        }\n\n        // Import all names that don't begin with an underscore.\n        namesToImport = [];\n        lookupInfo.symbolTable.forEach((_, name) => {\n            if (!name.startsWith('_')) {\n                namesToImport!.push(name);\n            }\n        });\n\n        return namesToImport;\n    }\n\n    private _walkStatementsAndReportUnreachable(statements: StatementNode[]) {\n        let foundUnreachableStatement = false;\n\n        for (const statement of statements) {\n            AnalyzerNodeInfo.setFlowNode(statement, this._currentFlowNode!);\n\n            if (!foundUnreachableStatement) {\n                foundUnreachableStatement = this._isCodeUnreachable();\n            }\n\n            if (!foundUnreachableStatement) {\n                this.walk(statement);\n            } else {\n                // If we're within a function, we need to look for unreachable yield\n                // statements because they affect the behavior of the function (making\n                // it a generator) even if they're never executed.\n                if (this._targetFunctionDeclaration && !this._targetFunctionDeclaration.isGenerator) {\n                    const yieldFinder = new YieldFinder();\n                    if (yieldFinder.checkContainsYield(statement)) {\n                        this._targetFunctionDeclaration.isGenerator = true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    private _createStartFlowNode() {\n        const flowNode: FlowNode = {\n            flags: FlowFlags.Start,\n            id: getUniqueFlowNodeId(),\n        };\n        return flowNode;\n    }\n\n    private _createBranchLabel() {\n        const flowNode: FlowLabel = {\n            flags: FlowFlags.BranchLabel,\n            id: getUniqueFlowNodeId(),\n            antecedents: [],\n        };\n        return flowNode;\n    }\n\n    private _createLoopLabel() {\n        const flowNode: FlowLabel = {\n            flags: FlowFlags.LoopLabel,\n            id: getUniqueFlowNodeId(),\n            antecedents: [],\n        };\n        return flowNode;\n    }\n\n    private _finishFlowLabel(node: FlowLabel) {\n        // If there were no antecedents, this is unreachable.\n        if (node.antecedents.length === 0) {\n            return Binder._unreachableFlowNode;\n        }\n\n        // If there was only one antecedent, there's no need\n        // for a label to exist.\n        if (node.antecedents.length === 1) {\n            return node.antecedents[0];\n        }\n\n        return node;\n    }\n\n    private _bindConditional(node: ExpressionNode, trueTarget: FlowLabel, falseTarget: FlowLabel) {\n        const savedTrueTarget = this._currentTrueTarget;\n        const savedFalseTarget = this._currentFalseTarget;\n        this._currentTrueTarget = trueTarget;\n        this._currentFalseTarget = falseTarget;\n\n        this.walk(node);\n\n        this._currentTrueTarget = savedTrueTarget;\n        this._currentFalseTarget = savedFalseTarget;\n\n        if (!this._isLogicalExpression(node)) {\n            this._addAntecedent(\n                trueTarget,\n                this._createFlowConditional(FlowFlags.TrueCondition, this._currentFlowNode!, node)\n            );\n            this._addAntecedent(\n                falseTarget,\n                this._createFlowConditional(FlowFlags.FalseCondition, this._currentFlowNode!, node)\n            );\n        }\n    }\n\n    private _createFlowConditional(flags: FlowFlags, antecedent: FlowNode, expression: ExpressionNode): FlowNode {\n        if (antecedent.flags & FlowFlags.Unreachable) {\n            return antecedent;\n        }\n        const staticValue = StaticExpressions.evaluateStaticBoolLikeExpression(\n            expression,\n            this._fileInfo.executionEnvironment\n        );\n        if (\n            (staticValue === true && flags & FlowFlags.FalseCondition) ||\n            (staticValue === false && flags & FlowFlags.TrueCondition)\n        ) {\n            return Binder._unreachableFlowNode;\n        }\n\n        const expressionList: NarrowingExpressionNode[] = [];\n        if (!this._isNarrowingExpression(expression, expressionList)) {\n            return antecedent;\n        }\n\n        expressionList.forEach((expr) => {\n            const referenceKey = createKeyForReference(expr);\n            this._currentExecutionScopeReferenceMap!.set(referenceKey, referenceKey);\n        });\n\n        const conditionalFlowNode: FlowCondition = {\n            flags,\n            id: getUniqueFlowNodeId(),\n            expression,\n            antecedent,\n        };\n\n        this._addExceptTargets(conditionalFlowNode);\n\n        return conditionalFlowNode;\n    }\n\n    // Indicates whether the expression is a NOT, AND or OR expression.\n    private _isLogicalExpression(expression: ExpressionNode): boolean {\n        switch (expression.nodeType) {\n            case ParseNodeType.UnaryOperation: {\n                return expression.operator === OperatorType.Not;\n            }\n\n            case ParseNodeType.BinaryOperation: {\n                return expression.operator === OperatorType.And || expression.operator === OperatorType.Or;\n            }\n        }\n\n        return false;\n    }\n\n    private _isNarrowingExpression(expression: ExpressionNode, expressionList: NarrowingExpressionNode[]): boolean {\n        switch (expression.nodeType) {\n            case ParseNodeType.Name:\n            case ParseNodeType.MemberAccess: {\n                if (isCodeFlowSupportedForReference(expression)) {\n                    expressionList.push(expression);\n                    return true;\n                }\n\n                return false;\n            }\n\n            case ParseNodeType.AssignmentExpression: {\n                expressionList.push(expression.name);\n                return true;\n            }\n\n            case ParseNodeType.BinaryOperation: {\n                const isOrIsNotOperator =\n                    expression.operator === OperatorType.Is || expression.operator === OperatorType.IsNot;\n                const equalsOrNotEqualsOperator =\n                    expression.operator === OperatorType.Equals || expression.operator === OperatorType.NotEquals;\n\n                if (isOrIsNotOperator || equalsOrNotEqualsOperator) {\n                    // Look for \"X is None\", \"X is not None\", \"X == None\", \"X != None\".\n                    // These are commonly-used patterns used in control flow.\n                    if (\n                        expression.rightExpression.nodeType === ParseNodeType.Constant &&\n                        expression.rightExpression.constType === KeywordType.None\n                    ) {\n                        return this._isNarrowingExpression(expression.leftExpression, expressionList);\n                    }\n\n                    // Look for \"type(X) is Y\" or \"type(X) is not Y\".\n                    if (\n                        isOrIsNotOperator &&\n                        expression.leftExpression.nodeType === ParseNodeType.Call &&\n                        expression.leftExpression.leftExpression.nodeType === ParseNodeType.Name &&\n                        expression.leftExpression.leftExpression.value === 'type' &&\n                        expression.leftExpression.arguments.length === 1 &&\n                        expression.leftExpression.arguments[0].argumentCategory === ArgumentCategory.Simple\n                    ) {\n                        return this._isNarrowingExpression(\n                            expression.leftExpression.arguments[0].valueExpression,\n                            expressionList\n                        );\n                    }\n\n                    const isLeftNarrowing = this._isNarrowingExpression(expression.leftExpression, expressionList);\n\n                    // Look for \"X is Y\" or \"X is not Y\".\n                    if (isOrIsNotOperator) {\n                        return isLeftNarrowing;\n                    }\n\n                    // Look for X == <literal>, X != <literal> or <literal> == X, <literal> != X\n                    if (equalsOrNotEqualsOperator) {\n                        const isRightNarrowing = this._isNarrowingExpression(\n                            expression.rightExpression,\n                            expressionList\n                        );\n                        return isLeftNarrowing || isRightNarrowing;\n                    }\n                }\n\n                // Look for \"X in Y\".\n                if (expression.operator === OperatorType.In) {\n                    return this._isNarrowingExpression(expression.leftExpression, expressionList);\n                }\n\n                return false;\n            }\n\n            case ParseNodeType.UnaryOperation: {\n                return (\n                    expression.operator === OperatorType.Not &&\n                    this._isNarrowingExpression(expression.expression, expressionList)\n                );\n            }\n\n            case ParseNodeType.AugmentedAssignment: {\n                return this._isNarrowingExpression(expression.rightExpression, expressionList);\n            }\n\n            case ParseNodeType.Call: {\n                if (\n                    expression.leftExpression.nodeType === ParseNodeType.Name &&\n                    (expression.leftExpression.value === 'isinstance' ||\n                        expression.leftExpression.value === 'issubclass') &&\n                    expression.arguments.length === 2\n                ) {\n                    return this._isNarrowingExpression(expression.arguments[0].valueExpression, expressionList);\n                }\n\n                if (\n                    expression.leftExpression.nodeType === ParseNodeType.Name &&\n                    expression.leftExpression.value === 'callable' &&\n                    expression.arguments.length === 1\n                ) {\n                    return this._isNarrowingExpression(expression.arguments[0].valueExpression, expressionList);\n                }\n            }\n        }\n\n        return false;\n    }\n\n    private _createAssignmentTargetFlowNodes(target: ExpressionNode, walkTargets: boolean, unbound: boolean) {\n        switch (target.nodeType) {\n            case ParseNodeType.Name:\n            case ParseNodeType.MemberAccess: {\n                this._createFlowAssignment(target, unbound);\n                if (walkTargets) {\n                    this.walk(target);\n                }\n                break;\n            }\n\n            case ParseNodeType.Tuple: {\n                target.expressions.forEach((expr) => {\n                    this._createAssignmentTargetFlowNodes(expr, walkTargets, unbound);\n                });\n                break;\n            }\n\n            case ParseNodeType.TypeAnnotation: {\n                this._createAssignmentTargetFlowNodes(target.valueExpression, /* walkTargets */ false, unbound);\n                if (walkTargets) {\n                    this.walk(target);\n                }\n                break;\n            }\n\n            case ParseNodeType.Unpack: {\n                this._createAssignmentTargetFlowNodes(target.expression, /* walkTargets */ false, unbound);\n                if (walkTargets) {\n                    this.walk(target);\n                }\n                break;\n            }\n\n            case ParseNodeType.List: {\n                target.entries.forEach((entry) => {\n                    this._createAssignmentTargetFlowNodes(entry, walkTargets, unbound);\n                });\n                break;\n            }\n\n            default: {\n                if (walkTargets) {\n                    this.walk(target);\n                }\n            }\n        }\n    }\n\n    private _createCallFlowNode(node: CallNode) {\n        if (!this._isCodeUnreachable()) {\n            const flowNode: FlowCall = {\n                flags: FlowFlags.Call,\n                id: getUniqueFlowNodeId(),\n                node,\n                antecedent: this._currentFlowNode!,\n            };\n\n            this._currentFlowNode = flowNode;\n        }\n\n        AnalyzerNodeInfo.setFlowNode(node, this._currentFlowNode!);\n    }\n\n    private _createAssignmentAliasFlowNode(targetSymbolId: number, aliasSymbolId: number) {\n        if (!this._isCodeUnreachable()) {\n            const flowNode: FlowAssignmentAlias = {\n                flags: FlowFlags.AssignmentAlias,\n                id: getUniqueFlowNodeId(),\n                antecedent: this._currentFlowNode!,\n                targetSymbolId,\n                aliasSymbolId,\n            };\n\n            this._currentFlowNode = flowNode;\n        }\n    }\n\n    private _createFlowAssignment(node: NameNode | MemberAccessNode, unbound = false) {\n        let targetSymbolId = indeterminateSymbolId;\n        if (node.nodeType === ParseNodeType.Name) {\n            const symbolWithScope = this._currentScope!.lookUpSymbolRecursive(node.value);\n            assert(symbolWithScope !== undefined);\n            targetSymbolId = symbolWithScope!.symbol.id;\n        }\n\n        const prevFlowNode = this._currentFlowNode!;\n        if (!this._isCodeUnreachable() && isCodeFlowSupportedForReference(node)) {\n            const flowNode: FlowAssignment = {\n                flags: FlowFlags.Assignment,\n                id: getUniqueFlowNodeId(),\n                node,\n                antecedent: this._currentFlowNode!,\n                targetSymbolId,\n            };\n\n            const referenceKey = createKeyForReference(node);\n            this._currentExecutionScopeReferenceMap!.set(referenceKey, referenceKey);\n\n            if (unbound) {\n                flowNode.flags |= FlowFlags.Unbind;\n            }\n\n            this._addExceptTargets(flowNode);\n            this._currentFlowNode = flowNode;\n        }\n\n        // If we're marking the node as unbound and there is already a flow node\n        // associated with the node, don't replace it. This case applies for symbols\n        // introduced in except clauses. If there is no use the previous flow node\n        // associated, use the previous flow node (applies in the del case).\n        // Otherwise, the node will be evaluated as unbound at this point in the flow.\n        if (!unbound || AnalyzerNodeInfo.getFlowNode(node) === undefined) {\n            AnalyzerNodeInfo.setFlowNode(node, unbound ? prevFlowNode : this._currentFlowNode!);\n        }\n    }\n\n    private _createFlowWildcardImport(node: ImportFromNode, names: string[]) {\n        if (!this._isCodeUnreachable()) {\n            const flowNode: FlowWildcardImport = {\n                flags: FlowFlags.WildcardImport,\n                id: getUniqueFlowNodeId(),\n                node,\n                names,\n                antecedent: this._currentFlowNode!,\n            };\n\n            this._addExceptTargets(flowNode);\n            this._currentFlowNode = flowNode;\n        }\n\n        AnalyzerNodeInfo.setFlowNode(node, this._currentFlowNode!);\n    }\n\n    private _isCodeUnreachable() {\n        return !!(this._currentFlowNode!.flags & FlowFlags.Unreachable);\n    }\n\n    private _addExceptTargets(flowNode: FlowNode) {\n        // If there are any except targets, then we're in a try block, and we\n        // have to assume that an exception can be raised after every assignment.\n        if (this._currentExceptTargets) {\n            this._currentExceptTargets.forEach((label) => {\n                this._addAntecedent(label, flowNode);\n            });\n        }\n    }\n\n    private _bindLoopStatement(preLoopLabel: FlowLabel, postLoopLabel: FlowLabel, callback: () => void) {\n        const savedContinueTarget = this._currentContinueTarget;\n        const savedBreakTarget = this._currentBreakTarget;\n        this._currentContinueTarget = preLoopLabel;\n        this._currentBreakTarget = postLoopLabel;\n\n        callback();\n\n        this._currentContinueTarget = savedContinueTarget;\n        this._currentBreakTarget = savedBreakTarget;\n    }\n\n    private _addAntecedent(label: FlowLabel, antecedent: FlowNode) {\n        if (!(this._currentFlowNode!.flags & FlowFlags.Unreachable)) {\n            // Don't add the same antecedent twice.\n            if (!label.antecedents.some((existing) => existing.id === antecedent.id)) {\n                label.antecedents.push(antecedent);\n            }\n        }\n    }\n\n    private _bindNameToScope(scope: Scope, name: string, addedSymbols?: Map<string, Symbol>) {\n        if (this._notLocalBindings.get(name) === undefined) {\n            // Don't overwrite an existing symbol.\n            let symbol = scope.lookUpSymbol(name);\n            if (!symbol) {\n                symbol = scope.addSymbol(name, SymbolFlags.InitiallyUnbound | SymbolFlags.ClassMember);\n\n                // Handle the case where a new symbol is being added to a class\n                // but the expression assigned to it uses a symbol of the same\n                // name that is declared in an outer scope.\n                if (scope.type === ScopeType.Class) {\n                    const aliasSymbol = scope.parent!.lookUpSymbol(name);\n                    if (aliasSymbol) {\n                        this._createAssignmentAliasFlowNode(symbol.id, aliasSymbol.id);\n                    }\n                }\n\n                if (this._fileInfo.isStubFile && isPrivateOrProtectedName(name)) {\n                    symbol.setIsExternallyHidden();\n                }\n\n                if (addedSymbols) {\n                    addedSymbols.set(name, symbol);\n                }\n            }\n\n            return symbol;\n        }\n\n        return undefined;\n    }\n\n    private _bindPossibleTupleNamedTarget(target: ExpressionNode, addedSymbols?: Map<string, Symbol>) {\n        switch (target.nodeType) {\n            case ParseNodeType.Name: {\n                this._bindNameToScope(this._currentScope!, target.value, addedSymbols);\n                break;\n            }\n\n            case ParseNodeType.Tuple: {\n                target.expressions.forEach((expr) => {\n                    this._bindPossibleTupleNamedTarget(expr, addedSymbols);\n                });\n                break;\n            }\n\n            case ParseNodeType.List: {\n                target.entries.forEach((expr) => {\n                    this._bindPossibleTupleNamedTarget(expr, addedSymbols);\n                });\n                break;\n            }\n\n            case ParseNodeType.TypeAnnotation: {\n                this._bindPossibleTupleNamedTarget(target.valueExpression, addedSymbols);\n                break;\n            }\n\n            case ParseNodeType.Unpack: {\n                this._bindPossibleTupleNamedTarget(target.expression, addedSymbols);\n                break;\n            }\n        }\n    }\n\n    private _addBuiltInSymbolToCurrentScope(\n        nameValue: string,\n        node: ModuleNode | ClassNode | FunctionNode,\n        type: IntrinsicType\n    ) {\n        const symbol = this._addSymbolToCurrentScope(nameValue, /* isInitiallyUnbound */ false);\n        if (symbol) {\n            symbol.addDeclaration({\n                type: DeclarationType.Intrinsic,\n                node,\n                intrinsicType: type,\n                path: this._fileInfo.filePath,\n                range: getEmptyRange(),\n                moduleName: this._fileInfo.moduleName,\n            });\n            symbol.setIsIgnoredForProtocolMatch();\n        }\n    }\n\n    // Adds a new symbol with the specified name if it doesn't already exist.\n    private _addSymbolToCurrentScope(nameValue: string, isInitiallyUnbound: boolean) {\n        let symbol = this._currentScope!.lookUpSymbol(nameValue);\n\n        if (!symbol) {\n            let symbolFlags = SymbolFlags.None;\n\n            if (isInitiallyUnbound) {\n                symbolFlags |= SymbolFlags.InitiallyUnbound;\n            }\n\n            if (this._currentScope!.type === ScopeType.Class) {\n                symbolFlags |= SymbolFlags.ClassMember;\n            }\n\n            if (this._fileInfo.isStubFile && isPrivateOrProtectedName(nameValue)) {\n                symbolFlags |= SymbolFlags.ExternallyHidden;\n            }\n\n            // Add the symbol. Assume that symbols with a default type source ID\n            // are \"implicit\" symbols added to the scope. These are not initially unbound.\n            symbol = this._currentScope!.addSymbol(nameValue, symbolFlags);\n        }\n\n        return symbol;\n    }\n\n    private _createNewScope(scopeType: ScopeType, parentScope: Scope | undefined, callback: () => void) {\n        const prevScope = this._currentScope;\n        this._currentScope = new Scope(scopeType, parentScope);\n\n        // If this scope is an execution scope, allocate a new reference map.\n        const isExecutionScope =\n            scopeType === ScopeType.Builtin || scopeType === ScopeType.Module || scopeType === ScopeType.Function;\n        const prevReferenceMap = this._currentExecutionScopeReferenceMap;\n\n        if (isExecutionScope) {\n            this._currentExecutionScopeReferenceMap = new Map<string, string>();\n        }\n\n        const prevNonLocalBindings = this._notLocalBindings;\n        this._notLocalBindings = new Map<string, NameBindingType>();\n\n        callback();\n\n        this._currentExecutionScopeReferenceMap = prevReferenceMap;\n        this._currentScope = prevScope;\n        this._notLocalBindings = prevNonLocalBindings;\n    }\n\n    private _addInferredTypeAssignmentForVariable(\n        target: ExpressionNode,\n        source: ParseNode,\n        isPossibleTypeAlias = false\n    ) {\n        switch (target.nodeType) {\n            case ParseNodeType.Name: {\n                const name = target;\n                const symbolWithScope = this._currentScope!.lookUpSymbolRecursive(name.value);\n                if (symbolWithScope && symbolWithScope.symbol) {\n                    const declaration: VariableDeclaration = {\n                        type: DeclarationType.Variable,\n                        node: target,\n                        isConstant: isConstantName(target.value),\n                        inferredTypeSource: source,\n                        typeAliasName: isPossibleTypeAlias ? target : undefined,\n                        path: this._fileInfo.filePath,\n                        range: convertOffsetsToRange(name.start, TextRange.getEnd(name), this._fileInfo.lines),\n                        moduleName: this._fileInfo.moduleName,\n                    };\n                    symbolWithScope.symbol.addDeclaration(declaration);\n                }\n                break;\n            }\n\n            case ParseNodeType.MemberAccess: {\n                const memberAccessInfo = this._getMemberAccessInfo(target);\n                if (memberAccessInfo) {\n                    const name = target.memberName;\n\n                    let symbol = memberAccessInfo.classScope.lookUpSymbol(name.value);\n                    if (!symbol) {\n                        symbol = memberAccessInfo.classScope.addSymbol(name.value, SymbolFlags.InitiallyUnbound);\n                        const honorPrivateNaming = this._fileInfo.diagnosticRuleSet.reportPrivateUsage !== 'none';\n                        if (isPrivateOrProtectedName(name.value) && honorPrivateNaming) {\n                            symbol.setIsPrivateMember();\n                        }\n                    }\n\n                    if (memberAccessInfo.isInstanceMember) {\n                        // If a method (which has a declared type) is being overwritten\n                        // by an expression with no declared type, don't mark it as\n                        // an instance member because the type evaluator will think\n                        // that it doesn't need to perform object binding.\n                        if (\n                            !symbol.isClassMember() ||\n                            !symbol\n                                .getDeclarations()\n                                .some((decl) => decl.type === DeclarationType.Function && decl.isMethod)\n                        ) {\n                            symbol.setIsInstanceMember();\n                        }\n                    } else {\n                        symbol.setIsClassMember();\n                    }\n\n                    const declaration: VariableDeclaration = {\n                        type: DeclarationType.Variable,\n                        node: target.memberName,\n                        isConstant: isConstantName(name.value),\n                        inferredTypeSource: source,\n                        isDefinedByMemberAccess: true,\n                        path: this._fileInfo.filePath,\n                        range: convertOffsetsToRange(\n                            target.memberName.start,\n                            target.memberName.start + target.memberName.length,\n                            this._fileInfo.lines\n                        ),\n                        moduleName: this._fileInfo.moduleName,\n                    };\n                    symbol.addDeclaration(declaration);\n                }\n                break;\n            }\n\n            case ParseNodeType.Tuple: {\n                target.expressions.forEach((expr) => {\n                    this._addInferredTypeAssignmentForVariable(expr, source);\n                });\n                break;\n            }\n\n            case ParseNodeType.TypeAnnotation: {\n                this._addInferredTypeAssignmentForVariable(target.valueExpression, source);\n                break;\n            }\n\n            case ParseNodeType.Unpack: {\n                this._addInferredTypeAssignmentForVariable(target.expression, source);\n                break;\n            }\n\n            case ParseNodeType.List: {\n                target.entries.forEach((entry) => {\n                    this._addInferredTypeAssignmentForVariable(entry, source);\n                });\n                break;\n            }\n        }\n    }\n\n    private _addTypeDeclarationForVariable(target: ExpressionNode, typeAnnotation: ExpressionNode) {\n        let declarationHandled = false;\n\n        switch (target.nodeType) {\n            case ParseNodeType.Name: {\n                const name = target;\n                const symbolWithScope = this._currentScope!.lookUpSymbolRecursive(name.value);\n                if (symbolWithScope && symbolWithScope.symbol) {\n                    const finalInfo = this._isAnnotationFinal(typeAnnotation);\n                    const isExplicitTypeAlias = this._isAnnotationTypeAlias(typeAnnotation);\n\n                    let typeAnnotationNode: ExpressionNode | undefined = typeAnnotation;\n                    if (isExplicitTypeAlias) {\n                        typeAnnotationNode = undefined;\n\n                        // Type aliases are allowed only in the global scope.\n                        if (this._currentScope!.type !== ScopeType.Module) {\n                            this._addError(Localizer.Diagnostic.typeAliasNotInModule(), typeAnnotation);\n                        }\n                    } else if (finalInfo.isFinal) {\n                        typeAnnotationNode = finalInfo.finalTypeNode;\n                    }\n\n                    const declaration: VariableDeclaration = {\n                        type: DeclarationType.Variable,\n                        node: target,\n                        isConstant: isConstantName(name.value),\n                        isFinal: finalInfo.isFinal,\n                        typeAliasAnnotation: isExplicitTypeAlias ? typeAnnotation : undefined,\n                        typeAliasName: isExplicitTypeAlias ? target : undefined,\n                        path: this._fileInfo.filePath,\n                        typeAnnotationNode,\n                        range: convertOffsetsToRange(name.start, TextRange.getEnd(name), this._fileInfo.lines),\n                        moduleName: this._fileInfo.moduleName,\n                    };\n                    symbolWithScope.symbol.addDeclaration(declaration);\n\n                    // Is this annotation indicating that the variable is a \"ClassVar\"? Note\n                    // that this check is somewhat fragile because we can't verify here that\n                    // \"ClassVar\" maps to the typing module symbol by this name.\n                    const isClassVar =\n                        typeAnnotation.nodeType === ParseNodeType.Index &&\n                        typeAnnotation.baseExpression.nodeType === ParseNodeType.Name &&\n                        typeAnnotation.baseExpression.value === 'ClassVar';\n\n                    if (isClassVar) {\n                        symbolWithScope.symbol.setIsClassVar();\n                    } else {\n                        symbolWithScope.symbol.setIsInstanceMember();\n                    }\n                }\n\n                declarationHandled = true;\n                break;\n            }\n\n            case ParseNodeType.MemberAccess: {\n                // We need to determine whether this expression is declaring a class or\n                // instance variable. This is difficult because python doesn't provide\n                // a keyword for accessing \"this\". Instead, it uses naming conventions\n                // of \"cls\" and \"self\", but we don't want to rely on these naming\n                // conventions here. Instead, we'll apply some heuristics to determine\n                // whether the symbol on the LHS is a reference to the current class\n                // or an instance of the current class.\n\n                const memberAccessInfo = this._getMemberAccessInfo(target);\n                if (memberAccessInfo) {\n                    const name = target.memberName;\n\n                    let symbol = memberAccessInfo.classScope.lookUpSymbol(name.value);\n                    if (!symbol) {\n                        symbol = memberAccessInfo.classScope.addSymbol(name.value, SymbolFlags.InitiallyUnbound);\n                        const honorPrivateNaming = this._fileInfo.diagnosticRuleSet.reportPrivateUsage !== 'none';\n                        if (isPrivateOrProtectedName(name.value) && honorPrivateNaming) {\n                            symbol.setIsPrivateMember();\n                        }\n                    }\n\n                    if (memberAccessInfo.isInstanceMember) {\n                        symbol.setIsInstanceMember();\n                    } else {\n                        symbol.setIsClassMember();\n                    }\n\n                    const finalInfo = this._isAnnotationFinal(typeAnnotation);\n                    const declaration: VariableDeclaration = {\n                        type: DeclarationType.Variable,\n                        node: target.memberName,\n                        isConstant: isConstantName(name.value),\n                        isDefinedByMemberAccess: true,\n                        isFinal: finalInfo.isFinal,\n                        path: this._fileInfo.filePath,\n                        typeAnnotationNode: finalInfo.isFinal ? finalInfo.finalTypeNode : typeAnnotation,\n                        range: convertOffsetsToRange(\n                            target.memberName.start,\n                            target.memberName.start + target.memberName.length,\n                            this._fileInfo.lines\n                        ),\n                        moduleName: this._fileInfo.moduleName,\n                    };\n                    symbol.addDeclaration(declaration);\n\n                    declarationHandled = true;\n                }\n                break;\n            }\n        }\n\n        if (!declarationHandled) {\n            this._addError(Localizer.Diagnostic.annotationNotSupported(), typeAnnotation);\n        }\n    }\n\n    // Determines whether the expression refers to a type exported by the typing\n    // or typing_extensions modules. We can directly evaluate the types at binding\n    // time. We assume here that the code isn't making use of some custom type alias\n    // to refer to the typing types.\n    private _isTypingAnnotation(typeAnnotation: ExpressionNode, name: string): boolean {\n        if (typeAnnotation.nodeType === ParseNodeType.Name) {\n            const alias = this._typingSymbolAliases.get(typeAnnotation.value);\n            if (alias === name) {\n                return true;\n            }\n        } else if (typeAnnotation.nodeType === ParseNodeType.MemberAccess) {\n            if (\n                typeAnnotation.leftExpression.nodeType === ParseNodeType.Name &&\n                typeAnnotation.memberName.value === name\n            ) {\n                const baseName = typeAnnotation.leftExpression.value;\n                return this._typingImportAliases.some((alias) => alias === baseName);\n            }\n        }\n\n        return false;\n    }\n\n    // Determines if the specified type annotation expression is a \"Final\".\n    // It returns two boolean values indicating if the expression is a \"Final\"\n    // expression and whether it's a \"raw\" Final with no type arguments.\n    private _isAnnotationFinal(typeAnnotation: ExpressionNode | undefined): FinalInfo {\n        let isFinal = false;\n        let finalTypeNode: ExpressionNode | undefined;\n\n        if (typeAnnotation) {\n            if (this._isTypingAnnotation(typeAnnotation, 'Final')) {\n                isFinal = true;\n            } else if (typeAnnotation.nodeType === ParseNodeType.Index && typeAnnotation.items.items.length === 1) {\n                // Recursively call to see if the base expression is \"Final\".\n                const finalInfo = this._isAnnotationFinal(typeAnnotation.baseExpression);\n                if (finalInfo.isFinal) {\n                    isFinal = true;\n                    finalTypeNode = typeAnnotation.items.items[0];\n                }\n            }\n        }\n\n        return { isFinal, finalTypeNode };\n    }\n\n    private _isAnnotationTypeAlias(typeAnnotation: ExpressionNode | undefined) {\n        if (!typeAnnotation) {\n            return false;\n        }\n\n        if (this._fileInfo.executionEnvironment.pythonVersion < PythonVersion.V3_10 && !this._fileInfo.isStubFile) {\n            return false;\n        }\n\n        return this._isTypingAnnotation(typeAnnotation, 'TypeAlias');\n    }\n\n    // Determines whether a member access expression is referring to a\n    // member of a class (either a class or instance member). This will\n    // typically take the form \"self.x\" or \"cls.x\".\n    private _getMemberAccessInfo(node: MemberAccessNode): MemberAccessInfo | undefined {\n        // We handle only simple names on the left-hand side of the expression,\n        // not calls, nested member accesses, index expressions, etc.\n        if (node.leftExpression.nodeType !== ParseNodeType.Name) {\n            return undefined;\n        }\n\n        const leftSymbolName = node.leftExpression.value;\n\n        // Make sure the expression is within a function (i.e. a method) that's\n        // within a class definition.\n        const methodNode = ParseTreeUtils.getEnclosingFunction(node);\n        if (!methodNode) {\n            return undefined;\n        }\n\n        const classNode = ParseTreeUtils.getEnclosingClass(methodNode);\n        if (!classNode) {\n            return undefined;\n        }\n\n        // Determine whether the left-hand side indicates a class or\n        // instance member.\n        let isInstanceMember = false;\n\n        if (methodNode.parameters.length < 1 || !methodNode.parameters[0].name) {\n            return undefined;\n        }\n\n        const className = classNode.name.value;\n        const firstParamName = methodNode.parameters[0].name.value;\n\n        if (leftSymbolName === className) {\n            isInstanceMember = false;\n        } else {\n            if (leftSymbolName !== firstParamName) {\n                return undefined;\n            }\n\n            // To determine whether the first parameter of the method\n            // refers to the class or the instance, we need to apply\n            // some heuristics.\n            if (methodNode.name.value === '__new__') {\n                // The __new__ method is special. It acts as a classmethod even\n                // though it doesn't have a @classmethod decorator.\n                isInstanceMember = false;\n            } else {\n                // Assume that it's an instance member unless we find\n                // a decorator that tells us otherwise.\n                isInstanceMember = true;\n                for (const decorator of methodNode.decorators) {\n                    if (decorator.leftExpression.nodeType === ParseNodeType.Name) {\n                        const decoratorName = decorator.leftExpression.value;\n\n                        if (decoratorName === 'staticmethod') {\n                            // A static method doesn't have a \"self\" or \"cls\" parameter.\n                            return undefined;\n                        } else if (decoratorName === 'classmethod') {\n                            // A classmethod implies that the first parameter is \"cls\".\n                            isInstanceMember = false;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        const classScope = AnalyzerNodeInfo.getScope(classNode)!;\n        assert(classScope !== undefined);\n\n        return {\n            classNode,\n            methodNode,\n            classScope,\n            isInstanceMember,\n        };\n    }\n\n    private _addImplicitImportsToLoaderActions(importResult: ImportResult, loaderActions: ModuleLoaderActions) {\n        importResult.implicitImports.forEach((implicitImport) => {\n            const existingLoaderAction = loaderActions.implicitImports\n                ? loaderActions.implicitImports.get(implicitImport.name)\n                : undefined;\n            if (existingLoaderAction) {\n                existingLoaderAction.path = implicitImport.path;\n            } else {\n                if (!loaderActions.implicitImports) {\n                    loaderActions.implicitImports = new Map<string, ModuleLoaderActions>();\n                }\n                loaderActions.implicitImports.set(implicitImport.name, {\n                    path: implicitImport.path,\n                    implicitImports: new Map<string, ModuleLoaderActions>(),\n                });\n            }\n        });\n    }\n\n    // Handles some special-case assignment statements that are found\n    // within the typings.pyi file.\n    private _handleTypingStubAssignmentOrAnnotation(node: AssignmentNode | TypeAnnotationNode) {\n        if (!this._fileInfo.isTypingStubFile) {\n            return false;\n        }\n\n        let annotationNode: TypeAnnotationNode;\n\n        if (node.nodeType === ParseNodeType.TypeAnnotation) {\n            annotationNode = node;\n        } else {\n            if (node.leftExpression.nodeType !== ParseNodeType.TypeAnnotation) {\n                return false;\n            }\n\n            annotationNode = node.leftExpression;\n        }\n\n        if (annotationNode.valueExpression.nodeType !== ParseNodeType.Name) {\n            return false;\n        }\n\n        const assignedNameNode = annotationNode.valueExpression;\n        const specialTypes: { [name: string]: boolean } = {\n            Tuple: true,\n            Generic: true,\n            Protocol: true,\n            Callable: true,\n            Type: true,\n            ClassVar: true,\n            Final: true,\n            Literal: true,\n            TypedDict: true,\n            Union: true,\n            Optional: true,\n            Annotated: true,\n            TypeAlias: true,\n            OrderedDict: true,\n            Concatenate: true,\n        };\n\n        const assignedName = assignedNameNode.value;\n\n        if (!specialTypes[assignedName]) {\n            return false;\n        }\n        const symbol = this._bindNameToScope(this._currentScope!, assignedName);\n\n        if (symbol) {\n            symbol.addDeclaration({\n                type: DeclarationType.SpecialBuiltInClass,\n                node: annotationNode,\n                path: this._fileInfo.filePath,\n                range: convertOffsetsToRange(\n                    annotationNode.start,\n                    TextRange.getEnd(annotationNode),\n                    this._fileInfo.lines\n                ),\n                moduleName: this._fileInfo.moduleName,\n            });\n        }\n        return true;\n    }\n\n    private _deferBinding(callback: () => void) {\n        this._deferredBindingTasks.push({\n            scope: this._currentScope!,\n            nonLocalBindingsMap: this._notLocalBindings,\n            codeFlowExpressionMap: this._currentExecutionScopeReferenceMap!,\n            callback,\n        });\n    }\n\n    private _bindDeferred() {\n        while (this._deferredBindingTasks.length > 0) {\n            const nextItem = this._deferredBindingTasks.shift()!;\n\n            // Reset the state\n            this._currentScope = nextItem.scope;\n            this._notLocalBindings = nextItem.nonLocalBindingsMap;\n            this._nestedExceptDepth = 0;\n            this._currentExecutionScopeReferenceMap = nextItem.codeFlowExpressionMap;\n\n            nextItem.callback();\n        }\n    }\n\n    private _bindYield(node: YieldNode | YieldFromNode) {\n        const functionNode = ParseTreeUtils.getEnclosingFunction(node);\n\n        if (!functionNode) {\n            if (!ParseTreeUtils.getEnclosingLambda(node)) {\n                this._addError(Localizer.Diagnostic.yieldOutsideFunction(), node);\n            }\n        } else if (functionNode.isAsync && node.nodeType === ParseNodeType.YieldFrom) {\n            // PEP 525 indicates that 'yield from' is not allowed in an\n            // async function.\n            this._addError(Localizer.Diagnostic.yieldFromOutsideAsync(), node);\n        }\n\n        if (this._targetFunctionDeclaration) {\n            if (!this._targetFunctionDeclaration.yieldStatements) {\n                this._targetFunctionDeclaration.yieldStatements = [];\n            }\n            this._targetFunctionDeclaration.yieldStatements.push(node);\n            this._targetFunctionDeclaration.isGenerator = true;\n        }\n\n        if (node.expression) {\n            this.walk(node.expression);\n        }\n\n        AnalyzerNodeInfo.setFlowNode(node, this._currentFlowNode!);\n    }\n\n    private _addDiagnostic(diagLevel: DiagnosticLevel, rule: string, message: string, textRange: TextRange) {\n        let diagnostic: Diagnostic | undefined;\n        switch (diagLevel) {\n            case 'error':\n                diagnostic = this._addError(message, textRange);\n                break;\n\n            case 'warning':\n                diagnostic = this._addWarning(message, textRange);\n                break;\n\n            case 'information':\n                diagnostic = this._addInformation(message, textRange);\n                break;\n\n            case 'none':\n                break;\n\n            default:\n                return assertNever(diagLevel, `${diagLevel} is not expected`);\n        }\n\n        if (diagnostic) {\n            diagnostic.setRule(rule);\n        }\n\n        return diagnostic;\n    }\n\n    private _addError(message: string, textRange: TextRange) {\n        return this._fileInfo.diagnosticSink.addDiagnosticWithTextRange('error', message, textRange);\n    }\n\n    private _addWarning(message: string, textRange: TextRange) {\n        return this._fileInfo.diagnosticSink.addDiagnosticWithTextRange('warning', message, textRange);\n    }\n\n    private _addInformation(message: string, textRange: TextRange) {\n        return this._fileInfo.diagnosticSink.addDiagnosticWithTextRange('information', message, textRange);\n    }\n}\n\nexport class YieldFinder extends ParseTreeWalker {\n    private _containsYield = false;\n\n    checkContainsYield(node: ParseNode) {\n        this.walk(node);\n        return this._containsYield;\n    }\n\n    visitYield(node: YieldNode): boolean {\n        this._containsYield = true;\n        return false;\n    }\n\n    visitYieldFrom(node: YieldFromNode): boolean {\n        this._containsYield = true;\n        return false;\n    }\n}\n","/*\n * checker.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * A parse tree walker that performs static type checking for\n * a source file. Most of its work is performed by the type\n * evaluator, but this module touches every node in the file\n * to ensure that all statements and expressions are evaluated\n * and checked. It also performs some additional checks that\n * cannot (or should not be) performed lazily.\n */\n\nimport { Commands } from '../commands/commands';\nimport { DiagnosticLevel } from '../common/configOptions';\nimport { assert } from '../common/debug';\nimport { Diagnostic, DiagnosticAddendum } from '../common/diagnostic';\nimport { DiagnosticRule } from '../common/diagnosticRules';\nimport { TextRange } from '../common/textRange';\nimport { Localizer } from '../localization/localize';\nimport {\n    AssertNode,\n    AssignmentExpressionNode,\n    AssignmentNode,\n    AugmentedAssignmentNode,\n    BinaryOperationNode,\n    CallNode,\n    ClassNode,\n    DelNode,\n    ErrorNode,\n    ExceptNode,\n    FormatStringNode,\n    ForNode,\n    FunctionNode,\n    IfNode,\n    ImportAsNode,\n    ImportFromAsNode,\n    ImportFromNode,\n    IndexNode,\n    isExpressionNode,\n    LambdaNode,\n    ListComprehensionNode,\n    MemberAccessNode,\n    ModuleNode,\n    NameNode,\n    ParameterCategory,\n    ParseNode,\n    ParseNodeType,\n    RaiseNode,\n    ReturnNode,\n    SliceNode,\n    StatementListNode,\n    StatementNode,\n    StringListNode,\n    SuiteNode,\n    TernaryNode,\n    TupleNode,\n    TypeAnnotationNode,\n    UnaryOperationNode,\n    UnpackNode,\n    WhileNode,\n    WithNode,\n    YieldFromNode,\n    YieldNode,\n} from '../parser/parseNodes';\nimport { AnalyzerFileInfo } from './analyzerFileInfo';\nimport * as AnalyzerNodeInfo from './analyzerNodeInfo';\nimport { Declaration, DeclarationType } from './declaration';\nimport { isExplicitTypeAliasDeclaration, isFinalVariableDeclaration } from './declarationUtils';\nimport { ImportType } from './importResult';\nimport { getTopLevelImports } from './importStatementUtils';\nimport * as ParseTreeUtils from './parseTreeUtils';\nimport { ParseTreeWalker } from './parseTreeWalker';\nimport { ScopeType } from './scope';\nimport { getScopeForNode } from './scopeUtils';\nimport { Symbol } from './symbol';\nimport * as SymbolNameUtils from './symbolNameUtils';\nimport { getLastTypedDeclaredForSymbol, isFinalVariable } from './symbolUtils';\nimport { TypeEvaluator } from './typeEvaluator';\nimport {\n    ClassType,\n    combineTypes,\n    FunctionType,\n    isAnyOrUnknown,\n    isClass,\n    isNever,\n    isNone,\n    isObject,\n    isTypeSame,\n    isTypeVar,\n    isUnknown,\n    NoneType,\n    ObjectType,\n    Type,\n    TypeBase,\n    TypeCategory,\n    UnknownType,\n} from './types';\nimport {\n    CanAssignFlags,\n    ClassMemberLookupFlags,\n    derivesFromAnyOrUnknown,\n    derivesFromClassRecursive,\n    doForSubtypes,\n    getDeclaredGeneratorReturnType,\n    getDeclaredGeneratorYieldType,\n    isEllipsisType,\n    isNoReturnType,\n    isPartlyUnknown,\n    isProperty,\n    isTupleClass,\n    lookUpClassMember,\n    makeTypeVarsConcrete,\n    partiallySpecializeType,\n    specializeType,\n    transformTypeObjectToClass,\n} from './typeUtils';\n\nexport class Checker extends ParseTreeWalker {\n    private readonly _moduleNode: ModuleNode;\n    private readonly _fileInfo: AnalyzerFileInfo;\n    private readonly _evaluator: TypeEvaluator;\n\n    // A list of all nodes that are defined within the module that\n    // have their own scopes.\n    private _scopedNodes: AnalyzerNodeInfo.ScopedNode[] = [];\n\n    constructor(node: ModuleNode, evaluator: TypeEvaluator) {\n        super();\n\n        this._moduleNode = node;\n        this._fileInfo = AnalyzerNodeInfo.getFileInfo(node)!;\n        this._evaluator = evaluator;\n    }\n\n    check() {\n        this._scopedNodes.push(this._moduleNode);\n\n        this._walkStatementsAndReportUnreachable(this._moduleNode.statements);\n\n        // Perform a one-time validation of symbols in all scopes\n        // defined in this module for things like unaccessed variables.\n        this._validateSymbolTables();\n\n        this._reportDuplicateImports();\n    }\n\n    walk(node: ParseNode) {\n        if (!AnalyzerNodeInfo.isCodeUnreachable(node)) {\n            super.walk(node);\n        } else {\n            this._evaluator.suppressDiagnostics(() => {\n                super.walk(node);\n            });\n        }\n    }\n\n    visitSuite(node: SuiteNode): boolean {\n        this._walkStatementsAndReportUnreachable(node.statements);\n        return false;\n    }\n\n    visitStatementList(node: StatementListNode) {\n        node.statements.forEach((statement) => {\n            if (isExpressionNode(statement)) {\n                // Evaluate the expression in case it wasn't otherwise evaluated\n                // through lazy analysis. This will mark referenced symbols as\n                // accessed and report any errors associated with it.\n                this._evaluator.getType(statement);\n            }\n        });\n\n        return true;\n    }\n\n    visitClass(node: ClassNode): boolean {\n        const classTypeResult = this._evaluator.getTypeOfClass(node);\n\n        this.walk(node.suite);\n        this.walkMultiple(node.decorators);\n        this.walkMultiple(node.arguments);\n\n        if (classTypeResult) {\n            this._validateClassMethods(classTypeResult.classType);\n\n            this._validateFinalMemberOverrides(classTypeResult.classType);\n\n            if (ClassType.isTypedDictClass(classTypeResult.classType)) {\n                this._validateTypedDictClassSuite(node.suite);\n            }\n        }\n\n        this._scopedNodes.push(node);\n\n        return false;\n    }\n\n    visitFunction(node: FunctionNode): boolean {\n        const functionTypeResult = this._evaluator.getTypeOfFunction(node);\n        const containingClassNode = ParseTreeUtils.getEnclosingClass(node, true);\n\n        if (functionTypeResult) {\n            // Report any unknown parameter types.\n            node.parameters.forEach((param, index) => {\n                // Allow unknown param types if the param is named '_'.\n                if (param.name && param.name.value !== '_') {\n                    const paramType = functionTypeResult.functionType.details.parameters[index].type;\n                    if (\n                        isUnknown(paramType) ||\n                        (isTypeVar(paramType) && paramType.details.isSynthesized && !paramType.details.boundType)\n                    ) {\n                        this._evaluator.addDiagnostic(\n                            this._fileInfo.diagnosticRuleSet.reportUnknownParameterType,\n                            DiagnosticRule.reportUnknownParameterType,\n                            Localizer.Diagnostic.paramTypeUnknown().format({ paramName: param.name.value }),\n                            param.name\n                        );\n                    } else if (isPartlyUnknown(paramType)) {\n                        const diagAddendum = new DiagnosticAddendum();\n                        diagAddendum.addMessage(\n                            Localizer.DiagnosticAddendum.paramType().format({\n                                paramType: this._evaluator.printType(paramType, /* expandTypeAlias */ true),\n                            })\n                        );\n                        this._evaluator.addDiagnostic(\n                            this._fileInfo.diagnosticRuleSet.reportUnknownParameterType,\n                            DiagnosticRule.reportUnknownParameterType,\n                            Localizer.Diagnostic.paramTypePartiallyUnknown().format({ paramName: param.name.value }) +\n                                diagAddendum.getString(),\n                            param.name\n                        );\n                    }\n                }\n\n                // If it's a stub file, report an issue of the default value expression is not \"...\".\n                if (param.defaultValue && this._fileInfo.isStubFile) {\n                    const defaultValueType = this._evaluator.getType(param.defaultValue);\n                    if (!defaultValueType || !isEllipsisType(defaultValueType)) {\n                        this._evaluator.addDiagnostic(\n                            this._fileInfo.diagnosticRuleSet.reportInvalidStubStatement,\n                            DiagnosticRule.reportInvalidStubStatement,\n                            Localizer.Diagnostic.defaultValueNotEllipsis(),\n                            param.defaultValue\n                        );\n                    }\n                }\n            });\n\n            // If this is a stub, ensure that the return type is specified.\n            if (this._fileInfo.isStubFile) {\n                const returnAnnotation =\n                    node.returnTypeAnnotation || node.functionAnnotationComment?.returnTypeAnnotation;\n                if (!returnAnnotation) {\n                    this._evaluator.addDiagnostic(\n                        this._fileInfo.diagnosticRuleSet.reportUnknownParameterType,\n                        DiagnosticRule.reportUnknownParameterType,\n                        Localizer.Diagnostic.returnTypeUnknown(),\n                        node.name\n                    );\n                }\n            }\n\n            if (containingClassNode) {\n                this._validateMethod(node, functionTypeResult.functionType, containingClassNode);\n            }\n        }\n\n        node.parameters.forEach((param) => {\n            if (param.defaultValue) {\n                this.walk(param.defaultValue);\n            }\n\n            if (param.typeAnnotation) {\n                this.walk(param.typeAnnotation);\n            }\n\n            if (param.typeAnnotationComment) {\n                this.walk(param.typeAnnotationComment);\n            }\n        });\n\n        if (node.returnTypeAnnotation) {\n            this.walk(node.returnTypeAnnotation);\n        }\n\n        if (node.functionAnnotationComment) {\n            this.walk(node.functionAnnotationComment);\n        }\n\n        this.walkMultiple(node.decorators);\n\n        node.parameters.forEach((param) => {\n            if (param.name) {\n                this.walk(param.name);\n            }\n        });\n\n        this.walk(node.suite);\n\n        if (functionTypeResult) {\n            // Validate that the function returns the declared type.\n            this._validateFunctionReturn(node, functionTypeResult.functionType);\n        }\n\n        // If we're at the module level within a stub file, report a diagnostic\n        // if there is a '__getattr__' function defined when in strict mode.\n        // This signifies an incomplete stub file that obscures type errors.\n        if (this._fileInfo.isStubFile && node.name.value === '__getattr__') {\n            const scope = getScopeForNode(node);\n            if (scope?.type === ScopeType.Module) {\n                this._evaluator.addDiagnostic(\n                    this._fileInfo.diagnosticRuleSet.reportUnknownMemberType,\n                    DiagnosticRule.reportUnknownMemberType,\n                    Localizer.Diagnostic.stubUsesGetAttr(),\n                    node.name\n                );\n            }\n        }\n\n        this._scopedNodes.push(node);\n\n        if (functionTypeResult && functionTypeResult.decoratedType.category === TypeCategory.OverloadedFunction) {\n            const overloads = functionTypeResult.decoratedType.overloads;\n            if (overloads.length > 1) {\n                this._validateOverloadConsistency(\n                    node,\n                    overloads[overloads.length - 1],\n                    overloads.slice(0, overloads.length - 1)\n                );\n            }\n        }\n\n        return false;\n    }\n\n    visitLambda(node: LambdaNode): boolean {\n        this._evaluator.getType(node);\n\n        // Walk the children.\n        this.walkMultiple([...node.parameters, node.expression]);\n\n        node.parameters.forEach((param) => {\n            if (param.name) {\n                const paramType = this._evaluator.getType(param.name);\n                if (paramType) {\n                    if (isUnknown(paramType)) {\n                        this._evaluator.addDiagnostic(\n                            this._fileInfo.diagnosticRuleSet.reportUnknownLambdaType,\n                            DiagnosticRule.reportUnknownLambdaType,\n                            Localizer.Diagnostic.paramTypeUnknown().format({ paramName: param.name.value }),\n                            param.name\n                        );\n                    } else if (isPartlyUnknown(paramType)) {\n                        this._evaluator.addDiagnostic(\n                            this._fileInfo.diagnosticRuleSet.reportUnknownLambdaType,\n                            DiagnosticRule.reportUnknownLambdaType,\n                            Localizer.Diagnostic.paramTypePartiallyUnknown().format({ paramName: param.name.value }),\n                            param.name\n                        );\n                    }\n                }\n            }\n        });\n\n        const returnType = this._evaluator.getType(node.expression);\n        if (returnType) {\n            if (isUnknown(returnType)) {\n                this._evaluator.addDiagnostic(\n                    this._fileInfo.diagnosticRuleSet.reportUnknownLambdaType,\n                    DiagnosticRule.reportUnknownLambdaType,\n                    Localizer.Diagnostic.lambdaReturnTypeUnknown(),\n                    node.expression\n                );\n            } else if (isPartlyUnknown(returnType)) {\n                this._evaluator.addDiagnostic(\n                    this._fileInfo.diagnosticRuleSet.reportUnknownLambdaType,\n                    DiagnosticRule.reportUnknownLambdaType,\n                    Localizer.Diagnostic.lambdaReturnTypePartiallyUnknown().format({\n                        returnType: this._evaluator.printType(returnType, /* expandTypeAlias */ false),\n                    }),\n                    node.expression\n                );\n            }\n        }\n\n        this._scopedNodes.push(node);\n\n        return false;\n    }\n\n    visitCall(node: CallNode): boolean {\n        this._validateIsInstanceCall(node);\n\n        if (ParseTreeUtils.isWithinDefaultParamInitializer(node) && !this._fileInfo.isStubFile) {\n            this._evaluator.addDiagnostic(\n                this._fileInfo.diagnosticRuleSet.reportCallInDefaultInitializer,\n                DiagnosticRule.reportCallInDefaultInitializer,\n                Localizer.Diagnostic.defaultValueContainsCall(),\n                node\n            );\n        }\n\n        return true;\n    }\n\n    visitFor(node: ForNode): boolean {\n        this._evaluator.evaluateTypesForStatement(node);\n        return true;\n    }\n\n    visitListComprehension(node: ListComprehensionNode): boolean {\n        this._scopedNodes.push(node);\n        return true;\n    }\n\n    visitIf(node: IfNode): boolean {\n        this._evaluator.getType(node.testExpression);\n        return true;\n    }\n\n    visitWhile(node: WhileNode): boolean {\n        this._evaluator.getType(node.testExpression);\n        return true;\n    }\n\n    visitWith(node: WithNode): boolean {\n        node.withItems.forEach((item) => {\n            this._evaluator.evaluateTypesForStatement(item);\n        });\n\n        return true;\n    }\n\n    visitReturn(node: ReturnNode): boolean {\n        let returnType: Type;\n\n        const enclosingFunctionNode = ParseTreeUtils.getEnclosingFunction(node);\n        const declaredReturnType = enclosingFunctionNode\n            ? this._evaluator.getFunctionDeclaredReturnType(enclosingFunctionNode)\n            : undefined;\n\n        if (node.returnExpression) {\n            returnType = this._evaluator.getType(node.returnExpression) || UnknownType.create();\n        } else {\n            // There is no return expression, so \"None\" is assumed.\n            returnType = NoneType.createInstance();\n        }\n\n        if (this._evaluator.isNodeReachable(node) && enclosingFunctionNode) {\n            if (declaredReturnType) {\n                if (isNoReturnType(declaredReturnType)) {\n                    this._evaluator.addDiagnostic(\n                        this._fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                        DiagnosticRule.reportGeneralTypeIssues,\n                        Localizer.Diagnostic.noReturnContainsReturn(),\n                        node\n                    );\n                } else {\n                    const diagAddendum = new DiagnosticAddendum();\n\n                    // Specialize the return type in case it contains references to type variables.\n                    // These will be replaced with the corresponding constraint or bound types.\n                    const specializedDeclaredType = specializeType(declaredReturnType, undefined);\n                    if (!this._evaluator.canAssignType(specializedDeclaredType, returnType, diagAddendum)) {\n                        this._evaluator.addDiagnostic(\n                            this._fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                            DiagnosticRule.reportGeneralTypeIssues,\n                            Localizer.Diagnostic.returnTypeMismatch().format({\n                                exprType: this._evaluator.printType(returnType, /* expandTypeAlias */ false),\n                                returnType: this._evaluator.printType(\n                                    specializedDeclaredType,\n                                    /* expandTypeAlias */ false\n                                ),\n                            }) + diagAddendum.getString(),\n                            node.returnExpression ? node.returnExpression : node\n                        );\n                    }\n                }\n            }\n\n            if (isUnknown(returnType)) {\n                this._evaluator.addDiagnostic(\n                    this._fileInfo.diagnosticRuleSet.reportUnknownVariableType,\n                    DiagnosticRule.reportUnknownVariableType,\n                    Localizer.Diagnostic.returnTypeUnknown(),\n                    node.returnExpression!\n                );\n            } else if (isPartlyUnknown(returnType)) {\n                this._evaluator.addDiagnostic(\n                    this._fileInfo.diagnosticRuleSet.reportUnknownVariableType,\n                    DiagnosticRule.reportUnknownVariableType,\n                    Localizer.Diagnostic.returnTypePartiallyUnknown().format({\n                        returnType: this._evaluator.printType(returnType, /* expandTypeAlias */ true),\n                    }),\n                    node.returnExpression!\n                );\n            }\n        }\n\n        return true;\n    }\n\n    visitYield(node: YieldNode) {\n        const yieldType = node.expression ? this._evaluator.getType(node.expression) : NoneType.createInstance();\n\n        // Wrap the yield type in an Iterator.\n        let adjYieldType = yieldType;\n        const iteratorType = this._evaluator.getBuiltInType(node, 'Iterator');\n        if (yieldType && isClass(iteratorType)) {\n            adjYieldType = ObjectType.create(\n                ClassType.cloneForSpecialization(iteratorType, [yieldType], /* isTypeArgumentExplicit */ false)\n            );\n        } else {\n            adjYieldType = UnknownType.create();\n        }\n\n        this._validateYieldType(node, adjYieldType);\n\n        return true;\n    }\n\n    visitYieldFrom(node: YieldFromNode) {\n        const yieldType = this._evaluator.getType(node.expression);\n        if (yieldType) {\n            this._validateYieldType(node, yieldType);\n        }\n\n        return true;\n    }\n\n    visitRaise(node: RaiseNode): boolean {\n        this._evaluator.verifyRaiseExceptionType(node);\n\n        if (node.valueExpression) {\n            const baseExceptionType = this._evaluator.getBuiltInType(node, 'BaseException') as ClassType;\n            const exceptionType = this._evaluator.getType(node.valueExpression);\n\n            // Validate that the argument of \"raise\" is an exception object or None.\n            if (exceptionType && baseExceptionType && isClass(baseExceptionType)) {\n                const diagAddendum = new DiagnosticAddendum();\n\n                doForSubtypes(exceptionType, (subtype) => {\n                    if (!isAnyOrUnknown(subtype) && !isNone(subtype)) {\n                        if (isObject(subtype)) {\n                            if (\n                                !derivesFromClassRecursive(\n                                    subtype.classType,\n                                    baseExceptionType,\n                                    /* ignoreUnknown */ false\n                                )\n                            ) {\n                                diagAddendum.addMessage(\n                                    Localizer.Diagnostic.exceptionTypeIncorrect().format({\n                                        type: this._evaluator.printType(subtype, /* expandTypeAlias */ false),\n                                    })\n                                );\n                            }\n                        } else {\n                            diagAddendum.addMessage(\n                                Localizer.Diagnostic.exceptionTypeIncorrect().format({\n                                    type: this._evaluator.printType(subtype, /* expandTypeAlias */ false),\n                                })\n                            );\n                        }\n                    }\n\n                    return subtype;\n                });\n\n                if (!diagAddendum.isEmpty()) {\n                    this._evaluator.addError(\n                        Localizer.Diagnostic.expectedExceptionObj() + diagAddendum.getString(),\n                        node.valueExpression\n                    );\n                }\n            }\n        }\n\n        return true;\n    }\n\n    visitExcept(node: ExceptNode): boolean {\n        if (node.typeExpression) {\n            this._evaluator.evaluateTypesForStatement(node);\n\n            const exceptionType = this._evaluator.getType(node.typeExpression);\n            if (exceptionType) {\n                this._validateExceptionType(exceptionType, node.typeExpression);\n            }\n        }\n\n        return true;\n    }\n\n    visitAssert(node: AssertNode) {\n        if (node.exceptionExpression) {\n            this._evaluator.getType(node.exceptionExpression);\n        }\n\n        // Specifically look for a common programming error where the two arguments\n        // to an assert are enclosed in parens and interpreted as a two-element tuple.\n        //   assert (x > 3, \"bad value x\")\n        const type = this._evaluator.getType(node.testExpression);\n        if (type && isObject(type)) {\n            if (isTupleClass(type.classType) && type.classType.typeArguments) {\n                if (type.classType.typeArguments.length > 0) {\n                    const lastTypeArg = type.classType.typeArguments[type.classType.typeArguments.length - 1];\n                    if (!isEllipsisType(lastTypeArg)) {\n                        this._evaluator.addDiagnosticForTextRange(\n                            this._fileInfo,\n                            this._fileInfo.diagnosticRuleSet.reportAssertAlwaysTrue,\n                            DiagnosticRule.reportAssertAlwaysTrue,\n                            Localizer.Diagnostic.assertAlwaysTrue(),\n                            node.testExpression\n                        );\n                    }\n                }\n            }\n        }\n\n        return true;\n    }\n\n    visitAssignment(node: AssignmentNode): boolean {\n        this._evaluator.evaluateTypesForStatement(node);\n        if (node.typeAnnotationComment) {\n            this._evaluator.getType(node.typeAnnotationComment);\n        }\n\n        return true;\n    }\n\n    visitAssignmentExpression(node: AssignmentExpressionNode): boolean {\n        this._evaluator.getType(node);\n        return true;\n    }\n\n    visitAugmentedAssignment(node: AugmentedAssignmentNode): boolean {\n        this._evaluator.evaluateTypesForStatement(node);\n        return true;\n    }\n\n    visitIndex(node: IndexNode): boolean {\n        this._evaluator.getType(node);\n        return true;\n    }\n\n    visitBinaryOperation(node: BinaryOperationNode): boolean {\n        this._evaluator.getType(node);\n        return true;\n    }\n\n    visitSlice(node: SliceNode): boolean {\n        this._evaluator.getType(node);\n        return true;\n    }\n\n    visitUnpack(node: UnpackNode): boolean {\n        this._evaluator.getType(node);\n        return true;\n    }\n\n    visitTuple(node: TupleNode): boolean {\n        this._evaluator.getType(node);\n        return true;\n    }\n\n    visitUnaryOperation(node: UnaryOperationNode): boolean {\n        this._evaluator.getType(node);\n        return true;\n    }\n\n    visitTernary(node: TernaryNode): boolean {\n        this._evaluator.getType(node);\n        return true;\n    }\n\n    visitStringList(node: StringListNode): boolean {\n        if (node.typeAnnotation) {\n            this._evaluator.getType(node);\n        }\n\n        if (node.strings.length > 1) {\n            this._evaluator.addDiagnosticForTextRange(\n                this._fileInfo,\n                this._fileInfo.diagnosticRuleSet.reportImplicitStringConcatenation,\n                DiagnosticRule.reportImplicitStringConcatenation,\n                Localizer.Diagnostic.implicitStringConcat(),\n                node\n            );\n        }\n\n        return true;\n    }\n\n    visitFormatString(node: FormatStringNode): boolean {\n        node.expressions.forEach((formatExpr) => {\n            this._evaluator.getType(formatExpr);\n        });\n\n        return true;\n    }\n\n    visitName(node: NameNode) {\n        // Determine if we should log information about private usage.\n        this._conditionallyReportPrivateUsage(node);\n        return true;\n    }\n\n    visitDel(node: DelNode) {\n        node.expressions.forEach((expr) => {\n            this._evaluator.verifyDeleteExpression(expr);\n        });\n\n        return true;\n    }\n\n    visitMemberAccess(node: MemberAccessNode) {\n        this._evaluator.getType(node);\n        this._conditionallyReportPrivateUsage(node.memberName);\n\n        // Walk the leftExpression but not the memberName.\n        this.walk(node.leftExpression);\n\n        return false;\n    }\n\n    visitImportAs(node: ImportAsNode): boolean {\n        this._evaluator.evaluateTypesForStatement(node);\n        return false;\n    }\n\n    visitImportFrom(node: ImportFromNode): boolean {\n        if (!node.isWildcardImport) {\n            node.imports.forEach((importAs) => {\n                this._evaluator.evaluateTypesForStatement(importAs);\n            });\n        } else {\n            const importInfo = AnalyzerNodeInfo.getImportInfo(node.module);\n            if (importInfo && importInfo.isImportFound && importInfo.importType !== ImportType.Local) {\n                this._evaluator.addDiagnosticForTextRange(\n                    this._fileInfo,\n                    this._fileInfo.diagnosticRuleSet.reportWildcardImportFromLibrary,\n                    DiagnosticRule.reportWildcardImportFromLibrary,\n                    Localizer.Diagnostic.wildcardLibraryImport(),\n                    node.wildcardToken || node\n                );\n            }\n        }\n\n        return false;\n    }\n\n    visitTypeAnnotation(node: TypeAnnotationNode): boolean {\n        this._evaluator.getType(node.typeAnnotation);\n        return true;\n    }\n\n    visitError(node: ErrorNode) {\n        // Get the type of the child so it's available to\n        // the completion provider.\n        if (node.child) {\n            this._evaluator.getType(node.child);\n        }\n\n        // Don't explore further.\n        return false;\n    }\n\n    private _validateOverloadConsistency(\n        node: FunctionNode,\n        functionType: FunctionType,\n        prevOverloads: FunctionType[]\n    ) {\n        for (let i = 0; i < prevOverloads.length; i++) {\n            const prevOverload = prevOverloads[i];\n            if (this._isOverlappingOverload(functionType, prevOverload)) {\n                this._evaluator.addDiagnostic(\n                    this._fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                    DiagnosticRule.reportGeneralTypeIssues,\n                    Localizer.Diagnostic.overlappingOverload().format({\n                        name: node.name.value,\n                        obscured: prevOverloads.length + 1,\n                        obscuredBy: i + 1,\n                    }),\n                    node.name\n                );\n                break;\n            }\n        }\n\n        for (let i = 0; i < prevOverloads.length; i++) {\n            const prevOverload = prevOverloads[i];\n            if (this._isOverlappingOverload(prevOverload, functionType)) {\n                const prevReturnType = FunctionType.getSpecializedReturnType(prevOverload);\n                const returnType = FunctionType.getSpecializedReturnType(functionType);\n\n                if (\n                    prevReturnType &&\n                    returnType &&\n                    !this._evaluator.canAssignType(returnType, prevReturnType, new DiagnosticAddendum())\n                ) {\n                    const altNode = this._findNodeForOverload(node, prevOverload);\n                    this._evaluator.addDiagnostic(\n                        this._fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                        DiagnosticRule.reportGeneralTypeIssues,\n                        Localizer.Diagnostic.overloadReturnTypeMismatch().format({\n                            name: node.name.value,\n                            newIndex: prevOverloads.length + 1,\n                            prevIndex: i + 1,\n                        }),\n                        (altNode || node).name\n                    );\n                    break;\n                }\n            }\n        }\n    }\n\n    // Mypy reports overlapping overload errors on the line that contains the\n    // earlier overload. Typeshed stubs contain type: ignore comments on these\n    // lines, so it is important for us to report them in the same manner.\n    private _findNodeForOverload(functionNode: FunctionNode, overloadType: FunctionType): FunctionNode | undefined {\n        const decls = this._evaluator.getDeclarationsForNameNode(functionNode.name);\n        if (!decls) {\n            return undefined;\n        }\n\n        for (const decl of decls) {\n            if (decl.type === DeclarationType.Function) {\n                const functionType = this._evaluator.getTypeOfFunction(decl.node);\n                if (functionType?.functionType === overloadType) {\n                    return decl.node;\n                }\n            }\n        }\n\n        return undefined;\n    }\n\n    private _isOverlappingOverload(functionType: FunctionType, prevOverload: FunctionType) {\n        return this._evaluator.canAssignType(\n            functionType,\n            prevOverload,\n            new DiagnosticAddendum(),\n            /* typeVarMap */ undefined,\n            CanAssignFlags.MatchTypeVarsExactly |\n                CanAssignFlags.SkipFunctionReturnTypeCheck |\n                CanAssignFlags.DisallowAssignFromAny\n        );\n    }\n\n    private _walkStatementsAndReportUnreachable(statements: StatementNode[]) {\n        let reportedUnreachable = false;\n\n        for (const statement of statements) {\n            // No need to report unreachable more than once since the first time\n            // covers all remaining statements in the statement list.\n            if (!reportedUnreachable) {\n                if (!this._evaluator.isNodeReachable(statement)) {\n                    // Create a text range that covers the next statement through\n                    // the end of the statement list.\n                    const start = statement.start;\n                    const lastStatement = statements[statements.length - 1];\n                    const end = TextRange.getEnd(lastStatement);\n                    this._evaluator.addUnusedCode(statement, { start, length: end - start });\n\n                    reportedUnreachable = true;\n                }\n            }\n\n            if (!reportedUnreachable && this._fileInfo.isStubFile) {\n                this._validateStubStatement(statement);\n            }\n\n            this.walk(statement);\n        }\n    }\n\n    private _validateStubStatement(statement: StatementNode) {\n        switch (statement.nodeType) {\n            case ParseNodeType.If:\n            case ParseNodeType.Function:\n            case ParseNodeType.Class:\n            case ParseNodeType.Error: {\n                // These are allowed in a stub file.\n                break;\n            }\n\n            case ParseNodeType.While:\n            case ParseNodeType.For:\n            case ParseNodeType.Try:\n            case ParseNodeType.With: {\n                // These are not allowed.\n                this._evaluator.addDiagnostic(\n                    this._fileInfo.diagnosticRuleSet.reportInvalidStubStatement,\n                    DiagnosticRule.reportInvalidStubStatement,\n                    Localizer.Diagnostic.invalidStubStatement(),\n                    statement\n                );\n                break;\n            }\n\n            case ParseNodeType.StatementList: {\n                for (const substatement of statement.statements) {\n                    switch (substatement.nodeType) {\n                        case ParseNodeType.Assert:\n                        case ParseNodeType.AssignmentExpression:\n                        case ParseNodeType.AugmentedAssignment:\n                        case ParseNodeType.Await:\n                        case ParseNodeType.BinaryOperation:\n                        case ParseNodeType.Call:\n                        case ParseNodeType.Constant:\n                        case ParseNodeType.Del:\n                        case ParseNodeType.Dictionary:\n                        case ParseNodeType.Index:\n                        case ParseNodeType.For:\n                        case ParseNodeType.FormatString:\n                        case ParseNodeType.Global:\n                        case ParseNodeType.Lambda:\n                        case ParseNodeType.List:\n                        case ParseNodeType.MemberAccess:\n                        case ParseNodeType.Name:\n                        case ParseNodeType.Nonlocal:\n                        case ParseNodeType.Number:\n                        case ParseNodeType.Raise:\n                        case ParseNodeType.Return:\n                        case ParseNodeType.Set:\n                        case ParseNodeType.Slice:\n                        case ParseNodeType.Ternary:\n                        case ParseNodeType.Tuple:\n                        case ParseNodeType.Try:\n                        case ParseNodeType.UnaryOperation:\n                        case ParseNodeType.Unpack:\n                        case ParseNodeType.While:\n                        case ParseNodeType.With:\n                        case ParseNodeType.WithItem:\n                        case ParseNodeType.Yield:\n                        case ParseNodeType.YieldFrom: {\n                            this._evaluator.addDiagnostic(\n                                this._fileInfo.diagnosticRuleSet.reportInvalidStubStatement,\n                                DiagnosticRule.reportInvalidStubStatement,\n                                Localizer.Diagnostic.invalidStubStatement(),\n                                substatement\n                            );\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    private _validateExceptionType(exceptionType: Type, errorNode: ParseNode) {\n        const baseExceptionType = this._evaluator.getBuiltInType(errorNode, 'BaseException');\n        const derivesFromBaseException = (classType: ClassType) => {\n            if (!baseExceptionType || !isClass(baseExceptionType)) {\n                return true;\n            }\n\n            return derivesFromClassRecursive(classType, baseExceptionType, /* ignoreUnknown */ false);\n        };\n\n        const diagAddendum = new DiagnosticAddendum();\n        let resultingExceptionType: Type | undefined;\n\n        if (isAnyOrUnknown(exceptionType)) {\n            resultingExceptionType = exceptionType;\n        } else {\n            // Handle the case where we have a Type[X] object.\n            if (isObject(exceptionType)) {\n                exceptionType = transformTypeObjectToClass(exceptionType);\n            }\n\n            if (isClass(exceptionType)) {\n                if (!derivesFromBaseException(exceptionType)) {\n                    diagAddendum.addMessage(\n                        Localizer.Diagnostic.exceptionTypeIncorrect().format({\n                            type: this._evaluator.printType(exceptionType, /* expandTypeAlias */ false),\n                        })\n                    );\n                }\n                resultingExceptionType = ObjectType.create(exceptionType);\n            } else if (isObject(exceptionType)) {\n                const iterableType = this._evaluator.getTypeFromIterable(\n                    exceptionType,\n                    /* isAsync */ false,\n                    errorNode,\n                    false\n                );\n\n                resultingExceptionType = doForSubtypes(iterableType, (subtype) => {\n                    if (isAnyOrUnknown(subtype)) {\n                        return subtype;\n                    }\n\n                    const transformedSubtype = transformTypeObjectToClass(subtype);\n                    if (isClass(transformedSubtype)) {\n                        if (!derivesFromBaseException(transformedSubtype)) {\n                            diagAddendum.addMessage(\n                                Localizer.Diagnostic.exceptionTypeIncorrect().format({\n                                    type: this._evaluator.printType(exceptionType, /* expandTypeAlias */ false),\n                                })\n                            );\n                        }\n\n                        return ObjectType.create(transformedSubtype);\n                    }\n\n                    diagAddendum.addMessage(\n                        Localizer.Diagnostic.exceptionTypeIncorrect().format({\n                            type: this._evaluator.printType(exceptionType, /* expandTypeAlias */ false),\n                        })\n                    );\n                    return UnknownType.create();\n                });\n            }\n        }\n\n        if (!diagAddendum.isEmpty()) {\n            this._evaluator.addError(\n                Localizer.Diagnostic.exceptionTypeNotClass().format({\n                    type: this._evaluator.printType(exceptionType, /* expandTypeAlias */ false),\n                }),\n                errorNode\n            );\n        }\n\n        return resultingExceptionType || UnknownType.create();\n    }\n\n    private _validateSymbolTables() {\n        for (const scopedNode of this._scopedNodes) {\n            const scope = AnalyzerNodeInfo.getScope(scopedNode);\n\n            if (scope) {\n                scope.symbolTable.forEach((symbol, name) => {\n                    this._conditionallyReportUnusedSymbol(name, symbol, scope.type);\n\n                    this._reportIncompatibleDeclarations(name, symbol);\n\n                    this._reportMultipleFinalDeclarations(name, symbol);\n\n                    this._reportMultipleTypeAliasDeclarations(name, symbol);\n\n                    this._reportInvalidOverload(name, symbol);\n                });\n            }\n        }\n    }\n\n    private _reportInvalidOverload(name: string, symbol: Symbol) {\n        const typedDecls = symbol.getTypedDeclarations();\n        if (typedDecls.length === 1) {\n            const primaryDecl = typedDecls[0];\n            if (primaryDecl.type === DeclarationType.Function) {\n                const type = this._evaluator.getEffectiveTypeOfSymbol(symbol);\n\n                if (type.category === TypeCategory.Function && FunctionType.isOverloaded(type)) {\n                    // There should never be a single overload.\n                    this._evaluator.addDiagnostic(\n                        this._fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                        DiagnosticRule.reportGeneralTypeIssues,\n                        Localizer.Diagnostic.singleOverload().format({ name }),\n                        primaryDecl.node.name\n                    );\n                }\n            }\n        }\n    }\n\n    private _reportMultipleFinalDeclarations(name: string, symbol: Symbol) {\n        if (!isFinalVariable(symbol)) {\n            return;\n        }\n\n        const decls = symbol.getDeclarations();\n        let sawFinal = false;\n        let sawAssignment = false;\n\n        decls.forEach((decl) => {\n            if (isFinalVariableDeclaration(decl)) {\n                if (sawFinal) {\n                    this._evaluator.addError(Localizer.Diagnostic.finalRedeclaration().format({ name }), decl.node);\n                }\n                sawFinal = true;\n            }\n\n            if (decl.type === DeclarationType.Variable && decl.inferredTypeSource) {\n                if (sawAssignment) {\n                    this._evaluator.addError(Localizer.Diagnostic.finalReassigned().format({ name }), decl.node);\n                }\n                sawAssignment = true;\n            }\n        });\n\n        // If it's not a stub file, an assignment must be provided.\n        if (!sawAssignment && !this._fileInfo.isStubFile) {\n            const firstDecl = decls.find((decl) => decl.type === DeclarationType.Variable && decl.isFinal);\n            if (firstDecl) {\n                this._evaluator.addError(Localizer.Diagnostic.finalUnassigned().format({ name }), firstDecl.node);\n            }\n        }\n    }\n\n    private _reportMultipleTypeAliasDeclarations(name: string, symbol: Symbol) {\n        const decls = symbol.getDeclarations();\n        const typeAliasDecl = decls.find((decl) => isExplicitTypeAliasDeclaration(decl));\n\n        // If this is a type alias, there should be only one declaration.\n        if (typeAliasDecl && decls.length > 1) {\n            decls.forEach((decl) => {\n                if (decl !== typeAliasDecl) {\n                    this._evaluator.addError(Localizer.Diagnostic.typeAliasRedeclared().format({ name }), decl.node);\n                }\n            });\n        }\n    }\n\n    private _reportIncompatibleDeclarations(name: string, symbol: Symbol) {\n        // If there's one or more declaration with a declared type,\n        // all other declarations should match. The only exception is\n        // for functions that have an overload.\n        const primaryDecl = getLastTypedDeclaredForSymbol(symbol);\n\n        // If there's no declaration with a declared type, we're done.\n        if (!primaryDecl) {\n            return;\n        }\n\n        let otherDecls = symbol.getDeclarations().filter((decl) => decl !== primaryDecl);\n\n        // If it's a function, we can skip any other declarations\n        // that are overloads.\n        if (primaryDecl.type === DeclarationType.Function) {\n            otherDecls = otherDecls.filter((decl) => decl.type !== DeclarationType.Function);\n        }\n\n        // If there are no other declarations to consider, we're done.\n        if (otherDecls.length === 0) {\n            return;\n        }\n\n        let primaryDeclInfo: string;\n        if (primaryDecl.type === DeclarationType.Function) {\n            if (primaryDecl.isMethod) {\n                primaryDeclInfo = Localizer.DiagnosticAddendum.seeMethodDeclaration();\n            } else {\n                primaryDeclInfo = Localizer.DiagnosticAddendum.seeFunctionDeclaration();\n            }\n        } else if (primaryDecl.type === DeclarationType.Class) {\n            primaryDeclInfo = Localizer.DiagnosticAddendum.seeClassDeclaration();\n        } else if (primaryDecl.type === DeclarationType.Parameter) {\n            primaryDeclInfo = Localizer.DiagnosticAddendum.seeParameterDeclaration();\n        } else if (primaryDecl.type === DeclarationType.Variable) {\n            primaryDeclInfo = Localizer.DiagnosticAddendum.seeVariableDeclaration();\n        } else {\n            primaryDeclInfo = Localizer.DiagnosticAddendum.seeDeclaration();\n        }\n\n        const addPrimaryDeclInfo = (diag?: Diagnostic) => {\n            if (diag) {\n                let primaryDeclNode: ParseNode | undefined;\n                if (primaryDecl.type === DeclarationType.Function || primaryDecl.type === DeclarationType.Class) {\n                    primaryDeclNode = primaryDecl.node.name;\n                } else if (primaryDecl.type === DeclarationType.Variable) {\n                    if (primaryDecl.node.nodeType === ParseNodeType.Name) {\n                        primaryDeclNode = primaryDecl.node;\n                    }\n                } else if (primaryDecl.type === DeclarationType.Parameter) {\n                    if (primaryDecl.node.name) {\n                        primaryDeclNode = primaryDecl.node.name;\n                    }\n                }\n\n                if (primaryDeclNode) {\n                    diag.addRelatedInfo(primaryDeclInfo, primaryDecl.path, primaryDecl.range);\n                }\n            }\n        };\n\n        for (const otherDecl of otherDecls) {\n            if (otherDecl.type === DeclarationType.Class) {\n                const diag = this._evaluator.addDiagnostic(\n                    this._fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                    DiagnosticRule.reportGeneralTypeIssues,\n                    Localizer.Diagnostic.obscuredClassDeclaration().format({ name }),\n                    otherDecl.node.name\n                );\n                addPrimaryDeclInfo(diag);\n            } else if (otherDecl.type === DeclarationType.Function) {\n                const diag = this._evaluator.addDiagnostic(\n                    this._fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                    DiagnosticRule.reportGeneralTypeIssues,\n                    Localizer.Diagnostic.obscuredFunctionDeclaration().format({ name }),\n                    otherDecl.node.name\n                );\n                addPrimaryDeclInfo(diag);\n            } else if (otherDecl.type === DeclarationType.Parameter) {\n                if (otherDecl.node.name) {\n                    const diag = this._evaluator.addDiagnostic(\n                        this._fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                        DiagnosticRule.reportGeneralTypeIssues,\n                        Localizer.Diagnostic.obscuredParameterDeclaration().format({ name }),\n                        otherDecl.node.name\n                    );\n                    addPrimaryDeclInfo(diag);\n                }\n            } else if (otherDecl.type === DeclarationType.Variable) {\n                const primaryType = this._evaluator.getTypeForDeclaration(primaryDecl);\n\n                if (otherDecl.typeAnnotationNode) {\n                    if (otherDecl.node.nodeType === ParseNodeType.Name) {\n                        let duplicateIsOk = false;\n\n                        // If both declarations are variables, it's OK if they\n                        // both have the same declared type.\n                        if (primaryDecl.type === DeclarationType.Variable) {\n                            const otherType = this._evaluator.getTypeForDeclaration(otherDecl);\n                            if (primaryType && otherType && isTypeSame(primaryType, otherType)) {\n                                duplicateIsOk = true;\n                            }\n                        }\n\n                        if (!duplicateIsOk) {\n                            const diag = this._evaluator.addDiagnostic(\n                                this._fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                                DiagnosticRule.reportGeneralTypeIssues,\n                                Localizer.Diagnostic.obscuredVariableDeclaration().format({ name }),\n                                otherDecl.node\n                            );\n                            addPrimaryDeclInfo(diag);\n                        }\n                    }\n                } else if (primaryType && !isProperty(primaryType)) {\n                    if (primaryDecl.type === DeclarationType.Function || primaryDecl.type === DeclarationType.Class) {\n                        const diag = this._evaluator.addDiagnostic(\n                            this._fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                            DiagnosticRule.reportGeneralTypeIssues,\n                            Localizer.Diagnostic.obscuredVariableDeclaration().format({ name }),\n                            otherDecl.node\n                        );\n                        addPrimaryDeclInfo(diag);\n                    }\n                }\n            }\n        }\n    }\n\n    private _conditionallyReportUnusedSymbol(name: string, symbol: Symbol, scopeType: ScopeType) {\n        const accessedSymbolMap = this._fileInfo.accessedSymbolMap;\n        if (symbol.isIgnoredForProtocolMatch() || accessedSymbolMap.has(symbol.id)) {\n            return;\n        }\n\n        // A name of \"_\" means \"I know this symbol isn't used\", so\n        // don't report it as unused.\n        if (name === '_') {\n            return;\n        }\n\n        if (SymbolNameUtils.isDunderName(name)) {\n            return;\n        }\n\n        const decls = symbol.getDeclarations();\n        decls.forEach((decl) => {\n            this._conditionallyReportUnusedDeclaration(decl, this._isSymbolPrivate(name, scopeType));\n        });\n    }\n\n    private _conditionallyReportUnusedDeclaration(decl: Declaration, isPrivate: boolean) {\n        let diagnosticLevel: DiagnosticLevel;\n        let nameNode: NameNode | undefined;\n        let message: string | undefined;\n        let rule: DiagnosticRule | undefined;\n\n        switch (decl.type) {\n            case DeclarationType.Alias:\n                diagnosticLevel = this._fileInfo.diagnosticRuleSet.reportUnusedImport;\n                rule = DiagnosticRule.reportUnusedImport;\n                if (decl.node.nodeType === ParseNodeType.ImportAs) {\n                    if (decl.node.alias) {\n                        // Aliases in stub files are assumed to be re-exports.\n                        if (!this._fileInfo.isStubFile) {\n                            nameNode = decl.node.alias;\n                        }\n                    } else {\n                        // Handle multi-part names specially.\n                        const nameParts = decl.node.module.nameParts;\n                        if (nameParts.length > 0) {\n                            const multipartName = nameParts.map((np) => np.value).join('.');\n                            const textRange: TextRange = { start: nameParts[0].start, length: nameParts[0].length };\n                            TextRange.extend(textRange, nameParts[nameParts.length - 1]);\n                            this._fileInfo.diagnosticSink.addUnusedCodeWithTextRange(\n                                Localizer.Diagnostic.unaccessedSymbol().format({ name: multipartName }),\n                                textRange,\n                                { action: Commands.unusedImport }\n                            );\n\n                            this._evaluator.addDiagnosticForTextRange(\n                                this._fileInfo,\n                                this._fileInfo.diagnosticRuleSet.reportUnusedImport,\n                                DiagnosticRule.reportUnusedImport,\n                                Localizer.Diagnostic.unaccessedImport().format({ name: multipartName }),\n                                textRange\n                            );\n                            return;\n                        }\n                    }\n                } else if (decl.node.nodeType === ParseNodeType.ImportFromAs) {\n                    const importFrom = decl.node.parent as ImportFromNode;\n\n                    // If this is a stub file that is using the \"from A import B as C\" or \"from . import C\",\n                    // don't mark \"C\" as unaccessed because it's assumed to be re-exported.\n                    const isReexport = this._fileInfo.isStubFile && decl.node.alias !== undefined;\n\n                    // If this is a __future__ import, it's OK for the import symbol to be unaccessed.\n                    const isFuture =\n                        importFrom.module.nameParts.length === 1 &&\n                        importFrom.module.nameParts[0].value === '__future__';\n\n                    if (!isReexport && !isFuture) {\n                        nameNode = decl.node.alias || decl.node.name;\n                    }\n                }\n\n                if (nameNode) {\n                    message = Localizer.Diagnostic.unaccessedImport().format({ name: nameNode.value });\n                }\n                break;\n\n            case DeclarationType.Variable:\n            case DeclarationType.Parameter:\n                if (!isPrivate) {\n                    return;\n                }\n\n                if (this._fileInfo.isStubFile) {\n                    // Don't mark variables or parameters as unaccessed in\n                    // stub files. It's typical for them to be unaccessed here.\n                    return;\n                }\n\n                diagnosticLevel = this._fileInfo.diagnosticRuleSet.reportUnusedVariable;\n\n                if (decl.node.nodeType === ParseNodeType.Name) {\n                    nameNode = decl.node;\n                } else if (decl.node.nodeType === ParseNodeType.Parameter) {\n                    nameNode = decl.node.name;\n\n                    // Don't emit a diagnostic for unused parameters.\n                    diagnosticLevel = 'none';\n                }\n\n                if (nameNode) {\n                    rule = DiagnosticRule.reportUnusedVariable;\n                    message = Localizer.Diagnostic.unaccessedVariable().format({ name: nameNode.value });\n                }\n                break;\n\n            case DeclarationType.Class:\n                if (!isPrivate) {\n                    return;\n                }\n\n                // If a stub is exporting a private type, we'll assume that the author\n                // knows what he or she is doing.\n                if (this._fileInfo.isStubFile) {\n                    return;\n                }\n\n                diagnosticLevel = this._fileInfo.diagnosticRuleSet.reportUnusedClass;\n                nameNode = decl.node.name;\n                rule = DiagnosticRule.reportUnusedClass;\n                message = Localizer.Diagnostic.unaccessedClass().format({ name: nameNode.value });\n                break;\n\n            case DeclarationType.Function:\n                if (!isPrivate) {\n                    return;\n                }\n\n                // If a stub is exporting a private type, we'll assume that the author\n                // knows what he or she is doing.\n                if (this._fileInfo.isStubFile) {\n                    return;\n                }\n\n                diagnosticLevel = this._fileInfo.diagnosticRuleSet.reportUnusedFunction;\n                nameNode = decl.node.name;\n                rule = DiagnosticRule.reportUnusedFunction;\n                message = Localizer.Diagnostic.unaccessedFunction().format({ name: nameNode.value });\n                break;\n\n            default:\n                return;\n        }\n\n        if (nameNode && rule !== undefined && message) {\n            const action = rule === DiagnosticRule.reportUnusedImport ? { action: Commands.unusedImport } : undefined;\n            this._fileInfo.diagnosticSink.addUnusedCodeWithTextRange(\n                Localizer.Diagnostic.unaccessedSymbol().format({ name: nameNode.value }),\n                nameNode,\n                action\n            );\n            this._evaluator.addDiagnostic(diagnosticLevel, rule, message, nameNode);\n        }\n    }\n\n    // Validates that a call to isinstance or issubclass are necessary. This is a\n    // common source of programming errors. Also validates that arguments passed\n    // to isinstance or issubclass won't generate exceptions.\n    private _validateIsInstanceCall(node: CallNode) {\n        if (\n            node.leftExpression.nodeType !== ParseNodeType.Name ||\n            (node.leftExpression.value !== 'isinstance' && node.leftExpression.value !== 'issubclass') ||\n            node.arguments.length !== 2\n        ) {\n            return;\n        }\n\n        const callName = node.leftExpression.value;\n        const isInstanceCheck = callName === 'isinstance';\n\n        let arg0Type = this._evaluator.getType(node.arguments[0].valueExpression);\n        if (!arg0Type) {\n            return;\n        }\n        arg0Type = doForSubtypes(arg0Type, (subtype) => {\n            return transformTypeObjectToClass(subtype);\n        });\n\n        if (derivesFromAnyOrUnknown(arg0Type)) {\n            return;\n        }\n\n        const arg1Type = this._evaluator.getType(node.arguments[1].valueExpression);\n        if (!arg1Type) {\n            return;\n        }\n\n        // Create a helper function that determines whether the specified\n        // type is valid for the isinstance or issubclass call.\n        const isSupportedTypeForIsInstance = (type: Type) => {\n            let isSupported = true;\n\n            doForSubtypes(type, (subtype) => {\n                subtype = makeTypeVarsConcrete(subtype);\n\n                switch (subtype.category) {\n                    case TypeCategory.Any:\n                    case TypeCategory.Unknown:\n                    case TypeCategory.Unbound:\n                        break;\n\n                    case TypeCategory.Class:\n                        // If it's a class, make sure that it has not been given explicit\n                        // type arguments. This will result in a TypeError exception.\n                        if (subtype.isTypeArgumentExplicit) {\n                            isSupported = false;\n                        }\n                        break;\n\n                    case TypeCategory.Function:\n                        isSupported = TypeBase.isInstantiable(subtype);\n                        break;\n\n                    default:\n                        isSupported = false;\n                        break;\n                }\n                return undefined;\n            });\n\n            return isSupported;\n        };\n\n        let isValidType = true;\n        if (isObject(arg1Type) && isTupleClass(arg1Type.classType) && arg1Type.classType.typeArguments) {\n            isValidType = !arg1Type.classType.typeArguments.some((typeArg) => !isSupportedTypeForIsInstance(typeArg));\n        } else {\n            isValidType = isSupportedTypeForIsInstance(arg1Type);\n        }\n\n        if (!isValidType) {\n            const diag = new DiagnosticAddendum();\n            diag.addMessage(Localizer.DiagnosticAddendum.typeVarNotAllowed());\n\n            this._evaluator.addDiagnostic(\n                this._fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                DiagnosticRule.reportGeneralTypeIssues,\n                isInstanceCheck\n                    ? Localizer.Diagnostic.isInstanceInvalidType().format({\n                          type: this._evaluator.printType(arg1Type, /* expandTypeAlias */ false),\n                      }) + diag.getString()\n                    : Localizer.Diagnostic.isSubclassInvalidType().format({\n                          type: this._evaluator.printType(arg1Type, /* expandTypeAlias */ false),\n                      }) + diag.getString(),\n                node.arguments[1]\n            );\n        }\n\n        // If this call is within an assert statement, we won't check whether\n        // it's unnecessary.\n        let curNode: ParseNode | undefined = node;\n        while (curNode) {\n            if (curNode.nodeType === ParseNodeType.Assert) {\n                return;\n            }\n            curNode = curNode.parent;\n        }\n\n        // Several built-in classes don't follow the normal class hierarchy\n        // rules, so we'll avoid emitting false-positive diagnostics if these\n        // are used.\n        const nonstandardClassTypes = ['FunctionType', 'LambdaType', 'BuiltinFunctionType', 'BuiltinMethodType'];\n\n        const classTypeList: ClassType[] = [];\n        if (isClass(arg1Type)) {\n            classTypeList.push(arg1Type);\n            if (ClassType.isBuiltIn(arg1Type) && nonstandardClassTypes.some((name) => name === arg1Type.details.name)) {\n                return;\n            }\n        } else if (isObject(arg1Type)) {\n            // The isinstance and issubclass call supports a variation where the second\n            // parameter is a tuple of classes.\n            const objClass = arg1Type.classType;\n            if (isTupleClass(objClass) && objClass.typeArguments) {\n                objClass.typeArguments.forEach((typeArg) => {\n                    if (isClass(typeArg)) {\n                        classTypeList.push(typeArg);\n                    } else {\n                        return;\n                    }\n                });\n            }\n            if (ClassType.isBuiltIn(objClass) && nonstandardClassTypes.some((name) => name === objClass.details.name)) {\n                return;\n            }\n        } else {\n            return;\n        }\n\n        // According to PEP 544, protocol classes cannot be used as the right-hand\n        // argument to isinstance or issubclass unless they are annotated as\n        // \"runtime checkable\".\n        if (classTypeList.some((type) => ClassType.isProtocolClass(type) && !ClassType.isRuntimeCheckable(type))) {\n            this._evaluator.addError(\n                Localizer.Diagnostic.protocolUsedInCall().format({ name: callName }),\n                node.arguments[1].valueExpression\n            );\n        }\n\n        const finalizeFilteredTypeList = (types: Type[]): Type => {\n            return combineTypes(types);\n        };\n\n        const filterType = (varType: ClassType): Type[] => {\n            const filteredTypes: Type[] = [];\n\n            for (const filterType of classTypeList) {\n                const filterIsSuperclass = ClassType.isDerivedFrom(varType, filterType);\n                const filterIsSubclass = ClassType.isDerivedFrom(filterType, varType);\n\n                // Normally, a class should never be both a subclass and a\n                // superclass. However, this can happen if one of the classes\n                // derives from an unknown type. In this case, we'll add an\n                // unknown type into the filtered type list to avoid any\n                // false positives.\n                const isClassRelationshipIndeterminate =\n                    filterIsSubclass && filterIsSubclass && !ClassType.isSameGenericClass(varType, filterType);\n\n                if (isClassRelationshipIndeterminate) {\n                    filteredTypes.push(UnknownType.create());\n                } else if (filterIsSuperclass) {\n                    // If the variable type is a subclass of the isinstance\n                    // filter, we haven't learned anything new about the\n                    // variable type.\n                    filteredTypes.push(varType);\n                } else if (filterIsSubclass) {\n                    // If the variable type is a superclass of the isinstance\n                    // filter, we can narrow the type to the subclass.\n                    filteredTypes.push(filterType);\n                }\n            }\n\n            if (!isInstanceCheck) {\n                return filteredTypes;\n            }\n\n            // Make all class types into object types before returning them.\n            return filteredTypes.map((t) => (isClass(t) ? ObjectType.create(t) : t));\n        };\n\n        let filteredType: Type;\n        if (isInstanceCheck && isObject(arg0Type)) {\n            const remainingTypes = filterType(arg0Type.classType);\n            filteredType = finalizeFilteredTypeList(remainingTypes);\n        } else if (!isInstanceCheck && isClass(arg0Type)) {\n            const remainingTypes = filterType(arg0Type);\n            filteredType = finalizeFilteredTypeList(remainingTypes);\n        } else if (arg0Type.category === TypeCategory.Union) {\n            let remainingTypes: Type[] = [];\n            let foundAnyType = false;\n\n            arg0Type.subtypes.forEach((t) => {\n                if (isAnyOrUnknown(t)) {\n                    foundAnyType = true;\n                }\n\n                if (isInstanceCheck && isObject(t)) {\n                    remainingTypes = remainingTypes.concat(filterType(t.classType));\n                } else if (!isInstanceCheck && isClass(t)) {\n                    remainingTypes = remainingTypes.concat(filterType(t));\n                }\n            });\n\n            filteredType = finalizeFilteredTypeList(remainingTypes);\n\n            // If we found an any or unknown type, all bets are off.\n            if (foundAnyType) {\n                return;\n            }\n        } else {\n            return;\n        }\n\n        const getTestType = () => {\n            const objTypeList = classTypeList.map((t) => ObjectType.create(t));\n            return combineTypes(objTypeList);\n        };\n\n        if (isNever(filteredType)) {\n            this._evaluator.addDiagnostic(\n                this._fileInfo.diagnosticRuleSet.reportUnnecessaryIsInstance,\n                DiagnosticRule.reportUnnecessaryIsInstance,\n                isInstanceCheck\n                    ? Localizer.Diagnostic.unnecessaryIsInstanceNever().format({\n                          testType: this._evaluator.printType(arg0Type, /* expandTypeAlias */ false),\n                          classType: this._evaluator.printType(getTestType(), /* expandTypeAlias */ false),\n                      })\n                    : Localizer.Diagnostic.unnecessaryIsSubclassNever().format({\n                          testType: this._evaluator.printType(arg0Type, /* expandTypeAlias */ false),\n                          classType: this._evaluator.printType(getTestType(), /* expandTypeAlias */ false),\n                      }),\n                node\n            );\n        } else if (isTypeSame(filteredType, arg0Type)) {\n            this._evaluator.addDiagnostic(\n                this._fileInfo.diagnosticRuleSet.reportUnnecessaryIsInstance,\n                DiagnosticRule.reportUnnecessaryIsInstance,\n                isInstanceCheck\n                    ? Localizer.Diagnostic.unnecessaryIsInstanceAlways().format({\n                          testType: this._evaluator.printType(arg0Type, /* expandTypeAlias */ false),\n                          classType: this._evaluator.printType(getTestType(), /* expandTypeAlias */ false),\n                      })\n                    : Localizer.Diagnostic.unnecessaryIsSubclassAlways().format({\n                          testType: this._evaluator.printType(arg0Type, /* expandTypeAlias */ false),\n                          classType: this._evaluator.printType(getTestType(), /* expandTypeAlias */ false),\n                      }),\n                node\n            );\n        }\n    }\n\n    private _isSymbolPrivate(nameValue: string, scopeType: ScopeType) {\n        // All variables within the scope of a function or a list\n        // comprehension are considered private.\n        if (scopeType === ScopeType.Function || scopeType === ScopeType.ListComprehension) {\n            return true;\n        }\n\n        // See if the symbol is private.\n        if (SymbolNameUtils.isPrivateName(nameValue)) {\n            return true;\n        }\n\n        if (SymbolNameUtils.isProtectedName(nameValue)) {\n            // Protected names outside of a class scope are considered private.\n            const isClassScope = scopeType === ScopeType.Class;\n            return !isClassScope;\n        }\n\n        return false;\n    }\n\n    private _conditionallyReportPrivateUsage(node: NameNode) {\n        if (this._fileInfo.diagnosticRuleSet.reportPrivateUsage === 'none') {\n            return;\n        }\n\n        // Ignore privates in type stubs.\n        if (this._fileInfo.isStubFile) {\n            return;\n        }\n\n        const nameValue = node.value;\n        const isPrivateName = SymbolNameUtils.isPrivateName(nameValue);\n        const isProtectedName = SymbolNameUtils.isProtectedName(nameValue);\n\n        // If it's not a protected or private name, don't bother with\n        // any further checks.\n        if (!isPrivateName && !isProtectedName) {\n            return;\n        }\n\n        const declarations = this._evaluator.getDeclarationsForNameNode(node);\n\n        let primaryDeclaration =\n            declarations && declarations.length > 0 ? declarations[declarations.length - 1] : undefined;\n        if (!primaryDeclaration || primaryDeclaration.node === node) {\n            return;\n        }\n\n        // If this symbol is an import alias (i.e. it's a local name rather than the original\n        // imported name), skip the private check.\n        if (primaryDeclaration.type === DeclarationType.Alias && primaryDeclaration.usesLocalName) {\n            return;\n        }\n\n        primaryDeclaration = this._evaluator.resolveAliasDeclaration(primaryDeclaration, /* resolveLocalNames */ true);\n        if (!primaryDeclaration || primaryDeclaration.node === node) {\n            return;\n        }\n\n        let classOrModuleNode: ClassNode | ModuleNode | undefined;\n        if (primaryDeclaration.node) {\n            classOrModuleNode = ParseTreeUtils.getEnclosingClassOrModule(primaryDeclaration.node);\n        }\n\n        // If this is the name of a class, find the module or class that contains it rather\n        // than constraining the use of the class name within the class itself.\n        if (\n            primaryDeclaration.node &&\n            primaryDeclaration.node.parent &&\n            primaryDeclaration.node.parent === classOrModuleNode &&\n            classOrModuleNode.nodeType === ParseNodeType.Class\n        ) {\n            classOrModuleNode = ParseTreeUtils.getEnclosingClassOrModule(classOrModuleNode);\n        }\n\n        // If it's a class member, check whether it's a legal protected access.\n        let isProtectedAccess = false;\n        if (classOrModuleNode && classOrModuleNode.nodeType === ParseNodeType.Class) {\n            if (isProtectedName) {\n                const declClassTypeInfo = this._evaluator.getTypeOfClass(classOrModuleNode);\n                if (declClassTypeInfo && isClass(declClassTypeInfo.decoratedType)) {\n                    // Note that the access is to a protected class member.\n                    isProtectedAccess = true;\n\n                    const enclosingClassNode = ParseTreeUtils.getEnclosingClass(node);\n                    if (enclosingClassNode) {\n                        isProtectedAccess = true;\n                        const enclosingClassTypeInfo = this._evaluator.getTypeOfClass(enclosingClassNode);\n\n                        // If the referencing class is a subclass of the declaring class, it's\n                        // allowed to access a protected name.\n                        if (enclosingClassTypeInfo && isClass(enclosingClassTypeInfo.decoratedType)) {\n                            if (\n                                derivesFromClassRecursive(\n                                    enclosingClassTypeInfo.decoratedType,\n                                    declClassTypeInfo.decoratedType,\n                                    /* ignoreUnknown */ true\n                                )\n                            ) {\n                                return;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if (classOrModuleNode && !ParseTreeUtils.isNodeContainedWithin(node, classOrModuleNode)) {\n            if (isProtectedAccess) {\n                this._evaluator.addDiagnostic(\n                    this._fileInfo.diagnosticRuleSet.reportPrivateUsage,\n                    DiagnosticRule.reportPrivateUsage,\n                    Localizer.Diagnostic.protectedUsedOutsideOfClass().format({ name: nameValue }),\n                    node\n                );\n            } else {\n                this._evaluator.addDiagnostic(\n                    this._fileInfo.diagnosticRuleSet.reportPrivateUsage,\n                    DiagnosticRule.reportPrivateUsage,\n                    classOrModuleNode.nodeType === ParseNodeType.Class\n                        ? Localizer.Diagnostic.privateUsedOutsideOfClass().format({ name: nameValue })\n                        : Localizer.Diagnostic.privateUsedOutsideOfModule().format({ name: nameValue }),\n                    node\n                );\n            }\n        }\n    }\n\n    // Verifies the rules specified in PEP 589 about TypedDict classes.\n    // They cannot have statements other than type annotations, doc\n    // strings, and \"pass\" statements or ellipses.\n    private _validateTypedDictClassSuite(suiteNode: SuiteNode) {\n        const emitBadStatementError = (node: ParseNode) => {\n            this._evaluator.addError(Localizer.Diagnostic.typedDictBadVar(), node);\n        };\n\n        suiteNode.statements.forEach((statement) => {\n            if (!AnalyzerNodeInfo.isCodeUnreachable(statement)) {\n                if (statement.nodeType === ParseNodeType.StatementList) {\n                    for (const substatement of statement.statements) {\n                        if (\n                            substatement.nodeType !== ParseNodeType.TypeAnnotation &&\n                            substatement.nodeType !== ParseNodeType.Ellipsis &&\n                            substatement.nodeType !== ParseNodeType.StringList &&\n                            substatement.nodeType !== ParseNodeType.Pass\n                        ) {\n                            emitBadStatementError(substatement);\n                        }\n                    }\n                } else {\n                    emitBadStatementError(statement);\n                }\n            }\n        });\n    }\n\n    private _validateFunctionReturn(node: FunctionNode, functionType: FunctionType) {\n        // Stub files are allowed not to return an actual value,\n        // so skip this if it's a stub file.\n        if (this._fileInfo.isStubFile) {\n            return;\n        }\n\n        const returnAnnotation = node.returnTypeAnnotation || node.functionAnnotationComment?.returnTypeAnnotation;\n        if (returnAnnotation) {\n            const functionNeverReturns = !this._evaluator.isAfterNodeReachable(node);\n            const implicitlyReturnsNone = this._evaluator.isAfterNodeReachable(node.suite);\n\n            let declaredReturnType = functionType.details.declaredReturnType;\n\n            if (declaredReturnType) {\n                if (isUnknown(declaredReturnType)) {\n                    this._evaluator.addDiagnostic(\n                        this._fileInfo.diagnosticRuleSet.reportUnknownVariableType,\n                        DiagnosticRule.reportUnknownVariableType,\n                        Localizer.Diagnostic.declaredReturnTypeUnknown(),\n                        returnAnnotation\n                    );\n                } else if (isPartlyUnknown(declaredReturnType)) {\n                    this._evaluator.addDiagnostic(\n                        this._fileInfo.diagnosticRuleSet.reportUnknownVariableType,\n                        DiagnosticRule.reportUnknownVariableType,\n                        Localizer.Diagnostic.declaredReturnTypePartiallyUnknown().format({\n                            returnType: this._evaluator.printType(declaredReturnType, /* expandTypeAlias */ true),\n                        }),\n                        returnAnnotation\n                    );\n                }\n            }\n\n            // Wrap the declared type in a generator type if the function is a generator.\n            if (FunctionType.isGenerator(functionType)) {\n                declaredReturnType = getDeclaredGeneratorReturnType(functionType);\n            }\n\n            // The types of all return statement expressions were already checked\n            // against the declared type, but we need to verify the implicit None\n            // at the end of the function.\n            if (declaredReturnType && !functionNeverReturns && implicitlyReturnsNone) {\n                if (isNoReturnType(declaredReturnType)) {\n                    // If the function consists entirely of \"...\", assume that it's\n                    // an abstract method or a protocol method and don't require that\n                    // the return type matches.\n                    if (!ParseTreeUtils.isSuiteEmpty(node.suite)) {\n                        this._evaluator.addDiagnostic(\n                            this._fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                            DiagnosticRule.reportGeneralTypeIssues,\n                            Localizer.Diagnostic.noReturnReturnsNone(),\n                            returnAnnotation\n                        );\n                    }\n                } else if (!FunctionType.isAbstractMethod(functionType)) {\n                    // Make sure that the function doesn't implicitly return None if the declared\n                    // type doesn't allow it. Skip this check for abstract methods.\n                    const diagAddendum = new DiagnosticAddendum();\n\n                    // If the declared type isn't compatible with 'None', flag an error.\n                    if (!this._evaluator.canAssignType(declaredReturnType, NoneType.createInstance(), diagAddendum)) {\n                        // If the function consists entirely of \"...\", assume that it's\n                        // an abstract method or a protocol method and don't require that\n                        // the return type matches.\n                        if (!ParseTreeUtils.isSuiteEmpty(node.suite)) {\n                            this._evaluator.addDiagnostic(\n                                this._fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                                DiagnosticRule.reportGeneralTypeIssues,\n                                Localizer.Diagnostic.returnMissing().format({\n                                    returnType: this._evaluator.printType(\n                                        declaredReturnType,\n                                        /* expandTypeAlias */ false\n                                    ),\n                                }) + diagAddendum.getString(),\n                                returnAnnotation\n                            );\n                        }\n                    }\n                }\n            }\n        } else {\n            const inferredReturnType = this._evaluator.getFunctionInferredReturnType(functionType);\n            if (isUnknown(inferredReturnType)) {\n                this._evaluator.addDiagnostic(\n                    this._fileInfo.diagnosticRuleSet.reportUnknownParameterType,\n                    DiagnosticRule.reportUnknownParameterType,\n                    Localizer.Diagnostic.returnTypeUnknown(),\n                    node.name\n                );\n            } else if (isPartlyUnknown(inferredReturnType)) {\n                this._evaluator.addDiagnostic(\n                    this._fileInfo.diagnosticRuleSet.reportUnknownParameterType,\n                    DiagnosticRule.reportUnknownParameterType,\n                    Localizer.Diagnostic.returnTypePartiallyUnknown().format({\n                        returnType: this._evaluator.printType(inferredReturnType, /* expandTypeAlias */ true),\n                    }),\n                    node.name\n                );\n            }\n        }\n    }\n\n    // Validates that any overridden member variables are not marked\n    // as Final in parent classes.\n    private _validateFinalMemberOverrides(classType: ClassType) {\n        classType.details.fields.forEach((localSymbol, name) => {\n            const parentSymbol = lookUpClassMember(classType, name, ClassMemberLookupFlags.SkipOriginalClass);\n            if (parentSymbol && isClass(parentSymbol.classType) && isFinalVariable(parentSymbol.symbol)) {\n                const decl = localSymbol.getDeclarations()[0];\n                this._evaluator.addError(\n                    Localizer.Diagnostic.finalRedeclarationBySubclass().format({\n                        name,\n                        className: parentSymbol.classType.details.name,\n                    }),\n                    decl.node\n                );\n            }\n        });\n    }\n\n    // Validates that any overridden methods contain the same signatures\n    // as the original method. Also marks the class as abstract if one or\n    // more abstract methods are not overridden.\n    private _validateClassMethods(classType: ClassType) {\n        // Skip the overrides check for stub files. Many of the built-in\n        // typeshed stub files trigger this diagnostic.\n        if (!this._fileInfo.isStubFile) {\n            this._validateBaseClassOverrides(classType);\n        }\n    }\n\n    private _validateBaseClassOverrides(classType: ClassType) {\n        classType.details.fields.forEach((symbol, name) => {\n            // Don't check magic functions or private symbols.\n            if (\n                !symbol.isClassMember() ||\n                SymbolNameUtils.isDunderName(name) ||\n                SymbolNameUtils.isPrivateOrProtectedName(name)\n            ) {\n                return;\n            }\n\n            // Get the symbol type defined in this class.\n            const typeOfSymbol = this._evaluator.getEffectiveTypeOfSymbol(symbol);\n\n            // If the type of the override symbol isn't known, stop here.\n            if (isAnyOrUnknown(typeOfSymbol)) {\n                return;\n            }\n\n            // Get the symbol defined in the base class.\n            const baseClassAndSymbol = lookUpClassMember(classType, name, ClassMemberLookupFlags.SkipOriginalClass);\n\n            if (!baseClassAndSymbol || !isClass(baseClassAndSymbol.classType)) {\n                return;\n            }\n\n            // If the base class doesn't provide a type declaration, we won't bother\n            // proceeding with additional checks. Type inference is too inaccurate\n            // in this case, plus it would be very slow.\n            if (!baseClassAndSymbol.symbol.hasTypedDeclarations()) {\n                return;\n            }\n\n            const baseClassSymbolType = partiallySpecializeType(\n                this._evaluator.getEffectiveTypeOfSymbol(baseClassAndSymbol.symbol),\n                baseClassAndSymbol.classType\n            );\n            const diagAddendum = new DiagnosticAddendum();\n\n            if (\n                baseClassSymbolType.category === TypeCategory.Function ||\n                baseClassSymbolType.category === TypeCategory.OverloadedFunction\n            ) {\n                if (typeOfSymbol.category === TypeCategory.Function) {\n                    if (!this._evaluator.canOverrideMethod(baseClassSymbolType, typeOfSymbol, diagAddendum)) {\n                        const decl = getLastTypedDeclaredForSymbol(symbol);\n                        if (decl && decl.type === DeclarationType.Function) {\n                            const diag = this._evaluator.addDiagnostic(\n                                this._fileInfo.diagnosticRuleSet.reportIncompatibleMethodOverride,\n                                DiagnosticRule.reportIncompatibleMethodOverride,\n                                Localizer.Diagnostic.incompatibleMethodOverride().format({\n                                    name,\n                                    className: baseClassAndSymbol.classType.details.name,\n                                }) + diagAddendum.getString(),\n                                decl.node.name\n                            );\n\n                            const origDecl = getLastTypedDeclaredForSymbol(baseClassAndSymbol.symbol);\n                            if (diag && origDecl) {\n                                diag.addRelatedInfo(\n                                    Localizer.DiagnosticAddendum.overriddenMethod(),\n                                    origDecl.path,\n                                    origDecl.range\n                                );\n                            }\n                        }\n                    }\n\n                    if (baseClassSymbolType.category === TypeCategory.Function) {\n                        if (FunctionType.isFinal(baseClassSymbolType)) {\n                            const decl = getLastTypedDeclaredForSymbol(symbol);\n                            if (decl && decl.type === DeclarationType.Function) {\n                                const diag = this._evaluator.addError(\n                                    Localizer.Diagnostic.finalMethodOverride().format({\n                                        name,\n                                        className: baseClassAndSymbol.classType.details.name,\n                                    }),\n                                    decl.node.name\n                                );\n\n                                const origDecl = getLastTypedDeclaredForSymbol(baseClassAndSymbol.symbol);\n                                if (diag && origDecl) {\n                                    diag.addRelatedInfo(\n                                        Localizer.DiagnosticAddendum.finalMethod(),\n                                        origDecl.path,\n                                        origDecl.range\n                                    );\n                                }\n                            }\n                        }\n                    }\n                } else if (!isAnyOrUnknown(typeOfSymbol)) {\n                    const decls = symbol.getDeclarations();\n                    if (decls.length > 0) {\n                        const lastDecl = decls[decls.length - 1];\n                        const diag = this._evaluator.addDiagnostic(\n                            this._fileInfo.diagnosticRuleSet.reportIncompatibleMethodOverride,\n                            DiagnosticRule.reportIncompatibleMethodOverride,\n                            Localizer.Diagnostic.methodOverridden().format({\n                                name,\n                                className: baseClassAndSymbol.classType.details.name,\n                            }) + diagAddendum.getString(),\n                            lastDecl.node\n                        );\n\n                        const origDecl = getLastTypedDeclaredForSymbol(baseClassAndSymbol.symbol);\n                        if (diag && origDecl) {\n                            diag.addRelatedInfo(\n                                Localizer.DiagnosticAddendum.overriddenMethod(),\n                                origDecl.path,\n                                origDecl.range\n                            );\n                        }\n                    }\n                }\n            } else {\n                // This check can be expensive, so don't perform it if the corresponding\n                // rule is disabled.\n                if (this._fileInfo.diagnosticRuleSet.reportIncompatibleVariableOverride !== 'none') {\n                    // Verify that the override type is assignable to (same or narrower than)\n                    // the declared type of the base symbol.\n                    if (!this._evaluator.canAssignType(baseClassSymbolType, typeOfSymbol, diagAddendum)) {\n                        const decls = symbol.getDeclarations();\n                        if (decls.length > 0) {\n                            const lastDecl = decls[decls.length - 1];\n                            if (lastDecl) {\n                                const diag = this._evaluator.addDiagnostic(\n                                    this._fileInfo.diagnosticRuleSet.reportIncompatibleVariableOverride,\n                                    DiagnosticRule.reportIncompatibleVariableOverride,\n                                    Localizer.Diagnostic.symbolOverridden().format({\n                                        name,\n                                        className: baseClassAndSymbol.classType.details.name,\n                                    }) + diagAddendum.getString(),\n                                    lastDecl.node\n                                );\n\n                                const origDecl = getLastTypedDeclaredForSymbol(baseClassAndSymbol.symbol);\n                                if (diag && origDecl) {\n                                    diag.addRelatedInfo(\n                                        Localizer.DiagnosticAddendum.overriddenSymbol(),\n                                        origDecl.path,\n                                        origDecl.range\n                                    );\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        });\n    }\n\n    // Performs checks on a function that is located within a class\n    // and has been determined not to be a property accessor.\n    private _validateMethod(node: FunctionNode, functionType: FunctionType, classNode: ClassNode) {\n        if (node.name && node.name.value === '__new__') {\n            // __new__ overrides should have a \"cls\" parameter.\n            if (\n                node.parameters.length === 0 ||\n                !node.parameters[0].name ||\n                (node.parameters[0].name.value !== 'cls' && node.parameters[0].name.value !== 'mcs')\n            ) {\n                this._evaluator.addDiagnostic(\n                    this._fileInfo.diagnosticRuleSet.reportSelfClsParameterName,\n                    DiagnosticRule.reportSelfClsParameterName,\n                    Localizer.Diagnostic.newClsParam(),\n                    node.parameters.length > 0 ? node.parameters[0] : node.name\n                );\n            }\n        } else if (node.name && node.name.value === '__init_subclass__') {\n            // __init_subclass__ overrides should have a \"cls\" parameter.\n            if (node.parameters.length === 0 || !node.parameters[0].name || node.parameters[0].name.value !== 'cls') {\n                this._evaluator.addDiagnostic(\n                    this._fileInfo.diagnosticRuleSet.reportSelfClsParameterName,\n                    DiagnosticRule.reportSelfClsParameterName,\n                    Localizer.Diagnostic.initSubclassClsParam(),\n                    node.parameters.length > 0 ? node.parameters[0] : node.name\n                );\n            }\n        } else if (node.name && node.name.value === '__class_getitem__') {\n            // __class_getitem__ overrides should have a \"cls\" parameter.\n            if (node.parameters.length === 0 || !node.parameters[0].name || node.parameters[0].name.value !== 'cls') {\n                this._evaluator.addDiagnostic(\n                    this._fileInfo.diagnosticRuleSet.reportSelfClsParameterName,\n                    DiagnosticRule.reportSelfClsParameterName,\n                    Localizer.Diagnostic.classGetItemClsParam(),\n                    node.parameters.length > 0 ? node.parameters[0] : node.name\n                );\n            }\n        } else if (FunctionType.isStaticMethod(functionType)) {\n            // Static methods should not have \"self\" or \"cls\" parameters.\n            if (node.parameters.length > 0 && node.parameters[0].name) {\n                const paramName = node.parameters[0].name.value;\n                if (paramName === 'self' || paramName === 'cls') {\n                    this._evaluator.addDiagnostic(\n                        this._fileInfo.diagnosticRuleSet.reportSelfClsParameterName,\n                        DiagnosticRule.reportSelfClsParameterName,\n                        Localizer.Diagnostic.staticClsSelfParam(),\n                        node.parameters[0].name\n                    );\n                }\n            }\n        } else if (FunctionType.isClassMethod(functionType)) {\n            let paramName = '';\n            if (node.parameters.length > 0 && node.parameters[0].name) {\n                paramName = node.parameters[0].name.value;\n            }\n            // Class methods should have a \"cls\" parameter. We'll exempt parameter\n            // names that start with an underscore since those are used in a few\n            // cases in the stdlib pyi files.\n            if (paramName !== 'cls') {\n                if (!this._fileInfo.isStubFile || (!paramName.startsWith('_') && paramName !== 'metacls')) {\n                    this._evaluator.addDiagnostic(\n                        this._fileInfo.diagnosticRuleSet.reportSelfClsParameterName,\n                        DiagnosticRule.reportSelfClsParameterName,\n                        Localizer.Diagnostic.classMethodClsParam(),\n                        node.parameters.length > 0 ? node.parameters[0] : node.name\n                    );\n                }\n            }\n        } else {\n            // The presence of a decorator can change the behavior, so we need\n            // to back off from this check if a decorator is present.\n            if (node.decorators.length === 0) {\n                let paramName = '';\n                let firstParamIsSimple = true;\n                if (node.parameters.length > 0) {\n                    if (node.parameters[0].name) {\n                        paramName = node.parameters[0].name.value;\n                    }\n\n                    if (node.parameters[0].category !== ParameterCategory.Simple) {\n                        firstParamIsSimple = false;\n                    }\n                }\n\n                // Instance methods should have a \"self\" parameter.\n                if (firstParamIsSimple && paramName !== 'self') {\n                    // Special-case metaclasses, which can use \"cls\".\n                    let isLegalMetaclassName = false;\n                    if (paramName === 'cls') {\n                        const classTypeInfo = this._evaluator.getTypeOfClass(classNode);\n                        const typeType = this._evaluator.getBuiltInType(classNode, 'type');\n                        if (typeType && isClass(typeType) && classTypeInfo && isClass(classTypeInfo.classType)) {\n                            if (\n                                derivesFromClassRecursive(classTypeInfo.classType, typeType, /* ignoreUnknown */ true)\n                            ) {\n                                isLegalMetaclassName = true;\n                            }\n                        }\n                    }\n\n                    // Some typeshed stubs use a name that starts with an underscore to designate\n                    // a parameter that cannot be positional.\n                    const isPrivateName = SymbolNameUtils.isPrivateOrProtectedName(paramName);\n\n                    if (!isLegalMetaclassName && !isPrivateName) {\n                        this._evaluator.addDiagnostic(\n                            this._fileInfo.diagnosticRuleSet.reportSelfClsParameterName,\n                            DiagnosticRule.reportSelfClsParameterName,\n                            Localizer.Diagnostic.instanceMethodSelfParam(),\n                            node.parameters.length > 0 ? node.parameters[0] : node.name\n                        );\n                    }\n                }\n            }\n        }\n    }\n\n    private _validateYieldType(node: YieldNode | YieldFromNode, adjustedYieldType: Type) {\n        let declaredYieldType: Type | undefined;\n        const enclosingFunctionNode = ParseTreeUtils.getEnclosingFunction(node);\n\n        if (enclosingFunctionNode) {\n            const functionTypeResult = this._evaluator.getTypeOfFunction(enclosingFunctionNode);\n            if (functionTypeResult) {\n                assert(functionTypeResult.functionType.category === TypeCategory.Function);\n                const iterableType = this._evaluator.getBuiltInType(node, 'Iterable');\n                declaredYieldType = getDeclaredGeneratorYieldType(functionTypeResult.functionType, iterableType);\n            }\n        }\n\n        if (this._evaluator.isNodeReachable(node)) {\n            if (declaredYieldType) {\n                if (isNoReturnType(declaredYieldType)) {\n                    this._evaluator.addDiagnostic(\n                        this._fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                        DiagnosticRule.reportGeneralTypeIssues,\n                        Localizer.Diagnostic.noReturnContainsYield(),\n                        node\n                    );\n                } else {\n                    const diagAddendum = new DiagnosticAddendum();\n                    if (!this._evaluator.canAssignType(declaredYieldType, adjustedYieldType, diagAddendum)) {\n                        this._evaluator.addDiagnostic(\n                            this._fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                            DiagnosticRule.reportGeneralTypeIssues,\n                            Localizer.Diagnostic.yieldTypeMismatch().format({\n                                exprType: this._evaluator.printType(adjustedYieldType, /* expandTypeAlias */ false),\n                                yieldType: this._evaluator.printType(declaredYieldType, /* expandTypeAlias */ false),\n                            }) + diagAddendum.getString(),\n                            node.expression || node\n                        );\n                    }\n                }\n            }\n        }\n    }\n\n    private _reportDuplicateImports() {\n        const importStatements = getTopLevelImports(this._moduleNode);\n\n        const importModuleMap = new Map<string, ImportAsNode>();\n\n        importStatements.orderedImports.forEach((importStatement) => {\n            if (importStatement.node.nodeType === ParseNodeType.ImportFrom) {\n                const symbolMap = new Map<string, ImportFromAsNode>();\n\n                importStatement.node.imports.forEach((importFromAs) => {\n                    // Ignore duplicates if they're aliased.\n                    if (!importFromAs.alias) {\n                        const prevImport = symbolMap.get(importFromAs.name.value);\n                        if (prevImport) {\n                            this._evaluator.addDiagnostic(\n                                this._fileInfo.diagnosticRuleSet.reportDuplicateImport,\n                                DiagnosticRule.reportDuplicateImport,\n                                Localizer.Diagnostic.duplicateImport().format({ importName: importFromAs.name.value }),\n                                importFromAs.name\n                            );\n                        } else {\n                            symbolMap.set(importFromAs.name.value, importFromAs);\n                        }\n                    }\n                });\n            } else if (importStatement.subnode) {\n                // Ignore duplicates if they're aliased.\n                if (!importStatement.subnode.alias) {\n                    const prevImport = importModuleMap.get(importStatement.moduleName);\n                    if (prevImport) {\n                        this._evaluator.addDiagnostic(\n                            this._fileInfo.diagnosticRuleSet.reportDuplicateImport,\n                            DiagnosticRule.reportDuplicateImport,\n                            Localizer.Diagnostic.duplicateImport().format({ importName: importStatement.moduleName }),\n                            importStatement.subnode\n                        );\n                    } else {\n                        importModuleMap.set(importStatement.moduleName, importStatement.subnode);\n                    }\n                }\n            }\n        });\n    }\n}\n","/*\n * circularDependency.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * A list of file paths that are part of a circular dependency\n * chain (i.e. a chain of imports). Since these are circular, there\n * no defined \"start\", but this module helps normalize the start\n * by picking the alphabetically-first module in the cycle.\n */\n\nexport class CircularDependency {\n    private _paths: string[] = [];\n\n    appendPath(path: string) {\n        this._paths.push(path);\n    }\n\n    getPaths() {\n        return this._paths;\n    }\n\n    normalizeOrder() {\n        // Find the path that is alphabetically first and reorder\n        // based on that.\n        let firstIndex = 0;\n        this._paths.forEach((path, index) => {\n            if (path < this._paths[firstIndex]) {\n                firstIndex = index;\n            }\n        });\n\n        if (firstIndex !== 0) {\n            this._paths = this._paths.slice(firstIndex).concat(this._paths.slice(0, firstIndex));\n        }\n    }\n\n    isEqual(circDependency: CircularDependency) {\n        if (circDependency._paths.length !== this._paths.length) {\n            return false;\n        }\n\n        for (let i = 0; i < this._paths.length; i++) {\n            if (this._paths[i] !== circDependency._paths[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n","/*\n * codeFlow.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Data structures that track the code flow (or more accurately,\n * the inverse of code flow) starting with return statements and\n * working back to the entry. This allows us to work out the\n * types at each point of the code flow.\n *\n * This is largely based on the code flow engine in the\n * TypeScript compiler.\n */\n\nimport { assert } from '../common/debug';\nimport {\n    CallNode,\n    ExpressionNode,\n    ImportFromNode,\n    MemberAccessNode,\n    NameNode,\n    ParseNodeType,\n} from '../parser/parseNodes';\n\nexport enum FlowFlags {\n    Unreachable = 1 << 0, // Unreachable code\n    Start = 1 << 1, // Entry point\n    BranchLabel = 1 << 2, // Junction for forward control flow\n    LoopLabel = 1 << 3, // Junction for backward control flow\n    Assignment = 1 << 4, // Assignment statement\n    Unbind = 1 << 5, // Used with assignment to indicate target should be unbound\n    WildcardImport = 1 << 6, // For \"from X import *\" statements\n    TrueCondition = 1 << 7, // Condition known to be true\n    FalseCondition = 1 << 9, // Condition known to be false\n    Call = 1 << 10, // Call node\n    PreFinallyGate = 1 << 11, // Injected edge that links pre-finally label and pre-try flow\n    PostFinally = 1 << 12, // Injected edge that links post-finally flow with the rest of the graph\n    AssignmentAlias = 1 << 13, // Assigned symbol is aliased to another symbol with the same name\n}\n\nlet _nextFlowNodeId = 1;\n\nexport function getUniqueFlowNodeId() {\n    return _nextFlowNodeId++;\n}\n\nexport interface FlowNode {\n    flags: FlowFlags;\n    id: number;\n}\n\n// FlowLabel represents a junction with multiple possible\n// preceding control flows.\nexport interface FlowLabel extends FlowNode {\n    antecedents: FlowNode[];\n}\n\n// FlowAssignment represents a node that assigns a value.\nexport interface FlowAssignment extends FlowNode {\n    node: NameNode | MemberAccessNode;\n    antecedent: FlowNode;\n    targetSymbolId: number;\n}\n\n// FlowAssignmentAlias handles a case where a symbol\n// takes on the value of a symbol with the same name\n// but within an outer scope, such as when a variable\n// is references within a list comprehension iteration\n// expression before the result is assigned to a\n// local variable of the same name.\nexport interface FlowAssignmentAlias extends FlowNode {\n    antecedent: FlowNode;\n    targetSymbolId: number;\n    aliasSymbolId: number;\n}\n\n// Similar to FlowAssignment but used specifically for\n// wildcard \"from X import *\" statements.\nexport interface FlowWildcardImport extends FlowNode {\n    node: ImportFromNode;\n    names: string[];\n    antecedent: FlowNode;\n}\n\n// FlowCondition represents a condition that is known to\n// be true or false at the node's location in the control flow.\nexport interface FlowCondition extends FlowNode {\n    expression: ExpressionNode;\n    antecedent: FlowNode;\n}\n\n// Records a call, which may raise exceptions, thus affecting\n// the code flow and making subsequent code unreachable.\nexport interface FlowCall extends FlowNode {\n    node: CallNode;\n    antecedent: FlowNode;\n}\n\n// See comment in the visitTry method in binder.ts for a full\n// explanation of the FlowPreFinally and FlowPostFinally nodes.\nexport interface FlowPreFinallyGate extends FlowNode {\n    antecedent: FlowNode;\n    isGateClosed: boolean;\n}\n\nexport interface FlowPostFinally extends FlowNode {\n    antecedent: FlowNode;\n    preFinallyGate: FlowPreFinallyGate;\n}\n\nexport function isCodeFlowSupportedForReference(reference: ExpressionNode): boolean {\n    if (reference.nodeType === ParseNodeType.Name) {\n        return true;\n    }\n\n    if (reference.nodeType === ParseNodeType.MemberAccess) {\n        return isCodeFlowSupportedForReference(reference.leftExpression);\n    }\n\n    return false;\n}\n\nexport function createKeyForReference(reference: NameNode | MemberAccessNode): string {\n    let key;\n    if (reference.nodeType === ParseNodeType.Name) {\n        key = reference.value;\n    } else {\n        key = reference.memberName.value;\n        let leftNode = reference.leftExpression;\n        while (leftNode.nodeType === ParseNodeType.MemberAccess) {\n            key = leftNode.memberName.value + `.${key}`;\n            leftNode = leftNode.leftExpression;\n        }\n        assert(leftNode.nodeType === ParseNodeType.Name);\n        key = (leftNode as NameNode).value + `.${key}`;\n    }\n\n    return key;\n}\n","/*\n * commentUtils.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Utility functions that parse comments and extract commands\n * or other directives from them.\n */\n\nimport {\n    cloneDiagnosticRuleSet,\n    DiagnosticLevel,\n    DiagnosticRuleSet,\n    getBooleanDiagnosticRules,\n    getDiagLevelDiagnosticRules,\n    getStrictDiagnosticRuleSet,\n    getStrictModeNotOverriddenRules,\n} from '../common/configOptions';\nimport { TextRangeCollection } from '../common/textRangeCollection';\nimport { Token } from '../parser/tokenizerTypes';\n\nexport function getFileLevelDirectives(\n    tokens: TextRangeCollection<Token>,\n    defaultRuleSet: DiagnosticRuleSet,\n    useStrict: boolean\n): DiagnosticRuleSet {\n    let ruleSet = cloneDiagnosticRuleSet(defaultRuleSet);\n\n    if (useStrict) {\n        _applyStrictRules(ruleSet);\n    }\n\n    for (let i = 0; i < tokens.count; i++) {\n        const token = tokens.getItemAt(i);\n        if (token.comments) {\n            for (const comment of token.comments) {\n                const value = comment.value.trim();\n\n                ruleSet = _parsePyrightComment(value, ruleSet);\n            }\n        }\n    }\n\n    return ruleSet;\n}\n\nfunction _applyStrictRules(ruleSet: DiagnosticRuleSet) {\n    const strictRuleSet = getStrictDiagnosticRuleSet();\n    const boolRuleNames = getBooleanDiagnosticRules();\n    const diagRuleNames = getDiagLevelDiagnosticRules();\n    const skipRuleNames = getStrictModeNotOverriddenRules();\n\n    // Enable the strict rules as appropriate.\n    for (const ruleName of boolRuleNames) {\n        if (skipRuleNames.find((r) => r === ruleName)) {\n            continue;\n        }\n\n        if ((strictRuleSet as any)[ruleName]) {\n            (ruleSet as any)[ruleName] = true;\n        }\n    }\n\n    for (const ruleName of diagRuleNames) {\n        if (skipRuleNames.find((r) => r === ruleName)) {\n            continue;\n        }\n\n        const strictValue: DiagnosticLevel = (strictRuleSet as any)[ruleName];\n        const prevValue: DiagnosticLevel = (ruleSet as any)[ruleName];\n\n        if (\n            strictValue === 'error' ||\n            (strictValue === 'warning' && prevValue !== 'error') ||\n            (strictValue === 'information' && prevValue !== 'error' && prevValue !== 'warning')\n        ) {\n            (ruleSet as any)[ruleName] = strictValue;\n        }\n    }\n}\n\nfunction _parsePyrightComment(commentValue: string, ruleSet: DiagnosticRuleSet) {\n    // Is this a pyright or mspython-specific comment?\n    const validPrefixes = ['pyright:', 'mspython:'];\n    const prefix = validPrefixes.find((p) => commentValue.startsWith(p));\n    if (prefix) {\n        const operands = commentValue.substr(prefix.length).trim();\n        const operandList = operands.split(',').map((s) => s.trim());\n\n        // If it contains a \"strict\" operand, replace the existing\n        // diagnostic rules with their strict counterparts.\n        if (operandList.some((s) => s === 'strict')) {\n            _applyStrictRules(ruleSet);\n        }\n\n        for (const operand of operandList) {\n            ruleSet = _parsePyrightOperand(operand, ruleSet);\n        }\n    }\n\n    return ruleSet;\n}\n\nfunction _parsePyrightOperand(operand: string, ruleSet: DiagnosticRuleSet) {\n    const operandSplit = operand.split('=').map((s) => s.trim());\n    if (operandSplit.length !== 2) {\n        return ruleSet;\n    }\n\n    const ruleName = operandSplit[0];\n    const boolRules = getBooleanDiagnosticRules();\n    const diagLevelRules = getDiagLevelDiagnosticRules();\n\n    if (diagLevelRules.find((r) => r === ruleName)) {\n        const diagLevelValue = _parseDiagLevel(operandSplit[1]);\n        if (diagLevelValue !== undefined) {\n            (ruleSet as any)[ruleName] = diagLevelValue;\n        }\n    } else if (boolRules.find((r) => r === ruleName)) {\n        const boolValue = _parseBoolSetting(operandSplit[1]);\n        if (boolValue !== undefined) {\n            (ruleSet as any)[ruleName] = boolValue;\n        }\n    }\n\n    return ruleSet;\n}\n\nfunction _parseDiagLevel(value: string): DiagnosticLevel | undefined {\n    switch (value) {\n        case 'false':\n        case 'none':\n            return 'none';\n\n        case 'true':\n        case 'error':\n            return 'error';\n\n        case 'warning':\n            return 'warning';\n\n        case 'information':\n            return 'information';\n\n        default:\n            return undefined;\n    }\n}\n\nfunction _parseBoolSetting(value: string): boolean | undefined {\n    if (value === 'false') {\n        return false;\n    } else if (value === 'true') {\n        return true;\n    }\n\n    return undefined;\n}\n","/*\n * declarationUtils.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Collection of static methods that operate on declarations.\n */\n\nimport { ParseNodeType } from '../parser/parseNodes';\nimport { Declaration, DeclarationType } from './declaration';\n\nexport function hasTypeForDeclaration(declaration: Declaration): boolean {\n    switch (declaration.type) {\n        case DeclarationType.Intrinsic:\n        case DeclarationType.Class:\n        case DeclarationType.SpecialBuiltInClass:\n        case DeclarationType.Function:\n            return true;\n\n        case DeclarationType.Parameter: {\n            if (declaration.node.typeAnnotation || declaration.node.typeAnnotationComment) {\n                return true;\n            }\n            const parameterParent = declaration.node.parent;\n            if (parameterParent?.nodeType === ParseNodeType.Function) {\n                if (\n                    parameterParent.functionAnnotationComment &&\n                    !parameterParent.functionAnnotationComment.isParamListEllipsis\n                ) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        case DeclarationType.Variable:\n            return !!declaration.typeAnnotationNode;\n\n        case DeclarationType.Alias:\n            return false;\n    }\n}\n\nexport function areDeclarationsSame(decl1: Declaration, decl2: Declaration): boolean {\n    if (decl1.type !== decl2.type) {\n        return false;\n    }\n\n    if (decl1.path !== decl2.path) {\n        return false;\n    }\n\n    if (\n        decl1.range.start.line !== decl2.range.start.line ||\n        decl1.range.start.character !== decl2.range.start.character\n    ) {\n        return false;\n    }\n\n    // Alias declarations refer to the entire import statement.\n    // We need to further differentiate.\n    if (decl1.type === DeclarationType.Alias && decl2.type === DeclarationType.Alias) {\n        if (\n            decl1.symbolName !== decl2.symbolName ||\n            decl1.firstNamePart !== decl2.firstNamePart ||\n            decl1.usesLocalName !== decl2.usesLocalName\n        ) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nexport function isFinalVariableDeclaration(decl: Declaration) {\n    return decl.type === DeclarationType.Variable && !!decl.isFinal;\n}\n\nexport function isExplicitTypeAliasDeclaration(decl: Declaration) {\n    return decl.type === DeclarationType.Variable && !!decl.typeAliasAnnotation;\n}\n\nexport function isPossibleTypeAliasDeclaration(decl: Declaration) {\n    return decl.type === DeclarationType.Variable && !!decl.typeAliasName;\n}\n\nexport function getNameFromDeclaration(declaration: Declaration) {\n    switch (declaration.type) {\n        case DeclarationType.Alias:\n            return declaration.symbolName;\n\n        case DeclarationType.Class:\n        case DeclarationType.Function:\n            return declaration.node.name.value;\n\n        case DeclarationType.Parameter:\n            return declaration.node.name?.value;\n\n        case DeclarationType.Variable:\n            return declaration.node.nodeType === ParseNodeType.Name ? declaration.node.value : undefined;\n\n        case DeclarationType.Intrinsic:\n        case DeclarationType.SpecialBuiltInClass:\n            return undefined;\n    }\n\n    throw new Error(`Shouldn't reach here`);\n}\n","/*\n * docStringToMarkdown.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * Python doc string to markdown converter.\n *\n * This does various things, including removing common indention, escaping\n * characters, handling code blocks, and more.\n *\n * This is a straight port of\n * https://github.com/microsoft/python-language-server/blob/master/src/LanguageServer/Impl/Documentation/DocstringConverter.cs\n *\n * The restructured npm library was evaluated, and while it worked well for\n * parsing valid input, it was going to be more difficult to handle invalid\n * RST input.\n */\n\nexport function convertDocStringToMarkdown(docString: string): string {\n    return new DocStringConverter(docString).convert();\n}\n\ninterface RegexReplacement {\n    exp: RegExp;\n    replacement: string;\n}\n\n// Regexes for one match\nconst LeadingSpaceCountRegEx = /\\S|$/;\nconst CrLfRegEx = /\\r?\\n/;\nconst NonWhitespaceRegEx = /\\S/;\nconst TildaHeaderRegex = /^\\s*~~~+$/;\nconst PlusHeaderRegex = /^\\s*\\+\\+\\++$/;\nconst LeadingAsteriskRegex = /^(\\s+\\* )(.*)$/;\nconst SpaceDotDotRegex = /^\\s*\\.\\. /;\nconst DirectiveLikeRegex = /^\\s*\\.\\.\\s+(\\w+)::\\s*(.*)$/;\nconst DoctestRegex = / *>>> /;\nconst DirectivesExtraNewlineRegex = /^\\s*:(param|arg|type|return|rtype|raise|except|var|ivar|cvar|copyright|license)/;\n\nconst PotentialHeaders: RegexReplacement[] = [\n    { exp: /^\\s*=+(\\s+=+)+$/, replacement: '=' },\n    { exp: /^\\s*-+(\\s+-+)+$/, replacement: '-' },\n    { exp: /^\\s*~+(\\s+-+)+$/, replacement: '~' },\n    { exp: /^\\s*\\++(\\s+\\++)+$/, replacement: '+' },\n];\n\n// Regexes for replace all\nconst WhitespaceRegex = /\\s/g;\nconst DoubleTickRegEx = /``/g;\nconst TabRegEx = /\\t/g;\nconst TildeRegEx = /~/g;\nconst PlusRegEx = /\\+/g;\nconst UnescapedMarkdownCharsRegex = /(?<!\\\\)([_*~[\\]])/g;\n\n// http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#literal-blocks\nconst LiteralBlockEmptyRegex = /^\\s*::$/;\nconst LiteralBlockReplacements: RegexReplacement[] = [\n    { exp: /\\s+::$/g, replacement: '' },\n    { exp: /(\\S)\\s*::$/g, replacement: '$1:' },\n    // http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#interpreted-text\n    { exp: /:[\\w_\\-+:.]+:`/g, replacement: '`' },\n    { exp: /`:[\\w_\\-+:.]+:/g, replacement: '`' },\n];\n\n// Converter is a state machine, where the current state is a function which\n// will be run (and change the state again) until completion.\ntype State = () => void;\n\nclass DocStringConverter {\n    private _builder = '';\n    private _skipAppendEmptyLine = true;\n    private _insideInlineCode = false;\n    private _appendDirectiveBlock = false;\n\n    private _state: State;\n    private _stateStack: State[] = [];\n\n    private _lines: string[];\n    private _lineNum = 0;\n\n    private _blockIndent = 0;\n\n    constructor(input: string) {\n        this._state = this._parseText;\n        this._lines = _splitDocString(input);\n    }\n\n    convert(): string {\n        while (this._currentLineOrUndefined() !== undefined) {\n            const before = this._state;\n            const beforeLine = this._lineNum;\n\n            this._state();\n\n            // Parser must make progress; either the state or line number must change.\n            if (this._state === before && this._lineNum === beforeLine) {\n                break;\n            }\n        }\n\n        // Close out any outstanding code blocks.\n        if (\n            this._state === this._parseBacktickBlock ||\n            this._state === this._parseDocTest ||\n            this._state === this._parseLiteralBlock\n        ) {\n            this._trimOutputAndAppendLine('```');\n        } else if (this._insideInlineCode) {\n            this._trimOutputAndAppendLine('`', true);\n        }\n\n        return this._builder.trim();\n    }\n\n    private _eatLine() {\n        this._lineNum++;\n    }\n\n    private _currentLineOrUndefined(): string | undefined {\n        return this._lineNum < this._lines.length ? this._lines[this._lineNum] : undefined;\n    }\n\n    private _currentLine(): string {\n        return this._currentLineOrUndefined() || '';\n    }\n\n    private _currentIndent(): number {\n        return _countLeadingSpaces(this._currentLine());\n    }\n\n    private _lineAt(i: number): string | undefined {\n        return i < this._lines.length ? this._lines[i] : undefined;\n    }\n\n    private _nextBlockIndent(): number {\n        return _countLeadingSpaces(\n            this._lines.slice(this._lineNum + 1).find((v) => !_isUndefinedOrWhitespace(v)) || ''\n        );\n    }\n\n    private _currentLineIsOutsideBlock(): boolean {\n        return this._currentIndent() < this._blockIndent;\n    }\n\n    private _currentLineWithinBlock(): string {\n        return this._currentLine().substr(this._blockIndent);\n    }\n\n    private _pushAndSetState(next: State): void {\n        if (this._state === this._parseText) {\n            this._insideInlineCode = false;\n        }\n\n        this._stateStack.push(this._state);\n        this._state = next;\n    }\n\n    private _popState(): void {\n        this._state = this._stateStack.splice(0, 1)[0];\n\n        if (this._state === this._parseText) {\n            // Terminate inline code when leaving a block.\n            this._insideInlineCode = false;\n        }\n    }\n\n    private _parseText(): void {\n        if (_isUndefinedOrWhitespace(this._currentLineOrUndefined())) {\n            this._state = this._parseEmpty;\n            return;\n        }\n\n        if (this._beginBacktickBlock()) {\n            return;\n        }\n\n        if (this._beginLiteralBlock()) {\n            return;\n        }\n\n        if (this._beginDocTest()) {\n            return;\n        }\n\n        if (this._beginDirective()) {\n            return;\n        }\n\n        // TODO: Push into Google/Numpy style list parser.\n\n        this._appendTextLine(this._currentLine());\n        this._eatLine();\n    }\n\n    private _appendTextLine(line: string): void {\n        line = this._preprocessTextLine(line);\n\n        // Attempt to put directives lines into their own paragraphs.\n        // This should be removed once proper list-like parsing is written.\n        if (!this._insideInlineCode && DirectivesExtraNewlineRegex.test(line)) {\n            this._appendLine();\n        }\n\n        const parts = line.split('`');\n\n        for (let i = 0; i < parts.length; i++) {\n            let part = parts[i];\n\n            if (i > 0) {\n                this._insideInlineCode = !this._insideInlineCode;\n                this._append('`');\n            }\n\n            if (this._insideInlineCode) {\n                this._append(part);\n                continue;\n            }\n\n            if (i === 0) {\n                // Only one part, and not inside code, so check header cases.\n                if (parts.length === 1) {\n                    // Handle weird separator lines which contain random spaces.\n                    for (const expReplacement of PotentialHeaders) {\n                        if (expReplacement.exp.test(part)) {\n                            part = part.replace(WhitespaceRegex, expReplacement.replacement);\n                            break;\n                        }\n                    }\n\n                    // Replace ReST style ~~~ header to prevent it being interpreted as a code block\n                    // (an alternative in Markdown to triple backtick blocks).\n                    if (TildaHeaderRegex.test(part)) {\n                        this._append(part.replace(TildeRegEx, '-'));\n                        continue;\n                    }\n\n                    // Replace +++ heading too.\n                    // TODO: Handle the rest of these, and the precedence order (which depends on the\n                    // order heading lines are seen, not what the line contains).\n                    // http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#sections\n                    if (PlusHeaderRegex.test(part)) {\n                        this._append(part.replace(PlusRegEx, '-'));\n                        continue;\n                    }\n                }\n\n                // Don't strip away asterisk-based bullet point lists.\n                //\n                // TODO: Replace this with real list parsing. This may have\n                // false positives and cause random italics when the ReST list\n                // doesn't match Markdown's specification.\n                const match = LeadingAsteriskRegex.exec(part);\n                if (match !== null && match.length === 3) {\n                    this._append(match[1]);\n                    part = match[2];\n                }\n            }\n\n            // TODO: Find a better way to handle this; the below breaks escaped\n            // characters which appear at the beginning or end of a line.\n            // Applying this only when i == 0 or i == parts.Length-1 may work.\n\n            // http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#hyperlink-references\n            // part = Regex.Replace(part, @\"^_+\", \"\");\n            // http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#inline-internal-targets\n            // part = Regex.Replace(part, @\"_+$\", \"\");\n\n            // TODO: Strip footnote/citation references.\n\n            // Escape _, *, and ~, but ignore things like \":param \\*\\*kwargs:\".\n            part = part.replace(UnescapedMarkdownCharsRegex, '\\\\$1');\n\n            this._append(part);\n        }\n\n        // Go straight to the builder so that _appendLine doesn't think\n        // we're actually trying to insert an extra blank line and skip\n        // future whitespace. Empty line deduplication is already handled\n        // because Append is used above.\n        this._builder += '\\n';\n    }\n\n    private _preprocessTextLine(line: string): string {\n        // http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#literal-blocks\n        if (LiteralBlockEmptyRegex.test(line)) {\n            return '';\n        }\n\n        LiteralBlockReplacements.forEach((item) => (line = line.replace(item.exp, item.replacement)));\n\n        line = line.replace(DoubleTickRegEx, '`');\n        return line;\n    }\n\n    private _parseEmpty(): void {\n        if (_isUndefinedOrWhitespace(this._currentLineOrUndefined())) {\n            this._appendLine();\n            this._eatLine();\n            return;\n        }\n\n        this._state = this._parseText;\n    }\n\n    private _beginMinIndentCodeBlock(state: State): void {\n        this._appendLine('```');\n        this._pushAndSetState(state);\n        this._blockIndent = this._currentIndent();\n    }\n\n    private _beginBacktickBlock(): boolean {\n        if (this._currentLine().startsWith('```')) {\n            this._appendLine(this._currentLine());\n            this._pushAndSetState(this._parseBacktickBlock);\n            this._eatLine();\n            return true;\n        }\n        return false;\n    }\n\n    private _parseBacktickBlock(): void {\n        if (this._currentLine().startsWith('```')) {\n            this._appendLine('```');\n            this._appendLine();\n            this._popState();\n        } else {\n            this._appendLine(this._currentLine());\n        }\n\n        this._eatLine();\n    }\n\n    private _beginDocTest(): boolean {\n        if (!DoctestRegex.test(this._currentLine())) {\n            return false;\n        }\n\n        this._beginMinIndentCodeBlock(this._parseDocTest);\n        this._appendLine(this._currentLineWithinBlock());\n        this._eatLine();\n        return true;\n    }\n\n    private _parseDocTest(): void {\n        if (this._currentLineIsOutsideBlock() || _isUndefinedOrWhitespace(this._currentLine())) {\n            this._trimOutputAndAppendLine('```');\n            this._appendLine();\n            this._popState();\n            return;\n        }\n\n        this._appendLine(this._currentLineWithinBlock());\n        this._eatLine();\n    }\n\n    private _beginLiteralBlock(): boolean {\n        // The previous line must be empty.\n        const prev = this._lineAt(this._lineNum - 1);\n        if (prev === undefined) {\n            return false;\n        } else if (!_isUndefinedOrWhitespace(prev)) {\n            return false;\n        }\n\n        // Find the previous paragraph and check that it ends with ::\n        let i = this._lineNum - 2;\n        for (; i >= 0; i--) {\n            const line = this._lineAt(i);\n            if (_isUndefinedOrWhitespace(line)) {\n                continue;\n            }\n\n            // Safe to ignore whitespace after the :: because all lines have been trimRight'd.\n            if (line!.endsWith('::')) {\n                break;\n            }\n\n            return false;\n        }\n\n        if (i < 0) {\n            return false;\n        }\n\n        // Special case: allow one-liners at the same indent level.\n        if (this._currentIndent() === 0) {\n            this._appendLine('```');\n            this._pushAndSetState(this._parseLiteralBlockSingleLine);\n            return true;\n        }\n\n        this._beginMinIndentCodeBlock(this._parseLiteralBlock);\n        return true;\n    }\n\n    private _parseLiteralBlock(): void {\n        // Slightly different than doctest, wait until the first non-empty unindented line to exit.\n        if (_isUndefinedOrWhitespace(this._currentLineOrUndefined())) {\n            this._appendLine();\n            this._eatLine();\n            return;\n        }\n\n        if (this._currentLineIsOutsideBlock()) {\n            this._trimOutputAndAppendLine('```');\n            this._appendLine();\n            this._popState();\n            return;\n        }\n\n        this._appendLine(this._currentLineWithinBlock());\n        this._eatLine();\n    }\n\n    private _parseLiteralBlockSingleLine(): void {\n        this._appendLine(this._currentLine());\n        this._appendLine('```');\n        this._appendLine();\n        this._popState();\n        this._eatLine();\n    }\n\n    private _beginDirective(): boolean {\n        if (!SpaceDotDotRegex.test(this._currentLine())) {\n            return false;\n        }\n\n        this._pushAndSetState(this._parseDirective);\n        this._blockIndent = this._nextBlockIndent();\n        this._appendDirectiveBlock = false;\n        return true;\n    }\n\n    private _parseDirective(): void {\n        // http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#directives\n\n        const match = DirectiveLikeRegex.exec(this._currentLine());\n        if (match !== null && match.length === 3) {\n            const directiveType = match[1];\n            const directive = match[2];\n\n            if (directiveType === 'class') {\n                this._appendDirectiveBlock = true;\n                this._appendLine();\n                this._appendLine('```');\n                this._appendLine(directive);\n                this._appendLine('```');\n                this._appendLine();\n            }\n        }\n\n        if (this._blockIndent === 0) {\n            // This is a one-liner directive, so pop back.\n            this._popState();\n        } else {\n            this._state = this._parseDirectiveBlock;\n        }\n\n        this._eatLine();\n    }\n\n    private _parseDirectiveBlock(): void {\n        if (!_isUndefinedOrWhitespace(this._currentLineOrUndefined()) && this._currentLineIsOutsideBlock()) {\n            this._popState();\n            return;\n        }\n\n        if (this._appendDirectiveBlock) {\n            // This is a bit of a hack. This just trims the text and appends it\n            // like top-level text, rather than doing actual indent-based recursion.\n            this._appendTextLine(this._currentLine().trimLeft());\n        }\n\n        this._eatLine();\n    }\n\n    private _appendLine(line?: string): void {\n        if (!_isUndefinedOrWhitespace(line)) {\n            this._builder += line + '\\n';\n            this._skipAppendEmptyLine = false;\n        } else if (!this._skipAppendEmptyLine) {\n            this._builder += '\\n';\n            this._skipAppendEmptyLine = true;\n        }\n    }\n\n    private _append(text: string): void {\n        this._builder += text;\n        this._skipAppendEmptyLine = false;\n    }\n\n    private _trimOutputAndAppendLine(line: string, noNewLine = false): void {\n        this._builder = this._builder.trimRight();\n        this._skipAppendEmptyLine = false;\n\n        if (!noNewLine) {\n            this._appendLine();\n        }\n\n        this._appendLine(line);\n    }\n}\n\nfunction _splitDocString(docstring: string): string[] {\n    // As done by inspect.cleandoc.\n    docstring = docstring.replace(TabRegEx, ' '.repeat(8));\n\n    let lines = docstring.split(CrLfRegEx).map((v) => v.trimRight());\n    if (lines.length > 0) {\n        let first: string | undefined = lines[0].trimLeft();\n        if (first === '') {\n            first = undefined;\n        } else {\n            lines.splice(0, 1);\n        }\n\n        lines = _stripLeadingWhitespace(lines);\n\n        if (first !== undefined) {\n            lines.splice(0, 0, first);\n        }\n    }\n\n    return lines;\n}\n\nfunction _stripLeadingWhitespace(lines: string[], trim?: number): string[] {\n    const amount = trim === undefined ? _largestTrim(lines) : trim;\n    return lines.map((line) => (amount > line.length ? '' : line.substr(amount)));\n}\n\nfunction _largestTrim(lines: string[]): number {\n    const nonEmptyLines = lines.filter((s) => !_isUndefinedOrWhitespace(s));\n    const counts = nonEmptyLines.map(_countLeadingSpaces);\n    const largest = counts.length > 0 ? Math.min(...counts) : 0;\n    return largest;\n}\n\nfunction _countLeadingSpaces(s: string): number {\n    return s.search(LeadingSpaceCountRegEx);\n}\n\nfunction _isUndefinedOrWhitespace(s: string | undefined): boolean {\n    return s === undefined || !NonWhitespaceRegEx.test(s);\n}\n","/*\n * docStringUtils.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Static methods that format and parse doc strings based on\n * the rules specified in PEP 257\n * (https://www.python.org/dev/peps/pep-0257/).\n */\n\nexport function decodeDocString(rawString: string): string {\n    // Remove carriage returns and replace tabs.\n    const unescaped = rawString.replace(/\\r/g, '').replace(/\\t/g, '        ');\n\n    // Split into lines.\n    const lines = unescaped.split('\\n');\n\n    // Determine the max indent amount.\n    let leftSpacesToRemove = Number.MAX_VALUE;\n    lines.forEach((line, index) => {\n        // First line is special.\n        if (lines.length <= 1 || index > 0) {\n            const trimmed = line.trimLeft();\n            if (trimmed) {\n                leftSpacesToRemove = Math.min(leftSpacesToRemove, line.length - trimmed.length);\n            }\n        }\n    });\n\n    // If there was only\n    if (leftSpacesToRemove >= Number.MAX_VALUE) {\n        leftSpacesToRemove = 0;\n    }\n\n    // Trim the lines.\n    const trimmedLines: string[] = [];\n    lines.forEach((line, index) => {\n        if (index === 0) {\n            trimmedLines.push(line.trimRight());\n        } else {\n            trimmedLines.push(line.substr(leftSpacesToRemove).trimRight());\n        }\n    });\n\n    // Strip off leading and trailing blank lines.\n    while (trimmedLines.length > 0 && trimmedLines[0].length === 0) {\n        trimmedLines.shift();\n    }\n\n    while (trimmedLines.length > 0 && trimmedLines[trimmedLines.length - 1].length === 0) {\n        trimmedLines.pop();\n    }\n\n    return trimmedLines.join('\\n');\n}\n\nexport function extractParameterDocumentation(functionDocString: string, paramName: string): string | undefined {\n    if (!functionDocString || !paramName) {\n        return undefined;\n    }\n\n    // Python doesn't have a single standard for param documentation. There are three\n    // popular styles.\n    //\n    // 1. Epytext:\n    //      @param param1: description\n    // 2. reST:\n    //      :param param1: description\n    // 3. Google (variant 1):\n    //      Args:\n    //          param1: description\n    // 4. Google (variant 2):\n    //      Args:\n    //          param1 (type): description\n\n    const docStringLines = functionDocString.split('\\n');\n    for (const line of docStringLines) {\n        const trimmedLine = line.trim();\n\n        // Check for Epytext\n        let paramOffset = trimmedLine.indexOf('@param ' + paramName);\n        if (paramOffset >= 0) {\n            return trimmedLine.substr(paramOffset + 7);\n        }\n\n        // Check for reST format\n        paramOffset = trimmedLine.indexOf(':param ' + paramName);\n        if (paramOffset >= 0) {\n            return trimmedLine.substr(paramOffset + 7);\n        }\n\n        // Check for Google (variant 1) format\n        paramOffset = trimmedLine.indexOf(paramName + ': ');\n        if (paramOffset >= 0) {\n            return trimmedLine.substr(paramOffset);\n        }\n\n        // Check for Google (variant 1) format\n        paramOffset = trimmedLine.indexOf(paramName + ' (');\n        if (paramOffset >= 0) {\n            return trimmedLine.substr(paramOffset);\n        }\n    }\n\n    return undefined;\n}\n","/*\n * importResolver.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Provides the logic for resolving imports according to the\n * runtime rules of Python.\n */\n\nimport { ConfigOptions, ExecutionEnvironment } from '../common/configOptions';\nimport { FileSystem } from '../common/fileSystem';\nimport {\n    changeAnyExtension,\n    combinePathComponents,\n    combinePaths,\n    containsPath,\n    ensureTrailingDirectorySeparator,\n    getDirectoryPath,\n    getFileExtension,\n    getFileName,\n    getFileSystemEntries,\n    getPathComponents,\n    getRelativePathComponentsFromDirectory,\n    isDirectory,\n    isFile,\n    resolvePaths,\n    stripFileExtension,\n    stripTrailingDirectorySeparator,\n} from '../common/pathUtils';\nimport { versionToString } from '../common/pythonVersion';\nimport { equateStringsCaseInsensitive } from '../common/stringUtils';\nimport * as StringUtils from '../common/stringUtils';\nimport { isIdentifierChar, isIdentifierStartChar } from '../parser/characters';\nimport { ImplicitImport, ImportResult, ImportType } from './importResult';\nimport * as PythonPathUtils from './pythonPathUtils';\nimport { isDunderName } from './symbolNameUtils';\n\nexport interface ImportedModuleDescriptor {\n    leadingDots: number;\n    nameParts: string[];\n    hasTrailingDot?: boolean;\n    importedSymbols: string[] | undefined;\n}\n\nexport interface ModuleNameAndType {\n    moduleName: string;\n    importType: ImportType;\n    isLocalTypingsFile: boolean;\n}\n\ntype CachedImportResults = Map<string, ImportResult>;\n\nconst supportedNativeLibExtensions = ['.pyd', '.so', '.dylib'];\nconst supportedFileExtensions = ['.py', '.pyi', ...supportedNativeLibExtensions];\nconst stubsSuffix = '-stubs';\nconst pyTypedFileName = 'py.typed';\n\n// Should we allow partial resolution for third-party packages? Some use tricks\n// to populate their package namespaces, so we might be able to partially resolve\n// a multi - part import(e.g. \"a.b.c\") but not fully resolve it. If this is set to\n// false, we will have some false positives. If it is set to true, we won't report\n// errors when these partial-resolutions fail.\nconst allowPartialResolutionForThirdPartyPackages = false;\n\ninterface PyTypedInfo {\n    isPyTypedPresent: boolean;\n    isPartiallyTyped: boolean;\n}\n\nexport class ImportResolver {\n    private _configOptions: ConfigOptions;\n    private _cachedPythonSearchPaths = new Map<string, string[]>();\n    private _cachedImportResults = new Map<string, CachedImportResults>();\n    private _cachedTypeshedStdLibPath: string | undefined;\n    private _cachedTypeshedThirdPartyPath: string | undefined;\n\n    readonly fileSystem: FileSystem;\n\n    constructor(fs: FileSystem, configOptions: ConfigOptions) {\n        this.fileSystem = fs;\n        this._configOptions = configOptions;\n    }\n\n    invalidateCache() {\n        this._cachedPythonSearchPaths = new Map<string, string[]>();\n        this._cachedImportResults = new Map<string, CachedImportResults>();\n    }\n\n    // Resolves the import and returns the path if it exists, otherwise\n    // returns undefined.\n    resolveImport(\n        sourceFilePath: string,\n        execEnv: ExecutionEnvironment,\n        moduleDescriptor: ImportedModuleDescriptor\n    ): ImportResult {\n        const importName = this._formatImportName(moduleDescriptor);\n        const importFailureInfo: string[] = [];\n\n        const notFoundResult: ImportResult = {\n            importName,\n            isRelative: false,\n            isImportFound: false,\n            isNamespacePackage: false,\n            importFailureInfo,\n            resolvedPaths: [],\n            importType: ImportType.Local,\n            isStubFile: false,\n            isNativeLib: false,\n            implicitImports: [],\n            nonStubImportResult: undefined,\n        };\n\n        // Is it a relative import?\n        if (moduleDescriptor.leadingDots > 0) {\n            const relativeImport = this._resolveRelativeImport(\n                sourceFilePath,\n                moduleDescriptor,\n                importName,\n                importFailureInfo\n            );\n\n            if (relativeImport) {\n                relativeImport.isRelative = true;\n                return relativeImport;\n            }\n        } else {\n            // Is it already cached?\n            const cachedResults = this._lookUpResultsInCache(execEnv, importName, moduleDescriptor.importedSymbols);\n            if (cachedResults) {\n                return cachedResults;\n            }\n\n            const bestImport = this._resolveBestAbsoluteImport(sourceFilePath, execEnv, moduleDescriptor, true);\n            if (bestImport) {\n                if (bestImport.isStubFile) {\n                    bestImport.nonStubImportResult =\n                        this._resolveBestAbsoluteImport(sourceFilePath, execEnv, moduleDescriptor, false) ||\n                        notFoundResult;\n                }\n                return this.addResultsToCache(execEnv, importName, bestImport, moduleDescriptor.importedSymbols);\n            }\n        }\n\n        return this.addResultsToCache(execEnv, importName, notFoundResult, undefined);\n    }\n\n    getCompletionSuggestions(\n        sourceFilePath: string,\n        execEnv: ExecutionEnvironment,\n        moduleDescriptor: ImportedModuleDescriptor,\n        similarityLimit: number\n    ): string[] {\n        const importFailureInfo: string[] = [];\n        const suggestions: string[] = [];\n\n        // Is it a relative import?\n        if (moduleDescriptor.leadingDots > 0) {\n            this._getCompletionSuggestionsRelative(sourceFilePath, moduleDescriptor, suggestions, similarityLimit);\n        } else {\n            // First check for a typeshed file.\n            if (moduleDescriptor.nameParts.length > 0) {\n                this._getCompletionSuggestionsTypeshedPath(\n                    execEnv,\n                    moduleDescriptor,\n                    true,\n                    suggestions,\n                    similarityLimit\n                );\n            }\n\n            // Look for it in the root directory of the execution environment.\n            this._getCompletionSuggestionsAbsolute(execEnv.root, moduleDescriptor, suggestions, similarityLimit);\n\n            for (const extraPath of execEnv.extraPaths) {\n                this._getCompletionSuggestionsAbsolute(extraPath, moduleDescriptor, suggestions, similarityLimit);\n            }\n\n            // Check for a typings file.\n            if (this._configOptions.stubPath) {\n                this._getCompletionSuggestionsAbsolute(\n                    this._configOptions.stubPath,\n                    moduleDescriptor,\n                    suggestions,\n                    similarityLimit\n                );\n            }\n\n            // Check for a typeshed file.\n            this._getCompletionSuggestionsTypeshedPath(execEnv, moduleDescriptor, false, suggestions, similarityLimit);\n\n            // Look for the import in the list of third-party packages.\n            const pythonSearchPaths = this._getPythonSearchPaths(execEnv, importFailureInfo);\n            for (const searchPath of pythonSearchPaths) {\n                this._getCompletionSuggestionsAbsolute(searchPath, moduleDescriptor, suggestions, similarityLimit);\n            }\n        }\n\n        return suggestions;\n    }\n\n    // Returns the implementation file(s) for the given stub file.\n    getSourceFilesFromStub(stubFilePath: string, execEnv: ExecutionEnvironment): string[] {\n        const sourceFilePaths: string[] = [];\n\n        // When ImportResolver resolves an import to a stub file, a second resolve is done\n        // ignoring stub files, which gives us an approximation of where the implementation\n        // for that stub is located.\n        this._cachedImportResults.forEach((map, env) => {\n            map.forEach((result, importName) => {\n                if (result.isStubFile && result.isImportFound && result.nonStubImportResult) {\n                    if (result.resolvedPaths.some((f) => f === stubFilePath)) {\n                        if (result.nonStubImportResult.isImportFound) {\n                            const nonEmptyPaths = result.nonStubImportResult.resolvedPaths.filter((p) =>\n                                p.endsWith('.py')\n                            );\n                            sourceFilePaths.push(...nonEmptyPaths);\n                        }\n                    }\n                }\n            });\n        });\n\n        // We haven't seen an import of that stub, attempt to find the source\n        // in some other ways.\n        if (sourceFilePaths.length === 0) {\n            // Simple case where the stub and source files are next to each other.\n            const sourceFilePath = changeAnyExtension(stubFilePath, '.py');\n            if (this.fileSystem.existsSync(sourceFilePath)) {\n                sourceFilePaths.push(sourceFilePath);\n            }\n        }\n\n        if (sourceFilePaths.length === 0) {\n            // The stub and the source file may have the same name, but be located\n            // in different folder hierarchies.\n            // Example:\n            // <stubPath>\\package\\module.pyi\n            // <site-packages>\\package\\module.py\n            // We get the relative path(s) of the stub to its import root(s),\n            // in theory there can be more than one, then look for source\n            // files in all the import roots using the same relative path(s).\n            const importRootPaths = this.getImportRoots(execEnv, /* useTypeshedVersionedFolders */ true);\n\n            const relativeStubPaths: string[] = [];\n            for (const importRootPath of importRootPaths) {\n                if (containsPath(importRootPath, stubFilePath, true)) {\n                    const parts = getRelativePathComponentsFromDirectory(importRootPath, stubFilePath, true);\n\n                    // Note that relative paths have an empty parts[0]\n                    if (parts.length > 1) {\n                        // Handle the case where the symbol was resolved to a stubs package\n                        // rather than the real package. We'll strip off the \"-stubs\" suffix\n                        // in this case.\n                        if (parts[1].endsWith(stubsSuffix)) {\n                            parts[1] = parts[1].substr(0, parts[1].length - stubsSuffix.length);\n                        }\n\n                        const relativeStubPath = combinePathComponents(parts);\n                        if (relativeStubPath) {\n                            relativeStubPaths.push(relativeStubPath);\n                        }\n                    }\n                }\n            }\n\n            for (const relativeStubPath of relativeStubPaths) {\n                for (const importRootPath of importRootPaths) {\n                    const absoluteStubPath = resolvePaths(importRootPath, relativeStubPath);\n                    let absoluteSourcePath = changeAnyExtension(absoluteStubPath, '.py');\n                    if (this.fileSystem.existsSync(absoluteSourcePath)) {\n                        sourceFilePaths.push(absoluteSourcePath);\n                    } else {\n                        const filePathWithoutExtension = stripFileExtension(absoluteSourcePath);\n\n                        if (filePathWithoutExtension.endsWith('__init__')) {\n                            // Did not match: <root>/package/__init__.py\n                            // Try equivalent: <root>/package.py\n                            absoluteSourcePath =\n                                filePathWithoutExtension.substr(0, filePathWithoutExtension.length - 9) + '.py';\n                            if (this.fileSystem.existsSync(absoluteSourcePath)) {\n                                sourceFilePaths.push(absoluteSourcePath);\n                            }\n                        } else {\n                            // Did not match: <root>/package.py\n                            // Try equivalent: <root>/package/__init__.py\n                            absoluteSourcePath = combinePaths(filePathWithoutExtension, '__init__.py');\n                            if (this.fileSystem.existsSync(absoluteSourcePath)) {\n                                sourceFilePaths.push(absoluteSourcePath);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return sourceFilePaths;\n    }\n\n    // Returns the module name (of the form X.Y.Z) that needs to be imported\n    // from the current context to access the module with the specified file path.\n    // In a sense, it's performing the inverse of resolveImport.\n    getModuleNameForImport(filePath: string, execEnv: ExecutionEnvironment): ModuleNameAndType {\n        let moduleName: string | undefined;\n        let importType = ImportType.BuiltIn;\n        let isLocalTypingsFile = false;\n\n        const importFailureInfo: string[] = [];\n\n        // Is this a stdlib typeshed path?\n        const stdLibTypeshedPath = this._getTypeshedPath(true, execEnv, importFailureInfo);\n        if (stdLibTypeshedPath) {\n            moduleName = this._getModuleNameFromPath(stdLibTypeshedPath, filePath, true);\n            if (moduleName) {\n                return { moduleName, importType, isLocalTypingsFile };\n            }\n        }\n\n        // Look for it in the root directory of the execution environment.\n        moduleName = this._getModuleNameFromPath(execEnv.root, filePath);\n\n        for (const extraPath of execEnv.extraPaths) {\n            const candidateModuleName = this._getModuleNameFromPath(extraPath, filePath);\n\n            // Does this candidate look better than the previous best module name?\n            // We'll always try to use the shortest version.\n            if (!moduleName || (candidateModuleName && candidateModuleName.length < moduleName.length)) {\n                moduleName = candidateModuleName;\n                importType = ImportType.Local;\n            }\n        }\n\n        // Check for a typings file.\n        if (this._configOptions.stubPath) {\n            const candidateModuleName = this._getModuleNameFromPath(this._configOptions.stubPath, filePath);\n\n            // Does this candidate look better than the previous best module name?\n            // We'll always try to use the shortest version.\n            if (!moduleName || (candidateModuleName && candidateModuleName.length < moduleName.length)) {\n                moduleName = candidateModuleName;\n\n                // Treat the typings path as a local import so errors are reported for it.\n                importType = ImportType.Local;\n                isLocalTypingsFile = true;\n            }\n        }\n\n        // Check for a typeshed file.\n        const thirdPartyTypeshedPath = this._getTypeshedPath(false, execEnv, importFailureInfo);\n        if (thirdPartyTypeshedPath) {\n            const candidateModuleName = this._getModuleNameFromPath(thirdPartyTypeshedPath, filePath, true);\n\n            // Does this candidate look better than the previous best module name?\n            // We'll always try to use the shortest version.\n            if (!moduleName || (candidateModuleName && candidateModuleName.length < moduleName.length)) {\n                moduleName = candidateModuleName;\n                importType = ImportType.ThirdParty;\n            }\n        }\n\n        const thirdPartyTypeshedPathEx = this.getTypeshedPathEx(execEnv, importFailureInfo);\n        if (thirdPartyTypeshedPathEx) {\n            const candidateModuleName = this._getModuleNameFromPath(thirdPartyTypeshedPathEx, filePath);\n\n            // Does this candidate look better than the previous best module name?\n            // We'll always try to use the shortest version.\n            if (!moduleName || (candidateModuleName && candidateModuleName.length < moduleName.length)) {\n                moduleName = candidateModuleName;\n                importType = ImportType.ThirdParty;\n            }\n        }\n\n        // Look for the import in the list of third-party packages.\n        const pythonSearchPaths = this._getPythonSearchPaths(execEnv, importFailureInfo);\n        for (const searchPath of pythonSearchPaths) {\n            const candidateModuleName = this._getModuleNameFromPath(searchPath, filePath);\n\n            // Does this candidate look better than the previous best module name?\n            // We'll always try to use the shortest version.\n            if (!moduleName || (candidateModuleName && candidateModuleName.length < moduleName.length)) {\n                moduleName = candidateModuleName;\n                importType = ImportType.ThirdParty;\n            }\n        }\n\n        if (moduleName) {\n            return { moduleName, importType, isLocalTypingsFile };\n        }\n\n        // We didn't find any module name.\n        return { moduleName: '', importType: ImportType.Local, isLocalTypingsFile };\n    }\n\n    getTypeshedStdLibPath(execEnv: ExecutionEnvironment) {\n        const unused: string[] = [];\n        return this._getTypeshedPath(true, execEnv, unused);\n    }\n\n    getImportRoots(execEnv: ExecutionEnvironment, useTypeshedVersionedFolders: boolean) {\n        const importFailureInfo: string[] = [];\n        const roots = [];\n\n        const pythonVersion = execEnv.pythonVersion;\n        const minorVersion = pythonVersion & 0xff;\n        const versionFolders = ['2and3', '3'];\n        if (minorVersion > 0) {\n            versionFolders.push(versionToString(0x300 + minorVersion));\n        }\n\n        const stdTypeshed = this._getTypeshedPath(true, execEnv, importFailureInfo);\n        if (stdTypeshed) {\n            if (useTypeshedVersionedFolders) {\n                roots.push(...versionFolders.map((vf) => combinePaths(stdTypeshed, vf)));\n            } else {\n                roots.push(stdTypeshed);\n            }\n        }\n\n        roots.push(execEnv.root);\n        roots.push(...execEnv.extraPaths);\n\n        if (this._configOptions.stubPath) {\n            roots.push(this._configOptions.stubPath);\n        }\n\n        const typeshedPath = this._getTypeshedPath(false, execEnv, importFailureInfo);\n        if (typeshedPath) {\n            if (useTypeshedVersionedFolders) {\n                roots.push(...versionFolders.map((vf) => combinePaths(typeshedPath, vf)));\n            } else {\n                roots.push(typeshedPath);\n            }\n        }\n\n        const typeshedPathEx = this.getTypeshedPathEx(execEnv, importFailureInfo);\n        if (typeshedPathEx) {\n            roots.push(typeshedPathEx);\n        }\n\n        const pythonSearchPaths = this._getPythonSearchPaths(execEnv, importFailureInfo);\n        if (pythonSearchPaths.length > 0) {\n            roots.push(...pythonSearchPaths);\n        }\n\n        return roots;\n    }\n\n    protected addResultsToCache(\n        execEnv: ExecutionEnvironment,\n        importName: string,\n        importResult: ImportResult,\n        importedSymbols: string[] | undefined\n    ) {\n        let cacheForExecEnv = this._cachedImportResults.get(execEnv.root);\n        if (!cacheForExecEnv) {\n            cacheForExecEnv = new Map<string, ImportResult>();\n            this._cachedImportResults.set(execEnv.root, cacheForExecEnv);\n        }\n\n        cacheForExecEnv.set(importName, importResult);\n\n        return this._filterImplicitImports(importResult, importedSymbols);\n    }\n\n    // Follows import resolution algorithm defined in PEP-420:\n    // https://www.python.org/dev/peps/pep-0420/\n    protected resolveAbsoluteImport(\n        rootPath: string,\n        moduleDescriptor: ImportedModuleDescriptor,\n        importName: string,\n        importFailureInfo: string[],\n        allowPartial = false,\n        allowNativeLib = false,\n        useStubPackage = false,\n        allowPyi = true\n    ): ImportResult {\n        importFailureInfo.push(`Attempting to resolve using root path '${rootPath}'`);\n\n        // Starting at the specified path, walk the file system to find the\n        // specified module.\n        const resolvedPaths: string[] = [];\n        let dirPath = rootPath;\n        let isNamespacePackage = false;\n        let isStubFile = false;\n        let isNativeLib = false;\n        let implicitImports: ImplicitImport[] = [];\n        let packageDirectory: string | undefined;\n\n        // Handle the \"from . import XXX\" case.\n        if (moduleDescriptor.nameParts.length === 0) {\n            const fileNameWithoutExtension = '__init__';\n            const pyFilePath = combinePaths(dirPath, fileNameWithoutExtension + '.py');\n            const pyiFilePath = combinePaths(dirPath, fileNameWithoutExtension + '.pyi');\n\n            if (allowPyi && this.fileSystem.existsSync(pyiFilePath) && isFile(this.fileSystem, pyiFilePath)) {\n                importFailureInfo.push(`Resolved import with file '${pyiFilePath}'`);\n                resolvedPaths.push(pyiFilePath);\n                isStubFile = true;\n            } else if (this.fileSystem.existsSync(pyFilePath) && isFile(this.fileSystem, pyFilePath)) {\n                importFailureInfo.push(`Resolved import with file '${pyFilePath}'`);\n                resolvedPaths.push(pyFilePath);\n            } else {\n                importFailureInfo.push(`Partially resolved import with directory '${dirPath}'`);\n                resolvedPaths.push('');\n                isNamespacePackage = true;\n            }\n\n            implicitImports = this._findImplicitImports(dirPath, [pyFilePath, pyiFilePath]);\n        } else {\n            for (let i = 0; i < moduleDescriptor.nameParts.length; i++) {\n                const isFirstPart = i === 0;\n                const isLastPart = i === moduleDescriptor.nameParts.length - 1;\n                dirPath = combinePaths(dirPath, moduleDescriptor.nameParts[i]);\n\n                if (useStubPackage && isFirstPart) {\n                    dirPath += stubsSuffix;\n                }\n\n                const foundDirectory = this.fileSystem.existsSync(dirPath) && isDirectory(this.fileSystem, dirPath);\n\n                if (foundDirectory) {\n                    if (isFirstPart) {\n                        packageDirectory = dirPath;\n                    }\n\n                    if (!isLastPart) {\n                        // We are not at the last part, and we found a directory,\n                        // so continue to look for the next part.\n                        resolvedPaths.push('');\n                        continue;\n                    }\n\n                    // See if we can find an __init__.py[i] in this directory.\n                    const fileNameWithoutExtension = '__init__';\n                    const pyFilePath = combinePaths(dirPath, fileNameWithoutExtension + '.py');\n                    const pyiFilePath = combinePaths(dirPath, fileNameWithoutExtension + '.pyi');\n                    let foundInit = false;\n\n                    if (allowPyi && this.fileSystem.existsSync(pyiFilePath) && isFile(this.fileSystem, pyiFilePath)) {\n                        importFailureInfo.push(`Resolved import with file '${pyiFilePath}'`);\n                        resolvedPaths.push(pyiFilePath);\n                        if (isLastPart) {\n                            isStubFile = true;\n                        }\n                        foundInit = true;\n                    } else if (this.fileSystem.existsSync(pyFilePath) && isFile(this.fileSystem, pyFilePath)) {\n                        importFailureInfo.push(`Resolved import with file '${pyFilePath}'`);\n                        resolvedPaths.push(pyFilePath);\n                        foundInit = true;\n                    }\n\n                    if (foundInit) {\n                        implicitImports = this._findImplicitImports(dirPath, [pyFilePath, pyiFilePath]);\n                        break;\n                    }\n                }\n\n                // We weren't able to find a directory or we found a directory with\n                // no __init__.py[i] file. See if we can find a \".py\" or \".pyi\" file\n                // with this name.\n                let fileDirectory = stripTrailingDirectorySeparator(dirPath);\n                const fileNameWithoutExtension = getFileName(fileDirectory);\n                fileDirectory = getDirectoryPath(fileDirectory);\n                const pyFilePath = combinePaths(fileDirectory, fileNameWithoutExtension + '.py');\n                const pyiFilePath = combinePaths(fileDirectory, fileNameWithoutExtension + '.pyi');\n\n                if (allowPyi && this.fileSystem.existsSync(pyiFilePath) && isFile(this.fileSystem, pyiFilePath)) {\n                    importFailureInfo.push(`Resolved import with file '${pyiFilePath}'`);\n                    resolvedPaths.push(pyiFilePath);\n                    if (isLastPart) {\n                        isStubFile = true;\n                    }\n                } else if (this.fileSystem.existsSync(pyFilePath) && isFile(this.fileSystem, pyFilePath)) {\n                    importFailureInfo.push(`Resolved import with file '${pyFilePath}'`);\n                    resolvedPaths.push(pyFilePath);\n                } else {\n                    if (\n                        allowNativeLib &&\n                        this.fileSystem.existsSync(fileDirectory) &&\n                        isDirectory(this.fileSystem, fileDirectory)\n                    ) {\n                        const filesInDir = this._getFilesInDirectory(fileDirectory);\n                        const nativeLibFileName = filesInDir.find((f) => {\n                            // Strip off the final file extension and the part of the file name\n                            // that excludes all (multi-part) file extensions. This allows us to\n                            // handle file names like \"foo.cpython-32m.so\".\n                            const fileExtension = getFileExtension(f, /* multiDotExtension */ false).toLowerCase();\n                            const withoutExtension = stripFileExtension(f, /* multiDotExtension */ true);\n                            if (supportedNativeLibExtensions.some((ext) => ext === fileExtension)) {\n                                if (equateStringsCaseInsensitive(fileNameWithoutExtension, withoutExtension)) {\n                                    return true;\n                                }\n                            }\n\n                            return false;\n                        });\n\n                        if (nativeLibFileName) {\n                            const nativeLibPath = combinePaths(fileDirectory, nativeLibFileName);\n                            importFailureInfo.push(`Resolved import with file '${nativeLibPath}'`);\n                            resolvedPaths.push(nativeLibPath);\n                            isNativeLib = true;\n                        }\n                    }\n\n                    if (!isNativeLib && foundDirectory) {\n                        importFailureInfo.push(`Partially resolved import with directory '${dirPath}'`);\n                        resolvedPaths.push('');\n                        if (isLastPart) {\n                            implicitImports = this._findImplicitImports(dirPath, [pyFilePath, pyiFilePath]);\n                            isNamespacePackage = true;\n                        }\n                    } else {\n                        importFailureInfo.push(`Did not find file '${pyiFilePath}' or '${pyFilePath}'`);\n                    }\n                }\n                break;\n            }\n        }\n\n        let importFound: boolean;\n        if (allowPartial) {\n            importFound = resolvedPaths.length > 0;\n        } else {\n            importFound = resolvedPaths.length >= moduleDescriptor.nameParts.length;\n\n            // Empty namespace packages are not allowed.\n            if (isNamespacePackage && implicitImports.length === 0) {\n                importFound = false;\n            }\n        }\n\n        return {\n            importName,\n            isRelative: false,\n            isNamespacePackage,\n            isImportFound: importFound,\n            importFailureInfo,\n            importType: ImportType.Local,\n            resolvedPaths,\n            searchPath: rootPath,\n            isStubFile,\n            isNativeLib,\n            implicitImports,\n            packageDirectory,\n        };\n    }\n\n    // Intended to be overridden by subclasses to provide additional stub\n    // path capabilities. Return undefined if no extra stub path were found.\n    protected getTypeshedPathEx(execEnv: ExecutionEnvironment, importFailureInfo: string[]): string | undefined {\n        return undefined;\n    }\n\n    // Intended to be overridden by subclasses to provide additional stub\n    // resolving capabilities. Return undefined if no stubs were found for\n    // this import.\n    protected resolveImportEx(\n        sourceFilePath: string,\n        execEnv: ExecutionEnvironment,\n        moduleDescriptor: ImportedModuleDescriptor,\n        importName: string,\n        importFailureInfo: string[] = [],\n        allowPyi = true\n    ): ImportResult | undefined {\n        return undefined;\n    }\n\n    private _getPyTypedInfo(dirPath: string): PyTypedInfo {\n        let isPyTypedPresent = false;\n        let isPartiallyTyped = false;\n\n        if (this.fileSystem.existsSync(dirPath) && isDirectory(this.fileSystem, dirPath)) {\n            const pyTypedPath = combinePaths(dirPath, pyTypedFileName);\n\n            if (this.fileSystem.existsSync(dirPath) && isFile(this.fileSystem, pyTypedPath)) {\n                isPyTypedPresent = true;\n\n                // Read the contents of the file as text.\n                const fileStats = this.fileSystem.statSync(pyTypedPath);\n\n                // Do a quick sanity check on the size before we attempt to read it. This\n                // file should always be really small - typically zero bytes in length.\n                if (fileStats.size > 0 && fileStats.size < 16 * 1024) {\n                    const pyTypedContents = this.fileSystem.readFileSync(pyTypedPath, 'utf8');\n\n                    // PEP 561 doesn't specify the format of \"py.typed\" in any detail other than\n                    // to say that \"If a stub package is partial it MUST include partial\\n in a top\n                    // level py.typed file.\"\n                    if (pyTypedContents.match(/partial\\n/) || pyTypedContents.match(/partial\\r\\n/)) {\n                        isPartiallyTyped = true;\n                    }\n                }\n            }\n        }\n\n        return {\n            isPyTypedPresent,\n            isPartiallyTyped,\n        };\n    }\n\n    private _lookUpResultsInCache(\n        execEnv: ExecutionEnvironment,\n        importName: string,\n        importedSymbols: string[] | undefined\n    ) {\n        const cacheForExecEnv = this._cachedImportResults.get(execEnv.root);\n        if (!cacheForExecEnv) {\n            return undefined;\n        }\n\n        const cachedEntry = cacheForExecEnv.get(importName);\n        if (!cachedEntry) {\n            return undefined;\n        }\n\n        return this._filterImplicitImports(cachedEntry, importedSymbols);\n    }\n\n    private _getModuleNameFromPath(\n        containerPath: string,\n        filePath: string,\n        stripTopContainerDir = false\n    ): string | undefined {\n        containerPath = ensureTrailingDirectorySeparator(containerPath);\n        let filePathWithoutExtension = stripFileExtension(filePath);\n\n        if (!filePathWithoutExtension.startsWith(containerPath)) {\n            return undefined;\n        }\n\n        // Strip off the '/__init__' if it's present.\n        if (filePathWithoutExtension.endsWith('__init__')) {\n            filePathWithoutExtension = filePathWithoutExtension.substr(0, filePathWithoutExtension.length - 9);\n        }\n\n        const relativeFilePath = filePathWithoutExtension.substr(containerPath.length);\n        const parts = getPathComponents(relativeFilePath);\n        parts.shift();\n        if (stripTopContainerDir) {\n            if (parts.length === 0) {\n                return undefined;\n            }\n            parts.shift();\n        }\n\n        if (parts.length === 0) {\n            return undefined;\n        }\n\n        // Handle the case where the symbol was resolved to a stubs package\n        // rather than the real package. We'll strip off the \"-stubs\" suffix\n        // in this case.\n        if (parts[0].endsWith(stubsSuffix)) {\n            parts[0] = parts[0].substr(0, parts[0].length - stubsSuffix.length);\n        }\n\n        // Check whether parts contains invalid characters.\n        if (parts.some((p) => !this._isIdentifier(p))) {\n            return undefined;\n        }\n\n        return parts.join('.');\n    }\n\n    private _resolveBestAbsoluteImport(\n        sourceFilePath: string,\n        execEnv: ExecutionEnvironment,\n        moduleDescriptor: ImportedModuleDescriptor,\n        allowPyi: boolean\n    ): ImportResult | undefined {\n        const importName = this._formatImportName(moduleDescriptor);\n        const importFailureInfo: string[] = [];\n\n        // First check for a stdlib typeshed file.\n        if (allowPyi && moduleDescriptor.nameParts.length > 0) {\n            const builtInImport = this._findTypeshedPath(\n                execEnv,\n                moduleDescriptor,\n                importName,\n                /* isStdLib */ true,\n                importFailureInfo\n            );\n            if (builtInImport) {\n                builtInImport.isTypeshedFile = true;\n                return builtInImport;\n            }\n        }\n\n        if (allowPyi) {\n            // Check for a local stub file using stubPath.\n            if (this._configOptions.stubPath) {\n                importFailureInfo.push(`Looking in stubPath '${this._configOptions.stubPath}'`);\n                const typingsImport = this.resolveAbsoluteImport(\n                    this._configOptions.stubPath,\n                    moduleDescriptor,\n                    importName,\n                    importFailureInfo\n                );\n\n                if (typingsImport.isImportFound) {\n                    // We will treat typings files as \"local\" rather than \"third party\".\n                    typingsImport.importType = ImportType.Local;\n                    typingsImport.isLocalTypingsFile = true;\n                    return typingsImport;\n                }\n            }\n        }\n\n        let bestResultSoFar: ImportResult | undefined;\n\n        // Look for it in the root directory of the execution environment.\n        importFailureInfo.push(`Looking in root directory of execution environment ` + `'${execEnv.root}'`);\n        let localImport = this.resolveAbsoluteImport(\n            execEnv.root,\n            moduleDescriptor,\n            importName,\n            importFailureInfo,\n            /* allowPartial */ undefined,\n            /* allowNativeLib */ true,\n            /* useStubPackage */ undefined,\n            allowPyi\n        );\n        if (localImport.isImportFound && !localImport.isNamespacePackage) {\n            return localImport;\n        }\n        bestResultSoFar = localImport;\n\n        for (const extraPath of execEnv.extraPaths) {\n            importFailureInfo.push(`Looking in extraPath '${extraPath}'`);\n            localImport = this.resolveAbsoluteImport(\n                extraPath,\n                moduleDescriptor,\n                importName,\n                importFailureInfo,\n                /* allowPartial */ undefined,\n                /* allowNativeLib */ true,\n                /* useStubPackage */ undefined,\n                allowPyi\n            );\n            if (localImport.isImportFound) {\n                return localImport;\n            }\n\n            if (\n                localImport &&\n                (bestResultSoFar === undefined ||\n                    (!bestResultSoFar.isImportFound && localImport.isImportFound) ||\n                    (bestResultSoFar.isNamespacePackage && !localImport.isNamespacePackage) ||\n                    localImport.resolvedPaths.length > bestResultSoFar.resolvedPaths.length)\n            ) {\n                bestResultSoFar = localImport;\n            }\n        }\n\n        // Look for the import in the list of third-party packages.\n        const pythonSearchPaths = this._getPythonSearchPaths(execEnv, importFailureInfo);\n        if (pythonSearchPaths.length > 0) {\n            for (const searchPath of pythonSearchPaths) {\n                importFailureInfo.push(`Looking in python search path '${searchPath}'`);\n\n                // Is there a \"py.typed\" file present?\n                const dirPath = combinePaths(searchPath, moduleDescriptor.nameParts[0]);\n                let pyTypedInfo: PyTypedInfo | undefined;\n                let thirdPartyImport: ImportResult | undefined;\n\n                if (allowPyi) {\n                    pyTypedInfo = this._getPyTypedInfo(dirPath + stubsSuffix);\n\n                    // Look for packaged stubs first. PEP 561 indicates that package authors can ship\n                    // their stubs separately from their package implementation by appending the string\n                    // '-stubs' to its top - level directory name. We'll look there first.\n                    thirdPartyImport = this.resolveAbsoluteImport(\n                        searchPath,\n                        moduleDescriptor,\n                        importName,\n                        importFailureInfo,\n                        /* allowPartial */ allowPartialResolutionForThirdPartyPackages,\n                        /* allowNativeLib */ false,\n                        /* useStubPackage */ true,\n                        allowPyi\n                    );\n                }\n\n                if (!thirdPartyImport?.isImportFound) {\n                    // Either we didn't look for a packaged stub or we looked but didn't find one.\n                    // If there was a packaged stub directory, we can stop searching unless\n                    // it happened to be marked as \"partially typed\".\n                    if (!thirdPartyImport?.packageDirectory || pyTypedInfo?.isPartiallyTyped) {\n                        pyTypedInfo = this._getPyTypedInfo(dirPath);\n\n                        thirdPartyImport = this.resolveAbsoluteImport(\n                            searchPath,\n                            moduleDescriptor,\n                            importName,\n                            importFailureInfo,\n                            /* allowPartial */ allowPartialResolutionForThirdPartyPackages,\n                            /* allowNativeLib */ true,\n                            /* useStubPackage */ false,\n                            allowPyi\n                        );\n                    }\n                }\n\n                if (thirdPartyImport) {\n                    thirdPartyImport.importType = ImportType.ThirdParty;\n                    thirdPartyImport.isPyTypedPresent = pyTypedInfo?.isPyTypedPresent;\n\n                    if (thirdPartyImport.isImportFound && thirdPartyImport.isStubFile) {\n                        return thirdPartyImport;\n                    }\n\n                    // We did not find it, or we did and it's not from a\n                    // stub, so give chance for resolveImportEx to find\n                    // one from a stub.\n                    if (\n                        bestResultSoFar === undefined ||\n                        (!bestResultSoFar.isImportFound && thirdPartyImport.isImportFound) ||\n                        (bestResultSoFar.isNamespacePackage &&\n                            thirdPartyImport.isImportFound &&\n                            !thirdPartyImport.isNamespacePackage) ||\n                        (thirdPartyImport.isImportFound &&\n                            thirdPartyImport.resolvedPaths.length > bestResultSoFar.resolvedPaths.length)\n                    ) {\n                        bestResultSoFar = thirdPartyImport;\n                    }\n                }\n            }\n        } else {\n            importFailureInfo.push('No python interpreter search path');\n        }\n\n        const extraResults = this.resolveImportEx(\n            sourceFilePath,\n            execEnv,\n            moduleDescriptor,\n            importName,\n            importFailureInfo,\n            allowPyi\n        );\n        if (extraResults !== undefined) {\n            return extraResults;\n        }\n\n        if (allowPyi) {\n            // Check for a third-party typeshed file.\n            importFailureInfo.push(`Looking for typeshed path`);\n            const typeshedImport = this._findTypeshedPath(\n                execEnv,\n                moduleDescriptor,\n                importName,\n                /* isStdLib */ false,\n                importFailureInfo\n            );\n            if (typeshedImport) {\n                typeshedImport.isTypeshedFile = true;\n                return typeshedImport;\n            }\n        }\n\n        // We weren't able to find an exact match, so return the best\n        // partial match.\n        return bestResultSoFar;\n    }\n\n    private _isIdentifier(value: string) {\n        for (let i = 0; i < value.length; i++) {\n            if (i === 0 ? !isIdentifierStartChar(value.charCodeAt(i)) : !isIdentifierChar(value.charCodeAt(i))) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private _getPythonSearchPaths(execEnv: ExecutionEnvironment, importFailureInfo: string[]) {\n        const cacheKey = execEnv.venv ? execEnv.venv : '<default>';\n\n        // Find the site packages for the configured virtual environment.\n        if (!this._cachedPythonSearchPaths.has(cacheKey)) {\n            this._cachedPythonSearchPaths.set(\n                cacheKey,\n                PythonPathUtils.findPythonSearchPaths(\n                    this.fileSystem,\n                    this._configOptions,\n                    execEnv.venv,\n                    importFailureInfo\n                ) || []\n            );\n        }\n\n        return this._cachedPythonSearchPaths.get(cacheKey)!;\n    }\n\n    private _findTypeshedPath(\n        execEnv: ExecutionEnvironment,\n        moduleDescriptor: ImportedModuleDescriptor,\n        importName: string,\n        isStdLib: boolean,\n        importFailureInfo: string[]\n    ): ImportResult | undefined {\n        importFailureInfo.push(\n            `Looking for typeshed ${\n                isStdLib ? PythonPathUtils.stdLibFolderName : PythonPathUtils.thirdPartyFolderName\n            } path`\n        );\n\n        const typeshedPath = this._getTypeshedPath(isStdLib, execEnv, importFailureInfo);\n        if (!typeshedPath) {\n            return undefined;\n        }\n\n        const pythonVersion = execEnv.pythonVersion;\n        let minorVersion = pythonVersion & 0xff;\n\n        // Search for module starting at \"3.x\" down to \"3.1\", then \"3\", then \"2and3\".\n        while (true) {\n            const pythonVersionString =\n                minorVersion > 0 ? versionToString(0x300 + minorVersion) : minorVersion === 0 ? '3' : '2and3';\n            const testPath = combinePaths(typeshedPath, pythonVersionString);\n            if (this.fileSystem.existsSync(testPath)) {\n                const importInfo = this.resolveAbsoluteImport(\n                    testPath,\n                    moduleDescriptor,\n                    importName,\n                    importFailureInfo\n                );\n                if (importInfo.isImportFound) {\n                    importInfo.importType = isStdLib ? ImportType.BuiltIn : ImportType.ThirdParty;\n                    return importInfo;\n                }\n            }\n\n            // We use -1 to indicate \"2and3\", which is searched after \"3.0\".\n            if (minorVersion === -1) {\n                break;\n            }\n            minorVersion--;\n        }\n\n        importFailureInfo.push(`Typeshed path not found`);\n        return undefined;\n    }\n\n    private _getCompletionSuggestionsTypeshedPath(\n        execEnv: ExecutionEnvironment,\n        moduleDescriptor: ImportedModuleDescriptor,\n        isStdLib: boolean,\n        suggestions: string[],\n        similarityLimit: number\n    ) {\n        const importFailureInfo: string[] = [];\n        const typeshedPath = this._getTypeshedPath(isStdLib, execEnv, importFailureInfo);\n        if (!typeshedPath) {\n            return;\n        }\n\n        const pythonVersion = execEnv.pythonVersion;\n        let minorVersion = pythonVersion & 0xff;\n\n        // Search for module starting at \"3.x\" down to \"3.1\", then \"3\", then \"2and3\".\n        while (true) {\n            const pythonVersionString =\n                minorVersion > 0 ? versionToString(0x300 + minorVersion) : minorVersion === 0 ? '3' : '2and3';\n            const testPath = combinePaths(typeshedPath, pythonVersionString);\n            if (this.fileSystem.existsSync(testPath)) {\n                this._getCompletionSuggestionsAbsolute(testPath, moduleDescriptor, suggestions, similarityLimit);\n            }\n\n            // We use -1 to indicate \"2and3\", which is searched after \"3.0\".\n            if (minorVersion === -1) {\n                break;\n            }\n            minorVersion--;\n        }\n    }\n\n    private _getTypeshedPath(isStdLib: boolean, execEnv: ExecutionEnvironment, importFailureInfo: string[]) {\n        // See if we have it cached.\n        if (isStdLib) {\n            if (this._cachedTypeshedStdLibPath !== undefined) {\n                return this._cachedTypeshedStdLibPath;\n            }\n        } else {\n            if (this._cachedTypeshedThirdPartyPath !== undefined) {\n                return this._cachedTypeshedThirdPartyPath;\n            }\n        }\n\n        let typeshedPath = '';\n\n        // Did the user specify a typeshed path? If not, we'll look in the\n        // python search paths, then in the typeshed-fallback directory.\n        if (this._configOptions.typeshedPath) {\n            const possibleTypeshedPath = this._configOptions.typeshedPath;\n            if (\n                this.fileSystem.existsSync(possibleTypeshedPath) &&\n                isDirectory(this.fileSystem, possibleTypeshedPath)\n            ) {\n                typeshedPath = possibleTypeshedPath;\n            }\n        } else {\n            const pythonSearchPaths = this._getPythonSearchPaths(execEnv, importFailureInfo);\n            for (const searchPath of pythonSearchPaths) {\n                const possibleTypeshedPath = combinePaths(searchPath, 'typeshed');\n                if (\n                    this.fileSystem.existsSync(possibleTypeshedPath) &&\n                    isDirectory(this.fileSystem, possibleTypeshedPath)\n                ) {\n                    typeshedPath = possibleTypeshedPath;\n                    break;\n                }\n            }\n        }\n\n        // If typeshed directory wasn't found in other locations, use the fallback.\n        if (!typeshedPath) {\n            typeshedPath = PythonPathUtils.getTypeShedFallbackPath(this.fileSystem) || '';\n        }\n\n        typeshedPath = PythonPathUtils.getTypeshedSubdirectory(typeshedPath, isStdLib);\n\n        if (!this.fileSystem.existsSync(typeshedPath) || !isDirectory(this.fileSystem, typeshedPath)) {\n            return undefined;\n        }\n\n        // Cache the results.\n        if (isStdLib) {\n            this._cachedTypeshedStdLibPath = typeshedPath;\n        } else {\n            this._cachedTypeshedThirdPartyPath = typeshedPath;\n        }\n\n        return typeshedPath;\n    }\n\n    private _resolveRelativeImport(\n        sourceFilePath: string,\n        moduleDescriptor: ImportedModuleDescriptor,\n        importName: string,\n        importFailureInfo: string[]\n    ): ImportResult | undefined {\n        importFailureInfo.push('Attempting to resolve relative import');\n\n        // Determine which search path this file is part of.\n        let curDir = getDirectoryPath(sourceFilePath);\n        for (let i = 1; i < moduleDescriptor.leadingDots; i++) {\n            if (curDir === '') {\n                importFailureInfo.push(`Invalid relative path '${importName}'`);\n                return undefined;\n            }\n            curDir = getDirectoryPath(curDir);\n        }\n\n        // Now try to match the module parts from the current directory location.\n        const absImport = this.resolveAbsoluteImport(curDir, moduleDescriptor, importName, importFailureInfo);\n        return this._filterImplicitImports(absImport, moduleDescriptor.importedSymbols);\n    }\n\n    private _getCompletionSuggestionsRelative(\n        sourceFilePath: string,\n        moduleDescriptor: ImportedModuleDescriptor,\n        suggestions: string[],\n        similarityLimit: number\n    ) {\n        // Determine which search path this file is part of.\n        let curDir = getDirectoryPath(sourceFilePath);\n        for (let i = 1; i < moduleDescriptor.leadingDots; i++) {\n            if (curDir === '') {\n                return;\n            }\n            curDir = getDirectoryPath(curDir);\n        }\n\n        // Now try to match the module parts from the current directory location.\n        this._getCompletionSuggestionsAbsolute(curDir, moduleDescriptor, suggestions, similarityLimit);\n    }\n\n    private _getFilesInDirectory(dirPath: string): string[] {\n        return this.fileSystem\n            .readdirEntriesSync(dirPath)\n            .filter((f) => f.isFile())\n            .map((f) => f.name);\n    }\n\n    private _getCompletionSuggestionsAbsolute(\n        rootPath: string,\n        moduleDescriptor: ImportedModuleDescriptor,\n        suggestions: string[],\n        similarityLimit: number\n    ) {\n        // Starting at the specified path, walk the file system to find the\n        // specified module.\n        let dirPath = rootPath;\n\n        // Copy the nameParts into a new directory and add an extra empty\n        // part if there is a trailing dot.\n        const nameParts = moduleDescriptor.nameParts.map((name) => name);\n        if (moduleDescriptor.hasTrailingDot) {\n            nameParts.push('');\n        }\n\n        // Handle the case where the user has typed the first\n        // dot (or multiple) in a relative path.\n        if (nameParts.length === 0) {\n            this._addFilteredSuggestions(dirPath, '', suggestions, similarityLimit);\n        } else {\n            for (let i = 0; i < nameParts.length; i++) {\n                // Provide completions only if we're on the last part\n                // of the name.\n                if (i === nameParts.length - 1) {\n                    this._addFilteredSuggestions(dirPath, nameParts[i], suggestions, similarityLimit);\n                }\n\n                dirPath = combinePaths(dirPath, nameParts[i]);\n                if (!this.fileSystem.existsSync(dirPath) || !isDirectory(this.fileSystem, dirPath)) {\n                    break;\n                }\n            }\n        }\n    }\n\n    private _addFilteredSuggestions(dirPath: string, filter: string, suggestions: string[], similarityLimit: number) {\n        const entries = getFileSystemEntries(this.fileSystem, dirPath);\n\n        entries.files.forEach((file) => {\n            // Strip multi-dot extensions to handle file names like \"foo.cpython-32m.so\". We want\n            // to detect the \".so\" but strip off the entire \".cpython-32m.so\" extension.\n            const fileExtension = getFileExtension(file, /* multiDotExtension */ false).toLowerCase();\n            const fileWithoutExtension = stripFileExtension(file, /* multiDotExtension */ true);\n\n            if (supportedFileExtensions.some((ext) => ext === fileExtension)) {\n                if (fileWithoutExtension !== '__init__') {\n                    if (\n                        !filter ||\n                        StringUtils.computeCompletionSimilarity(filter, fileWithoutExtension) >= similarityLimit\n                    ) {\n                        this._addUniqueSuggestion(fileWithoutExtension, suggestions);\n                    }\n                }\n            }\n        });\n\n        entries.directories.forEach((dir) => {\n            if (!filter || dir.startsWith(filter)) {\n                this._addUniqueSuggestion(dir, suggestions);\n            }\n        });\n    }\n\n    private _addUniqueSuggestion(suggestionToAdd: string, suggestions: string[]) {\n        if (suggestions.some((s) => s === suggestionToAdd)) {\n            return;\n        }\n\n        // Don't add directories with illegal module names.\n        if (/[.-]/.test(suggestionToAdd)) {\n            return;\n        }\n\n        // Don't add directories with dunder names like \"__pycache__\".\n        if (isDunderName(suggestionToAdd)) {\n            return;\n        }\n\n        suggestions.push(suggestionToAdd);\n    }\n\n    // Potentially modifies the ImportResult by removing some or all of the\n    // implicit import entries. Only the imported symbols should be included.\n    private _filterImplicitImports(importResult: ImportResult, importedSymbols: string[] | undefined): ImportResult {\n        if (importedSymbols === undefined) {\n            const newImportResult = Object.assign({}, importResult);\n            newImportResult.implicitImports = [];\n            return newImportResult;\n        }\n\n        if (importedSymbols.length === 0) {\n            return importResult;\n        }\n\n        if (importResult.implicitImports.length === 0) {\n            return importResult;\n        }\n\n        const filteredImplicitImports = importResult.implicitImports.filter((implicitImport) => {\n            return importedSymbols.some((sym) => sym === implicitImport.name);\n        });\n\n        if (filteredImplicitImports.length === importResult.implicitImports.length) {\n            return importResult;\n        }\n\n        const newImportResult = Object.assign({}, importResult);\n        newImportResult.implicitImports = filteredImplicitImports;\n        return newImportResult;\n    }\n\n    private _findImplicitImports(dirPath: string, exclusions: string[]): ImplicitImport[] {\n        const implicitImportMap = new Map<string, ImplicitImport>();\n\n        // Enumerate all of the files and directories in the path.\n        const entries = getFileSystemEntries(this.fileSystem, dirPath);\n\n        // Add implicit file-based modules.\n        for (const fileName of entries.files) {\n            if (fileName.endsWith('.py') || fileName.endsWith('.pyi')) {\n                const filePath = combinePaths(dirPath, fileName);\n\n                if (!exclusions.find((exclusion) => exclusion === filePath)) {\n                    const strippedFileName = stripFileExtension(fileName);\n                    const implicitImport: ImplicitImport = {\n                        isStubFile: fileName.endsWith('.pyi'),\n                        name: strippedFileName,\n                        path: filePath,\n                    };\n\n                    // Always prefer stub files over non-stub files.\n                    const entry = implicitImportMap.get(implicitImport.name);\n                    if (!entry || !entry.isStubFile) {\n                        implicitImportMap.set(implicitImport.name, implicitImport);\n                    }\n                }\n            }\n        }\n\n        // Add implicit directory-based modules.\n        for (const dirName of entries.directories) {\n            const pyFilePath = combinePaths(dirPath, dirName, '__init__.py');\n            const pyiFilePath = pyFilePath + 'i';\n            let isStubFile = false;\n            let path = '';\n\n            if (this.fileSystem.existsSync(pyiFilePath) && isFile(this.fileSystem, pyiFilePath)) {\n                isStubFile = true;\n                path = pyiFilePath;\n            } else if (this.fileSystem.existsSync(pyFilePath) && isFile(this.fileSystem, pyFilePath)) {\n                path = pyFilePath;\n            }\n\n            if (path) {\n                if (!exclusions.find((exclusion) => exclusion === path)) {\n                    const implicitImport: ImplicitImport = {\n                        isStubFile,\n                        name: dirName,\n                        path,\n                    };\n\n                    implicitImportMap.set(implicitImport.name, implicitImport);\n                }\n            }\n        }\n\n        return [...implicitImportMap.values()];\n    }\n\n    private _formatImportName(moduleDescriptor: ImportedModuleDescriptor) {\n        let name = '';\n        for (let i = 0; i < moduleDescriptor.leadingDots; i++) {\n            name += '.';\n        }\n\n        return name + moduleDescriptor.nameParts.map((part) => part).join('.');\n    }\n}\n\nexport type ImportResolverFactory = (fs: FileSystem, options: ConfigOptions) => ImportResolver;\n","/*\n * importStatementUtils.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Utility routines for summarizing and manipulating\n * import statements in a python source file.\n */\n\nimport { CancellationToken } from 'vscode-languageserver';\n\nimport { throwIfCancellationRequested } from '../common/cancellationUtils';\nimport { TextEditAction } from '../common/editAction';\nimport { convertOffsetToPosition, convertPositionToOffset } from '../common/positionUtils';\nimport { Position } from '../common/textRange';\nimport { TextRange } from '../common/textRange';\nimport {\n    ImportAsNode,\n    ImportFromAsNode,\n    ImportFromNode,\n    ImportNode,\n    ModuleNameNode,\n    ModuleNode,\n    ParseNode,\n    ParseNodeType,\n} from '../parser/parseNodes';\nimport { ParseResults } from '../parser/parser';\nimport * as AnalyzerNodeInfo from './analyzerNodeInfo';\nimport { ImportResult, ImportType } from './importResult';\nimport * as SymbolNameUtils from './symbolNameUtils';\n\nexport interface ImportStatement {\n    node: ImportNode | ImportFromNode;\n    subnode?: ImportAsNode;\n    importResult: ImportResult | undefined;\n    resolvedPath: string | undefined;\n    moduleName: string;\n    followsNonImportStatement: boolean;\n}\n\nexport interface ImportStatements {\n    orderedImports: ImportStatement[];\n    mapByFilePath: Map<string, ImportStatement>;\n}\n\nexport const enum ImportGroup {\n    // The ordering here is important because this is the order\n    // in which PEP8 specifies that imports should be ordered.\n    BuiltIn = 0,\n    ThirdParty = 1,\n    Local = 2,\n    LocalRelative = 3,\n}\n\n// Determines which import grouping should be used when sorting imports.\nexport function getImportGroup(statement: ImportStatement): ImportGroup {\n    if (statement.importResult) {\n        if (statement.importResult.importType === ImportType.BuiltIn) {\n            return ImportGroup.BuiltIn;\n        } else if (\n            statement.importResult.importType === ImportType.ThirdParty ||\n            statement.importResult.isLocalTypingsFile\n        ) {\n            return ImportGroup.ThirdParty;\n        }\n\n        if (statement.importResult.isRelative) {\n            return ImportGroup.LocalRelative;\n        }\n\n        return ImportGroup.Local;\n    } else {\n        return ImportGroup.Local;\n    }\n}\n\n// Compares sort order of two import statements.\nexport function compareImportStatements(a: ImportStatement, b: ImportStatement) {\n    const aImportGroup = getImportGroup(a);\n    const bImportGroup = getImportGroup(b);\n\n    if (aImportGroup < bImportGroup) {\n        return -1;\n    } else if (aImportGroup > bImportGroup) {\n        return 1;\n    }\n\n    return a.moduleName < b.moduleName ? -1 : 1;\n}\n\n// Looks for top-level 'import' and 'import from' statements and provides\n// an ordered list and a map (by file path).\nexport function getTopLevelImports(parseTree: ModuleNode): ImportStatements {\n    const localImports: ImportStatements = {\n        orderedImports: [],\n        mapByFilePath: new Map<string, ImportStatement>(),\n    };\n\n    let followsNonImportStatement = false;\n    let foundFirstImportStatement = false;\n\n    parseTree.statements.forEach((statement) => {\n        if (statement.nodeType === ParseNodeType.StatementList) {\n            statement.statements.forEach((subStatement) => {\n                if (subStatement.nodeType === ParseNodeType.Import) {\n                    foundFirstImportStatement = true;\n                    _processImportNode(subStatement, localImports, followsNonImportStatement);\n                    followsNonImportStatement = false;\n                } else if (subStatement.nodeType === ParseNodeType.ImportFrom) {\n                    foundFirstImportStatement = true;\n                    _processImportFromNode(subStatement, localImports, followsNonImportStatement);\n                    followsNonImportStatement = false;\n                } else {\n                    followsNonImportStatement = foundFirstImportStatement;\n                }\n            });\n        } else {\n            followsNonImportStatement = foundFirstImportStatement;\n        }\n    });\n\n    return localImports;\n}\n\nexport function getTextEditsForAutoImportSymbolAddition(\n    symbolName: string,\n    importStatement: ImportStatement,\n    parseResults: ParseResults,\n    aliasName?: string\n) {\n    const textEditList: TextEditAction[] = [];\n\n    // Scan through the import symbols to find the right insertion point,\n    // assuming we want to keep the imports alphabetized.\n    let priorImport: ImportFromAsNode | undefined;\n\n    if (importStatement.node && importStatement.node.nodeType === ParseNodeType.ImportFrom) {\n        // Make sure we're not attempting to auto-import a symbol that\n        // already exists in the import list.\n        if (!importStatement.node.imports.some((importAs) => importAs.name.value === symbolName)) {\n            for (const curImport of importStatement.node.imports) {\n                if (curImport.name.value > symbolName) {\n                    break;\n                }\n\n                priorImport = curImport;\n            }\n\n            const insertionOffset = priorImport\n                ? TextRange.getEnd(priorImport)\n                : importStatement.node.imports.length > 0\n                ? importStatement.node.imports[0].start\n                : importStatement.node.start + importStatement.node.length;\n            const insertionPosition = convertOffsetToPosition(insertionOffset, parseResults.tokenizerOutput.lines);\n\n            const insertText = aliasName ? `${symbolName} as ${aliasName}` : symbolName;\n\n            textEditList.push({\n                range: { start: insertionPosition, end: insertionPosition },\n                replacementText: priorImport ? ', ' + insertText : insertText + ', ',\n            });\n        }\n    }\n\n    return textEditList;\n}\n\nexport function getTextEditsForAutoImportInsertion(\n    symbolName: string | undefined,\n    importStatements: ImportStatements,\n    moduleName: string,\n    importGroup: ImportGroup,\n    parseResults: ParseResults,\n    invocationPosition: Position,\n    aliasName?: string\n): TextEditAction[] {\n    const textEditList: TextEditAction[] = [];\n\n    // We need to emit a new 'from import' statement if symbolName is given. otherwise, use 'import' statement.\n    const importText = symbolName ? symbolName : moduleName;\n    const importTextWithAlias = aliasName ? `${importText} as ${aliasName}` : importText;\n    let newImportStatement = symbolName\n        ? `from ${moduleName} import ${importTextWithAlias}`\n        : `import ${importTextWithAlias}`;\n\n    let insertionPosition: Position;\n    const invocation = convertPositionToOffset(invocationPosition, parseResults.tokenizerOutput.lines)!;\n    if (importStatements.orderedImports.length > 0 && invocation >= importStatements.orderedImports[0].node.start) {\n        let insertBefore = true;\n        let insertionImport = importStatements.orderedImports[0];\n\n        // Find a good spot to insert the new import statement. Follow\n        // the PEP8 standard sorting order whereby built-in imports are\n        // followed by third-party, which are followed by local.\n        let prevImportGroup = ImportGroup.BuiltIn;\n        for (const curImport of importStatements.orderedImports) {\n            // If the import was resolved, use its import type. If it wasn't\n            // resolved, assume that it's the same import type as the previous\n            // one.\n            const curImportGroup: ImportGroup = curImport.importResult ? getImportGroup(curImport) : prevImportGroup;\n\n            if (importGroup < curImportGroup) {\n                if (!insertBefore && prevImportGroup < importGroup) {\n                    // Add an extra line to create a new group.\n                    newImportStatement = parseResults.tokenizerOutput.predominantEndOfLineSequence + newImportStatement;\n                }\n                break;\n            }\n\n            if (importGroup === curImportGroup && curImport.moduleName > moduleName) {\n                break;\n            }\n\n            // If we're about to hit the end of the import statements, don't go\n            // any further.\n            if (curImport.followsNonImportStatement) {\n                if (importGroup > prevImportGroup) {\n                    // Add an extra line to create a new group.\n                    newImportStatement = parseResults.tokenizerOutput.predominantEndOfLineSequence + newImportStatement;\n                }\n                break;\n            }\n\n            // If this is the last import, see if we need to create a new group.\n            if (curImport === importStatements.orderedImports[importStatements.orderedImports.length - 1]) {\n                if (importGroup > curImportGroup) {\n                    // Add an extra line to create a new group.\n                    newImportStatement = parseResults.tokenizerOutput.predominantEndOfLineSequence + newImportStatement;\n                }\n            }\n\n            // Are we starting a new group?\n            if (!insertBefore && importGroup < prevImportGroup && importGroup === curImportGroup) {\n                insertBefore = true;\n            } else {\n                insertBefore = false;\n            }\n\n            prevImportGroup = curImportGroup;\n            insertionImport = curImport;\n        }\n\n        if (insertionImport) {\n            if (insertBefore) {\n                newImportStatement = newImportStatement + parseResults.tokenizerOutput.predominantEndOfLineSequence;\n            } else {\n                newImportStatement = parseResults.tokenizerOutput.predominantEndOfLineSequence + newImportStatement;\n            }\n\n            insertionPosition = convertOffsetToPosition(\n                insertBefore ? insertionImport.node.start : TextRange.getEnd(insertionImport.node),\n                parseResults.tokenizerOutput.lines\n            );\n        } else {\n            insertionPosition = { line: 0, character: 0 };\n        }\n    } else {\n        // Insert at or near the top of the file. See if there's a doc string and\n        // copyright notice, etc. at the top. If so, move past those.\n        insertionPosition = { line: 0, character: 0 };\n        let addNewLineBefore = false;\n\n        for (const statement of parseResults.parseTree.statements) {\n            let stopHere = true;\n            if (statement.nodeType === ParseNodeType.StatementList && statement.statements.length === 1) {\n                const simpleStatement = statement.statements[0];\n\n                if (simpleStatement.nodeType === ParseNodeType.StringList) {\n                    // Assume that it's a file header doc string.\n                    stopHere = false;\n                } else if (simpleStatement.nodeType === ParseNodeType.Assignment) {\n                    if (simpleStatement.leftExpression.nodeType === ParseNodeType.Name) {\n                        if (SymbolNameUtils.isDunderName(simpleStatement.leftExpression.value)) {\n                            // Assume that it's an assignment of __copyright__, __author__, etc.\n                            stopHere = false;\n                        }\n                    }\n                }\n            }\n\n            if (stopHere) {\n                insertionPosition = convertOffsetToPosition(statement.start, parseResults.tokenizerOutput.lines);\n                addNewLineBefore = false;\n                break;\n            } else {\n                insertionPosition = convertOffsetToPosition(\n                    statement.start + statement.length,\n                    parseResults.tokenizerOutput.lines\n                );\n                addNewLineBefore = true;\n            }\n        }\n\n        newImportStatement +=\n            parseResults.tokenizerOutput.predominantEndOfLineSequence +\n            parseResults.tokenizerOutput.predominantEndOfLineSequence;\n\n        if (addNewLineBefore) {\n            newImportStatement = parseResults.tokenizerOutput.predominantEndOfLineSequence + newImportStatement;\n        } else {\n            newImportStatement += parseResults.tokenizerOutput.predominantEndOfLineSequence;\n        }\n    }\n\n    textEditList.push({\n        range: { start: insertionPosition, end: insertionPosition },\n        replacementText: newImportStatement,\n    });\n\n    return textEditList;\n}\n\nfunction _processImportNode(node: ImportNode, localImports: ImportStatements, followsNonImportStatement: boolean) {\n    node.list.forEach((importAsNode) => {\n        const importResult = AnalyzerNodeInfo.getImportInfo(importAsNode.module);\n        let resolvedPath: string | undefined;\n\n        if (importResult && importResult.isImportFound) {\n            resolvedPath = importResult.resolvedPaths[importResult.resolvedPaths.length - 1];\n        }\n\n        const localImport: ImportStatement = {\n            node,\n            subnode: importAsNode,\n            importResult,\n            resolvedPath,\n            moduleName: _formatModuleName(importAsNode.module),\n            followsNonImportStatement,\n        };\n\n        localImports.orderedImports.push(localImport);\n\n        // Add it to the map.\n        if (resolvedPath) {\n            // Don't overwrite existing import or import from statements\n            // because we always want to prefer 'import from' over 'import'\n            // in the map.\n            if (!localImports.mapByFilePath.has(resolvedPath)) {\n                localImports.mapByFilePath.set(resolvedPath, localImport);\n            }\n        }\n    });\n}\n\nfunction _processImportFromNode(\n    node: ImportFromNode,\n    localImports: ImportStatements,\n    followsNonImportStatement: boolean\n) {\n    const importResult = AnalyzerNodeInfo.getImportInfo(node.module);\n    let resolvedPath: string | undefined;\n\n    if (importResult && importResult.isImportFound) {\n        resolvedPath = importResult.resolvedPaths[importResult.resolvedPaths.length - 1];\n    }\n\n    const localImport: ImportStatement = {\n        node,\n        importResult,\n        resolvedPath,\n        moduleName: _formatModuleName(node.module),\n        followsNonImportStatement,\n    };\n\n    localImports.orderedImports.push(localImport);\n\n    // Add it to the map.\n    if (resolvedPath) {\n        const prevEntry = localImports.mapByFilePath.get(resolvedPath);\n        // Overwrite existing import statements because we always want to prefer\n        // 'import from' over 'import'. Also, overwrite existing 'import from' if\n        // the module name is shorter.\n        if (\n            !prevEntry ||\n            prevEntry.node.nodeType === ParseNodeType.Import ||\n            prevEntry.moduleName.length > localImport.moduleName.length\n        ) {\n            localImports.mapByFilePath.set(resolvedPath, localImport);\n        }\n    }\n}\n\nfunction _formatModuleName(node: ModuleNameNode): string {\n    let moduleName = '';\n    for (let i = 0; i < node.leadingDots; i++) {\n        moduleName = moduleName + '.';\n    }\n\n    moduleName += node.nameParts.map((part) => part.value).join('.');\n\n    return moduleName;\n}\n\nexport function getContainingImportStatement(node: ParseNode | undefined, token: CancellationToken) {\n    while (node) {\n        throwIfCancellationRequested(token);\n\n        if (node.nodeType === ParseNodeType.Import || node.nodeType === ParseNodeType.ImportFrom) {\n            break;\n        }\n\n        node = node.parent;\n    }\n\n    return node;\n}\n\nexport function getAllImportNames(node: ImportNode | ImportFromNode) {\n    if (node.nodeType === ParseNodeType.Import) {\n        const importNode = node as ImportNode;\n        return importNode.list;\n    }\n\n    const importFromNode = node as ImportFromNode;\n    return importFromNode.imports;\n}\n","/*\n * parseTreeCleaner.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * A parse tree walker that's used to clean any analysis\n * information hanging off the parse tree. It's used when\n * dependent files have been modified and the file requires\n * reanalysis. Without this, we'd need to generate a fresh\n * parse tree from scratch.\n */\n\nimport { ModuleNode, ParseNode } from '../parser/parseNodes';\nimport * as AnalyzerNodeInfo from './analyzerNodeInfo';\nimport { ParseTreeWalker } from './parseTreeWalker';\n\nexport class ParseTreeCleanerWalker extends ParseTreeWalker {\n    private _parseTree: ModuleNode;\n\n    constructor(parseTree: ModuleNode) {\n        super();\n\n        this._parseTree = parseTree;\n    }\n\n    clean() {\n        this.walk(this._parseTree);\n    }\n\n    visitNode(node: ParseNode) {\n        AnalyzerNodeInfo.cleanNodeAnalysisInfo(node);\n        return super.visitNode(node);\n    }\n}\n","/*\n * parseTreeUtils.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Utility routines for traversing a parse tree.\n */\n\nimport { fail } from '../common/debug';\nimport { convertPositionToOffset } from '../common/positionUtils';\nimport { Position } from '../common/textRange';\nimport { TextRange } from '../common/textRange';\nimport { TextRangeCollection } from '../common/textRangeCollection';\nimport {\n    ArgumentCategory,\n    AssignmentExpressionNode,\n    ClassNode,\n    EvaluationScopeNode,\n    ExecutionScopeNode,\n    ExpressionNode,\n    FunctionNode,\n    isExpressionNode,\n    LambdaNode,\n    ModuleNode,\n    ParameterCategory,\n    ParseNode,\n    ParseNodeType,\n    StatementNode,\n    SuiteNode,\n    TypeAnnotationNode,\n} from '../parser/parseNodes';\nimport { KeywordType, OperatorType, StringTokenFlags } from '../parser/tokenizerTypes';\nimport { getScope } from './analyzerNodeInfo';\nimport { decodeDocString } from './docStringUtils';\nimport { ParseTreeWalker } from './parseTreeWalker';\n\nexport const enum PrintExpressionFlags {\n    None = 0,\n\n    // Don't use string literals for forward declarations.\n    ForwardDeclarations = 1 << 0,\n}\n\nexport function getNodeDepth(node: ParseNode): number {\n    let depth = 0;\n    let curNode: ParseNode | undefined = node;\n\n    while (curNode) {\n        depth++;\n        curNode = curNode.parent;\n    }\n\n    return depth;\n}\n\n// Returns the deepest node that contains the specified position.\nexport function findNodeByPosition(\n    node: ParseNode,\n    position: Position,\n    lines: TextRangeCollection<TextRange>\n): ParseNode | undefined {\n    const offset = convertPositionToOffset(position, lines);\n    if (offset === undefined) {\n        return undefined;\n    }\n\n    return findNodeByOffset(node, offset);\n}\n\n// Returns the deepest node that contains the specified offset.\nexport function findNodeByOffset(node: ParseNode, offset: number): ParseNode | undefined {\n    if (offset < node.start || offset > TextRange.getEnd(node)) {\n        return undefined;\n    }\n\n    const parseTreeWalker = new ParseTreeWalker();\n\n    // The range is found within this node. See if we can localize it\n    // further by checking its children.\n    const children = parseTreeWalker.visitNode(node);\n    for (const child of children) {\n        if (child) {\n            const containingChild = findNodeByOffset(child, offset);\n            if (containingChild) {\n                return containingChild;\n            }\n        }\n    }\n\n    return node;\n}\n\nexport function printExpression(node: ExpressionNode, flags = PrintExpressionFlags.None): string {\n    switch (node.nodeType) {\n        case ParseNodeType.Name: {\n            return node.value;\n        }\n\n        case ParseNodeType.MemberAccess: {\n            return printExpression(node.leftExpression, flags) + '.' + node.memberName.value;\n        }\n\n        case ParseNodeType.Call: {\n            return (\n                printExpression(node.leftExpression, flags) +\n                '(' +\n                node.arguments\n                    .map((arg) => {\n                        let argStr = '';\n                        if (arg.argumentCategory === ArgumentCategory.UnpackedList) {\n                            argStr = '*';\n                        } else if (arg.argumentCategory === ArgumentCategory.UnpackedDictionary) {\n                            argStr = '**';\n                        }\n                        if (arg.name) {\n                            argStr += arg.name.value + '=';\n                        }\n                        argStr += printExpression(arg.valueExpression, flags);\n                        return argStr;\n                    })\n                    .join(', ') +\n                ')'\n            );\n        }\n\n        case ParseNodeType.Index: {\n            return (\n                printExpression(node.baseExpression, flags) +\n                '[' +\n                node.items.items.map((item) => printExpression(item, flags)).join(', ') +\n                ']'\n            );\n        }\n\n        case ParseNodeType.UnaryOperation: {\n            return printOperator(node.operator) + ' ' + printExpression(node.expression, flags);\n        }\n\n        case ParseNodeType.BinaryOperation: {\n            return (\n                printExpression(node.leftExpression, flags) +\n                ' ' +\n                printOperator(node.operator) +\n                ' ' +\n                printExpression(node.rightExpression, flags)\n            );\n        }\n\n        case ParseNodeType.Number: {\n            let value = node.value.toString();\n            if (node.isImaginary) {\n                value += 'j';\n            }\n            return value;\n        }\n\n        case ParseNodeType.StringList: {\n            if (flags & PrintExpressionFlags.ForwardDeclarations && node.typeAnnotation) {\n                return printExpression(node.typeAnnotation, flags);\n            } else {\n                return node.strings\n                    .map((str) => {\n                        return printExpression(str, flags);\n                    })\n                    .join(' ');\n            }\n        }\n\n        case ParseNodeType.String: {\n            let exprString = '';\n            if (node.token.flags & StringTokenFlags.Raw) {\n                exprString += 'r';\n            }\n\n            if (node.token.flags & StringTokenFlags.Unicode) {\n                exprString += 'u';\n            }\n\n            if (node.token.flags & StringTokenFlags.Bytes) {\n                exprString += 'b';\n            }\n\n            if (node.token.flags & StringTokenFlags.Format) {\n                exprString += 'f';\n            }\n\n            if (node.token.flags & StringTokenFlags.Triplicate) {\n                if (node.token.flags & StringTokenFlags.SingleQuote) {\n                    exprString += `'''${node.token.escapedValue}'''`;\n                } else {\n                    exprString += `\"\"\"${node.token.escapedValue}\"\"\"`;\n                }\n            } else {\n                if (node.token.flags & StringTokenFlags.SingleQuote) {\n                    exprString += `'${node.token.escapedValue}'`;\n                } else {\n                    exprString += `\"${node.token.escapedValue}\"`;\n                }\n            }\n\n            return exprString;\n        }\n\n        case ParseNodeType.Assignment: {\n            return printExpression(node.leftExpression, flags) + ' = ' + printExpression(node.rightExpression, flags);\n        }\n\n        case ParseNodeType.AssignmentExpression: {\n            return printExpression(node.name, flags) + ' := ' + printExpression(node.rightExpression, flags);\n        }\n\n        case ParseNodeType.TypeAnnotation: {\n            return printExpression(node.valueExpression, flags) + ': ' + printExpression(node.typeAnnotation, flags);\n        }\n\n        case ParseNodeType.AugmentedAssignment: {\n            return (\n                printExpression(node.leftExpression, flags) +\n                ' ' +\n                printOperator(node.operator) +\n                ' ' +\n                printExpression(node.rightExpression, flags)\n            );\n        }\n\n        case ParseNodeType.Await: {\n            return 'await ' + printExpression(node.expression, flags);\n        }\n\n        case ParseNodeType.Ternary: {\n            return (\n                printExpression(node.ifExpression, flags) +\n                ' if ' +\n                printExpression(node.testExpression, flags) +\n                ' else ' +\n                printExpression(node.elseExpression, flags)\n            );\n        }\n\n        case ParseNodeType.List: {\n            const expressions = node.entries.map((expr) => {\n                return printExpression(expr, flags);\n            });\n            return `[${expressions.join(', ')}]`;\n        }\n\n        case ParseNodeType.Unpack: {\n            return '*' + printExpression(node.expression, flags);\n        }\n\n        case ParseNodeType.Tuple: {\n            const expressions = node.expressions.map((expr) => {\n                return printExpression(expr, flags);\n            });\n            if (expressions.length === 1) {\n                return `(${expressions[0]}, )`;\n            }\n            return `(${expressions.join(', ')})`;\n        }\n\n        case ParseNodeType.Yield: {\n            if (node.expression) {\n                return 'yield ' + printExpression(node.expression, flags);\n            } else {\n                return 'yield';\n            }\n        }\n\n        case ParseNodeType.YieldFrom: {\n            return 'yield from ' + printExpression(node.expression, flags);\n        }\n\n        case ParseNodeType.Ellipsis: {\n            return '...';\n        }\n\n        case ParseNodeType.ListComprehension: {\n            let listStr = '<ListExpression>';\n\n            if (isExpressionNode(node.expression)) {\n                listStr = printExpression(node.expression as ExpressionNode, flags);\n            } else if (node.expression.nodeType === ParseNodeType.DictionaryKeyEntry) {\n                const keyStr = printExpression(node.expression.keyExpression, flags);\n                const valueStr = printExpression(node.expression.valueExpression, flags);\n                listStr = `${keyStr}: ${valueStr}`;\n            }\n\n            return (\n                listStr +\n                ' ' +\n                node.comprehensions\n                    .map((expr) => {\n                        if (expr.nodeType === ParseNodeType.ListComprehensionFor) {\n                            return (\n                                `${expr.isAsync ? 'async ' : ''}for ` +\n                                printExpression(expr.targetExpression, flags) +\n                                ` in ${printExpression(expr.iterableExpression, flags)}`\n                            );\n                        } else {\n                            return `if ${printExpression(expr.testExpression, flags)}`;\n                        }\n                    })\n                    .join(' ')\n            );\n        }\n\n        case ParseNodeType.Slice: {\n            let result = '';\n            if (node.startValue) {\n                result += printExpression(node.startValue, flags);\n            }\n            if (node.endValue) {\n                result += ': ' + printExpression(node.endValue, flags);\n            }\n            if (node.stepValue) {\n                result += ': ' + printExpression(node.stepValue, flags);\n            }\n            return result;\n        }\n\n        case ParseNodeType.Lambda: {\n            return (\n                'lambda ' +\n                node.parameters\n                    .map((param) => {\n                        let paramStr = '';\n\n                        if (param.category === ParameterCategory.VarArgList) {\n                            paramStr += '*';\n                        } else if (param.category === ParameterCategory.VarArgDictionary) {\n                            paramStr += '**';\n                        }\n\n                        if (param.name) {\n                            paramStr += param.name.value;\n                        }\n\n                        if (param.defaultValue) {\n                            paramStr += ' = ' + printExpression(param.defaultValue, flags);\n                        }\n                        return paramStr;\n                    })\n                    .join(', ') +\n                ': ' +\n                printExpression(node.expression, flags)\n            );\n        }\n\n        case ParseNodeType.Constant: {\n            if (node.constType === KeywordType.True) {\n                return 'True';\n            } else if (node.constType === KeywordType.False) {\n                return 'False';\n            } else if (node.constType === KeywordType.Debug) {\n                return '__debug__';\n            } else if (node.constType === KeywordType.None) {\n                return 'None';\n            }\n            break;\n        }\n\n        case ParseNodeType.Dictionary: {\n            return `{ ${node.entries.map((entry) => {\n                if (entry.nodeType === ParseNodeType.DictionaryKeyEntry) {\n                    return (\n                        `${printExpression(entry.keyExpression, flags)}: ` +\n                        `${printExpression(entry.valueExpression, flags)}`\n                    );\n                } else {\n                    return printExpression(entry, flags);\n                }\n            })} }`;\n        }\n\n        case ParseNodeType.DictionaryExpandEntry: {\n            return `**${printExpression(node.expandExpression, flags)}`;\n        }\n\n        case ParseNodeType.Set: {\n            return node.entries.map((entry) => printExpression(entry, flags)).join(', ');\n        }\n    }\n\n    return '<Expression>';\n}\n\nexport function printOperator(operator: OperatorType): string {\n    const operatorMap: { [operator: number]: string } = {\n        [OperatorType.Add]: '+',\n        [OperatorType.AddEqual]: '+=',\n        [OperatorType.Assign]: '=',\n        [OperatorType.BitwiseAnd]: '&',\n        [OperatorType.BitwiseAndEqual]: '&=',\n        [OperatorType.BitwiseInvert]: '~',\n        [OperatorType.BitwiseOr]: '|',\n        [OperatorType.BitwiseOrEqual]: '|=',\n        [OperatorType.BitwiseXor]: '^',\n        [OperatorType.BitwiseXorEqual]: '^=',\n        [OperatorType.Divide]: '/',\n        [OperatorType.DivideEqual]: '/=',\n        [OperatorType.Equals]: '==',\n        [OperatorType.FloorDivide]: '//',\n        [OperatorType.FloorDivideEqual]: '//=',\n        [OperatorType.GreaterThan]: '>',\n        [OperatorType.GreaterThanOrEqual]: '>=',\n        [OperatorType.LeftShift]: '<<',\n        [OperatorType.LeftShiftEqual]: '<<=',\n        [OperatorType.LessOrGreaterThan]: '<>',\n        [OperatorType.LessThan]: '<',\n        [OperatorType.LessThanOrEqual]: '<=',\n        [OperatorType.MatrixMultiply]: '@',\n        [OperatorType.MatrixMultiplyEqual]: '@=',\n        [OperatorType.Mod]: '%',\n        [OperatorType.ModEqual]: '%=',\n        [OperatorType.Multiply]: '*',\n        [OperatorType.MultiplyEqual]: '*=',\n        [OperatorType.NotEquals]: '!=',\n        [OperatorType.Power]: '**',\n        [OperatorType.PowerEqual]: '**=',\n        [OperatorType.RightShift]: '>>',\n        [OperatorType.RightShiftEqual]: '>>=',\n        [OperatorType.Subtract]: '-',\n        [OperatorType.SubtractEqual]: '-=',\n        [OperatorType.And]: 'and',\n        [OperatorType.Or]: 'or',\n        [OperatorType.Not]: 'not',\n        [OperatorType.Is]: 'is',\n        [OperatorType.IsNot]: 'is not',\n        [OperatorType.In]: 'in',\n        [OperatorType.NotIn]: 'not in',\n    };\n\n    if (operatorMap[operator]) {\n        return operatorMap[operator];\n    }\n\n    return 'unknown';\n}\n\nexport function getEnclosingClass(node: ParseNode, stopAtFunction = false): ClassNode | undefined {\n    let curNode = node.parent;\n    while (curNode) {\n        if (curNode.nodeType === ParseNodeType.Class) {\n            return curNode;\n        }\n\n        if (curNode.nodeType === ParseNodeType.Module) {\n            return undefined;\n        }\n\n        if (curNode.nodeType === ParseNodeType.Function) {\n            if (stopAtFunction) {\n                return undefined;\n            }\n        }\n\n        curNode = curNode.parent;\n    }\n\n    return undefined;\n}\n\nexport function getEnclosingModule(node: ParseNode): ModuleNode {\n    let curNode = node.parent;\n    while (curNode) {\n        if (curNode.nodeType === ParseNodeType.Module) {\n            return curNode;\n        }\n\n        curNode = curNode.parent;\n    }\n\n    fail('Module node not found');\n    return undefined!;\n}\n\nexport function getEnclosingClassOrModule(node: ParseNode, stopAtFunction = false): ClassNode | ModuleNode | undefined {\n    let curNode = node.parent;\n    while (curNode) {\n        if (curNode.nodeType === ParseNodeType.Class) {\n            return curNode;\n        }\n\n        if (curNode.nodeType === ParseNodeType.Module) {\n            return curNode;\n        }\n\n        if (curNode.nodeType === ParseNodeType.Function) {\n            if (stopAtFunction) {\n                return undefined;\n            }\n        }\n\n        curNode = curNode.parent;\n    }\n\n    return undefined;\n}\n\nexport function getEnclosingFunction(node: ParseNode): FunctionNode | undefined {\n    let curNode = node.parent;\n    while (curNode) {\n        if (curNode.nodeType === ParseNodeType.Function) {\n            return curNode;\n        }\n\n        if (curNode.nodeType === ParseNodeType.Class) {\n            return undefined;\n        }\n\n        curNode = curNode.parent;\n    }\n\n    return undefined;\n}\n\nexport function getEnclosingLambda(node: ParseNode): LambdaNode | undefined {\n    let curNode = node.parent;\n    while (curNode) {\n        if (curNode.nodeType === ParseNodeType.Lambda) {\n            return curNode;\n        }\n\n        if (curNode.nodeType === ParseNodeType.Suite) {\n            return undefined;\n        }\n\n        curNode = curNode.parent;\n    }\n\n    return undefined;\n}\n\nexport function getEnclosingClassOrFunction(node: ParseNode): FunctionNode | ClassNode | undefined {\n    let curNode = node.parent;\n    while (curNode) {\n        if (curNode.nodeType === ParseNodeType.Function) {\n            return curNode;\n        }\n\n        if (curNode.nodeType === ParseNodeType.Class) {\n            return curNode;\n        }\n\n        curNode = curNode.parent;\n    }\n\n    return undefined;\n}\n\nexport function getEnclosingSuiteOrModule(node: ParseNode): SuiteNode | ModuleNode | undefined {\n    let curNode = node.parent;\n    while (curNode) {\n        if (curNode.nodeType === ParseNodeType.Suite) {\n            return curNode;\n        }\n\n        if (curNode.nodeType === ParseNodeType.Module) {\n            return curNode;\n        }\n\n        if (curNode.nodeType === ParseNodeType.Lambda) {\n            return undefined;\n        }\n\n        curNode = curNode.parent;\n    }\n\n    return undefined;\n}\n\nexport function getEvaluationNodeForAssignmentExpression(\n    node: AssignmentExpressionNode\n): LambdaNode | FunctionNode | ModuleNode | undefined {\n    // PEP 572 indicates that the evaluation node for an assignment expression\n    // target is the containing lambda, function or module, but not a class.\n    let curNode: ParseNode | undefined = getEvaluationScopeNode(node);\n\n    while (curNode !== undefined) {\n        switch (curNode.nodeType) {\n            case ParseNodeType.Function:\n            case ParseNodeType.Lambda:\n            case ParseNodeType.Module:\n                return curNode;\n\n            case ParseNodeType.Class:\n                return undefined;\n        }\n\n        curNode = curNode.parent;\n    }\n\n    return undefined;\n}\n\n// Returns the parse node corresponding to the scope that is used to evaluate\n// a symbol referenced in the specified node.\nexport function getEvaluationScopeNode(node: ParseNode): EvaluationScopeNode {\n    let prevNode: ParseNode | undefined;\n    let curNode: ParseNode | undefined = node;\n    let isParamNameNode = false;\n\n    while (curNode) {\n        if (curNode.nodeType === ParseNodeType.Parameter && prevNode === curNode.name) {\n            // Note that we passed through a parameter name node.\n            isParamNameNode = true;\n        }\n\n        // We found a scope associated with this node. In most cases,\n        // we'll return this scope, but in a few cases we need to return\n        // the enclosing scope instead.\n        switch (curNode.nodeType) {\n            case ParseNodeType.Function: {\n                if (curNode.parameters.some((param) => param === prevNode)) {\n                    if (isParamNameNode) {\n                        if (getScope(curNode) !== undefined) {\n                            return curNode;\n                        }\n                    }\n                } else if (prevNode === curNode.suite) {\n                    if (getScope(curNode) !== undefined) {\n                        return curNode;\n                    }\n                }\n                break;\n            }\n\n            case ParseNodeType.Lambda: {\n                if (curNode.parameters.some((param) => param === prevNode)) {\n                    if (isParamNameNode) {\n                        if (getScope(curNode) !== undefined) {\n                            return curNode;\n                        }\n                    }\n                } else if (prevNode === curNode.expression) {\n                    if (getScope(curNode) !== undefined) {\n                        return curNode;\n                    }\n                }\n                break;\n            }\n\n            case ParseNodeType.Class: {\n                if (prevNode === curNode.suite) {\n                    if (getScope(curNode) !== undefined) {\n                        return curNode;\n                    }\n                }\n                break;\n            }\n\n            case ParseNodeType.ListComprehension:\n            case ParseNodeType.Module: {\n                if (getScope(curNode) !== undefined) {\n                    return curNode;\n                }\n            }\n        }\n\n        prevNode = curNode;\n        curNode = curNode.parent;\n    }\n\n    fail('Did not find evaluation scope');\n    return undefined!;\n}\n\n// Returns the parse node corresponding to the function or class that\n// contains the specified typeVar reference.\nexport function getTypeVarScopeNode(node: ParseNode): EvaluationScopeNode {\n    let prevNode: ParseNode | undefined;\n    let curNode: ParseNode | undefined = node;\n\n    while (curNode) {\n        switch (curNode.nodeType) {\n            case ParseNodeType.Function: {\n                if (prevNode === curNode.suite) {\n                    return curNode;\n                }\n                break;\n            }\n\n            case ParseNodeType.Class: {\n                if (prevNode === curNode.suite) {\n                    return curNode;\n                }\n                break;\n            }\n        }\n\n        prevNode = curNode;\n        curNode = curNode.parent;\n    }\n\n    return undefined!;\n}\n\n// Returns the parse node corresponding to the scope that is used\n// for executing the code referenced in the specified node.\nexport function getExecutionScopeNode(node: ParseNode): ExecutionScopeNode {\n    let evaluationScope = getEvaluationScopeNode(node);\n\n    // Classes are not considered execution scope because they are executed\n    // within the context of their containing module or function. Likewise, list\n    // comprehensions are executed within their container.\n    while (\n        evaluationScope.nodeType === ParseNodeType.Class ||\n        evaluationScope.nodeType === ParseNodeType.ListComprehension\n    ) {\n        evaluationScope = getEvaluationScopeNode(evaluationScope.parent!);\n    }\n\n    return evaluationScope;\n}\n\n// Given a node within a type annotation expression, returns the type annotation\n// node that contains it (if applicable).\nexport function getTypeAnnotationNode(node: ParseNode): TypeAnnotationNode | undefined {\n    let prevNode = node;\n    let curNode = node.parent;\n\n    while (curNode) {\n        if (curNode.nodeType === ParseNodeType.TypeAnnotation) {\n            if (curNode.typeAnnotation === prevNode) {\n                return curNode;\n            }\n\n            break;\n        }\n\n        prevNode = curNode;\n        curNode = curNode.parent;\n    }\n\n    return undefined;\n}\n\n// PEP 591 spells out certain limited cases where an assignment target\n// can be annotated with a \"Final\" annotation. This function determines\n// whether Final is allowed for the specified node.\nexport function isFinalAllowedForAssignmentTarget(targetNode: ExpressionNode): boolean {\n    // Simple names always support Final.\n    if (targetNode.nodeType === ParseNodeType.Name) {\n        return true;\n    }\n\n    // Member access expressions like \"self.x\" are permitted only\n    // within __init__ methods.\n    if (targetNode.nodeType === ParseNodeType.MemberAccess) {\n        if (targetNode.leftExpression.nodeType !== ParseNodeType.Name) {\n            return false;\n        }\n\n        const classNode = getEnclosingClass(targetNode);\n        if (!classNode) {\n            return false;\n        }\n\n        const methodNode = getEnclosingFunction(targetNode);\n        if (!methodNode) {\n            return false;\n        }\n\n        if (methodNode.name.value !== '__init__') {\n            return false;\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\nexport function isNodeContainedWithin(node: ParseNode, potentialContainer: ParseNode): boolean {\n    let curNode: ParseNode | undefined = node;\n    while (curNode) {\n        if (curNode === potentialContainer) {\n            return true;\n        }\n\n        curNode = curNode.parent;\n    }\n\n    return false;\n}\n\nexport function isSuiteEmpty(node: SuiteNode): boolean {\n    for (const statement of node.statements) {\n        if (statement.nodeType === ParseNodeType.StatementList) {\n            for (const substatement of statement.statements) {\n                if (substatement.nodeType === ParseNodeType.Ellipsis) {\n                    // Allow an ellipsis\n                } else if (substatement.nodeType === ParseNodeType.StringList) {\n                    // Allow doc strings\n                } else {\n                    return false;\n                }\n            }\n        } else {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nexport function isMatchingExpression(expression1: ExpressionNode, expression2: ExpressionNode): boolean {\n    if (expression1.nodeType === ParseNodeType.Name && expression2.nodeType === ParseNodeType.Name) {\n        return expression1.value === expression2.value;\n    } else if (\n        expression1.nodeType === ParseNodeType.MemberAccess &&\n        expression2.nodeType === ParseNodeType.MemberAccess\n    ) {\n        return (\n            isMatchingExpression(expression1.leftExpression, expression2.leftExpression) &&\n            expression1.memberName.value === expression2.memberName.value\n        );\n    }\n\n    return false;\n}\n\nexport function isWithinDefaultParamInitializer(node: ParseNode) {\n    let curNode: ParseNode | undefined = node;\n    let prevNode: ParseNode | undefined;\n\n    while (curNode) {\n        if (curNode.nodeType === ParseNodeType.Parameter && prevNode === curNode.defaultValue) {\n            return true;\n        }\n\n        if (\n            curNode.nodeType === ParseNodeType.Lambda ||\n            curNode.nodeType === ParseNodeType.Function ||\n            curNode.nodeType === ParseNodeType.Class ||\n            curNode.nodeType === ParseNodeType.Module\n        ) {\n            return false;\n        }\n\n        prevNode = curNode;\n        curNode = curNode.parent;\n    }\n\n    return false;\n}\n\nexport function isWithinTypeAnnotation(node: ParseNode, requireQuotedAnnotation: boolean) {\n    let curNode: ParseNode | undefined = node;\n    let prevNode: ParseNode | undefined;\n    let isQuoted = false;\n\n    while (curNode) {\n        if (\n            curNode.nodeType === ParseNodeType.Parameter &&\n            (prevNode === curNode.typeAnnotation || prevNode === curNode.typeAnnotationComment)\n        ) {\n            return isQuoted || !requireQuotedAnnotation;\n        }\n\n        if (curNode.nodeType === ParseNodeType.Function && prevNode === curNode.returnTypeAnnotation) {\n            return isQuoted || !requireQuotedAnnotation;\n        }\n\n        if (curNode.nodeType === ParseNodeType.Function && prevNode === curNode.functionAnnotationComment) {\n            // Type comments are always considered forward declarations even though\n            // they're not \"quoted\".\n            return true;\n        }\n\n        if (curNode.nodeType === ParseNodeType.TypeAnnotation && prevNode === curNode.typeAnnotation) {\n            return isQuoted || !requireQuotedAnnotation;\n        }\n\n        if (curNode.nodeType === ParseNodeType.Assignment && prevNode === curNode.typeAnnotationComment) {\n            // Type comments are always considered forward declarations even though\n            // they're not \"quoted\".\n            return true;\n        }\n\n        if (curNode.nodeType === ParseNodeType.StringList && prevNode === curNode.typeAnnotation) {\n            isQuoted = true;\n        }\n\n        if (\n            curNode.nodeType === ParseNodeType.Lambda ||\n            curNode.nodeType === ParseNodeType.Function ||\n            curNode.nodeType === ParseNodeType.Class ||\n            curNode.nodeType === ParseNodeType.Module\n        ) {\n            return false;\n        }\n\n        prevNode = curNode;\n        curNode = curNode.parent;\n    }\n\n    return false;\n}\n\nexport function getDocString(statements: StatementNode[]): string | undefined {\n    // See if the first statement in the suite is a triple-quote string.\n    if (statements.length === 0) {\n        return undefined;\n    }\n\n    if (statements[0].nodeType !== ParseNodeType.StatementList) {\n        return undefined;\n    }\n\n    // If the first statement in the suite isn't a StringNode,\n    // assume there is no docString.\n    const statementList = statements[0];\n    if (statementList.statements.length === 0 || statementList.statements[0].nodeType !== ParseNodeType.StringList) {\n        return undefined;\n    }\n\n    const docStringNode = statementList.statements[0];\n    const docStringToken = docStringNode.strings[0].token;\n\n    // Ignore f-strings.\n    if ((docStringToken.flags & StringTokenFlags.Format) !== 0) {\n        return undefined;\n    }\n\n    return decodeDocString(docStringNode.strings[0].value);\n}\n\n// Sometimes a NamedTuple assignment statement is followed by a statement\n// that looks like the following:\n//    MyNamedTuple.__new__.__defaults__ = ...\n// This pattern is commonly used to set the default values that are\n// not specified in the original list.\nexport function isAssignmentToDefaultsFollowingNamedTuple(callNode: ParseNode): boolean {\n    if (\n        callNode.nodeType !== ParseNodeType.Call ||\n        !callNode.parent ||\n        callNode.parent.nodeType !== ParseNodeType.Assignment ||\n        callNode.parent.leftExpression.nodeType !== ParseNodeType.Name ||\n        !callNode.parent.parent ||\n        callNode.parent.parent.nodeType !== ParseNodeType.StatementList\n    ) {\n        return false;\n    }\n\n    const namedTupleAssignedName = callNode.parent.leftExpression.value;\n    const statementList = callNode.parent.parent;\n    if (\n        statementList.statements[0] !== callNode.parent ||\n        !statementList.parent ||\n        !(\n            statementList.parent.nodeType === ParseNodeType.Module ||\n            statementList.parent.nodeType === ParseNodeType.Suite\n        )\n    ) {\n        return false;\n    }\n\n    const moduleOrSuite = statementList.parent;\n    let statementIndex = moduleOrSuite.statements.findIndex((s) => s === statementList);\n\n    if (statementIndex < 0) {\n        return false;\n    }\n    statementIndex++;\n\n    while (statementIndex < moduleOrSuite.statements.length) {\n        const nextStatement = moduleOrSuite.statements[statementIndex];\n        if (nextStatement.nodeType !== ParseNodeType.StatementList) {\n            break;\n        }\n\n        if (nextStatement.statements[0].nodeType === ParseNodeType.StringList) {\n            // Skip over comments\n            statementIndex++;\n            continue;\n        }\n\n        if (nextStatement.statements[0].nodeType === ParseNodeType.Assignment) {\n            const assignNode = nextStatement.statements[0];\n            if (\n                assignNode.leftExpression.nodeType === ParseNodeType.MemberAccess &&\n                assignNode.leftExpression.memberName.value === '__defaults__'\n            ) {\n                const defaultTarget = assignNode.leftExpression.leftExpression;\n                if (\n                    defaultTarget.nodeType === ParseNodeType.MemberAccess &&\n                    defaultTarget.memberName.value === '__new__' &&\n                    defaultTarget.leftExpression.nodeType === ParseNodeType.Name &&\n                    defaultTarget.leftExpression.value === namedTupleAssignedName\n                ) {\n                    return true;\n                }\n            }\n        }\n\n        break;\n    }\n\n    return false;\n}\n","/*\n * parseTreeWalker.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Class that traverses a parse tree.\n */\n\nimport { fail } from '../common/debug';\nimport {\n    ArgumentNode,\n    AssertNode,\n    AssignmentExpressionNode,\n    AssignmentNode,\n    AugmentedAssignmentNode,\n    AwaitNode,\n    BinaryOperationNode,\n    BreakNode,\n    CallNode,\n    ClassNode,\n    ConstantNode,\n    ContinueNode,\n    DecoratorNode,\n    DelNode,\n    DictionaryExpandEntryNode,\n    DictionaryKeyEntryNode,\n    DictionaryNode,\n    EllipsisNode,\n    ErrorNode,\n    ExceptNode,\n    FormatStringNode,\n    ForNode,\n    FunctionAnnotationNode,\n    FunctionNode,\n    GlobalNode,\n    IfNode,\n    ImportAsNode,\n    ImportFromAsNode,\n    ImportFromNode,\n    ImportNode,\n    IndexItemsNode,\n    IndexNode,\n    LambdaNode,\n    ListComprehensionForNode,\n    ListComprehensionIfNode,\n    ListComprehensionNode,\n    ListNode,\n    MemberAccessNode,\n    ModuleNameNode,\n    ModuleNode,\n    NameNode,\n    NonlocalNode,\n    NumberNode,\n    ParameterNode,\n    ParseNode,\n    ParseNodeArray,\n    ParseNodeType,\n    PassNode,\n    RaiseNode,\n    ReturnNode,\n    SetNode,\n    SliceNode,\n    StatementListNode,\n    StringListNode,\n    StringNode,\n    SuiteNode,\n    TernaryNode,\n    TryNode,\n    TupleNode,\n    TypeAnnotationNode,\n    UnaryOperationNode,\n    UnpackNode,\n    WhileNode,\n    WithItemNode,\n    WithNode,\n    YieldFromNode,\n    YieldNode,\n} from '../parser/parseNodes';\n\n// To use this class, create a subclass and override the\n// visitXXX methods that you want to handle.\nexport class ParseTreeWalker {\n    walk(node: ParseNode): void {\n        const childrenToWalk = this.visitNode(node);\n        if (childrenToWalk.length > 0) {\n            this.walkMultiple(childrenToWalk);\n        }\n    }\n\n    walkMultiple(nodes: ParseNodeArray) {\n        nodes.forEach((node) => {\n            if (node) {\n                this.walk(node);\n            }\n        });\n    }\n\n    // Calls the node-specific method (visitXXXX). If the method\n    // returns true, all child nodes for the node are returned.\n    // If the method returns false, we assume that the handler\n    // has already handled the child nodes, so an empty list is\n    // returned.\n    visitNode(node: ParseNode): ParseNodeArray {\n        switch (node.nodeType) {\n            case ParseNodeType.Argument:\n                if (this.visitArgument(node)) {\n                    return [node.name, node.valueExpression];\n                }\n                break;\n\n            case ParseNodeType.Assert:\n                if (this.visitAssert(node)) {\n                    return [node.testExpression, node.exceptionExpression];\n                }\n                break;\n\n            case ParseNodeType.Assignment:\n                if (this.visitAssignment(node)) {\n                    return [node.leftExpression, node.rightExpression, node.typeAnnotationComment];\n                }\n                break;\n\n            case ParseNodeType.AssignmentExpression:\n                if (this.visitAssignmentExpression(node)) {\n                    return [node.name, node.rightExpression];\n                }\n                break;\n\n            case ParseNodeType.AugmentedAssignment:\n                if (this.visitAugmentedAssignment(node)) {\n                    return [node.leftExpression, node.rightExpression];\n                }\n                break;\n\n            case ParseNodeType.Await:\n                if (this.visitAwait(node)) {\n                    return [node.expression];\n                }\n                break;\n\n            case ParseNodeType.BinaryOperation:\n                if (this.visitBinaryOperation(node)) {\n                    return [node.leftExpression, node.rightExpression];\n                }\n                break;\n\n            case ParseNodeType.Break:\n                if (this.visitBreak(node)) {\n                    return [];\n                }\n                break;\n\n            case ParseNodeType.Call:\n                if (this.visitCall(node)) {\n                    return [node.leftExpression, ...node.arguments];\n                }\n                break;\n\n            case ParseNodeType.Class:\n                if (this.visitClass(node)) {\n                    return [...node.decorators, node.name, ...node.arguments, node.suite];\n                }\n                break;\n\n            case ParseNodeType.Ternary:\n                if (this.visitTernary(node)) {\n                    return [node.ifExpression, node.testExpression, node.elseExpression];\n                }\n                break;\n\n            case ParseNodeType.Constant:\n                if (this.visitConstant(node)) {\n                    return [];\n                }\n                break;\n\n            case ParseNodeType.Continue:\n                if (this.visitContinue(node)) {\n                    return [];\n                }\n                break;\n\n            case ParseNodeType.Decorator:\n                if (this.visitDecorator(node)) {\n                    return [node.leftExpression, ...(node.arguments || [])];\n                }\n                break;\n\n            case ParseNodeType.Del:\n                if (this.visitDel(node)) {\n                    return node.expressions;\n                }\n                break;\n\n            case ParseNodeType.Dictionary:\n                if (this.visitDictionary(node)) {\n                    return node.entries;\n                }\n                break;\n\n            case ParseNodeType.DictionaryKeyEntry:\n                if (this.visitDictionaryKeyEntry(node)) {\n                    return [node.keyExpression, node.valueExpression];\n                }\n                break;\n\n            case ParseNodeType.DictionaryExpandEntry:\n                if (this.visitDictionaryExpandEntry(node)) {\n                    return [node.expandExpression];\n                }\n                break;\n\n            case ParseNodeType.Error:\n                if (this.visitError(node)) {\n                    return [node.child];\n                }\n                break;\n\n            case ParseNodeType.If:\n                if (this.visitIf(node)) {\n                    return [node.testExpression, node.ifSuite, node.elseSuite];\n                }\n                break;\n\n            case ParseNodeType.Import:\n                if (this.visitImport(node)) {\n                    return node.list;\n                }\n                break;\n\n            case ParseNodeType.ImportAs:\n                if (this.visitImportAs(node)) {\n                    return [node.module, node.alias];\n                }\n                break;\n\n            case ParseNodeType.ImportFrom:\n                if (this.visitImportFrom(node)) {\n                    return [node.module, ...node.imports];\n                }\n                break;\n\n            case ParseNodeType.ImportFromAs:\n                if (this.visitImportFromAs(node)) {\n                    return [node.name, node.alias];\n                }\n                break;\n\n            case ParseNodeType.Index:\n                if (this.visitIndex(node)) {\n                    return [node.baseExpression, node.items];\n                }\n                break;\n\n            case ParseNodeType.IndexItems:\n                if (this.visitIndexItems(node)) {\n                    return node.items;\n                }\n                break;\n\n            case ParseNodeType.Ellipsis:\n                if (this.visitEllipsis(node)) {\n                    return [];\n                }\n                break;\n\n            case ParseNodeType.Except:\n                if (this.visitExcept(node)) {\n                    return [node.typeExpression, node.name, node.exceptSuite];\n                }\n                break;\n\n            case ParseNodeType.For:\n                if (this.visitFor(node)) {\n                    return [node.targetExpression, node.iterableExpression, node.forSuite, node.elseSuite];\n                }\n                break;\n\n            case ParseNodeType.FormatString:\n                if (this.visitFormatString(node)) {\n                    return node.expressions;\n                }\n                break;\n\n            case ParseNodeType.Function:\n                if (this.visitFunction(node)) {\n                    return [\n                        ...node.decorators,\n                        node.name,\n                        ...node.parameters,\n                        node.returnTypeAnnotation,\n                        node.functionAnnotationComment,\n                        node.suite,\n                    ];\n                }\n                break;\n\n            case ParseNodeType.FunctionAnnotation:\n                if (this.visitFunctionAnnotation(node)) {\n                    return [...node.paramTypeAnnotations, node.returnTypeAnnotation];\n                }\n                break;\n\n            case ParseNodeType.Global:\n                if (this.visitGlobal(node)) {\n                    return node.nameList;\n                }\n                break;\n\n            case ParseNodeType.Lambda:\n                if (this.visitLambda(node)) {\n                    return [...node.parameters, node.expression];\n                }\n                break;\n\n            case ParseNodeType.List:\n                if (this.visitList(node)) {\n                    return node.entries;\n                }\n                break;\n\n            case ParseNodeType.ListComprehension:\n                if (this.visitListComprehension(node)) {\n                    return [node.expression, ...node.comprehensions];\n                }\n                break;\n\n            case ParseNodeType.ListComprehensionFor:\n                if (this.visitListComprehensionFor(node)) {\n                    return [node.targetExpression, node.iterableExpression];\n                }\n                break;\n\n            case ParseNodeType.ListComprehensionIf:\n                if (this.visitListComprehensionIf(node)) {\n                    return [node.testExpression];\n                }\n                break;\n\n            case ParseNodeType.MemberAccess:\n                if (this.visitMemberAccess(node)) {\n                    return [node.leftExpression, node.memberName];\n                }\n                break;\n\n            case ParseNodeType.Module:\n                if (this.visitModule(node)) {\n                    return [...node.statements];\n                }\n                break;\n\n            case ParseNodeType.ModuleName:\n                if (this.visitModuleName(node)) {\n                    return node.nameParts;\n                }\n                break;\n\n            case ParseNodeType.Name:\n                if (this.visitName(node)) {\n                    return [];\n                }\n                break;\n\n            case ParseNodeType.Nonlocal:\n                if (this.visitNonlocal(node)) {\n                    return node.nameList;\n                }\n                break;\n\n            case ParseNodeType.Number:\n                if (this.visitNumber(node)) {\n                    return [];\n                }\n                break;\n\n            case ParseNodeType.Parameter:\n                if (this.visitParameter(node)) {\n                    return [node.name, node.typeAnnotation, node.typeAnnotationComment, node.defaultValue];\n                }\n                break;\n\n            case ParseNodeType.Pass:\n                if (this.visitPass(node)) {\n                    return [];\n                }\n                break;\n\n            case ParseNodeType.Raise:\n                if (this.visitRaise(node)) {\n                    return [node.typeExpression, node.valueExpression, node.tracebackExpression];\n                }\n                break;\n\n            case ParseNodeType.Return:\n                if (this.visitReturn(node)) {\n                    return [node.returnExpression];\n                }\n                break;\n\n            case ParseNodeType.Set:\n                if (this.visitSet(node)) {\n                    return node.entries;\n                }\n                break;\n\n            case ParseNodeType.Slice:\n                if (this.visitSlice(node)) {\n                    return [node.startValue, node.endValue, node.stepValue];\n                }\n                break;\n\n            case ParseNodeType.StatementList:\n                if (this.visitStatementList(node)) {\n                    return node.statements;\n                }\n                break;\n\n            case ParseNodeType.String:\n                if (this.visitString(node)) {\n                    return [];\n                }\n                break;\n\n            case ParseNodeType.StringList:\n                if (this.visitStringList(node)) {\n                    return [node.typeAnnotation, ...node.strings];\n                }\n                break;\n\n            case ParseNodeType.Suite:\n                if (this.visitSuite(node)) {\n                    return [...node.statements];\n                }\n                break;\n\n            case ParseNodeType.Tuple:\n                if (this.visitTuple(node)) {\n                    return node.expressions;\n                }\n                break;\n\n            case ParseNodeType.Try:\n                if (this.visitTry(node)) {\n                    return [node.trySuite, ...node.exceptClauses, node.elseSuite, node.finallySuite];\n                }\n                break;\n\n            case ParseNodeType.TypeAnnotation:\n                if (this.visitTypeAnnotation(node)) {\n                    return [node.valueExpression, node.typeAnnotation];\n                }\n                break;\n\n            case ParseNodeType.UnaryOperation:\n                if (this.visitUnaryOperation(node)) {\n                    return [node.expression];\n                }\n                break;\n\n            case ParseNodeType.Unpack:\n                if (this.visitUnpack(node)) {\n                    return [node.expression];\n                }\n                break;\n\n            case ParseNodeType.While:\n                if (this.visitWhile(node)) {\n                    return [node.testExpression, node.whileSuite, node.elseSuite];\n                }\n                break;\n\n            case ParseNodeType.With:\n                if (this.visitWith(node)) {\n                    return [...node.withItems, node.suite];\n                }\n                break;\n\n            case ParseNodeType.WithItem:\n                if (this.visitWithItem(node)) {\n                    return [node.expression, node.target];\n                }\n                break;\n\n            case ParseNodeType.Yield:\n                if (this.visitYield(node)) {\n                    return [node.expression];\n                }\n                break;\n\n            case ParseNodeType.YieldFrom:\n                if (this.visitYieldFrom(node)) {\n                    return [node.expression];\n                }\n                break;\n\n            default:\n                fail('Unexpected node type');\n                break;\n        }\n\n        return [];\n    }\n\n    // Override these methods as necessary.\n    visitArgument(node: ArgumentNode) {\n        return true;\n    }\n\n    visitAssert(node: AssertNode) {\n        return true;\n    }\n\n    visitAssignment(node: AssignmentNode) {\n        return true;\n    }\n\n    visitAssignmentExpression(node: AssignmentExpressionNode) {\n        return true;\n    }\n\n    visitAugmentedAssignment(node: AugmentedAssignmentNode) {\n        return true;\n    }\n\n    visitAwait(node: AwaitNode) {\n        return true;\n    }\n\n    visitBinaryOperation(node: BinaryOperationNode) {\n        return true;\n    }\n\n    visitBreak(node: BreakNode) {\n        return true;\n    }\n\n    visitCall(node: CallNode) {\n        return true;\n    }\n\n    visitClass(node: ClassNode) {\n        return true;\n    }\n\n    visitTernary(node: TernaryNode) {\n        return true;\n    }\n\n    visitContinue(node: ContinueNode) {\n        return true;\n    }\n\n    visitConstant(node: ConstantNode) {\n        return true;\n    }\n\n    visitDecorator(node: DecoratorNode) {\n        return true;\n    }\n\n    visitDel(node: DelNode) {\n        return true;\n    }\n\n    visitDictionary(node: DictionaryNode) {\n        return true;\n    }\n\n    visitDictionaryKeyEntry(node: DictionaryKeyEntryNode) {\n        return true;\n    }\n\n    visitDictionaryExpandEntry(node: DictionaryExpandEntryNode) {\n        return true;\n    }\n\n    visitError(node: ErrorNode) {\n        return true;\n    }\n\n    visitEllipsis(node: EllipsisNode) {\n        return true;\n    }\n\n    visitIf(node: IfNode) {\n        return true;\n    }\n\n    visitImport(node: ImportNode) {\n        return true;\n    }\n\n    visitImportAs(node: ImportAsNode) {\n        return true;\n    }\n\n    visitImportFrom(node: ImportFromNode) {\n        return true;\n    }\n\n    visitImportFromAs(node: ImportFromAsNode) {\n        return true;\n    }\n\n    visitIndex(node: IndexNode) {\n        return true;\n    }\n\n    visitIndexItems(node: IndexItemsNode) {\n        return true;\n    }\n\n    visitExcept(node: ExceptNode) {\n        return true;\n    }\n\n    visitFor(node: ForNode) {\n        return true;\n    }\n\n    visitFormatString(node: FormatStringNode) {\n        return true;\n    }\n\n    visitFunction(node: FunctionNode) {\n        return true;\n    }\n\n    visitFunctionAnnotation(node: FunctionAnnotationNode) {\n        return true;\n    }\n\n    visitGlobal(node: GlobalNode) {\n        return true;\n    }\n\n    visitLambda(node: LambdaNode) {\n        return true;\n    }\n\n    visitList(node: ListNode) {\n        return true;\n    }\n\n    visitListComprehension(node: ListComprehensionNode) {\n        return true;\n    }\n\n    visitListComprehensionFor(node: ListComprehensionForNode) {\n        return true;\n    }\n\n    visitListComprehensionIf(node: ListComprehensionIfNode) {\n        return true;\n    }\n\n    visitMemberAccess(node: MemberAccessNode) {\n        return true;\n    }\n\n    visitModule(node: ModuleNode) {\n        return true;\n    }\n\n    visitModuleName(node: ModuleNameNode) {\n        return true;\n    }\n\n    visitName(node: NameNode) {\n        return true;\n    }\n\n    visitNonlocal(node: NonlocalNode) {\n        return true;\n    }\n\n    visitNumber(node: NumberNode) {\n        return true;\n    }\n\n    visitParameter(node: ParameterNode) {\n        return true;\n    }\n\n    visitPass(node: PassNode) {\n        return true;\n    }\n\n    visitRaise(node: RaiseNode) {\n        return true;\n    }\n\n    visitReturn(node: ReturnNode) {\n        return true;\n    }\n\n    visitSet(node: SetNode) {\n        return true;\n    }\n\n    visitSlice(node: SliceNode) {\n        return true;\n    }\n\n    visitStatementList(node: StatementListNode) {\n        return true;\n    }\n\n    visitString(node: StringNode) {\n        return true;\n    }\n\n    visitStringList(node: StringListNode) {\n        return true;\n    }\n\n    visitSuite(node: SuiteNode) {\n        return true;\n    }\n\n    visitTuple(node: TupleNode) {\n        return true;\n    }\n\n    visitTry(node: TryNode) {\n        return true;\n    }\n\n    visitTypeAnnotation(node: TypeAnnotationNode) {\n        return true;\n    }\n\n    visitUnaryOperation(node: UnaryOperationNode) {\n        return true;\n    }\n\n    visitUnpack(node: UnpackNode) {\n        return true;\n    }\n\n    visitWhile(node: WhileNode) {\n        return true;\n    }\n\n    visitWith(node: WithNode) {\n        return true;\n    }\n\n    visitWithItem(node: WithItemNode) {\n        return true;\n    }\n\n    visitYield(node: YieldNode) {\n        return true;\n    }\n\n    visitYieldFrom(node: YieldFromNode) {\n        return true;\n    }\n}\n","/*\n * program.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * An object that tracks all of the source files being analyzed\n * and all of their recursive imports.\n */\n\nimport { CancellationToken, CompletionItem, DocumentSymbol, SymbolInformation } from 'vscode-languageserver';\nimport {\n    CallHierarchyIncomingCall,\n    CallHierarchyItem,\n    CallHierarchyOutgoingCall,\n    DocumentHighlight,\n} from 'vscode-languageserver-types';\n\nimport { OperationCanceledException, throwIfCancellationRequested } from '../common/cancellationUtils';\nimport { ConfigOptions, ExecutionEnvironment } from '../common/configOptions';\nimport { ConsoleInterface, StandardConsole } from '../common/console';\nimport { isDebugMode } from '../common/core';\nimport { assert } from '../common/debug';\nimport { Diagnostic } from '../common/diagnostic';\nimport { FileDiagnostics } from '../common/diagnosticSink';\nimport { FileEditAction, TextEditAction } from '../common/editAction';\nimport { LanguageServiceExtension } from '../common/extensibility';\nimport { LogTracker } from '../common/logTracker';\nimport {\n    combinePaths,\n    getDirectoryPath,\n    getFileName,\n    getRelativePath,\n    makeDirectories,\n    normalizePath,\n    normalizePathCase,\n    stripFileExtension,\n} from '../common/pathUtils';\nimport { convertPositionToOffset, convertRangeToTextRange } from '../common/positionUtils';\nimport { DocumentRange, doesRangeContain, doRangesIntersect, Position, Range } from '../common/textRange';\nimport { Duration, timingStats } from '../common/timing';\nimport {\n    AutoImporter,\n    AutoImportResult,\n    buildModuleSymbolsMap,\n    ModuleSymbolMap,\n} from '../languageService/autoImporter';\nimport { CallHierarchyProvider } from '../languageService/callHierarchyProvider';\nimport { CompletionResults } from '../languageService/completionProvider';\nimport { IndexResults } from '../languageService/documentSymbolProvider';\nimport { HoverResults } from '../languageService/hoverProvider';\nimport { ReferencesResult } from '../languageService/referencesProvider';\nimport { SignatureHelpResults } from '../languageService/signatureHelpProvider';\nimport { ImportLookupResult } from './analyzerFileInfo';\nimport * as AnalyzerNodeInfo from './analyzerNodeInfo';\nimport { CircularDependency } from './circularDependency';\nimport { ImportResolver } from './importResolver';\nimport { ImportResult, ImportType } from './importResult';\nimport { findNodeByOffset } from './parseTreeUtils';\nimport { Scope } from './scope';\nimport { getScopeForNode } from './scopeUtils';\nimport { SourceFile } from './sourceFile';\nimport { SourceMapper } from './sourceMapper';\nimport { isPrivateOrProtectedName } from './symbolNameUtils';\nimport { createTypeEvaluator, PrintTypeFlags, TypeEvaluator } from './typeEvaluator';\nimport { TypeStubWriter } from './typeStubWriter';\n\nconst _maxImportDepth = 256;\n\n// Tracks information about each source file in a program,\n// including the reason it was added to the program and any\n// dependencies that it has on other files in the program.\nexport interface SourceFileInfo {\n    // Reference to the source file\n    sourceFile: SourceFile;\n\n    // Information about the source file\n    isTypeshedFile: boolean;\n    isThirdPartyImport: boolean;\n    isThirdPartyPyTypedPresent: boolean;\n    diagnosticsVersion?: number;\n    builtinsImport?: SourceFileInfo;\n\n    // Information about why the file is included in the program\n    // and its relation to other source files in the program.\n    isTracked: boolean;\n    isOpenByClient: boolean;\n    imports: SourceFileInfo[];\n    importedBy: SourceFileInfo[];\n    shadows: SourceFileInfo[];\n    shadowedBy: SourceFileInfo[];\n}\n\nexport interface MaxAnalysisTime {\n    // Maximum number of ms to analyze when there are open files\n    // that require analysis. This number is usually kept relatively\n    // small to guarantee responsiveness during typing.\n    openFilesTimeInMs: number;\n\n    // Maximum number of ms to analyze when all open files and their\n    // dependencies have been analyzed. This number can be higher\n    // to reduce overall analysis time but needs to be short enough\n    // to remain responsive if an open file is modified.\n    noOpenFilesTimeInMs: number;\n}\n\nexport interface Indices {\n    setWorkspaceIndex(path: string, indexResults: IndexResults): void;\n    getIndex(execEnv: string): Map<string, IndexResults> | undefined;\n    setIndex(execEnv: string, path: string, indexResults: IndexResults): void;\n    reset(): void;\n}\n\ninterface UpdateImportInfo {\n    path: string;\n    isTypeshedFile: boolean;\n    isThirdPartyImport: boolean;\n    isPyTypedPresent: boolean;\n}\n\n// Container for all of the files that are being analyzed. Files\n// can fall into one or more of the following categories:\n//  Tracked - specified by the config options\n//  Referenced - part of the transitive closure\n//  Opened - temporarily opened in the editor\n//  Shadowed - implementation file that shadows a type stub file\nexport class Program {\n    private _console: ConsoleInterface;\n    private _sourceFileList: SourceFileInfo[] = [];\n    private _sourceFileMap = new Map<string, SourceFileInfo>();\n    private _allowedThirdPartyImports: string[] | undefined;\n    private _evaluator: TypeEvaluator | undefined;\n    private _configOptions: ConfigOptions;\n    private _importResolver: ImportResolver;\n    private _logTracker: LogTracker;\n    private _parsedFileCount = 0;\n\n    constructor(\n        initialImportResolver: ImportResolver,\n        initialConfigOptions: ConfigOptions,\n        console?: ConsoleInterface,\n        private _extension?: LanguageServiceExtension,\n        logPrefix = 'FG'\n    ) {\n        this._console = console || new StandardConsole();\n        this._logTracker = new LogTracker(console, logPrefix);\n        this._importResolver = initialImportResolver;\n        this._configOptions = initialConfigOptions;\n        this._createNewEvaluator();\n    }\n\n    get evaluator(): TypeEvaluator | undefined {\n        return this._evaluator;\n    }\n\n    setConfigOptions(configOptions: ConfigOptions) {\n        this._configOptions = configOptions;\n\n        // Create a new evaluator with the updated config options.\n        this._createNewEvaluator();\n    }\n\n    setImportResolver(importResolver: ImportResolver) {\n        this._importResolver = importResolver;\n    }\n\n    // Sets the list of tracked files that make up the program.\n    setTrackedFiles(filePaths: string[]): FileDiagnostics[] {\n        if (this._sourceFileList.length > 0) {\n            // We need to determine which files to remove from the existing file list.\n            const newFileMap = new Map<string, string>();\n            filePaths.forEach((path) => {\n                newFileMap.set(normalizePathCase(this._fs, path), path);\n            });\n\n            // Files that are not in the tracked file list are\n            // marked as no longer tracked.\n            this._sourceFileList.forEach((oldFile) => {\n                const filePath = normalizePathCase(this._fs, oldFile.sourceFile.getFilePath());\n                if (!newFileMap.has(filePath)) {\n                    oldFile.isTracked = false;\n                }\n            });\n        }\n\n        // Add the new files. Only the new items will be added.\n        this.addTrackedFiles(filePaths);\n\n        return this._removeUnneededFiles();\n    }\n\n    // By default, no third-party imports are allowed. This enables\n    // third-party imports for a specified import and its children.\n    // For example, if importNames is ['tensorflow'], then third-party\n    // (absolute) imports are allowed for 'import tensorflow',\n    // 'import tensorflow.optimizers', etc.\n    setAllowedThirdPartyImports(importNames: string[]) {\n        this._allowedThirdPartyImports = importNames;\n    }\n\n    addTrackedFiles(filePaths: string[]) {\n        filePaths.forEach((filePath) => {\n            this.addTrackedFile(filePath);\n        });\n    }\n\n    addTrackedFile(filePath: string): SourceFile {\n        let sourceFileInfo = this._getSourceFileInfoFromPath(filePath);\n        if (sourceFileInfo) {\n            sourceFileInfo.isTracked = true;\n            return sourceFileInfo.sourceFile;\n        }\n\n        const importName = this._getImportNameForFile(filePath);\n        const sourceFile = new SourceFile(\n            this._fs,\n            filePath,\n            importName,\n            /* isThirdPartyImport */ false,\n            /* isInPyTypedPackage */ false,\n            this._console,\n            this._logTracker\n        );\n        sourceFileInfo = {\n            sourceFile,\n            isTracked: true,\n            isOpenByClient: false,\n            isTypeshedFile: false,\n            isThirdPartyImport: false,\n            isThirdPartyPyTypedPresent: false,\n            diagnosticsVersion: undefined,\n            imports: [],\n            importedBy: [],\n            shadows: [],\n            shadowedBy: [],\n        };\n        this._addToSourceFileListAndMap(sourceFileInfo);\n        return sourceFile;\n    }\n\n    setFileOpened(filePath: string, version: number | null, contents: string) {\n        let sourceFileInfo = this._getSourceFileInfoFromPath(filePath);\n        if (!sourceFileInfo) {\n            const importName = this._getImportNameForFile(filePath);\n            const sourceFile = new SourceFile(\n                this._fs,\n                filePath,\n                importName,\n                /* isThirdPartyImport */ false,\n                /* isInPyTypedPackage */ false,\n                this._console,\n                this._logTracker\n            );\n            sourceFileInfo = {\n                sourceFile,\n                isTracked: false,\n                isOpenByClient: true,\n                isTypeshedFile: false,\n                isThirdPartyImport: false,\n                isThirdPartyPyTypedPresent: false,\n                diagnosticsVersion: undefined,\n                imports: [],\n                importedBy: [],\n                shadows: [],\n                shadowedBy: [],\n            };\n            this._addToSourceFileListAndMap(sourceFileInfo);\n        } else {\n            sourceFileInfo.isOpenByClient = true;\n\n            // Reset the diagnostic version so we force an update\n            // to the diagnostics, which can change based on whether\n            // the file is open.\n            sourceFileInfo.diagnosticsVersion = undefined;\n        }\n\n        sourceFileInfo.sourceFile.setClientVersion(version, contents);\n    }\n\n    setFileClosed(filePath: string): FileDiagnostics[] {\n        const sourceFileInfo = this._getSourceFileInfoFromPath(filePath);\n        if (sourceFileInfo) {\n            sourceFileInfo.isOpenByClient = false;\n            sourceFileInfo.sourceFile.setClientVersion(null, '');\n        }\n\n        return this._removeUnneededFiles();\n    }\n\n    markAllFilesDirty(evenIfContentsAreSame: boolean) {\n        const markDirtyMap = new Map<string, boolean>();\n\n        this._sourceFileList.forEach((sourceFileInfo) => {\n            if (evenIfContentsAreSame) {\n                sourceFileInfo.sourceFile.markDirty();\n            } else if (sourceFileInfo.sourceFile.didContentsChangeOnDisk()) {\n                sourceFileInfo.sourceFile.markDirty();\n\n                // Mark any files that depend on this file as dirty\n                // also. This will retrigger analysis of these other files.\n                this._markFileDirtyRecursive(sourceFileInfo, markDirtyMap);\n            }\n        });\n\n        if (markDirtyMap.size > 0) {\n            this._createNewEvaluator();\n        }\n    }\n\n    markFilesDirty(filePaths: string[], evenIfContentsAreSame: boolean) {\n        const markDirtyMap = new Map<string, boolean>();\n        filePaths.forEach((filePath) => {\n            const sourceFileInfo = this._getSourceFileInfoFromPath(filePath);\n            if (sourceFileInfo) {\n                // If !evenIfContentsAreSame, see if the on-disk contents have\n                // changed. If the file is open, the on-disk contents don't matter\n                // because we'll receive updates directly from the client.\n                if (\n                    evenIfContentsAreSame ||\n                    (!sourceFileInfo.isOpenByClient && sourceFileInfo.sourceFile.didContentsChangeOnDisk())\n                ) {\n                    sourceFileInfo.sourceFile.markDirty();\n\n                    // Mark any files that depend on this file as dirty\n                    // also. This will retrigger analysis of these other files.\n                    this._markFileDirtyRecursive(sourceFileInfo, markDirtyMap);\n                }\n            }\n        });\n\n        if (markDirtyMap.size > 0) {\n            this._createNewEvaluator();\n        }\n    }\n\n    getFileCount() {\n        return this._sourceFileList.length;\n    }\n\n    getFilesToAnalyzeCount() {\n        let sourceFileCount = 0;\n\n        this._sourceFileList.forEach((fileInfo) => {\n            if (fileInfo.sourceFile.isCheckingRequired()) {\n                if (this._shouldCheckFile(fileInfo)) {\n                    sourceFileCount++;\n                }\n            }\n        });\n\n        return sourceFileCount;\n    }\n\n    isCheckingOnlyOpenFiles() {\n        return this._configOptions.checkOnlyOpenFiles || false;\n    }\n\n    getSourceFile(filePath: string): SourceFile | undefined {\n        const sourceFileInfo = this._getSourceFileInfoFromPath(filePath);\n        if (!sourceFileInfo) {\n            return undefined;\n        }\n\n        return sourceFileInfo.sourceFile;\n    }\n\n    getBoundSourceFile(filePath: string): SourceFile | undefined {\n        const sourceFileInfo = this._getSourceFileInfoFromPath(filePath);\n        if (!sourceFileInfo) {\n            return undefined;\n        }\n\n        this._bindFile(sourceFileInfo);\n        return this.getSourceFile(filePath);\n    }\n\n    // Performs parsing and analysis of any source files in the program\n    // that require it. If a limit time is specified, the operation\n    // is interrupted when the time expires. The return value indicates\n    // whether the method needs to be called again to complete the\n    // analysis. In interactive mode, the timeout is always limited\n    // to the smaller value to maintain responsiveness.\n    analyze(maxTime?: MaxAnalysisTime, token: CancellationToken = CancellationToken.None): boolean {\n        return this._runEvaluatorWithCancellationToken(token, () => {\n            const elapsedTime = new Duration();\n\n            const openFiles = this._sourceFileList.filter(\n                (sf) => sf.isOpenByClient && sf.sourceFile.isCheckingRequired()\n            );\n\n            if (openFiles.length > 0) {\n                const effectiveMaxTime = maxTime ? maxTime.openFilesTimeInMs : Number.MAX_VALUE;\n\n                // Check the open files.\n                for (const sourceFileInfo of openFiles) {\n                    if (this._checkTypes(sourceFileInfo)) {\n                        if (elapsedTime.getDurationInMilliseconds() > effectiveMaxTime) {\n                            return true;\n                        }\n                    }\n                }\n\n                // If the caller specified a maxTime, return at this point\n                // since we've finalized all open files. We want to get\n                // the results to the user as quickly as possible.\n                if (maxTime !== undefined) {\n                    return true;\n                }\n            }\n\n            if (!this._configOptions.checkOnlyOpenFiles) {\n                const effectiveMaxTime = maxTime ? maxTime.noOpenFilesTimeInMs : Number.MAX_VALUE;\n\n                // Now do type parsing and analysis of the remaining.\n                for (const sourceFileInfo of this._sourceFileList) {\n                    if (!this._isUserCode(sourceFileInfo)) {\n                        continue;\n                    }\n\n                    if (this._checkTypes(sourceFileInfo)) {\n                        if (elapsedTime.getDurationInMilliseconds() > effectiveMaxTime) {\n                            return true;\n                        }\n                    }\n                }\n            }\n\n            return false;\n        });\n    }\n\n    indexWorkspace(callback: (path: string, results: IndexResults) => void, token: CancellationToken) {\n        if (!this._configOptions.indexing) {\n            return;\n        }\n\n        return this._runEvaluatorWithCancellationToken(token, () => {\n            // Go through all workspace files to create indexing data.\n            // This will cause all files in the workspace to be parsed and bound. We might\n            // need to drop some of those parse tree and binding info once indexing is done\n            // if it didn't exist before.\n            for (const sourceFileInfo of this._sourceFileList) {\n                if (!this._isUserCode(sourceFileInfo)) {\n                    continue;\n                }\n\n                this._bindFile(sourceFileInfo);\n                const results = sourceFileInfo.sourceFile.index(false, token);\n                if (results) {\n                    callback(sourceFileInfo.sourceFile.getFilePath(), results);\n                }\n\n                this._handleMemoryHighUsage();\n            }\n        });\n    }\n\n    // Prints import dependency information for each of the files in\n    // the program, skipping any typeshed files.\n    printDependencies(projectRootDir: string, verbose: boolean) {\n        const sortedFiles = this._sourceFileList\n            .filter((s) => !s.isTypeshedFile)\n            .sort((a, b) => {\n                return a.sourceFile.getFilePath() < b.sourceFile.getFilePath() ? 1 : -1;\n            });\n\n        const zeroImportFiles: SourceFile[] = [];\n\n        sortedFiles.forEach((sfInfo) => {\n            this._console.info('');\n            let filePath = sfInfo.sourceFile.getFilePath();\n            const relPath = getRelativePath(filePath, projectRootDir);\n            if (relPath) {\n                filePath = relPath;\n            }\n\n            this._console.info(`${filePath}`);\n\n            this._console.info(\n                ` Imports     ${sfInfo.imports.length} ` + `file${sfInfo.imports.length === 1 ? '' : 's'}`\n            );\n            if (verbose) {\n                sfInfo.imports.forEach((importInfo) => {\n                    this._console.info(`    ${importInfo.sourceFile.getFilePath()}`);\n                });\n            }\n\n            this._console.info(\n                ` Imported by ${sfInfo.importedBy.length} ` + `file${sfInfo.importedBy.length === 1 ? '' : 's'}`\n            );\n            if (verbose) {\n                sfInfo.importedBy.forEach((importInfo) => {\n                    this._console.info(`    ${importInfo.sourceFile.getFilePath()}`);\n                });\n            }\n\n            if (sfInfo.importedBy.length === 0) {\n                zeroImportFiles.push(sfInfo.sourceFile);\n            }\n        });\n\n        if (zeroImportFiles.length > 0) {\n            this._console.info('');\n            this._console.info(\n                `${zeroImportFiles.length} file${zeroImportFiles.length === 1 ? '' : 's'}` + ` not explicitly imported`\n            );\n            zeroImportFiles.forEach((importFile) => {\n                this._console.info(`    ${importFile.getFilePath()}`);\n            });\n        }\n    }\n\n    writeTypeStub(targetImportPath: string, targetIsSingleFile: boolean, stubPath: string, token: CancellationToken) {\n        for (const sourceFileInfo of this._sourceFileList) {\n            throwIfCancellationRequested(token);\n\n            const filePath = sourceFileInfo.sourceFile.getFilePath();\n\n            // Generate type stubs only for the files within the target path,\n            // not any files that the target module happened to import.\n            const relativePath = getRelativePath(filePath, targetImportPath);\n            if (relativePath !== undefined) {\n                let typeStubPath = normalizePath(combinePaths(stubPath, relativePath));\n\n                // If the target is a single file implementation, as opposed to\n                // a package in a directory, transform the name of the type stub\n                // to __init__.pyi because we're placing it in a directory.\n                if (targetIsSingleFile) {\n                    typeStubPath = combinePaths(getDirectoryPath(typeStubPath), '__init__.pyi');\n                } else {\n                    typeStubPath = stripFileExtension(typeStubPath) + '.pyi';\n                }\n\n                const typeStubDir = getDirectoryPath(typeStubPath);\n\n                try {\n                    makeDirectories(this._fs, typeStubDir, stubPath);\n                } catch (e) {\n                    const errMsg = `Could not create directory for '${typeStubDir}'`;\n                    throw new Error(errMsg);\n                }\n\n                this._bindFile(sourceFileInfo);\n\n                this._runEvaluatorWithCancellationToken(token, () => {\n                    const writer = new TypeStubWriter(typeStubPath, sourceFileInfo.sourceFile, this._evaluator!);\n                    writer.write();\n                });\n\n                // This operation can consume significant memory, so check\n                // for situations where we need to discard the type cache.\n                this._handleMemoryHighUsage();\n            }\n        }\n    }\n\n    private static _getPrintTypeFlags(configOptions: ConfigOptions): PrintTypeFlags {\n        let flags = PrintTypeFlags.None;\n\n        if (configOptions.diagnosticRuleSet.printUnknownAsAny) {\n            flags |= PrintTypeFlags.PrintUnknownWithAny;\n        }\n\n        if (configOptions.diagnosticRuleSet.omitTypeArgsIfAny) {\n            flags |= PrintTypeFlags.OmitTypeArgumentsIfAny;\n        }\n\n        if (configOptions.diagnosticRuleSet.omitUnannotatedParamType) {\n            flags |= PrintTypeFlags.OmitUnannotatedParamType;\n        }\n\n        if (configOptions.diagnosticRuleSet.pep604Printing) {\n            flags |= PrintTypeFlags.PEP604;\n        }\n\n        return flags;\n    }\n\n    private get _fs() {\n        return this._importResolver.fileSystem;\n    }\n\n    private _getImportNameForFile(filePath: string) {\n        const moduleNameAndType = this._importResolver.getModuleNameForImport(\n            filePath,\n            this._configOptions.getDefaultExecEnvironment()\n        );\n        return moduleNameAndType.moduleName;\n    }\n\n    // A \"shadowed\" file is a python source file that has been added to the program because\n    // it \"shadows\" a type stub file for purposes of finding doc strings and definitions.\n    // We need to track the relationship so if the original type stub is removed from the\n    // program, we can remove the corresponding shadowed file and any files it imports.\n    private _addShadowedFile(stubFile: SourceFileInfo, shadowImplPath: string): SourceFile {\n        let shadowFileInfo = this._getSourceFileInfoFromPath(shadowImplPath);\n\n        if (!shadowFileInfo) {\n            const importName = this._getImportNameForFile(shadowImplPath);\n            const sourceFile = new SourceFile(\n                this._fs,\n                shadowImplPath,\n                importName,\n                /* isThirdPartyImport */ false,\n                /* isInPyTypedPackage */ false,\n                this._console,\n                this._logTracker\n            );\n            shadowFileInfo = {\n                sourceFile,\n                isTracked: false,\n                isOpenByClient: false,\n                isTypeshedFile: false,\n                isThirdPartyImport: false,\n                isThirdPartyPyTypedPresent: false,\n                diagnosticsVersion: undefined,\n                imports: [],\n                importedBy: [],\n                shadows: [],\n                shadowedBy: [],\n            };\n            this._addToSourceFileListAndMap(shadowFileInfo);\n        }\n\n        if (!shadowFileInfo.shadows.includes(stubFile)) {\n            shadowFileInfo.shadows.push(stubFile);\n        }\n\n        if (!stubFile.shadowedBy.includes(shadowFileInfo)) {\n            stubFile.shadowedBy.push(shadowFileInfo);\n        }\n\n        return shadowFileInfo.sourceFile;\n    }\n\n    private _createNewEvaluator() {\n        this._evaluator = createTypeEvaluator(this._lookUpImport, {\n            disableInferenceForPyTypedSources: this._configOptions.disableInferenceForPyTypedSources,\n            printTypeFlags: Program._getPrintTypeFlags(this._configOptions),\n        });\n    }\n\n    private _parseFile(fileToParse: SourceFileInfo) {\n        if (!this._isFileNeeded(fileToParse) || !fileToParse.sourceFile.isParseRequired()) {\n            return;\n        }\n\n        if (fileToParse.sourceFile.parse(this._configOptions, this._importResolver)) {\n            this._parsedFileCount++;\n            this._updateSourceFileImports(fileToParse, this._configOptions);\n        }\n\n        if (fileToParse.sourceFile.isFileDeleted()) {\n            fileToParse.isTracked = false;\n\n            // Mark any files that depend on this file as dirty\n            // also. This will retrigger analysis of these other files.\n            const markDirtyMap = new Map<string, boolean>();\n            this._markFileDirtyRecursive(fileToParse, markDirtyMap);\n\n            // Invalidate the import resolver's cache as well.\n            this._importResolver.invalidateCache();\n        }\n    }\n\n    // Binds the specified file and all of its dependencies, recursively. If\n    // it runs out of time, it returns true. If it completes, it returns false.\n    private _bindFile(fileToAnalyze: SourceFileInfo): void {\n        if (!this._isFileNeeded(fileToAnalyze) || !fileToAnalyze.sourceFile.isBindingRequired()) {\n            return;\n        }\n\n        this._parseFile(fileToAnalyze);\n\n        // We need to parse and bind the builtins import first.\n        let builtinsScope: Scope | undefined;\n        if (fileToAnalyze.builtinsImport) {\n            this._bindFile(fileToAnalyze.builtinsImport);\n\n            // Get the builtins scope to pass to the binding pass.\n            const parseResults = fileToAnalyze.builtinsImport.sourceFile.getParseResults();\n            if (parseResults) {\n                builtinsScope = AnalyzerNodeInfo.getScope(parseResults.parseTree);\n                assert(builtinsScope !== undefined);\n            }\n        }\n\n        fileToAnalyze.sourceFile.bind(this._configOptions, this._lookUpImport, builtinsScope);\n    }\n\n    private _lookUpImport = (filePath: string): ImportLookupResult | undefined => {\n        const sourceFileInfo = this._getSourceFileInfoFromPath(filePath);\n        if (!sourceFileInfo) {\n            return undefined;\n        }\n\n        if (sourceFileInfo.sourceFile.isBindingRequired()) {\n            // Bind the file if it's not already bound. Don't count this time\n            // against the type checker.\n            timingStats.typeCheckerTime.subtractFromTime(() => {\n                this._bindFile(sourceFileInfo);\n            });\n        }\n\n        const symbolTable = sourceFileInfo.sourceFile.getModuleSymbolTable();\n        if (!symbolTable) {\n            return undefined;\n        }\n\n        const docString = sourceFileInfo.sourceFile.getModuleDocString();\n\n        return {\n            symbolTable,\n            docString,\n        };\n    };\n\n    // Build a map of all modules within this program and the module-\n    // level scope that contains the symbol table for the module.\n    private _buildModuleSymbolsMap(sourceFileToExclude: SourceFileInfo, token: CancellationToken): ModuleSymbolMap {\n        return buildModuleSymbolsMap(\n            this._sourceFileList.filter((s) => s !== sourceFileToExclude),\n            token\n        );\n    }\n\n    private _shouldCheckFile(fileInfo: SourceFileInfo) {\n        // Always do a full checking for a file that's open in the editor.\n        if (fileInfo.isOpenByClient) {\n            return true;\n        }\n\n        // If the file isn't currently open, only perform full checking for\n        // files that are tracked, and only if the checkOnlyOpenFiles is disabled.\n        if (!this._configOptions.checkOnlyOpenFiles && fileInfo.isTracked) {\n            return true;\n        }\n\n        return false;\n    }\n\n    private _checkTypes(fileToCheck: SourceFileInfo) {\n        return this._logTracker.log(`analyzing: ${fileToCheck.sourceFile.getFilePath()}`, (logState) => {\n            // If the file isn't needed because it was eliminated from the\n            // transitive closure or deleted, skip the file rather than wasting\n            // time on it.\n            if (!this._isFileNeeded(fileToCheck)) {\n                logState.suppress();\n                return false;\n            }\n\n            if (!fileToCheck.sourceFile.isCheckingRequired()) {\n                logState.suppress();\n                return false;\n            }\n\n            if (!this._shouldCheckFile(fileToCheck)) {\n                logState.suppress();\n                return false;\n            }\n\n            this._bindFile(fileToCheck);\n\n            fileToCheck.sourceFile.check(this._evaluator!);\n\n            // For very large programs, we may need to discard the evaluator and\n            // its cached types to avoid running out of heap space.\n            this._handleMemoryHighUsage();\n\n            // Detect import cycles that involve the file.\n            if (this._configOptions.diagnosticRuleSet.reportImportCycles !== 'none') {\n                // Don't detect import cycles when doing type stub generation. Some\n                // third-party modules are pretty convoluted.\n                if (!this._allowedThirdPartyImports) {\n                    // We need to force all of the files to be parsed and build\n                    // a closure map for the files.\n                    const closureMap = new Map<string, SourceFileInfo>();\n                    this._getImportsRecursive(fileToCheck, closureMap, 0);\n\n                    closureMap.forEach((file) => {\n                        timingStats.cycleDetectionTime.timeOperation(() => {\n                            this._detectAndReportImportCycles(file);\n                        });\n                    });\n                }\n            }\n\n            return true;\n        });\n    }\n\n    // Builds a map of files that includes the specified file and all of the files\n    // it imports (recursively) and ensures that all such files. If any of these files\n    // have already been checked (they and their recursive imports have completed the\n    // check phase), they are not included in the results.\n    private _getImportsRecursive(\n        file: SourceFileInfo,\n        closureMap: Map<string, SourceFileInfo>,\n        recursionCount: number\n    ) {\n        // If the file is already in the closure map, we found a cyclical\n        // dependency. Don't recur further.\n        const filePath = normalizePathCase(this._fs, file.sourceFile.getFilePath());\n        if (closureMap.has(filePath)) {\n            return;\n        }\n\n        // If the import chain is too long, emit an error. Otherwise we\n        // risk blowing the stack.\n        if (recursionCount > _maxImportDepth) {\n            file.sourceFile.setHitMaxImportDepth(_maxImportDepth);\n            return;\n        }\n\n        // Add the file to the closure map.\n        closureMap.set(filePath, file);\n\n        // Recursively add the file's imports.\n        for (const importedFileInfo of file.imports) {\n            this._getImportsRecursive(importedFileInfo, closureMap, recursionCount + 1);\n        }\n    }\n\n    private _detectAndReportImportCycles(\n        sourceFileInfo: SourceFileInfo,\n        dependencyChain: SourceFileInfo[] = [],\n        dependencyMap = new Map<string, boolean>()\n    ): void {\n        // Don't bother checking for typestub files or third-party files.\n        if (sourceFileInfo.sourceFile.isStubFile() || sourceFileInfo.isThirdPartyImport) {\n            return;\n        }\n\n        const filePath = normalizePathCase(this._fs, sourceFileInfo.sourceFile.getFilePath());\n        if (dependencyMap.has(filePath)) {\n            // Look for chains at least two in length. A file that contains\n            // an \"import . from X\" will technically create a cycle with\n            // itself, but those are not interesting to report.\n            if (dependencyChain.length > 1 && sourceFileInfo === dependencyChain[0]) {\n                this._logImportCycle(dependencyChain);\n            }\n        } else {\n            // If we've already checked this dependency along\n            // some other path, we can skip it.\n            if (dependencyMap.has(filePath)) {\n                return;\n            }\n\n            // We use both a map (for fast lookups) and a list\n            // (for ordering information). Set the dependency map\n            // entry to true to indicate that we're actively exploring\n            // that dependency.\n            dependencyMap.set(filePath, true);\n            dependencyChain.push(sourceFileInfo);\n\n            for (const imp of sourceFileInfo.imports) {\n                this._detectAndReportImportCycles(imp, dependencyChain, dependencyMap);\n            }\n\n            // Set the dependencyMap entry to false to indicate that we have\n            // already explored this file and don't need to explore it again.\n            dependencyMap.set(filePath, false);\n            dependencyChain.pop();\n        }\n    }\n\n    private _logImportCycle(dependencyChain: SourceFileInfo[]) {\n        const circDep = new CircularDependency();\n        dependencyChain.forEach((sourceFileInfo) => {\n            circDep.appendPath(sourceFileInfo.sourceFile.getFilePath());\n        });\n\n        circDep.normalizeOrder();\n        const firstFilePath = circDep.getPaths()[0];\n        const firstSourceFile = this._getSourceFileInfoFromPath(firstFilePath)!;\n        assert(firstSourceFile !== undefined);\n        firstSourceFile.sourceFile.addCircularDependency(circDep);\n    }\n\n    private _markFileDirtyRecursive(sourceFileInfo: SourceFileInfo, markMap: Map<string, boolean>) {\n        const filePath = normalizePathCase(this._fs, sourceFileInfo.sourceFile.getFilePath());\n\n        // Don't mark it again if it's already been visited.\n        if (!markMap.has(filePath)) {\n            sourceFileInfo.sourceFile.markReanalysisRequired();\n            markMap.set(filePath, true);\n\n            sourceFileInfo.importedBy.forEach((dep) => {\n                this._markFileDirtyRecursive(dep, markMap);\n            });\n        }\n    }\n\n    getTextOnRange(filePath: string, range: Range, token: CancellationToken): string | undefined {\n        const sourceFileInfo = this._sourceFileMap.get(filePath);\n        if (!sourceFileInfo) {\n            return undefined;\n        }\n\n        const sourceFile = sourceFileInfo.sourceFile;\n        const fileContents = sourceFile.getFileContents();\n        if (!fileContents) {\n            // this only works with opened file\n            return undefined;\n        }\n\n        return this._runEvaluatorWithCancellationToken(token, () => {\n            this._parseFile(sourceFileInfo);\n\n            const parseTree = sourceFile.getParseResults()!;\n            const textRange = convertRangeToTextRange(range, parseTree.tokenizerOutput.lines);\n            if (!textRange) {\n                return undefined;\n            }\n\n            return fileContents.substr(textRange.start, textRange.length);\n        });\n    }\n\n    getAutoImports(\n        filePath: string,\n        range: Range,\n        similarityLimit: number,\n        nameMap: Map<string, string> | undefined,\n        libraryMap: Map<string, IndexResults> | undefined,\n        token: CancellationToken\n    ): AutoImportResult[] {\n        const sourceFileInfo = this._getSourceFileInfoFromPath(filePath);\n        if (!sourceFileInfo) {\n            return [];\n        }\n\n        const sourceFile = sourceFileInfo.sourceFile;\n        const fileContents = sourceFile.getFileContents();\n        if (!fileContents) {\n            // this only works with opened file\n            return [];\n        }\n\n        return this._runEvaluatorWithCancellationToken(token, () => {\n            this._bindFile(sourceFileInfo);\n\n            const parseTree = sourceFile.getParseResults()!;\n            const textRange = convertRangeToTextRange(range, parseTree.tokenizerOutput.lines);\n            if (!textRange) {\n                return [];\n            }\n\n            const currentNode = findNodeByOffset(parseTree.parseTree, textRange.start);\n            if (!currentNode) {\n                return [];\n            }\n\n            const writtenWord = fileContents.substr(textRange.start, textRange.length);\n            const map = this._buildModuleSymbolsMap(sourceFileInfo, token);\n            const autoImporter = new AutoImporter(\n                this._configOptions,\n                this._importResolver,\n                parseTree,\n                range.start,\n                [],\n                map,\n                libraryMap\n            );\n\n            // Filter out any name that is already defined in the current scope.\n            const results: AutoImportResult[] = [];\n\n            const currentScope = getScopeForNode(currentNode);\n            if (currentScope) {\n                const translatedWord = nameMap?.get(writtenWord);\n                if (translatedWord) {\n                    // No filter is needed since we only do exact match.\n                    const exactMatch = 1;\n                    results.push(\n                        ...autoImporter.getAutoImportCandidates(translatedWord, exactMatch, writtenWord, token)\n                    );\n                }\n\n                results.push(\n                    ...autoImporter\n                        .getAutoImportCandidates(writtenWord, similarityLimit, undefined, token)\n                        .filter((r) => !currentScope.lookUpSymbolRecursive(r.name))\n                );\n            }\n\n            return results;\n        });\n    }\n\n    getDiagnostics(options: ConfigOptions): FileDiagnostics[] {\n        const fileDiagnostics: FileDiagnostics[] = this._removeUnneededFiles();\n\n        this._sourceFileList.forEach((sourceFileInfo) => {\n            if (this._shouldCheckFile(sourceFileInfo)) {\n                const diagnostics = sourceFileInfo.sourceFile.getDiagnostics(\n                    options,\n                    sourceFileInfo.diagnosticsVersion\n                );\n                if (diagnostics !== undefined) {\n                    fileDiagnostics.push({\n                        filePath: sourceFileInfo.sourceFile.getFilePath(),\n                        diagnostics,\n                    });\n\n                    // Update the cached diagnosticsVersion so we can determine\n                    // whether there are any updates next time we call getDiagnostics.\n                    sourceFileInfo.diagnosticsVersion = sourceFileInfo.sourceFile.getDiagnosticVersion();\n                }\n            } else if (\n                !sourceFileInfo.isOpenByClient &&\n                options.checkOnlyOpenFiles &&\n                sourceFileInfo.diagnosticsVersion !== undefined\n            ) {\n                // This condition occurs when the user switches from workspace to\n                // \"open files only\" mode. Clear all diagnostics for this file.\n                fileDiagnostics.push({\n                    filePath: sourceFileInfo.sourceFile.getFilePath(),\n                    diagnostics: [],\n                });\n                sourceFileInfo.diagnosticsVersion = undefined;\n            }\n        });\n\n        return fileDiagnostics;\n    }\n\n    getDiagnosticsForRange(filePath: string, range: Range): Diagnostic[] {\n        const sourceFile = this.getSourceFile(filePath);\n        if (!sourceFile) {\n            return [];\n        }\n\n        const unfilteredDiagnostics = sourceFile.getDiagnostics(this._configOptions);\n        if (!unfilteredDiagnostics) {\n            return [];\n        }\n\n        return unfilteredDiagnostics.filter((diag) => {\n            return doRangesIntersect(diag.range, range);\n        });\n    }\n\n    getDefinitionsForPosition(\n        filePath: string,\n        position: Position,\n        token: CancellationToken\n    ): DocumentRange[] | undefined {\n        return this._runEvaluatorWithCancellationToken(token, () => {\n            const sourceFileInfo = this._getSourceFileInfoFromPath(filePath);\n            if (!sourceFileInfo) {\n                return undefined;\n            }\n\n            this._bindFile(sourceFileInfo);\n\n            const execEnv = this._configOptions.findExecEnvironment(filePath);\n            return sourceFileInfo.sourceFile.getDefinitionsForPosition(\n                this._createSourceMapper(execEnv),\n                position,\n                this._evaluator!,\n                token\n            );\n        });\n    }\n\n    getReferencesForPosition(\n        filePath: string,\n        position: Position,\n        includeDeclaration: boolean,\n        token: CancellationToken\n    ): DocumentRange[] | undefined {\n        return this._runEvaluatorWithCancellationToken(token, () => {\n            const sourceFileInfo = this._getSourceFileInfoFromPath(filePath);\n            if (!sourceFileInfo) {\n                return undefined;\n            }\n\n            const invokedFromUserFile = this._isUserCode(sourceFileInfo);\n            this._bindFile(sourceFileInfo);\n\n            const execEnv = this._configOptions.findExecEnvironment(filePath);\n            const referencesResult = sourceFileInfo.sourceFile.getDeclarationForPosition(\n                this._createSourceMapper(execEnv),\n                position,\n                this._evaluator!,\n                token\n            );\n\n            if (!referencesResult) {\n                return undefined;\n            }\n\n            // Do we need to do a global search as well?\n            if (referencesResult.requiresGlobalSearch) {\n                for (const curSourceFileInfo of this._sourceFileList) {\n                    throwIfCancellationRequested(token);\n\n                    // \"Find all references\" will only include references from user code\n                    // unless the file is explicitly opened in the editor or it is invoked from non user files.\n                    if (\n                        curSourceFileInfo.isOpenByClient ||\n                        !invokedFromUserFile ||\n                        this._isUserCode(curSourceFileInfo)\n                    ) {\n                        this._bindFile(curSourceFileInfo);\n\n                        curSourceFileInfo.sourceFile.addReferences(\n                            referencesResult,\n                            includeDeclaration,\n                            this._evaluator!,\n                            token\n                        );\n                    }\n\n                    // This operation can consume significant memory, so check\n                    // for situations where we need to discard the type cache.\n                    this._handleMemoryHighUsage();\n                }\n\n                // Make sure to include declarations regardless where they are defined\n                // if includeDeclaration is set.\n                if (includeDeclaration) {\n                    for (const decl of referencesResult.declarations) {\n                        throwIfCancellationRequested(token);\n\n                        if (referencesResult.locations.some((l) => l.path === decl.path)) {\n                            // Already included.\n                            continue;\n                        }\n\n                        const declFileInfo = this._getSourceFileInfoFromPath(decl.path);\n                        if (!declFileInfo) {\n                            // The file the declaration belongs to doesn't belong to the program.\n                            continue;\n                        }\n\n                        const tempResult: ReferencesResult = {\n                            requiresGlobalSearch: referencesResult.requiresGlobalSearch,\n                            nodeAtOffset: referencesResult.nodeAtOffset,\n                            symbolName: referencesResult.symbolName,\n                            declarations: referencesResult.declarations,\n                            locations: [],\n                        };\n\n                        declFileInfo.sourceFile.addReferences(tempResult, includeDeclaration, this._evaluator!, token);\n                        for (const loc of tempResult.locations) {\n                            // Include declarations only. And throw away any references\n                            if (loc.path === decl.path && doesRangeContain(decl.range, loc.range)) {\n                                referencesResult.locations.push(loc);\n                            }\n                        }\n                    }\n                }\n            } else {\n                sourceFileInfo.sourceFile.addReferences(referencesResult, includeDeclaration, this._evaluator!, token);\n            }\n\n            return referencesResult.locations;\n        });\n    }\n\n    getFileIndex(filePath: string, importSymbolsOnly: boolean, token: CancellationToken): IndexResults | undefined {\n        if (importSymbolsOnly) {\n            // Memory optimization. We only want to hold onto symbols\n            // usable outside when importSymbolsOnly is on.\n            const name = stripFileExtension(getFileName(filePath));\n            if (isPrivateOrProtectedName(name)) {\n                return undefined;\n            }\n        }\n\n        this._handleMemoryHighUsage();\n\n        return this._runEvaluatorWithCancellationToken(token, () => {\n            const sourceFileInfo = this._getSourceFileInfoFromPath(filePath);\n            if (!sourceFileInfo) {\n                return undefined;\n            }\n\n            this._bindFile(sourceFileInfo);\n            return sourceFileInfo.sourceFile.index(importSymbolsOnly, token);\n        });\n    }\n\n    addSymbolsForDocument(filePath: string, symbolList: DocumentSymbol[], token: CancellationToken) {\n        return this._runEvaluatorWithCancellationToken(token, () => {\n            const sourceFileInfo = this._getSourceFileInfoFromPath(filePath);\n            if (sourceFileInfo) {\n                if (!sourceFileInfo.sourceFile.getCachedIndexResults()) {\n                    // If we already have cached index for this file, no need to bind this file.\n                    this._bindFile(sourceFileInfo);\n                }\n\n                sourceFileInfo.sourceFile.addHierarchicalSymbolsForDocument(symbolList, token);\n            }\n        });\n    }\n\n    addSymbolsForWorkspace(symbolList: SymbolInformation[], query: string, token: CancellationToken) {\n        return this._runEvaluatorWithCancellationToken(token, () => {\n            // Don't do a search if the query is empty. We'll return\n            // too many results in this case.\n            if (!query) {\n                return;\n            }\n\n            // \"Workspace symbols\" searches symbols only from user code.\n            for (const sourceFileInfo of this._sourceFileList) {\n                if (!this._isUserCode(sourceFileInfo)) {\n                    continue;\n                }\n\n                if (!sourceFileInfo.sourceFile.getCachedIndexResults()) {\n                    // If we already have cached index for this file, no need to bind this file.\n                    this._bindFile(sourceFileInfo);\n                }\n\n                sourceFileInfo.sourceFile.addSymbolsForDocument(symbolList, query, token);\n\n                // This operation can consume significant memory, so check\n                // for situations where we need to discard the type cache.\n                this._handleMemoryHighUsage();\n            }\n        });\n    }\n\n    getHoverForPosition(filePath: string, position: Position, token: CancellationToken): HoverResults | undefined {\n        return this._runEvaluatorWithCancellationToken(token, () => {\n            const sourceFileInfo = this._getSourceFileInfoFromPath(filePath);\n            if (!sourceFileInfo) {\n                return undefined;\n            }\n\n            this._bindFile(sourceFileInfo);\n\n            const execEnv = this._configOptions.findExecEnvironment(filePath);\n            return sourceFileInfo.sourceFile.getHoverForPosition(\n                this._createSourceMapper(execEnv),\n                position,\n                this._evaluator!,\n                token\n            );\n        });\n    }\n\n    getDocumentHighlight(\n        filePath: string,\n        position: Position,\n        token: CancellationToken\n    ): DocumentHighlight[] | undefined {\n        return this._runEvaluatorWithCancellationToken(token, () => {\n            const sourceFileInfo = this._getSourceFileInfoFromPath(filePath);\n            if (!sourceFileInfo) {\n                return undefined;\n            }\n\n            this._bindFile(sourceFileInfo);\n\n            const execEnv = this._configOptions.findExecEnvironment(filePath);\n            return sourceFileInfo.sourceFile.getDocumentHighlight(\n                this._createSourceMapper(execEnv),\n                position,\n                this._evaluator!,\n                token\n            );\n        });\n    }\n\n    getSignatureHelpForPosition(\n        filePath: string,\n        position: Position,\n        token: CancellationToken\n    ): SignatureHelpResults | undefined {\n        return this._runEvaluatorWithCancellationToken(token, () => {\n            const sourceFileInfo = this._getSourceFileInfoFromPath(filePath);\n            if (!sourceFileInfo) {\n                return undefined;\n            }\n\n            this._bindFile(sourceFileInfo);\n\n            return sourceFileInfo.sourceFile.getSignatureHelpForPosition(\n                position,\n                this._lookUpImport,\n                this._evaluator!,\n                token\n            );\n        });\n    }\n\n    async getCompletionsForPosition(\n        filePath: string,\n        position: Position,\n        workspacePath: string,\n        libraryMap: Map<string, IndexResults> | undefined,\n        token: CancellationToken\n    ): Promise<CompletionResults | undefined> {\n        const sourceFileInfo = this._getSourceFileInfoFromPath(filePath);\n        if (!sourceFileInfo) {\n            return undefined;\n        }\n\n        const completionResult = this._runEvaluatorWithCancellationToken(token, () => {\n            this._bindFile(sourceFileInfo);\n\n            const execEnv = this._configOptions.findExecEnvironment(filePath);\n            return sourceFileInfo.sourceFile.getCompletionsForPosition(\n                position,\n                workspacePath,\n                this._configOptions,\n                this._importResolver,\n                this._lookUpImport,\n                this._evaluator!,\n                this._createSourceMapper(execEnv),\n                libraryMap,\n                () => this._buildModuleSymbolsMap(sourceFileInfo, token),\n                token\n            );\n        });\n\n        if (!completionResult?.completionList || !this._extension?.completionListExtension) {\n            return completionResult;\n        }\n\n        const pr = sourceFileInfo.sourceFile.getParseResults();\n        const content = sourceFileInfo.sourceFile.getFileContents();\n        if (pr?.parseTree && content) {\n            const offset = convertPositionToOffset(position, pr.tokenizerOutput.lines);\n            if (offset !== undefined) {\n                completionResult.completionList = await this._extension.completionListExtension.updateCompletionList(\n                    completionResult.completionList,\n                    pr.parseTree,\n                    content,\n                    offset,\n                    this._configOptions,\n                    token\n                );\n            }\n        }\n\n        return completionResult;\n    }\n\n    resolveCompletionItem(\n        filePath: string,\n        completionItem: CompletionItem,\n        libraryMap: Map<string, IndexResults> | undefined,\n        token: CancellationToken\n    ) {\n        return this._runEvaluatorWithCancellationToken(token, () => {\n            const sourceFileInfo = this._getSourceFileInfoFromPath(filePath);\n            if (!sourceFileInfo) {\n                return;\n            }\n\n            this._bindFile(sourceFileInfo);\n\n            const execEnv = this._configOptions.findExecEnvironment(filePath);\n            sourceFileInfo.sourceFile.resolveCompletionItem(\n                this._configOptions,\n                this._importResolver,\n                this._lookUpImport,\n                this._evaluator!,\n                this._createSourceMapper(execEnv),\n                libraryMap,\n                () => this._buildModuleSymbolsMap(sourceFileInfo, token),\n                completionItem,\n                token\n            );\n        });\n    }\n\n    renameSymbolAtPosition(\n        filePath: string,\n        position: Position,\n        newName: string,\n        token: CancellationToken\n    ): FileEditAction[] | undefined {\n        return this._runEvaluatorWithCancellationToken(token, () => {\n            const sourceFileInfo = this._getSourceFileInfoFromPath(filePath);\n            if (!sourceFileInfo) {\n                return undefined;\n            }\n\n            this._bindFile(sourceFileInfo);\n\n            const execEnv = this._configOptions.findExecEnvironment(filePath);\n            const referencesResult = sourceFileInfo.sourceFile.getDeclarationForPosition(\n                this._createSourceMapper(execEnv),\n                position,\n                this._evaluator!,\n                token\n            );\n\n            if (!referencesResult) {\n                return undefined;\n            }\n\n            if (referencesResult.declarations.some((d) => !this._isUserCode(this._getSourceFileInfoFromPath(d.path)))) {\n                // Some declarations come from non-user code, so do not allow rename\n                return undefined;\n            }\n\n            if (referencesResult.declarations.length === 0) {\n                // There is no symbol we can rename\n                return undefined;\n            }\n\n            // Do we need to do a global search as well?\n            if (referencesResult.requiresGlobalSearch) {\n                for (const curSourceFileInfo of this._sourceFileList) {\n                    // Make sure we only add user code to the references to prevent us\n                    // from accidentally changing third party library or type stub.\n                    if (this._isUserCode(curSourceFileInfo)) {\n                        this._bindFile(curSourceFileInfo);\n\n                        curSourceFileInfo.sourceFile.addReferences(referencesResult, true, this._evaluator!, token);\n                    }\n\n                    // This operation can consume significant memory, so check\n                    // for situations where we need to discard the type cache.\n                    this._handleMemoryHighUsage();\n                }\n            } else if (this._isUserCode(sourceFileInfo)) {\n                sourceFileInfo.sourceFile.addReferences(referencesResult, true, this._evaluator!, token);\n            }\n\n            const editActions: FileEditAction[] = [];\n\n            referencesResult.locations.forEach((loc) => {\n                editActions.push({\n                    filePath: loc.path,\n                    range: loc.range,\n                    replacementText: newName,\n                });\n            });\n\n            return editActions;\n        });\n    }\n\n    getCallForPosition(filePath: string, position: Position, token: CancellationToken): CallHierarchyItem | undefined {\n        const sourceFileInfo = this._getSourceFileInfoFromPath(filePath);\n        if (!sourceFileInfo) {\n            return undefined;\n        }\n        this._bindFile(sourceFileInfo);\n\n        const execEnv = this._configOptions.findExecEnvironment(filePath);\n        const referencesResult = sourceFileInfo.sourceFile.getDeclarationForPosition(\n            this._createSourceMapper(execEnv),\n            position,\n            this._evaluator!,\n            token\n        );\n\n        if (!referencesResult || referencesResult.declarations.length === 0) {\n            return undefined;\n        }\n\n        const targetDecl = CallHierarchyProvider.getTargetDeclaration(\n            referencesResult.declarations,\n            referencesResult.nodeAtOffset\n        );\n\n        return CallHierarchyProvider.getCallForDeclaration(\n            referencesResult.symbolName,\n            targetDecl,\n            this._evaluator!,\n            token\n        );\n    }\n\n    getIncomingCallsForPosition(\n        filePath: string,\n        position: Position,\n        token: CancellationToken\n    ): CallHierarchyIncomingCall[] | undefined {\n        const sourceFileInfo = this._getSourceFileInfoFromPath(filePath);\n        if (!sourceFileInfo) {\n            return undefined;\n        }\n        this._bindFile(sourceFileInfo);\n\n        const execEnv = this._configOptions.findExecEnvironment(filePath);\n        const referencesResult = sourceFileInfo.sourceFile.getDeclarationForPosition(\n            this._createSourceMapper(execEnv),\n            position,\n            this._evaluator!,\n            token\n        );\n\n        if (!referencesResult || referencesResult.declarations.length === 0) {\n            return undefined;\n        }\n\n        const targetDecl = CallHierarchyProvider.getTargetDeclaration(\n            referencesResult.declarations,\n            referencesResult.nodeAtOffset\n        );\n        let items: CallHierarchyIncomingCall[] = [];\n\n        for (const curSourceFileInfo of this._sourceFileList) {\n            if (this._isUserCode(curSourceFileInfo) || curSourceFileInfo.isOpenByClient) {\n                this._bindFile(curSourceFileInfo);\n\n                const itemsToAdd = CallHierarchyProvider.getIncomingCallsForDeclaration(\n                    curSourceFileInfo.sourceFile.getFilePath(),\n                    referencesResult.symbolName,\n                    targetDecl,\n                    curSourceFileInfo.sourceFile.getParseResults()!,\n                    this._evaluator!,\n                    token\n                );\n\n                if (itemsToAdd) {\n                    items = items.concat(...itemsToAdd);\n                }\n\n                // This operation can consume significant memory, so check\n                // for situations where we need to discard the type cache.\n                this._handleMemoryHighUsage();\n            }\n        }\n\n        return items;\n    }\n\n    getOutgoingCallsForPosition(\n        filePath: string,\n        position: Position,\n        token: CancellationToken\n    ): CallHierarchyOutgoingCall[] | undefined {\n        const sourceFileInfo = this._getSourceFileInfoFromPath(filePath);\n        if (!sourceFileInfo) {\n            return undefined;\n        }\n        this._bindFile(sourceFileInfo);\n\n        const execEnv = this._configOptions.findExecEnvironment(filePath);\n        const referencesResult = sourceFileInfo.sourceFile.getDeclarationForPosition(\n            this._createSourceMapper(execEnv),\n            position,\n            this._evaluator!,\n            token\n        );\n\n        if (!referencesResult || referencesResult.declarations.length === 0) {\n            return undefined;\n        }\n        const targetDecl = CallHierarchyProvider.getTargetDeclaration(\n            referencesResult.declarations,\n            referencesResult.nodeAtOffset\n        );\n\n        return CallHierarchyProvider.getOutgoingCallsForDeclaration(\n            targetDecl,\n            sourceFileInfo.sourceFile.getParseResults()!,\n            this._evaluator!,\n            token\n        );\n    }\n\n    performQuickAction(\n        filePath: string,\n        command: string,\n        args: any[],\n        token: CancellationToken\n    ): TextEditAction[] | undefined {\n        const sourceFileInfo = this._getSourceFileInfoFromPath(filePath);\n        if (!sourceFileInfo) {\n            return undefined;\n        }\n\n        this._bindFile(sourceFileInfo);\n\n        return sourceFileInfo.sourceFile.performQuickAction(command, args, token);\n    }\n\n    private _handleMemoryHighUsage() {\n        const typeCacheSize = this._evaluator!.getTypeCacheSize();\n\n        // If the type cache size has exceeded a high-water mark, query the heap usage.\n        // Don't bother doing this until we hit this point because the heap usage may not\n        // drop immediately after we empty the cache due to garbage collection timing.\n        if (typeCacheSize > 750000 || this._parsedFileCount > 1000) {\n            const heapSizeInMb = Math.round(process.memoryUsage().heapUsed / (1024 * 1024));\n\n            // Don't allow the heap to get close to the 2GB limit imposed by\n            // the OS when running Node in a 32-bit process.\n            if (heapSizeInMb > 1536) {\n                this._console.info(`Emptying type cache to avoid heap overflow. Heap size used: ${heapSizeInMb}MB`);\n                this._createNewEvaluator();\n                this._discardCachedParseResults();\n                this._parsedFileCount = 0;\n            }\n        }\n    }\n\n    // Discards all cached parse results and file contents to free up memory.\n    // It does not discard cached index results or diagnostics for files.\n    private _discardCachedParseResults() {\n        for (const sourceFileInfo of this._sourceFileList) {\n            sourceFileInfo.sourceFile.dropParseAndBindInfo();\n        }\n    }\n\n    private _isUserCode(fileInfo: SourceFileInfo | undefined) {\n        return fileInfo && fileInfo.isTracked && !fileInfo.isThirdPartyImport && !fileInfo.isTypeshedFile;\n    }\n\n    // Wrapper function that should be used when invoking this._evaluator\n    // with a cancellation token. It handles cancellation exceptions and\n    // any other unexpected exceptions.\n    private _runEvaluatorWithCancellationToken<T>(token: CancellationToken | undefined, callback: () => T): T {\n        try {\n            // Don't support cancellation in debug mode because cancellation\n            // checks and exceptions interfere with debugging.\n            if (token && !isDebugMode()) {\n                return this._evaluator!.runWithCancellationToken(token, callback);\n            } else {\n                return callback();\n            }\n        } catch (e) {\n            // An unexpected exception occurred, potentially leaving the current evaluator\n            // in an inconsistent state. Discard it and replace it with a fresh one. It is\n            // Cancellation exceptions are known to handle this correctly.\n            if (!(e instanceof OperationCanceledException)) {\n                this._createNewEvaluator();\n            }\n            throw e;\n        }\n    }\n\n    // Returns a list of empty file diagnostic entries for the files\n    // that have been removed. This is needed to clear out the\n    // errors for files that have been deleted or closed.\n    private _removeUnneededFiles(): FileDiagnostics[] {\n        const fileDiagnostics: FileDiagnostics[] = [];\n\n        // If a file is no longer tracked, opened or shadowed, it can\n        // be removed from the program.\n        for (let i = 0; i < this._sourceFileList.length; ) {\n            const fileInfo = this._sourceFileList[i];\n            if (!this._isFileNeeded(fileInfo)) {\n                fileDiagnostics.push({\n                    filePath: fileInfo.sourceFile.getFilePath(),\n                    diagnostics: [],\n                });\n\n                fileInfo.sourceFile.prepareForClose();\n                this._removeSourceFileFromListAndMap(fileInfo.sourceFile.getFilePath(), i);\n\n                // Unlink any imports and remove them from the list if\n                // they are no longer referenced.\n                fileInfo.imports.forEach((importedFile) => {\n                    const indexToRemove = importedFile.importedBy.findIndex((fi) => fi === fileInfo);\n                    assert(indexToRemove >= 0);\n                    importedFile.importedBy.splice(indexToRemove, 1);\n\n                    // See if we need to remove the imported file because it\n                    // is no longer needed. If its index is >= i, it will be\n                    // removed when we get to it.\n                    if (!this._isFileNeeded(importedFile)) {\n                        const indexToRemove = this._sourceFileList.findIndex((fi) => fi === importedFile);\n                        if (indexToRemove >= 0 && indexToRemove < i) {\n                            fileDiagnostics.push({\n                                filePath: importedFile.sourceFile.getFilePath(),\n                                diagnostics: [],\n                            });\n\n                            importedFile.sourceFile.prepareForClose();\n                            this._removeSourceFileFromListAndMap(importedFile.sourceFile.getFilePath(), indexToRemove);\n                            i--;\n                        }\n                    }\n                });\n\n                // Remove any shadowed files corresponding to this file.\n                fileInfo.shadowedBy.forEach((shadowedFile) => {\n                    shadowedFile.shadows = shadowedFile.shadows.filter((f) => f !== fileInfo);\n                });\n                fileInfo.shadowedBy = [];\n            } else {\n                // If we're showing the user errors only for open files, clear\n                // out the errors for the now-closed file.\n                if (!this._shouldCheckFile(fileInfo) && fileInfo.diagnosticsVersion !== undefined) {\n                    fileDiagnostics.push({\n                        filePath: fileInfo.sourceFile.getFilePath(),\n                        diagnostics: [],\n                    });\n                    fileInfo.diagnosticsVersion = undefined;\n                }\n\n                i++;\n            }\n        }\n\n        return fileDiagnostics;\n    }\n\n    private _isFileNeeded(fileInfo: SourceFileInfo) {\n        if (fileInfo.sourceFile.isFileDeleted()) {\n            return false;\n        }\n\n        if (fileInfo.isTracked || fileInfo.isOpenByClient) {\n            return true;\n        }\n\n        if (fileInfo.shadows.length > 0) {\n            return true;\n        }\n\n        if (fileInfo.importedBy.length === 0) {\n            return false;\n        }\n\n        // It's possible for a cycle of files to be imported\n        // by a tracked file but then abandoned. The import cycle\n        // will keep the entire group \"alive\" if we don't detect\n        // the condition and garbage collect them.\n        return this._isImportNeededRecursive(fileInfo, new Map<string, boolean>());\n    }\n\n    private _isImportNeededRecursive(fileInfo: SourceFileInfo, recursionMap: Map<string, boolean>) {\n        if (fileInfo.isTracked || fileInfo.isOpenByClient || fileInfo.shadows.length > 0) {\n            return true;\n        }\n\n        const filePath = normalizePathCase(this._fs, fileInfo.sourceFile.getFilePath());\n\n        // Avoid infinite recursion.\n        if (recursionMap.has(filePath)) {\n            return false;\n        }\n\n        recursionMap.set(filePath, true);\n\n        for (const importerInfo of fileInfo.importedBy) {\n            if (this._isImportNeededRecursive(importerInfo, recursionMap)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private _createSourceMapper(execEnv: ExecutionEnvironment) {\n        const sourceMapper = new SourceMapper(\n            this._importResolver,\n            execEnv,\n            this._evaluator!,\n            (stubFilePath: string, implFilePath: string) => {\n                const stubFileInfo = this._getSourceFileInfoFromPath(stubFilePath);\n                if (!stubFileInfo) {\n                    return undefined;\n                }\n                this._addShadowedFile(stubFileInfo, implFilePath);\n                return this.getBoundSourceFile(implFilePath);\n            }\n        );\n        return sourceMapper;\n    }\n\n    private _isImportAllowed(importer: SourceFileInfo, importResult: ImportResult, isImportStubFile: boolean): boolean {\n        // Don't import native libs. We don't want to track these files,\n        // and we definitely don't want to attempt to parse them.\n        if (importResult.isNativeLib) {\n            return false;\n        }\n\n        let thirdPartyImportAllowed =\n            this._configOptions.useLibraryCodeForTypes ||\n            (importResult.importType === ImportType.ThirdParty && !!importResult.isPyTypedPresent) ||\n            (importResult.importType === ImportType.Local && importer.isThirdPartyPyTypedPresent);\n\n        if (\n            importResult.importType === ImportType.ThirdParty ||\n            (importer.isThirdPartyImport && importResult.importType === ImportType.Local)\n        ) {\n            if (this._allowedThirdPartyImports) {\n                if (importResult.isRelative) {\n                    // If it's a relative import, we'll allow it because the\n                    // importer was already deemed to be allowed.\n                    thirdPartyImportAllowed = true;\n                } else if (\n                    this._allowedThirdPartyImports.some((importName: string) => {\n                        // If this import name is the one that was explicitly\n                        // allowed or is a child of that import name,\n                        // it's considered allowed.\n                        if (importResult.importName === importName) {\n                            return true;\n                        }\n\n                        if (importResult.importName.startsWith(importName + '.')) {\n                            return true;\n                        }\n\n                        return false;\n                    })\n                ) {\n                    thirdPartyImportAllowed = true;\n                }\n            }\n\n            // Some libraries ship with stub files that import from non-stubs. Don't\n            // explore those.\n            // Don't explore any third-party files unless they're type stub files\n            // or we've been told explicitly that third-party imports are OK.\n            if (!isImportStubFile) {\n                return thirdPartyImportAllowed;\n            }\n        }\n\n        return true;\n    }\n\n    private _updateSourceFileImports(sourceFileInfo: SourceFileInfo, options: ConfigOptions): SourceFileInfo[] {\n        const filesAdded: SourceFileInfo[] = [];\n\n        // Get the new list of imports and see if it changed from the last\n        // list of imports for this file.\n        const imports = sourceFileInfo.sourceFile.getImports();\n\n        // Create a local function that determines whether the import should\n        // be considered a \"third-party import\" and whether it is coming from\n        // a third-party package that claims to be typed. An import is\n        // considered third-party if it is external to the importer\n        // or is internal but the importer is itself a third-party package.\n        const getThirdPartyImportInfo = (importResult: ImportResult) => {\n            let isThirdPartyImport = false;\n            let isPyTypedPresent = false;\n\n            if (importResult.importType === ImportType.ThirdParty) {\n                isThirdPartyImport = true;\n                if (importResult.isPyTypedPresent) {\n                    isPyTypedPresent = true;\n                }\n            } else if (sourceFileInfo.isThirdPartyImport && importResult.importType === ImportType.Local) {\n                isThirdPartyImport = true;\n                if (sourceFileInfo.isThirdPartyPyTypedPresent) {\n                    isPyTypedPresent = true;\n                }\n            }\n\n            return {\n                isThirdPartyImport,\n                isPyTypedPresent,\n            };\n        };\n\n        // Create a map of unique imports, since imports can appear more than once.\n        const newImportPathMap = new Map<string, UpdateImportInfo>();\n        imports.forEach((importResult) => {\n            if (importResult.isImportFound) {\n                if (this._isImportAllowed(sourceFileInfo, importResult, importResult.isStubFile)) {\n                    if (importResult.resolvedPaths.length > 0) {\n                        const filePath = importResult.resolvedPaths[importResult.resolvedPaths.length - 1];\n                        if (filePath) {\n                            const thirdPartyTypeInfo = getThirdPartyImportInfo(importResult);\n                            newImportPathMap.set(normalizePathCase(this._fs, filePath), {\n                                path: filePath,\n                                isTypeshedFile: !!importResult.isTypeshedFile,\n                                isThirdPartyImport: thirdPartyTypeInfo.isThirdPartyImport,\n                                isPyTypedPresent: thirdPartyTypeInfo.isPyTypedPresent,\n                            });\n                        }\n                    }\n                }\n\n                importResult.implicitImports.forEach((implicitImport) => {\n                    if (this._isImportAllowed(sourceFileInfo, importResult, implicitImport.isStubFile)) {\n                        const thirdPartyTypeInfo = getThirdPartyImportInfo(importResult);\n                        newImportPathMap.set(normalizePathCase(this._fs, implicitImport.path), {\n                            path: implicitImport.path,\n                            isTypeshedFile: !!importResult.isTypeshedFile,\n                            isThirdPartyImport: thirdPartyTypeInfo.isThirdPartyImport,\n                            isPyTypedPresent: thirdPartyTypeInfo.isPyTypedPresent,\n                        });\n                    }\n                });\n            } else if (options.verboseOutput) {\n                this._console.info(\n                    `Could not import '${importResult.importName}' ` +\n                        `in file '${sourceFileInfo.sourceFile.getFilePath()}'`\n                );\n                if (importResult.importFailureInfo) {\n                    importResult.importFailureInfo.forEach((diag) => {\n                        this._console.info(`  ${diag}`);\n                    });\n                }\n            }\n        });\n\n        const updatedImportMap = new Map<string, SourceFileInfo>();\n        sourceFileInfo.imports.forEach((importInfo) => {\n            const oldFilePath = normalizePathCase(this._fs, importInfo.sourceFile.getFilePath());\n\n            // A previous import was removed.\n            if (!newImportPathMap.has(oldFilePath)) {\n                importInfo.importedBy = importInfo.importedBy.filter(\n                    (fi) =>\n                        normalizePathCase(this._fs, fi.sourceFile.getFilePath()) !==\n                        normalizePathCase(this._fs, sourceFileInfo.sourceFile.getFilePath())\n                );\n            } else {\n                updatedImportMap.set(oldFilePath, importInfo);\n            }\n        });\n\n        // See if there are any new imports to be added.\n        newImportPathMap.forEach((importInfo, normalizedImportPath) => {\n            if (!updatedImportMap.has(normalizedImportPath)) {\n                // We found a new import to add. See if it's already part\n                // of the program.\n                let importedFileInfo: SourceFileInfo;\n                if (this._getSourceFileInfoFromPath(importInfo.path)) {\n                    importedFileInfo = this._getSourceFileInfoFromPath(importInfo.path)!;\n                } else {\n                    const importName = this._getImportNameForFile(importInfo.path);\n                    const sourceFile = new SourceFile(\n                        this._fs,\n                        importInfo.path,\n                        importName,\n                        importInfo.isThirdPartyImport,\n                        importInfo.isPyTypedPresent,\n                        this._console,\n                        this._logTracker\n                    );\n                    importedFileInfo = {\n                        sourceFile,\n                        isTracked: false,\n                        isOpenByClient: false,\n                        isTypeshedFile: importInfo.isTypeshedFile,\n                        isThirdPartyImport: importInfo.isThirdPartyImport,\n                        isThirdPartyPyTypedPresent: importInfo.isPyTypedPresent,\n                        diagnosticsVersion: undefined,\n                        imports: [],\n                        importedBy: [],\n                        shadows: [],\n                        shadowedBy: [],\n                    };\n\n                    this._addToSourceFileListAndMap(importedFileInfo);\n                    filesAdded.push(importedFileInfo);\n                }\n\n                importedFileInfo.importedBy.push(sourceFileInfo);\n                updatedImportMap.set(normalizedImportPath, importedFileInfo);\n            }\n        });\n\n        // Update the imports list. It should now map the set of imports\n        // specified by the source file.\n        sourceFileInfo.imports = [];\n        newImportPathMap.forEach((_, path) => {\n            if (this._getSourceFileInfoFromPath(path)) {\n                sourceFileInfo.imports.push(this._getSourceFileInfoFromPath(path)!);\n            }\n        });\n\n        // Resolve the builtins import for the file. This needs to be\n        // analyzed before the file can be analyzed.\n        sourceFileInfo.builtinsImport = undefined;\n        const builtinsImport = sourceFileInfo.sourceFile.getBuiltinsImport();\n        if (builtinsImport) {\n            const resolvedBuiltinsPath = builtinsImport.resolvedPaths[builtinsImport.resolvedPaths.length - 1];\n            sourceFileInfo.builtinsImport = this._getSourceFileInfoFromPath(resolvedBuiltinsPath);\n        }\n\n        return filesAdded;\n    }\n\n    private _getSourceFileInfoFromPath(filePath: string): SourceFileInfo | undefined {\n        return this._sourceFileMap.get(normalizePathCase(this._fs, filePath));\n    }\n\n    private _removeSourceFileFromListAndMap(filePath: string, indexToRemove: number) {\n        this._sourceFileMap.delete(normalizePathCase(this._fs, filePath));\n        this._sourceFileList.splice(indexToRemove, 1);\n    }\n\n    private _addToSourceFileListAndMap(fileInfo: SourceFileInfo) {\n        const filePath = normalizePathCase(this._fs, fileInfo.sourceFile.getFilePath());\n\n        // We should never add a file with the same path twice.\n        assert(!this._sourceFileMap.has(filePath));\n\n        this._sourceFileList.push(fileInfo);\n        this._sourceFileMap.set(filePath, fileInfo);\n    }\n}\n","/*\n * pythonPathUtils.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Utility routines used to resolve various paths in python.\n */\n\nimport * as child_process from 'child_process';\n\nimport { ConfigOptions } from '../common/configOptions';\nimport { FileSystem } from '../common/fileSystem';\nimport * as pathConsts from '../common/pathConsts';\nimport {\n    combinePaths,\n    containsPath,\n    ensureTrailingDirectorySeparator,\n    getDirectoryPath,\n    getFileSystemEntries,\n    isDirectory,\n    normalizePath,\n} from '../common/pathUtils';\n\ninterface PythonPathResult {\n    paths: string[];\n    prefix: string;\n}\n\nconst cachedSearchPaths = new Map<string, PythonPathResult>();\n\nexport const stdLibFolderName = 'stdlib';\nexport const thirdPartyFolderName = 'third_party';\n\nexport function getTypeShedFallbackPath(fs: FileSystem) {\n    let moduleDirectory = fs.getModulePath();\n    if (!moduleDirectory) {\n        return undefined;\n    }\n\n    moduleDirectory = getDirectoryPath(ensureTrailingDirectorySeparator(normalizePath(moduleDirectory)));\n\n    const typeshedPath = combinePaths(moduleDirectory, pathConsts.typeshedFallback);\n    if (fs.existsSync(typeshedPath)) {\n        return typeshedPath;\n    }\n\n    // In the debug version of Pyright, the code is one level\n    // deeper, so we need to look one level up for the typeshed fallback.\n    const debugTypeshedPath = combinePaths(getDirectoryPath(moduleDirectory), pathConsts.typeshedFallback);\n    if (fs.existsSync(debugTypeshedPath)) {\n        return debugTypeshedPath;\n    }\n\n    return undefined;\n}\n\nexport function getTypeshedSubdirectory(typeshedPath: string, isStdLib: boolean) {\n    return combinePaths(typeshedPath, isStdLib ? stdLibFolderName : thirdPartyFolderName);\n}\n\nexport function findPythonSearchPaths(\n    fs: FileSystem,\n    configOptions: ConfigOptions,\n    venv: string | undefined,\n    importFailureInfo: string[],\n    includeWatchPathsOnly?: boolean | undefined,\n    workspaceRoot?: string | undefined\n): string[] | undefined {\n    importFailureInfo.push('Finding python search paths');\n\n    let venvPath: string | undefined;\n    if (venv !== undefined) {\n        if (configOptions.venvPath) {\n            venvPath = combinePaths(configOptions.venvPath, venv);\n        }\n    } else if (configOptions.defaultVenv) {\n        if (configOptions.venvPath) {\n            venvPath = combinePaths(configOptions.venvPath, configOptions.defaultVenv);\n        }\n    }\n\n    if (venvPath) {\n        let libPath = combinePaths(venvPath, pathConsts.lib);\n        if (fs.existsSync(libPath)) {\n            importFailureInfo.push(`Found path '${libPath}'; looking for ${pathConsts.sitePackages}`);\n        } else {\n            importFailureInfo.push(`Did not find '${libPath}'; trying 'Lib' instead`);\n            libPath = combinePaths(venvPath, 'Lib');\n            if (fs.existsSync(libPath)) {\n                importFailureInfo.push(`Found path '${libPath}'; looking for ${pathConsts.sitePackages}`);\n            } else {\n                importFailureInfo.push(`Did not find '${libPath}'`);\n                libPath = '';\n            }\n        }\n\n        if (libPath) {\n            const sitePackagesPath = combinePaths(libPath, pathConsts.sitePackages);\n            if (fs.existsSync(sitePackagesPath)) {\n                importFailureInfo.push(`Found path '${sitePackagesPath}'`);\n                return [sitePackagesPath];\n            } else {\n                importFailureInfo.push(`Did not find '${sitePackagesPath}', so looking for python subdirectory`);\n            }\n\n            // We didn't find a site-packages directory directly in the lib\n            // directory. Scan for a \"python*\" directory instead.\n            const entries = getFileSystemEntries(fs, libPath);\n            for (let i = 0; i < entries.directories.length; i++) {\n                const dirName = entries.directories[i];\n                if (dirName.startsWith('python')) {\n                    const dirPath = combinePaths(libPath, dirName, pathConsts.sitePackages);\n                    if (fs.existsSync(dirPath)) {\n                        importFailureInfo.push(`Found path '${dirPath}'`);\n                        return [dirPath];\n                    } else {\n                        importFailureInfo.push(`Path '${dirPath}' is not a valid directory`);\n                    }\n                }\n            }\n        }\n\n        importFailureInfo.push(`Did not find '${pathConsts.sitePackages}'. Falling back on python interpreter.`);\n    }\n\n    // Fall back on the python interpreter.\n    const pathResult = getPythonPathFromPythonInterpreter(fs, configOptions.pythonPath, importFailureInfo);\n    if (includeWatchPathsOnly && workspaceRoot) {\n        const paths = pathResult.paths.filter(\n            (p) => !containsPath(workspaceRoot, p, true) || containsPath(pathResult.prefix, p, true)\n        );\n\n        return paths;\n    }\n\n    return pathResult.paths;\n}\n\nfunction getPathResultFromInterpreter(\n    fs: FileSystem,\n    interpreter: string,\n    importFailureInfo: string[]\n): PythonPathResult | undefined {\n    const result: PythonPathResult = {\n        paths: [],\n        prefix: '',\n    };\n\n    try {\n        const commandLineArgs: string[] = [\n            '-c',\n            'import sys, json; json.dump(dict(path=sys.path, prefix=sys.prefix), sys.stdout)',\n        ];\n\n        importFailureInfo.push(`Executing interpreter: '${interpreter}'`);\n        const execOutput = child_process.execFileSync(interpreter, commandLineArgs, { encoding: 'utf8' });\n\n        // Parse the execOutput. It should be a JSON-encoded array of paths.\n        try {\n            const execSplit = JSON.parse(execOutput);\n            for (let execSplitEntry of execSplit.path) {\n                execSplitEntry = execSplitEntry.trim();\n                if (execSplitEntry) {\n                    const normalizedPath = normalizePath(execSplitEntry);\n                    // Make sure the path exists and is a directory. We don't currently\n                    // support zip files and other formats.\n                    if (fs.existsSync(normalizedPath) && isDirectory(fs, normalizedPath)) {\n                        result.paths.push(normalizedPath);\n                    } else {\n                        importFailureInfo.push(`Skipping '${normalizedPath}' because it is not a valid directory`);\n                    }\n                }\n            }\n\n            result.prefix = execSplit.prefix;\n\n            if (result.paths.length === 0) {\n                importFailureInfo.push(`Found no valid directories`);\n            }\n        } catch (err) {\n            importFailureInfo.push(`Could not parse output: '${execOutput}'`);\n            throw err;\n        }\n    } catch {\n        return undefined;\n    }\n\n    return result;\n}\n\nexport function getPythonPathFromPythonInterpreter(\n    fs: FileSystem,\n    interpreterPath: string | undefined,\n    importFailureInfo: string[]\n): PythonPathResult {\n    const searchKey = interpreterPath || '';\n\n    // If we've seen this request before, return the cached results.\n    const cachedPath = cachedSearchPaths.get(searchKey);\n    if (cachedPath) {\n        return cachedPath;\n    }\n\n    let result: PythonPathResult | undefined;\n\n    if (interpreterPath) {\n        result = getPathResultFromInterpreter(fs, interpreterPath, importFailureInfo);\n    } else {\n        // On non-Windows platforms, always default to python3 first. We want to\n        // avoid this on Windows because it might invoke a script that displays\n        // a dialog box indicating that python can be downloaded from the app store.\n        if (process.platform !== 'win32') {\n            result = getPathResultFromInterpreter(fs, 'python3', importFailureInfo);\n        }\n\n        // On some platforms, 'python3' might not exist. Try 'python' instead.\n        if (!result) {\n            result = getPathResultFromInterpreter(fs, 'python', importFailureInfo);\n        }\n    }\n\n    if (!result) {\n        result = {\n            paths: [],\n            prefix: '',\n        };\n    }\n\n    cachedSearchPaths.set(searchKey, result);\n    importFailureInfo.push(`Received ${result.paths.length} paths from interpreter`);\n    result.paths.forEach((path) => {\n        importFailureInfo.push(`  ${path}`);\n    });\n\n    return result;\n}\n","/*\n * scope.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Represents an evaluation scope and its defined symbols.\n * It also contains a link to a parent scope (except for the\n * top-most built-in scope).\n */\n\nimport { fail } from '../common/debug';\nimport { DeclarationType } from './declaration';\nimport { Symbol, SymbolFlags, SymbolTable } from './symbol';\n\nexport const enum ScopeType {\n    // Used for list comprehension nodes.\n    ListComprehension,\n\n    // Function scopes are used for lambdas and functions.\n    Function,\n\n    // Class scopes are used for classes.\n    Class,\n\n    // Module scopes are used for modules.\n    Module,\n\n    // Built-in scopes are used for all ambient symbols provided\n    // by the Python environment.\n    Builtin,\n}\n\n// Provides information for recursive scope lookups.\nexport interface SymbolWithScope {\n    // Found symbol\n    symbol: Symbol;\n\n    // Scope in which symbol was found\n    scope: Scope;\n\n    // Indicates that the recursion needed to proceed\n    // outside of the module's scope into the builtins\n    // scope.\n    isOutsideCallerModule: boolean;\n\n    // Indicates that the recursion needed to proceed\n    // to a scope that is beyond the current execution\n    // scope. An execution scope is defined as a function\n    // or a module. Classes are not considered execution\n    // scopes because they are \"executed\" immediately as\n    // part of the scope in which they are contained.\n    isBeyondExecutionScope: boolean;\n}\n\nexport class Scope {\n    // The scope type, as defined in the enumeration.\n    readonly type: ScopeType;\n\n    // The next scope in the hierarchy or undefined if it's the\n    // top-most scope.\n    readonly parent?: Scope;\n\n    // Association between names and symbols.\n    readonly symbolTable: SymbolTable = new Map<string, Symbol>();\n\n    constructor(type: ScopeType, parent?: Scope) {\n        this.type = type;\n        this.parent = parent;\n    }\n\n    getGlobalScope(): Scope {\n        let curScope: Scope | undefined = this;\n        while (curScope) {\n            if (curScope.type === ScopeType.Module || curScope.type === ScopeType.Builtin) {\n                return curScope;\n            }\n\n            curScope = curScope.parent;\n        }\n\n        fail('failed to find scope');\n        return this;\n    }\n\n    // Independently-executable scopes are those that are executed independently\n    // of their parent scopes. Classes are executed in the context of their parent\n    // scope, so they don't fit this category.\n    isIndependentlyExecutable(): boolean {\n        return this.type === ScopeType.Module || this.type === ScopeType.Function;\n    }\n\n    lookUpSymbol(name: string): Symbol | undefined {\n        return this.symbolTable.get(name);\n    }\n\n    lookUpSymbolRecursive(name: string): SymbolWithScope | undefined {\n        return this._lookUpSymbolRecursiveInternal(\n            name,\n            /* isOutsideCallerModule */ false,\n            /* isBeyondExecutionScope */ false\n        );\n    }\n\n    addSymbol(name: string, flags: SymbolFlags): Symbol {\n        const symbol = new Symbol(flags);\n        this.symbolTable.set(name, symbol);\n        return symbol;\n    }\n\n    private _lookUpSymbolRecursiveInternal(\n        name: string,\n        isOutsideCallerModule: boolean,\n        isBeyondExecutionScope: boolean\n    ): SymbolWithScope | undefined {\n        const symbol = this.symbolTable.get(name);\n\n        if (symbol) {\n            // If we're searching outside of the original caller's module (global) scope,\n            // hide any names that are not meant to be visible to importers.\n            if (isOutsideCallerModule && symbol.isExternallyHidden()) {\n                return undefined;\n            }\n\n            // If the symbol is a class variable that is defined only in terms of\n            // member accesses, it is not accessible directly by name, so hide it.\n            const decls = symbol.getDeclarations();\n            if (\n                decls.length === 0 ||\n                decls.some((decl) => decl.type !== DeclarationType.Variable || !decl.isDefinedByMemberAccess)\n            ) {\n                return {\n                    symbol,\n                    isOutsideCallerModule,\n                    isBeyondExecutionScope,\n                    scope: this,\n                };\n            }\n        }\n\n        if (this.parent) {\n            // If our recursion is about to take us outside the scope of the current\n            // module (i.e. into a built-in scope), indicate as such with the second\n            // parameter.\n            return this.parent._lookUpSymbolRecursiveInternal(\n                name,\n                isOutsideCallerModule || this.type === ScopeType.Module,\n                isBeyondExecutionScope || this.isIndependentlyExecutable()\n            );\n        }\n\n        return undefined;\n    }\n}\n","/*\n * scopeUtils.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Static utility methods related to scopes and their related\n * symbol tables.\n */\n\nimport { ParseNode } from '../parser/parseNodes';\nimport { getScope } from './analyzerNodeInfo';\nimport { getEvaluationScopeNode } from './parseTreeUtils';\nimport { Scope, ScopeType } from './scope';\n\nexport function getBuiltInScope(currentScope: Scope): Scope {\n    // Starting at the current scope, find the built-in scope, which should\n    // be the top-most parent.\n    let builtInScope = currentScope;\n\n    while (builtInScope.type !== ScopeType.Builtin) {\n        builtInScope = builtInScope.parent!;\n    }\n\n    return builtInScope;\n}\n\n// Locates the evaluation scope associated with the specified parse node.\nexport function getScopeForNode(node: ParseNode): Scope | undefined {\n    const scopeNode = getEvaluationScopeNode(node);\n    return getScope(scopeNode);\n}\n","/*\n * service.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * A persistent service that is able to analyze a collection of\n * Python files.\n */\n\nimport {\n    AbstractCancellationTokenSource,\n    CancellationToken,\n    CompletionItem,\n    DocumentSymbol,\n    SymbolInformation,\n} from 'vscode-languageserver';\nimport {\n    CallHierarchyIncomingCall,\n    CallHierarchyItem,\n    CallHierarchyOutgoingCall,\n    DocumentHighlight,\n} from 'vscode-languageserver-types';\n\nimport { BackgroundAnalysisBase } from '../backgroundAnalysisBase';\nimport { createBackgroundThreadCancellationTokenSource } from '../common/cancellationUtils';\nimport { CommandLineOptions } from '../common/commandLineOptions';\nimport { ConfigOptions } from '../common/configOptions';\nimport { ConsoleInterface, StandardConsole } from '../common/console';\nimport { Diagnostic } from '../common/diagnostic';\nimport { FileEditAction, TextEditAction } from '../common/editAction';\nimport { LanguageServiceExtension } from '../common/extensibility';\nimport { FileSystem, FileWatcher, ignoredWatchEventFunction } from '../common/fileSystem';\nimport {\n    combinePaths,\n    FileSpec,\n    forEachAncestorDirectory,\n    getDirectoryPath,\n    getFileName,\n    getFileSpec,\n    getFileSystemEntries,\n    isDirectory,\n    normalizePath,\n    stripFileExtension,\n} from '../common/pathUtils';\nimport { DocumentRange, Position, Range } from '../common/textRange';\nimport { timingStats } from '../common/timing';\nimport { CompletionResults } from '../languageService/completionProvider';\nimport { IndexResults } from '../languageService/documentSymbolProvider';\nimport { HoverResults } from '../languageService/hoverProvider';\nimport { SignatureHelpResults } from '../languageService/signatureHelpProvider';\nimport { AnalysisCompleteCallback } from './analysis';\nimport { BackgroundAnalysisProgram, BackgroundAnalysisProgramFactory } from './backgroundAnalysisProgram';\nimport { ImportedModuleDescriptor, ImportResolver, ImportResolverFactory } from './importResolver';\nimport { MaxAnalysisTime } from './program';\nimport { findPythonSearchPaths, getPythonPathFromPythonInterpreter } from './pythonPathUtils';\n\nexport const configFileNames = ['pyrightconfig.json', 'mspythonconfig.json'];\n\n// How long since the last user activity should we wait until running\n// the analyzer on any files that have not yet been analyzed?\nconst _userActivityBackoffTimeInMs = 250;\n\nexport class AnalyzerService {\n    private _instanceName: string;\n    private _importResolverFactory: ImportResolverFactory;\n    private _executionRootPath: string;\n    private _typeStubTargetPath: string | undefined;\n    private _typeStubTargetIsSingleFile = false;\n    private _console: ConsoleInterface;\n    private _sourceFileWatcher: FileWatcher | undefined;\n    private _reloadConfigTimer: any;\n    private _libraryReanalysisTimer: any;\n    private _configFilePath: string | undefined;\n    private _configFileWatcher: FileWatcher | undefined;\n    private _libraryFileWatcher: FileWatcher | undefined;\n    private _onCompletionCallback: AnalysisCompleteCallback | undefined;\n    private _commandLineOptions: CommandLineOptions | undefined;\n    private _analyzeTimer: any;\n    private _requireTrackedFileUpdate = true;\n    private _lastUserInteractionTime = Date.now();\n    private _extension: LanguageServiceExtension | undefined;\n    private _backgroundAnalysisProgram: BackgroundAnalysisProgram;\n    private _backgroundAnalysisCancellationSource: AbstractCancellationTokenSource | undefined;\n    private _maxAnalysisTimeInForeground?: MaxAnalysisTime;\n    private _backgroundAnalysisProgramFactory?: BackgroundAnalysisProgramFactory;\n    private _disposed = false;\n\n    constructor(\n        instanceName: string,\n        fs: FileSystem,\n        console?: ConsoleInterface,\n        importResolverFactory?: ImportResolverFactory,\n        configOptions?: ConfigOptions,\n        extension?: LanguageServiceExtension,\n        backgroundAnalysis?: BackgroundAnalysisBase,\n        maxAnalysisTime?: MaxAnalysisTime,\n        backgroundAnalysisProgramFactory?: BackgroundAnalysisProgramFactory\n    ) {\n        this._instanceName = instanceName;\n        this._console = console || new StandardConsole();\n        this._executionRootPath = '';\n        this._extension = extension;\n        this._importResolverFactory = importResolverFactory || AnalyzerService.createImportResolver;\n        this._maxAnalysisTimeInForeground = maxAnalysisTime;\n        this._backgroundAnalysisProgramFactory = backgroundAnalysisProgramFactory;\n\n        configOptions = configOptions ?? new ConfigOptions(process.cwd());\n        const importResolver = this._importResolverFactory(fs, configOptions);\n\n        this._backgroundAnalysisProgram =\n            backgroundAnalysisProgramFactory !== undefined\n                ? backgroundAnalysisProgramFactory(\n                      this._console,\n                      configOptions,\n                      importResolver,\n                      this._extension,\n                      backgroundAnalysis,\n                      this._maxAnalysisTimeInForeground\n                  )\n                : new BackgroundAnalysisProgram(\n                      this._console,\n                      configOptions,\n                      importResolver,\n                      this._extension,\n                      backgroundAnalysis,\n                      this._maxAnalysisTimeInForeground\n                  );\n    }\n\n    clone(instanceName: string, backgroundAnalysis?: BackgroundAnalysisBase): AnalyzerService {\n        return new AnalyzerService(\n            instanceName,\n            this._fs,\n            this._console,\n            this._importResolverFactory,\n            this._backgroundAnalysisProgram.configOptions,\n            this._extension,\n            backgroundAnalysis,\n            this._maxAnalysisTimeInForeground,\n            this._backgroundAnalysisProgramFactory\n        );\n    }\n\n    dispose() {\n        this._disposed = true;\n        this._removeSourceFileWatchers();\n        this._removeConfigFileWatcher();\n        this._removeLibraryFileWatcher();\n        this._clearReloadConfigTimer();\n        this._clearReanalysisTimer();\n        this._clearLibraryReanalysisTimer();\n    }\n\n    get backgroundAnalysisProgram(): BackgroundAnalysisProgram {\n        return this._backgroundAnalysisProgram;\n    }\n\n    static createImportResolver(fs: FileSystem, options: ConfigOptions): ImportResolver {\n        return new ImportResolver(fs, options);\n    }\n\n    setCompletionCallback(callback: AnalysisCompleteCallback | undefined): void {\n        this._onCompletionCallback = callback;\n        this._backgroundAnalysisProgram.setCompletionCallback(callback);\n    }\n\n    setOptions(commandLineOptions: CommandLineOptions, reanalyze = true): void {\n        this._commandLineOptions = commandLineOptions;\n\n        const configOptions = this._getConfigOptions(commandLineOptions);\n\n        if (configOptions.pythonPath) {\n            // Make sure we have default python environment set.\n            configOptions.ensureDefaultPythonVersion(configOptions.pythonPath, this._console);\n        }\n\n        configOptions.ensureDefaultPythonPlatform(this._console);\n\n        this._backgroundAnalysisProgram.setConfigOptions(configOptions);\n\n        this._executionRootPath = normalizePath(\n            combinePaths(commandLineOptions.executionRoot, configOptions.projectRoot)\n        );\n        this._applyConfigOptions(reanalyze);\n    }\n\n    setFileOpened(path: string, version: number | null, contents: string) {\n        this._backgroundAnalysisProgram.setFileOpened(path, version, contents);\n        this._scheduleReanalysis(false);\n    }\n\n    updateOpenFileContents(path: string, version: number | null, contents: string) {\n        this._backgroundAnalysisProgram.updateOpenFileContents(path, version, contents);\n        this._scheduleReanalysis(false);\n    }\n\n    test_setIndexing(\n        workspaceIndices: Map<string, IndexResults>,\n        libraryIndices: Map<string, Map<string, IndexResults>>\n    ) {\n        this._backgroundAnalysisProgram.test_setIndexing(workspaceIndices, libraryIndices);\n    }\n\n    startIndexing() {\n        this._backgroundAnalysisProgram.startIndexing();\n    }\n\n    setFileClosed(path: string) {\n        this._backgroundAnalysisProgram.setFileClosed(path);\n        this._scheduleReanalysis(false);\n    }\n\n    getParseResult(path: string) {\n        return this._program.getBoundSourceFile(path)?.getParseResults();\n    }\n\n    getTextOnRange(filePath: string, range: Range, token: CancellationToken) {\n        return this._program.getTextOnRange(filePath, range, token);\n    }\n\n    getAutoImports(\n        filePath: string,\n        range: Range,\n        similarityLimit: number,\n        nameMap: Map<string, string> | undefined,\n        token: CancellationToken\n    ) {\n        return this._program.getAutoImports(\n            filePath,\n            range,\n            similarityLimit,\n            nameMap,\n            this._backgroundAnalysisProgram.getIndexing(filePath),\n            token\n        );\n    }\n\n    getDefinitionForPosition(\n        filePath: string,\n        position: Position,\n        token: CancellationToken\n    ): DocumentRange[] | undefined {\n        return this._program.getDefinitionsForPosition(filePath, position, token);\n    }\n\n    getReferencesForPosition(\n        filePath: string,\n        position: Position,\n        includeDeclaration: boolean,\n        token: CancellationToken\n    ): DocumentRange[] | undefined {\n        return this._program.getReferencesForPosition(filePath, position, includeDeclaration, token);\n    }\n\n    addSymbolsForDocument(filePath: string, symbolList: DocumentSymbol[], token: CancellationToken) {\n        this._program.addSymbolsForDocument(filePath, symbolList, token);\n    }\n\n    addSymbolsForWorkspace(symbolList: SymbolInformation[], query: string, token: CancellationToken) {\n        this._program.addSymbolsForWorkspace(symbolList, query, token);\n    }\n\n    getHoverForPosition(filePath: string, position: Position, token: CancellationToken): HoverResults | undefined {\n        return this._program.getHoverForPosition(filePath, position, token);\n    }\n\n    getDocumentHighlight(\n        filePath: string,\n        position: Position,\n        token: CancellationToken\n    ): DocumentHighlight[] | undefined {\n        return this._program.getDocumentHighlight(filePath, position, token);\n    }\n\n    getSignatureHelpForPosition(\n        filePath: string,\n        position: Position,\n        token: CancellationToken\n    ): SignatureHelpResults | undefined {\n        return this._program.getSignatureHelpForPosition(filePath, position, token);\n    }\n\n    getCompletionsForPosition(\n        filePath: string,\n        position: Position,\n        workspacePath: string,\n        token: CancellationToken\n    ): Promise<CompletionResults | undefined> {\n        return this._program.getCompletionsForPosition(\n            filePath,\n            position,\n            workspacePath,\n            this._backgroundAnalysisProgram.getIndexing(filePath),\n            token\n        );\n    }\n\n    resolveCompletionItem(filePath: string, completionItem: CompletionItem, token: CancellationToken) {\n        this._program.resolveCompletionItem(\n            filePath,\n            completionItem,\n            this._backgroundAnalysisProgram.getIndexing(filePath),\n            token\n        );\n    }\n\n    performQuickAction(\n        filePath: string,\n        command: string,\n        args: any[],\n        token: CancellationToken\n    ): TextEditAction[] | undefined {\n        return this._program.performQuickAction(filePath, command, args, token);\n    }\n\n    renameSymbolAtPosition(\n        filePath: string,\n        position: Position,\n        newName: string,\n        token: CancellationToken\n    ): FileEditAction[] | undefined {\n        return this._program.renameSymbolAtPosition(filePath, position, newName, token);\n    }\n\n    getCallForPosition(filePath: string, position: Position, token: CancellationToken): CallHierarchyItem | undefined {\n        return this._program.getCallForPosition(filePath, position, token);\n    }\n\n    getIncomingCallsForPosition(\n        filePath: string,\n        position: Position,\n        token: CancellationToken\n    ): CallHierarchyIncomingCall[] | undefined {\n        return this._program.getIncomingCallsForPosition(filePath, position, token);\n    }\n\n    getOutgoingCallsForPosition(\n        filePath: string,\n        position: Position,\n        token: CancellationToken\n    ): CallHierarchyOutgoingCall[] | undefined {\n        return this._program.getOutgoingCallsForPosition(filePath, position, token);\n    }\n\n    printStats() {\n        this._console.info('');\n        this._console.info('Analysis stats');\n\n        const fileCount = this._program.getFileCount();\n        this._console.info('Total files analyzed: ' + fileCount.toString());\n    }\n\n    printDependencies(verbose: boolean) {\n        this._program.printDependencies(this._executionRootPath, verbose);\n    }\n\n    getDiagnosticsForRange(filePath: string, range: Range, token: CancellationToken): Promise<Diagnostic[]> {\n        return this._backgroundAnalysisProgram.getDiagnosticsForRange(filePath, range, token);\n    }\n\n    getConfigOptions() {\n        return this._configOptions;\n    }\n\n    getImportResolver(): ImportResolver {\n        return this._backgroundAnalysisProgram.importResolver;\n    }\n\n    recordUserInteractionTime() {\n        this._lastUserInteractionTime = Date.now();\n\n        // If we have a pending timer for reanalysis, cancel it\n        // and reschedule for some time in the future.\n        if (this._analyzeTimer) {\n            this._scheduleReanalysis(false);\n        }\n    }\n\n    // test only APIs\n    get test_program() {\n        return this._program;\n    }\n\n    test_getConfigOptions(commandLineOptions: CommandLineOptions): ConfigOptions {\n        return this._getConfigOptions(commandLineOptions);\n    }\n\n    test_getFileNamesFromFileSpecs(): string[] {\n        return this._getFileNamesFromFileSpecs();\n    }\n\n    // Calculates the effective options based on the command-line options,\n    // an optional config file, and default values.\n    private _getConfigOptions(commandLineOptions: CommandLineOptions): ConfigOptions {\n        let projectRoot = commandLineOptions.executionRoot;\n        let configFilePath: string | undefined;\n\n        if (commandLineOptions.configFilePath) {\n            // If the config file path was specified, determine whether it's\n            // a directory (in which case the default config file name is assumed)\n            // or a file.\n            configFilePath = combinePaths(\n                commandLineOptions.executionRoot,\n                normalizePath(commandLineOptions.configFilePath)\n            );\n            if (!this._fs.existsSync(configFilePath)) {\n                this._console.info(`Configuration file not found at ${configFilePath}.`);\n                configFilePath = commandLineOptions.executionRoot;\n            } else {\n                if (configFilePath.toLowerCase().endsWith('.json')) {\n                    projectRoot = getDirectoryPath(configFilePath);\n                } else {\n                    projectRoot = configFilePath;\n                    configFilePath = this._findConfigFile(configFilePath);\n                    if (!configFilePath) {\n                        this._console.info(`Configuration file not found at ${projectRoot}.`);\n                    }\n                }\n            }\n        } else if (projectRoot) {\n            configFilePath = this._findConfigFileHereOrUp(projectRoot);\n            if (configFilePath) {\n                projectRoot = getDirectoryPath(configFilePath);\n            } else {\n                this._console.info(`No configuration file found.`);\n                configFilePath = undefined;\n            }\n        }\n\n        const configOptions = new ConfigOptions(projectRoot, this._typeCheckingMode);\n        const defaultExcludes = ['**/node_modules', '**/__pycache__', '.git'];\n\n        if (commandLineOptions.fileSpecs.length > 0) {\n            commandLineOptions.fileSpecs.forEach((fileSpec) => {\n                configOptions.include.push(getFileSpec(projectRoot, fileSpec));\n            });\n        } else if (!configFilePath) {\n            // If no config file was found and there are no explicit include\n            // paths specified, assume the caller wants to include all source\n            // files under the execution root path.\n            if (commandLineOptions.executionRoot) {\n                configOptions.include.push(getFileSpec(commandLineOptions.executionRoot, '.'));\n\n                // Add a few common excludes to avoid long scan times.\n                defaultExcludes.forEach((exclude) => {\n                    configOptions.exclude.push(getFileSpec(commandLineOptions.executionRoot, exclude));\n                });\n            }\n        }\n\n        this._configFilePath = configFilePath;\n\n        // If we found a config file, parse it to compute the effective options.\n        if (configFilePath) {\n            this._console.info(`Loading configuration file at ${configFilePath}`);\n            const configJsonObj = this._parseConfigFile(configFilePath);\n            if (configJsonObj) {\n                configOptions.initializeFromJson(\n                    configJsonObj,\n                    this._typeCheckingMode,\n                    this._console,\n                    commandLineOptions.diagnosticSeverityOverrides,\n                    commandLineOptions.pythonPath,\n                    commandLineOptions.fileSpecs.length > 0\n                );\n\n                const configFileDir = getDirectoryPath(configFilePath);\n\n                // If no include paths were provided, assume that all files within\n                // the project should be included.\n                if (configOptions.include.length === 0) {\n                    this._console.info(`No include entries specified; assuming ${configFileDir}`);\n                    configOptions.include.push(getFileSpec(configFileDir, '.'));\n                }\n\n                // If there was no explicit set of excludes, add a few common ones to avoid long scan times.\n                if (configOptions.exclude.length === 0) {\n                    defaultExcludes.forEach((exclude) => {\n                        this._console.info(`Auto-excluding ${exclude}`);\n                        configOptions.exclude.push(getFileSpec(configFileDir, exclude));\n                    });\n\n                    if (configOptions.autoExcludeVenv === undefined) {\n                        configOptions.autoExcludeVenv = true;\n                    }\n                }\n\n                // If the user has defined execution environments, then we ignore\n                // autoSearchPaths, extraPaths and leave it up to them to set\n                // extraPaths on the execution environments.\n                if (configOptions.executionEnvironments.length === 0) {\n                    configOptions.addExecEnvironmentForExtraPaths(\n                        this._fs,\n                        commandLineOptions.autoSearchPaths || false,\n                        commandLineOptions.extraPaths || []\n                    );\n                }\n            }\n        } else {\n            configOptions.addExecEnvironmentForExtraPaths(\n                this._fs,\n                commandLineOptions.autoSearchPaths || false,\n                commandLineOptions.extraPaths || []\n            );\n\n            configOptions.autoExcludeVenv = true;\n            configOptions.applyDiagnosticOverrides(commandLineOptions.diagnosticSeverityOverrides);\n        }\n\n        const reportDuplicateSetting = (settingName: string, configValue: number | string | boolean) => {\n            const settingSource = commandLineOptions.fromVsCodeExtension\n                ? 'the client settings'\n                : 'a command-line option';\n            this._console.warn(\n                `The ${settingName} has been specified in both the config file and ` +\n                    `${settingSource}. The value in the config file (${configValue}) ` +\n                    `will take precedence`\n            );\n        };\n\n        // Apply the command-line options if the corresponding\n        // item wasn't already set in the config file. Report any\n        // duplicates.\n        if (commandLineOptions.venvPath) {\n            if (!configOptions.venvPath) {\n                configOptions.venvPath = commandLineOptions.venvPath;\n            } else {\n                reportDuplicateSetting('venvPath', configOptions.venvPath);\n            }\n        }\n\n        if (commandLineOptions.pythonPath) {\n            this._console.info(\n                `Setting pythonPath for service \"${this._instanceName}\": ` + `\"${commandLineOptions.pythonPath}\"`\n            );\n            configOptions.pythonPath = commandLineOptions.pythonPath;\n        }\n\n        if (commandLineOptions.typeshedPath) {\n            if (!configOptions.typeshedPath) {\n                configOptions.typeshedPath = commandLineOptions.typeshedPath;\n            } else {\n                reportDuplicateSetting('typeshedPath', configOptions.typeshedPath);\n            }\n        }\n\n        configOptions.verboseOutput = commandLineOptions.verboseOutput ?? configOptions.verboseOutput;\n        configOptions.checkOnlyOpenFiles = !!commandLineOptions.checkOnlyOpenFiles;\n        configOptions.autoImportCompletions = !!commandLineOptions.autoImportCompletions;\n        configOptions.indexing = !!commandLineOptions.indexing;\n\n        // If useLibraryCodeForTypes was not specified in the config, allow the settings\n        // or command line to override it.\n        if (configOptions.useLibraryCodeForTypes === undefined) {\n            configOptions.useLibraryCodeForTypes = !!commandLineOptions.useLibraryCodeForTypes;\n        } else if (commandLineOptions.useLibraryCodeForTypes !== undefined) {\n            reportDuplicateSetting('useLibraryCodeForTypes', configOptions.useLibraryCodeForTypes);\n        }\n\n        // If there was no stub path specified, use a default path.\n        if (commandLineOptions.stubPath) {\n            if (!configOptions.stubPath) {\n                configOptions.stubPath = commandLineOptions.stubPath;\n            } else {\n                reportDuplicateSetting('stubPath', configOptions.stubPath);\n            }\n        } else {\n            if (!configOptions.stubPath) {\n                configOptions.stubPath = normalizePath(combinePaths(configOptions.projectRoot, 'typings'));\n            }\n        }\n\n        // Do some sanity checks on the specified settings and report missing\n        // or inconsistent information.\n        if (configOptions.venvPath) {\n            if (!this._fs.existsSync(configOptions.venvPath) || !isDirectory(this._fs, configOptions.venvPath)) {\n                this._console.error(`venvPath ${configOptions.venvPath} is not a valid directory.`);\n            }\n\n            // venvPath without defaultVenv means it won't do anything while resolveImport.\n            // so first, try to set defaultVenv from existing configOption if it is null. if both are null,\n            // then, resolveImport won't consider venv\n            configOptions.defaultVenv = configOptions.defaultVenv ?? this._configOptions.defaultVenv;\n            if (configOptions.defaultVenv) {\n                const fullVenvPath = combinePaths(configOptions.venvPath, configOptions.defaultVenv);\n\n                if (!this._fs.existsSync(fullVenvPath) || !isDirectory(this._fs, fullVenvPath)) {\n                    this._console.error(\n                        `venv ${configOptions.defaultVenv} subdirectory not found ` +\n                            `in venv path ${configOptions.venvPath}.`\n                    );\n                } else {\n                    const importFailureInfo: string[] = [];\n                    if (findPythonSearchPaths(this._fs, configOptions, undefined, importFailureInfo) === undefined) {\n                        this._console.error(\n                            `site-packages directory cannot be located for venvPath ` +\n                                `${configOptions.venvPath} and venv ${configOptions.defaultVenv}.`\n                        );\n\n                        if (configOptions.verboseOutput) {\n                            importFailureInfo.forEach((diag) => {\n                                this._console.error(`  ${diag}`);\n                            });\n                        }\n                    }\n                }\n            }\n        } else {\n            const importFailureInfo: string[] = [];\n            const pythonPaths = getPythonPathFromPythonInterpreter(\n                this._fs,\n                configOptions.pythonPath,\n                importFailureInfo\n            ).paths;\n            if (pythonPaths.length === 0) {\n                if (configOptions.verboseOutput) {\n                    this._console.error(`No search paths found for configured python interpreter.`);\n                }\n            } else {\n                if (configOptions.verboseOutput) {\n                    this._console.info(`Search paths found for configured python interpreter:`);\n                    pythonPaths.forEach((path) => {\n                        this._console.info(`  ${path}`);\n                    });\n                }\n            }\n\n            if (configOptions.verboseOutput) {\n                if (importFailureInfo.length > 0) {\n                    this._console.info(`When attempting to get search paths from python interpreter:`);\n                    importFailureInfo.forEach((diag) => {\n                        this._console.info(`  ${diag}`);\n                    });\n                }\n            }\n        }\n\n        // Is there a reference to a venv? If so, there needs to be a valid venvPath.\n        if (configOptions.defaultVenv || configOptions.executionEnvironments.find((e) => !!e.venv)) {\n            if (!configOptions.venvPath) {\n                this._console.warn(`venvPath not specified, so venv settings will be ignored.`);\n            }\n        }\n\n        if (configOptions.typeshedPath) {\n            if (\n                !this._fs.existsSync(configOptions.typeshedPath) ||\n                !isDirectory(this._fs, configOptions.typeshedPath)\n            ) {\n                this._console.error(`typeshedPath ${configOptions.typeshedPath} is not a valid directory.`);\n            }\n        }\n\n        if (configOptions.stubPath) {\n            if (!this._fs.existsSync(configOptions.stubPath) || !isDirectory(this._fs, configOptions.stubPath)) {\n                this._console.error(`stubPath ${configOptions.stubPath} is not a valid directory.`);\n            }\n        }\n\n        return configOptions;\n    }\n\n    writeTypeStub(token: CancellationToken): void {\n        const typingsSubdirPath = this._getTypeStubFolder();\n\n        this._program.writeTypeStub(\n            this._typeStubTargetPath!,\n            this._typeStubTargetIsSingleFile,\n            typingsSubdirPath,\n            token\n        );\n    }\n\n    writeTypeStubInBackground(token: CancellationToken): Promise<any> {\n        const typingsSubdirPath = this._getTypeStubFolder();\n\n        return this._backgroundAnalysisProgram.writeTypeStub(\n            this._typeStubTargetPath!,\n            this._typeStubTargetIsSingleFile,\n            typingsSubdirPath,\n            token\n        );\n    }\n\n    // This is called after a new type stub has been created. It allows\n    // us to invalidate caches and force reanalysis of files that potentially\n    // are affected by the appearance of a new type stub.\n    invalidateAndForceReanalysis() {\n        // Mark all files with one or more errors dirty.\n        this._backgroundAnalysisProgram.invalidateAndForceReanalysis();\n    }\n\n    // Forces the service to stop all analysis, discard all its caches,\n    // and research for files.\n    restart() {\n        this._applyConfigOptions();\n\n        this._backgroundAnalysisProgram.restart();\n    }\n\n    private get _fs() {\n        return this._backgroundAnalysisProgram.importResolver.fileSystem;\n    }\n\n    private get _program() {\n        return this._backgroundAnalysisProgram.program;\n    }\n\n    private get _configOptions() {\n        return this._backgroundAnalysisProgram.configOptions;\n    }\n\n    private get _watchForSourceChanges() {\n        return !!this._commandLineOptions?.watchForSourceChanges;\n    }\n\n    private get _watchForLibraryChanges() {\n        return !!this._commandLineOptions?.watchForLibraryChanges;\n    }\n\n    private get _typeCheckingMode() {\n        return this._commandLineOptions?.typeCheckingMode;\n    }\n\n    private get _verboseOutput(): boolean {\n        return !!this._configOptions.verboseOutput;\n    }\n\n    private get _typeStubTargetImportName() {\n        return this._commandLineOptions?.typeStubTargetImportName;\n    }\n\n    private _getTypeStubFolder() {\n        const stubPath = this._configOptions.stubPath;\n        if (!this._typeStubTargetPath || !this._typeStubTargetImportName) {\n            const errMsg = `Import '${this._typeStubTargetImportName}'` + ` could not be resolved`;\n            this._console.error(errMsg);\n            throw new Error(errMsg);\n        }\n        if (!stubPath) {\n            // We should never get here because we always generate a\n            // default typings path if none was specified.\n            const errMsg = 'No typings path was specified';\n            this._console.info(errMsg);\n            throw new Error(errMsg);\n        }\n        const typeStubInputTargetParts = this._typeStubTargetImportName.split('.');\n        if (typeStubInputTargetParts[0].length === 0) {\n            // We should never get here because the import resolution\n            // would have failed.\n            const errMsg = `Import '${this._typeStubTargetImportName}'` + ` could not be resolved`;\n            this._console.error(errMsg);\n            throw new Error(errMsg);\n        }\n        try {\n            // Generate a new typings directory if necessary.\n            if (!this._fs.existsSync(stubPath)) {\n                this._fs.mkdirSync(stubPath);\n            }\n        } catch (e) {\n            const errMsg = `Could not create typings directory '${stubPath}'`;\n            this._console.error(errMsg);\n            throw new Error(errMsg);\n        }\n        // Generate a typings subdirectory.\n        const typingsSubdirPath = combinePaths(stubPath, typeStubInputTargetParts[0]);\n        try {\n            // Generate a new typings subdirectory if necessary.\n            if (!this._fs.existsSync(typingsSubdirPath)) {\n                this._fs.mkdirSync(typingsSubdirPath);\n            }\n        } catch (e) {\n            const errMsg = `Could not create typings subdirectory '${typingsSubdirPath}'`;\n            this._console.error(errMsg);\n            throw new Error(errMsg);\n        }\n        return typingsSubdirPath;\n    }\n\n    private _findConfigFileHereOrUp(searchPath: string): string | undefined {\n        return forEachAncestorDirectory(searchPath, (ancestor) => this._findConfigFile(ancestor));\n    }\n\n    private _findConfigFile(searchPath: string): string | undefined {\n        for (const name of configFileNames) {\n            const fileName = combinePaths(searchPath, name);\n            if (this._fs.existsSync(fileName)) {\n                return fileName;\n            }\n        }\n        return undefined;\n    }\n\n    private _parseConfigFile(configPath: string): any | undefined {\n        let configContents = '';\n        let parseAttemptCount = 0;\n\n        while (true) {\n            // Attempt to read the config file contents.\n            try {\n                configContents = this._fs.readFileSync(configPath, 'utf8');\n            } catch {\n                this._console.error(`Config file \"${configPath}\" could not be read.`);\n                this._reportConfigParseError();\n                return undefined;\n            }\n\n            // Attempt to parse the config file.\n            let configObj: any;\n            let parseFailed = false;\n            try {\n                configObj = JSON.parse(configContents);\n                return configObj;\n            } catch {\n                parseFailed = true;\n            }\n\n            if (!parseFailed) {\n                break;\n            }\n\n            // If we attempt to read the config file immediately after it\n            // was saved, it may have been partially written when we read it,\n            // resulting in parse errors. We'll give it a little more time and\n            // try again.\n            if (parseAttemptCount++ >= 5) {\n                this._console.error(`Config file \"${configPath}\" could not be parsed. Verify that JSON is correct.`);\n                this._reportConfigParseError();\n                return undefined;\n            }\n        }\n    }\n\n    private _getFileNamesFromFileSpecs(): string[] {\n        // Use a map to generate a list of unique files.\n        const fileMap = new Map<string, string>();\n\n        timingStats.findFilesTime.timeOperation(() => {\n            const matchedFiles = this._matchFiles(this._configOptions.include, this._configOptions.exclude);\n\n            for (const file of matchedFiles) {\n                fileMap.set(file, file);\n            }\n        });\n\n        return [...fileMap.values()];\n    }\n\n    // If markFilesDirtyUnconditionally is true, we need to reparse\n    // and reanalyze all files in the program. If false, we will\n    // reparse and reanalyze only those files whose on-disk contents\n    // have changed. Unconditional dirtying is needed in the case where\n    // configuration options have changed.\n    private _updateTrackedFileList(markFilesDirtyUnconditionally: boolean) {\n        // Are we in type stub generation mode? If so, we need to search\n        // for a different set of files.\n        if (this._typeStubTargetImportName) {\n            const execEnv = this._configOptions.findExecEnvironment(this._executionRootPath);\n            const moduleDescriptor: ImportedModuleDescriptor = {\n                leadingDots: 0,\n                nameParts: this._typeStubTargetImportName.split('.'),\n                importedSymbols: [],\n            };\n\n            const importResult = this._backgroundAnalysisProgram.importResolver.resolveImport(\n                '',\n                execEnv,\n                moduleDescriptor\n            );\n\n            if (importResult.isImportFound) {\n                const filesToImport: string[] = [];\n\n                // Namespace packages resolve to a directory name, so\n                // don't include those.\n                const resolvedPath = importResult.resolvedPaths[importResult.resolvedPaths.length - 1];\n\n                // Get the directory that contains the root package.\n                let targetPath = getDirectoryPath(resolvedPath);\n                let prevResolvedPath = resolvedPath;\n                for (let i = importResult.resolvedPaths.length - 2; i >= 0; i--) {\n                    const resolvedPath = importResult.resolvedPaths[i];\n                    if (resolvedPath) {\n                        targetPath = getDirectoryPath(resolvedPath);\n                        prevResolvedPath = resolvedPath;\n                    } else {\n                        // If there was no file corresponding to this portion\n                        // of the name path, assume that it's contained\n                        // within its parent directory.\n                        targetPath = getDirectoryPath(prevResolvedPath);\n                        prevResolvedPath = targetPath;\n                    }\n                }\n\n                if (isDirectory(this._fs, targetPath)) {\n                    this._typeStubTargetPath = targetPath;\n                }\n\n                if (!resolvedPath) {\n                    this._typeStubTargetIsSingleFile = false;\n                } else {\n                    filesToImport.push(resolvedPath);\n                    this._typeStubTargetIsSingleFile =\n                        importResult.resolvedPaths.length === 1 &&\n                        stripFileExtension(getFileName(importResult.resolvedPaths[0])) !== '__init__';\n                }\n\n                // Add the implicit import paths.\n                importResult.implicitImports.forEach((implicitImport) => {\n                    filesToImport.push(implicitImport.path);\n                });\n\n                this._backgroundAnalysisProgram.setAllowedThirdPartyImports([this._typeStubTargetImportName]);\n                this._backgroundAnalysisProgram.setTrackedFiles(filesToImport);\n            } else {\n                this._console.error(`Import '${this._typeStubTargetImportName}' not found`);\n            }\n        } else {\n            let fileList: string[] = [];\n            this._console.info(`Searching for source files`);\n            fileList = this._getFileNamesFromFileSpecs();\n\n            this._backgroundAnalysisProgram.setTrackedFiles(fileList);\n            this._backgroundAnalysisProgram.markAllFilesDirty(markFilesDirtyUnconditionally);\n\n            if (fileList.length === 0) {\n                this._console.info(`No source files found.`);\n            } else {\n                this._console.info(`Found ${fileList.length} ` + `source ${fileList.length === 1 ? 'file' : 'files'}`);\n            }\n        }\n\n        this._requireTrackedFileUpdate = false;\n    }\n\n    private _isInExcludePath(path: string, excludePaths: FileSpec[]) {\n        return !!excludePaths.find((excl) => excl.regExp.test(path));\n    }\n\n    private _matchFiles(include: FileSpec[], exclude: FileSpec[]): string[] {\n        const includeFileRegex = /\\.pyi?$/;\n        const envMarkers = [['bin', 'activate'], ['Scripts', 'activate'], ['pyvenv.cfg']];\n        const results: string[] = [];\n\n        const visitDirectory = (absolutePath: string, includeRegExp: RegExp) => {\n            if (this._configOptions.autoExcludeVenv) {\n                if (envMarkers.some((f) => this._fs.existsSync(combinePaths(absolutePath, ...f)))) {\n                    this._console.info(`Auto-excluding ${absolutePath}`);\n                    return;\n                }\n            }\n\n            const { files, directories } = getFileSystemEntries(this._fs, absolutePath);\n\n            for (const file of files) {\n                const filePath = combinePaths(absolutePath, file);\n\n                if (includeRegExp.test(filePath)) {\n                    if (!this._isInExcludePath(filePath, exclude) && includeFileRegex.test(filePath)) {\n                        results.push(filePath);\n                    }\n                }\n            }\n\n            for (const directory of directories) {\n                const dirPath = combinePaths(absolutePath, directory);\n                if (includeRegExp.test(dirPath)) {\n                    if (!this._isInExcludePath(dirPath, exclude)) {\n                        visitDirectory(dirPath, includeRegExp);\n                    }\n                }\n            }\n        };\n\n        include.forEach((includeSpec) => {\n            let foundFileSpec = false;\n\n            if (!this._isInExcludePath(includeSpec.wildcardRoot, exclude)) {\n                try {\n                    const stat = this._fs.statSync(includeSpec.wildcardRoot);\n                    if (stat.isFile()) {\n                        if (includeFileRegex.test(includeSpec.wildcardRoot)) {\n                            results.push(includeSpec.wildcardRoot);\n                            foundFileSpec = true;\n                        }\n                    } else if (stat.isDirectory()) {\n                        visitDirectory(includeSpec.wildcardRoot, includeSpec.regExp);\n                        foundFileSpec = true;\n                    }\n                } catch {\n                    // Ignore the exception.\n                }\n            }\n\n            if (!foundFileSpec) {\n                this._console.error(`File or directory \"${includeSpec.wildcardRoot}\" does not exist.`);\n            }\n        });\n\n        return results;\n    }\n\n    private _removeSourceFileWatchers() {\n        if (this._sourceFileWatcher) {\n            this._sourceFileWatcher.close();\n            this._sourceFileWatcher = undefined;\n        }\n    }\n\n    private _updateSourceFileWatchers() {\n        this._removeSourceFileWatchers();\n\n        this._backgroundAnalysisProgram.invalidateCache();\n\n        if (!this._watchForSourceChanges) {\n            return;\n        }\n\n        if (this._configOptions.include.length > 0) {\n            const fileList = this._configOptions.include.map((spec) => {\n                return combinePaths(this._executionRootPath, spec.wildcardRoot);\n            });\n\n            try {\n                if (this._verboseOutput) {\n                    this._console.info(`Adding fs watcher for directories:\\n ${fileList.join('\\n')}`);\n                }\n\n                const isIgnored = ignoredWatchEventFunction(fileList);\n                this._sourceFileWatcher = this._fs.createFileSystemWatcher(fileList, (event, path) => {\n                    if (isIgnored(path)) {\n                        return;\n                    }\n\n                    if (this._verboseOutput) {\n                        this._console.info(`SourceFile: Received fs event '${event}' for path '${path}'`);\n                    }\n\n                    // Delete comes in as a change event, so try to distinguish here.\n                    if (event === 'change' && this._fs.existsSync(path)) {\n                        this._backgroundAnalysisProgram.markFilesDirty([path], false);\n                        this._scheduleReanalysis(false);\n                    } else {\n                        // Determine if this is an add or delete event related to a temporary\n                        // file. Some tools (like auto-formatters) create temporary files\n                        // alongside the original file and name them \"x.py.<temp-id>.py\" where\n                        // <temp-id> is a 32-character random string of hex digits. We don't\n                        // want these events to trigger a full reanalysis.\n                        const fileName = getFileName(path);\n                        const fileNameSplit = fileName.split('.');\n                        let isTemporaryFile = false;\n                        if (fileNameSplit.length === 4) {\n                            if (fileNameSplit[3] === fileNameSplit[1] && fileNameSplit[2].length === 32) {\n                                isTemporaryFile = true;\n                            }\n                        }\n\n                        if (!isTemporaryFile) {\n                            // Added/deleted/renamed files impact imports,\n                            // clear the import resolver cache and reanalyze everything.\n                            this.invalidateAndForceReanalysis();\n                            this._scheduleReanalysis(true);\n                        }\n                    }\n                });\n            } catch {\n                this._console.error(`Exception caught when installing fs watcher for:\\n ${fileList.join('\\n')}`);\n            }\n        }\n    }\n\n    private _removeLibraryFileWatcher() {\n        if (this._libraryFileWatcher) {\n            this._libraryFileWatcher.close();\n            this._libraryFileWatcher = undefined;\n        }\n    }\n\n    private _updateLibraryFileWatcher() {\n        this._removeLibraryFileWatcher();\n\n        this._backgroundAnalysisProgram.invalidateCache();\n\n        if (!this._watchForLibraryChanges) {\n            return;\n        }\n\n        // Watch the library paths for package install/uninstall.\n        const importFailureInfo: string[] = [];\n        const watchList = findPythonSearchPaths(\n            this._fs,\n            this._backgroundAnalysisProgram.configOptions,\n            undefined,\n            importFailureInfo,\n            true,\n            this._executionRootPath\n        );\n\n        if (watchList && watchList.length > 0) {\n            try {\n                if (this._verboseOutput) {\n                    this._console.info(`Adding fs watcher for library directories:\\n ${watchList.join('\\n')}`);\n                }\n                const isIgnored = ignoredWatchEventFunction(watchList);\n                this._libraryFileWatcher = this._fs.createFileSystemWatcher(watchList, (event, path) => {\n                    if (isIgnored(path)) {\n                        return;\n                    }\n\n                    if (this._verboseOutput) {\n                        this._console.info(`LibraryFile: Received fs event '${event}' for path '${path}'}'`);\n                    }\n\n                    this._scheduleLibraryAnalysis();\n                });\n            } catch {\n                this._console.error(`Exception caught when installing fs watcher for:\\n ${watchList.join('\\n')}`);\n            }\n        }\n    }\n\n    private _clearLibraryReanalysisTimer() {\n        if (this._libraryReanalysisTimer) {\n            clearTimeout(this._libraryReanalysisTimer);\n            this._libraryReanalysisTimer = undefined;\n            this._backgroundAnalysisProgram?.cancelIndexing();\n        }\n    }\n\n    private _scheduleLibraryAnalysis() {\n        if (this._disposed) {\n            // Already disposed.\n            return;\n        }\n\n        this._clearLibraryReanalysisTimer();\n\n        // Wait for a little while, since library changes\n        // tend to happen in big batches when packages\n        // are installed or uninstalled.\n        this._libraryReanalysisTimer = setTimeout(() => {\n            this._clearLibraryReanalysisTimer();\n\n            // Invalidate import resolver, mark all files dirty unconditionally,\n            // and reanalyze.\n            this.invalidateAndForceReanalysis();\n            this._scheduleReanalysis(false);\n        }, 1000);\n    }\n\n    private _removeConfigFileWatcher() {\n        if (this._configFileWatcher) {\n            this._configFileWatcher.close();\n            this._configFileWatcher = undefined;\n        }\n    }\n\n    private _updateConfigFileWatcher() {\n        this._removeConfigFileWatcher();\n\n        if (this._configFilePath) {\n            this._configFileWatcher = this._fs.createFileSystemWatcher([this._configFilePath], (event) => {\n                if (this._verboseOutput) {\n                    this._console.info(`Received fs event '${event}' for config file`);\n                }\n                this._scheduleReloadConfigFile();\n            });\n        } else if (this._executionRootPath) {\n            this._configFileWatcher = this._fs.createFileSystemWatcher([this._executionRootPath], (event, path) => {\n                if (event === 'add' || event === 'change') {\n                    const fileName = getFileName(path);\n                    if (fileName && configFileNames.some((name) => name === fileName)) {\n                        if (this._verboseOutput) {\n                            this._console.info(`Received fs event '${event}' for config file`);\n                        }\n                        if (this._commandLineOptions) {\n                            this.setOptions(this._commandLineOptions);\n                        }\n                    }\n                }\n            });\n        }\n    }\n\n    private _clearReloadConfigTimer() {\n        if (this._reloadConfigTimer) {\n            clearTimeout(this._reloadConfigTimer);\n            this._reloadConfigTimer = undefined;\n        }\n    }\n\n    private _scheduleReloadConfigFile() {\n        this._clearReloadConfigTimer();\n\n        // Wait for a little while after we receive the\n        // change update event because it may take a while\n        // for the file to be written out. Plus, there may\n        // be multiple changes.\n        this._reloadConfigTimer = setTimeout(() => {\n            this._clearReloadConfigTimer();\n            this._reloadConfigFile();\n        }, 100);\n    }\n\n    private _reloadConfigFile() {\n        this._updateConfigFileWatcher();\n\n        if (this._configFilePath) {\n            this._console.info(`Reloading configuration file at ${this._configFilePath}`);\n\n            // We can't just reload config file when it is changed; we need to consider\n            // command line options as well to construct new config Options.\n            const configOptions = this._getConfigOptions(this._commandLineOptions!);\n            this._backgroundAnalysisProgram.setConfigOptions(configOptions);\n\n            this._applyConfigOptions();\n        }\n    }\n\n    private _applyConfigOptions(reanalyze = true) {\n        // Allocate a new import resolver because the old one has information\n        // cached based on the previous config options.\n        const importResolver = this._importResolverFactory(this._fs, this._backgroundAnalysisProgram.configOptions);\n        this._backgroundAnalysisProgram.setImportResolver(importResolver);\n\n        this._updateLibraryFileWatcher();\n        this._updateConfigFileWatcher();\n        this._updateSourceFileWatchers();\n        this._updateTrackedFileList(true);\n\n        if (reanalyze) {\n            this._scheduleReanalysis(false);\n        }\n    }\n\n    private _clearReanalysisTimer() {\n        if (this._analyzeTimer) {\n            clearTimeout(this._analyzeTimer);\n            this._analyzeTimer = undefined;\n        }\n    }\n\n    private _scheduleReanalysis(requireTrackedFileUpdate: boolean) {\n        if (this._disposed) {\n            // already disposed\n            return;\n        }\n\n        if (requireTrackedFileUpdate) {\n            this._requireTrackedFileUpdate = true;\n        }\n\n        this._backgroundAnalysisCancellationSource?.cancel();\n\n        // Remove any existing analysis timer.\n        this._clearReanalysisTimer();\n\n        // How long has it been since the user interacted with the service?\n        // If the user is actively typing, back off to let him or her finish.\n        const timeSinceLastUserInteractionInMs = Date.now() - this._lastUserInteractionTime;\n        const minBackoffTimeInMs = _userActivityBackoffTimeInMs;\n\n        // We choose a small non-zero value here. If this value\n        // is too small (like zero), the VS Code extension becomes\n        // unresponsive during heavy analysis. If this number is too\n        // large, analysis takes longer.\n        const minTimeBetweenAnalysisPassesInMs = 20;\n\n        const timeUntilNextAnalysisInMs = Math.max(\n            minBackoffTimeInMs - timeSinceLastUserInteractionInMs,\n            minTimeBetweenAnalysisPassesInMs\n        );\n\n        // Schedule a new timer.\n        this._analyzeTimer = setTimeout(() => {\n            this._analyzeTimer = undefined;\n\n            if (this._requireTrackedFileUpdate) {\n                this._updateTrackedFileList(false);\n            }\n\n            // This creates a cancellation source only if it actually gets used.\n            this._backgroundAnalysisCancellationSource = createBackgroundThreadCancellationTokenSource();\n            const moreToAnalyze = this._backgroundAnalysisProgram.startAnalysis(\n                this._backgroundAnalysisCancellationSource.token\n            );\n            if (moreToAnalyze) {\n                this._scheduleReanalysis(false);\n            }\n        }, timeUntilNextAnalysisInMs);\n    }\n\n    private _reportConfigParseError() {\n        if (this._onCompletionCallback) {\n            this._onCompletionCallback({\n                diagnostics: [],\n                filesInProgram: 0,\n                filesRequiringAnalysis: 0,\n                checkingOnlyOpenFiles: true,\n                fatalErrorOccurred: false,\n                configParseErrorOccurred: true,\n                elapsedTime: 0,\n            });\n        }\n    }\n}\n","/*\n * sourceFile.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Class that represents a single python source file.\n */\n\nimport {\n    CancellationToken,\n    CompletionItem,\n    DocumentHighlight,\n    DocumentSymbol,\n    SymbolInformation,\n} from 'vscode-languageserver';\nimport { isMainThread } from 'worker_threads';\n\nimport * as SymbolNameUtils from '../analyzer/symbolNameUtils';\nimport { OperationCanceledException } from '../common/cancellationUtils';\nimport { ConfigOptions, ExecutionEnvironment, getBasicDiagnosticRuleSet } from '../common/configOptions';\nimport { ConsoleInterface, StandardConsole } from '../common/console';\nimport { assert } from '../common/debug';\nimport { convertLevelToCategory, Diagnostic, DiagnosticCategory } from '../common/diagnostic';\nimport { DiagnosticSink, TextRangeDiagnosticSink } from '../common/diagnosticSink';\nimport { TextEditAction } from '../common/editAction';\nimport { FileSystem } from '../common/fileSystem';\nimport { LogTracker } from '../common/logTracker';\nimport { getFileName, normalizeSlashes, stripFileExtension } from '../common/pathUtils';\nimport * as StringUtils from '../common/stringUtils';\nimport { DocumentRange, getEmptyRange, Position, TextRange } from '../common/textRange';\nimport { TextRangeCollection } from '../common/textRangeCollection';\nimport { timingStats } from '../common/timing';\nimport { ModuleSymbolMap } from '../languageService/autoImporter';\nimport { CompletionResults } from '../languageService/completionProvider';\nimport { CompletionItemData, CompletionProvider } from '../languageService/completionProvider';\nimport { DefinitionProvider } from '../languageService/definitionProvider';\nimport { DocumentHighlightProvider } from '../languageService/documentHighlightProvider';\nimport { DocumentSymbolProvider, IndexResults } from '../languageService/documentSymbolProvider';\nimport { HoverProvider, HoverResults } from '../languageService/hoverProvider';\nimport { performQuickAction } from '../languageService/quickActions';\nimport { ReferencesProvider, ReferencesResult } from '../languageService/referencesProvider';\nimport { SignatureHelpProvider, SignatureHelpResults } from '../languageService/signatureHelpProvider';\nimport { Localizer } from '../localization/localize';\nimport { ModuleNode } from '../parser/parseNodes';\nimport { ModuleImport, ParseOptions, Parser, ParseResults } from '../parser/parser';\nimport { Token } from '../parser/tokenizerTypes';\nimport { AnalyzerFileInfo, ImportLookup } from './analyzerFileInfo';\nimport * as AnalyzerNodeInfo from './analyzerNodeInfo';\nimport { Binder, BinderResults } from './binder';\nimport { Checker } from './checker';\nimport { CircularDependency } from './circularDependency';\nimport * as CommentUtils from './commentUtils';\nimport { ImportResolver } from './importResolver';\nimport { ImportResult } from './importResult';\nimport { ParseTreeCleanerWalker } from './parseTreeCleaner';\nimport { Scope } from './scope';\nimport { SourceMapper } from './sourceMapper';\nimport { SymbolTable } from './symbol';\nimport { TestWalker } from './testWalker';\nimport { TypeEvaluator } from './typeEvaluator';\n\nconst _maxImportCyclesPerFile = 4;\n\nexport class SourceFile {\n    // Console interface to use for debugging.\n    private _console: ConsoleInterface;\n\n    // File path on disk.\n    private readonly _filePath: string;\n\n    // Period-delimited import path for the module.\n    private readonly _moduleName: string;\n\n    // True if file is a type-hint (.pyi) file versus a python\n    // (.py) file.\n    private readonly _isStubFile: boolean;\n\n    // True if the file was imported as a third-party import.\n    private readonly _isThirdPartyImport: boolean;\n\n    // True if the file is the \"typing.pyi\" file, which needs\n    // special-case handling.\n    private readonly _isTypingStubFile: boolean;\n\n    // True if the file is the \"typing_extensions.pyi\" file, which needs\n    // special-case handling.\n    private readonly _isTypingExtensionsStubFile: boolean;\n\n    // True if the file one of the other built-in stub files\n    // that require special-case handling: \"collections.pyi\",\n    // \"dataclasses.pyi\", \"abc.pyi\", \"asyncio/coroutines.pyi\".\n    private readonly _isBuiltInStubFile: boolean;\n\n    // True if the file is part of a package that contains a\n    // \"py.typed\" file.\n    private readonly _isThirdPartyPyTypedPresent: boolean;\n\n    // True if the file appears to have been deleted.\n    private _isFileDeleted = false;\n\n    // Number that is incremented every time the diagnostics\n    // are updated.\n    private _diagnosticVersion = 0;\n\n    // Generation count of the file contents. When the contents\n    // change, this is incremented.\n    private _fileContentsVersion = 0;\n\n    // Length and hash of the file the last time it was read from disk.\n    private _lastFileContentLength: number | undefined = undefined;\n    private _lastFileContentHash: number | undefined = undefined;\n\n    // Client's version of the file. Null implies that contents\n    // need to be read from disk.\n    private _clientVersion: number | null = null;\n\n    // In-memory contents if sent from the language client. If\n    // clientVersion is null, we'll ignore this and read the\n    // contents from disk.\n    private _fileContents: string | undefined;\n\n    // Version of file contents that have been analyzed.\n    private _analyzedFileContentsVersion = -1;\n\n    // Do we need to walk the parse tree and clean\n    // the binder information hanging from it?\n    private _parseTreeNeedsCleaning = false;\n\n    private _parseResults?: ParseResults;\n    private _moduleSymbolTable?: SymbolTable;\n    private _binderResults?: BinderResults;\n    private _cachedIndexResults?: IndexResults;\n\n    // Reentrancy check for binding.\n    private _isBindingInProgress = false;\n\n    // Diagnostics generated during different phases of analysis.\n    private _parseDiagnostics: Diagnostic[] = [];\n    private _bindDiagnostics: Diagnostic[] = [];\n    private _checkerDiagnostics: Diagnostic[] = [];\n\n    // Settings that control which diagnostics should be output.\n    private _diagnosticRuleSet = getBasicDiagnosticRuleSet();\n\n    // Circular dependencies that have been reported in this file.\n    private _circularDependencies: CircularDependency[] = [];\n\n    // Did we hit the maximum import depth?\n    private _hitMaxImportDepth?: number;\n\n    // Do we need to perform a binding step?\n    private _isBindingNeeded = true;\n\n    // Do we have valid diagnostic results from a checking pass?\n    private _isCheckingNeeded = true;\n\n    // Do we need to perform an indexing step?\n    private _indexingNeeded = true;\n\n    // Information about implicit and explicit imports from this file.\n    private _imports?: ImportResult[];\n    private _builtinsImport?: ImportResult;\n    private _typingModulePath?: string;\n    private _collectionsModulePath?: string;\n\n    private _logTracker: LogTracker;\n    readonly fileSystem: FileSystem;\n\n    constructor(\n        fs: FileSystem,\n        filePath: string,\n        moduleName: string,\n        isThirdPartyImport: boolean,\n        isThirdPartyPyTypedPresent: boolean,\n        console?: ConsoleInterface,\n        logTracker?: LogTracker\n    ) {\n        this.fileSystem = fs;\n        this._console = console || new StandardConsole();\n        this._filePath = filePath;\n        this._moduleName = moduleName;\n        this._isStubFile = filePath.endsWith('.pyi');\n        this._isThirdPartyImport = isThirdPartyImport;\n        this._isThirdPartyPyTypedPresent = isThirdPartyPyTypedPresent;\n        const fileName = getFileName(filePath);\n        this._isTypingStubFile =\n            this._isStubFile && (fileName === 'typing.pyi' || fileName === 'typing_extensions.pyi');\n        this._isTypingExtensionsStubFile = this._isStubFile && fileName === 'typing_extensions.pyi';\n\n        this._isBuiltInStubFile = false;\n        if (this._isStubFile) {\n            if (\n                this._filePath.endsWith(normalizeSlashes('/collections/__init__.pyi')) ||\n                this._filePath.endsWith(normalizeSlashes('/asyncio/futures.pyi')) ||\n                fileName === 'builtins.pyi' ||\n                fileName === '_importlib_modulespec.pyi' ||\n                fileName === 'dataclasses.pyi' ||\n                fileName === 'abc.pyi' ||\n                fileName === 'enum.pyi' ||\n                fileName === 'queue.pyi' ||\n                fileName === 'types.pyi'\n            ) {\n                this._isBuiltInStubFile = true;\n            }\n        }\n\n        // 'FG' or 'BG' based on current thread.\n        this._logTracker = logTracker ?? new LogTracker(console, isMainThread ? 'FG' : 'BG');\n    }\n\n    getFilePath(): string {\n        return this._filePath;\n    }\n\n    getDiagnosticVersion(): number {\n        return this._diagnosticVersion;\n    }\n\n    isStubFile() {\n        return this._isStubFile;\n    }\n\n    // Returns a list of cached diagnostics from the latest analysis job.\n    // If the prevVersion is specified, the method returns undefined if\n    // the diagnostics haven't changed.\n    getDiagnostics(options: ConfigOptions, prevDiagnosticVersion?: number): Diagnostic[] | undefined {\n        if (this._diagnosticVersion === prevDiagnosticVersion) {\n            return undefined;\n        }\n\n        let includeWarningsAndErrors = true;\n\n        // If a file was imported as a third-party file, don't report\n        // any errors for it. The user can't fix them anyway.\n        if (this._isThirdPartyImport) {\n            includeWarningsAndErrors = false;\n        }\n\n        let diagList: Diagnostic[] = [];\n        diagList = diagList.concat(this._parseDiagnostics, this._bindDiagnostics, this._checkerDiagnostics);\n\n        // Filter the diagnostics based on \"type: ignore\" lines.\n        if (options.diagnosticRuleSet.enableTypeIgnoreComments) {\n            const typeIgnoreLines = this._parseResults ? this._parseResults.tokenizerOutput.typeIgnoreLines : {};\n            if (Object.keys(typeIgnoreLines).length > 0) {\n                diagList = diagList.filter((d) => {\n                    if (d.category !== DiagnosticCategory.UnusedCode) {\n                        for (let line = d.range.start.line; line <= d.range.end.line; line++) {\n                            if (typeIgnoreLines[line]) {\n                                return false;\n                            }\n                        }\n                    }\n\n                    return true;\n                });\n            }\n        }\n\n        if (options.diagnosticRuleSet.reportImportCycles !== 'none' && this._circularDependencies.length > 0) {\n            const category = convertLevelToCategory(options.diagnosticRuleSet.reportImportCycles);\n\n            this._circularDependencies.forEach((cirDep) => {\n                diagList.push(\n                    new Diagnostic(\n                        category,\n                        Localizer.Diagnostic.importCycleDetected() +\n                            '\\n' +\n                            cirDep\n                                .getPaths()\n                                .map((path) => '  ' + path)\n                                .join('\\n'),\n                        getEmptyRange()\n                    )\n                );\n            });\n        }\n\n        if (this._hitMaxImportDepth !== undefined) {\n            diagList.push(\n                new Diagnostic(\n                    DiagnosticCategory.Error,\n                    Localizer.Diagnostic.importDepthExceeded().format({ depth: this._hitMaxImportDepth }),\n                    getEmptyRange()\n                )\n            );\n        }\n\n        // If the file is in the ignore list, clear the diagnostic list.\n        if (options.ignore.find((ignoreFileSpec) => ignoreFileSpec.regExp.test(this._filePath))) {\n            diagList = [];\n        }\n\n        // If there is a \"type: ignore\" comment at the top of the file, clear\n        // the diagnostic list.\n        if (options.diagnosticRuleSet.enableTypeIgnoreComments) {\n            if (this._parseResults && this._parseResults.tokenizerOutput.typeIgnoreAll) {\n                diagList = [];\n            }\n        }\n\n        // If we're not returning any diagnostics, filter out all of\n        // the errors and warnings, leaving only the unreachable code\n        // diagnostics.\n        if (!includeWarningsAndErrors) {\n            diagList = diagList.filter((diag) => diag.category === DiagnosticCategory.UnusedCode);\n        }\n\n        return diagList;\n    }\n\n    getImports(): ImportResult[] {\n        return this._imports || [];\n    }\n\n    getBuiltinsImport(): ImportResult | undefined {\n        return this._builtinsImport;\n    }\n\n    getModuleSymbolTable(): SymbolTable | undefined {\n        return this._moduleSymbolTable;\n    }\n\n    getModuleDocString(): string | undefined {\n        return this._binderResults ? this._binderResults.moduleDocString : undefined;\n    }\n\n    // Indicates whether the contents of the file have changed since\n    // the last analysis was performed.\n    didContentsChangeOnDisk(): boolean {\n        // If this is an open file any content changes will be\n        // provided through the editor. We can assume contents\n        // didn't change without us knowing about them.\n        if (this._clientVersion !== null) {\n            return false;\n        }\n\n        // If the file was never read previously, no need to check for a change.\n        if (this._lastFileContentLength === undefined) {\n            return false;\n        }\n\n        // Read in the latest file contents and see if the hash matches\n        // that of the previous contents.\n        try {\n            // Read the file's contents.\n            const fileContents = this.fileSystem.readFileSync(this._filePath, 'utf8');\n\n            if (fileContents.length !== this._lastFileContentLength) {\n                return true;\n            }\n\n            if (StringUtils.hashString(fileContents) !== this._lastFileContentHash) {\n                return true;\n            }\n        } catch (error) {\n            return true;\n        }\n\n        return false;\n    }\n\n    // Drop parse and binding info to save memory. It is used\n    // in cases where memory is low. When info is needed, the file\n    // will be re-parsed and rebound.\n    dropParseAndBindInfo(): void {\n        this._parseResults = undefined;\n        this._moduleSymbolTable = undefined;\n        this._isBindingNeeded = true;\n        this._binderResults = undefined;\n    }\n\n    markDirty(): void {\n        this._fileContentsVersion++;\n        this._isCheckingNeeded = true;\n        this._isBindingNeeded = true;\n        this._indexingNeeded = true;\n        this._moduleSymbolTable = undefined;\n        this._binderResults = undefined;\n        this._cachedIndexResults = undefined;\n    }\n\n    markReanalysisRequired(): void {\n        // Keep the parse info, but reset the analysis to the beginning.\n        this._isCheckingNeeded = true;\n\n        // If the file contains a wildcard import, we need to rebind\n        // also because the dependent import may have changed.\n        if (this._parseResults && this._parseResults.containsWildcardImport) {\n            this._parseTreeNeedsCleaning = true;\n            this._isBindingNeeded = true;\n            this._indexingNeeded = true;\n            this._moduleSymbolTable = undefined;\n            this._binderResults = undefined;\n            this._cachedIndexResults = undefined;\n        }\n    }\n\n    getClientVersion() {\n        return this._clientVersion;\n    }\n\n    getFileContents() {\n        return this._fileContents;\n    }\n\n    setClientVersion(version: number | null, contents: string): void {\n        this._clientVersion = version;\n\n        if (version === null) {\n            this._fileContents = undefined;\n        } else {\n            if (this._fileContents !== undefined) {\n                if (this._fileContents !== contents) {\n                    this.markDirty();\n                }\n            }\n\n            this._fileContents = contents;\n        }\n    }\n\n    prepareForClose() {\n        // Nothing to do currently.\n    }\n\n    isFileDeleted() {\n        return this._isFileDeleted;\n    }\n\n    isParseRequired() {\n        return !this._parseResults || this._analyzedFileContentsVersion !== this._fileContentsVersion;\n    }\n\n    isBindingRequired() {\n        if (this._isBindingInProgress) {\n            return false;\n        }\n\n        if (this.isParseRequired()) {\n            return true;\n        }\n\n        return this._isBindingNeeded;\n    }\n\n    isIndexingRequired() {\n        return this._indexingNeeded;\n    }\n\n    isCheckingRequired() {\n        return this._isCheckingNeeded;\n    }\n\n    getParseResults(): ParseResults | undefined {\n        if (!this.isParseRequired()) {\n            return this._parseResults;\n        }\n\n        return undefined;\n    }\n\n    getCachedIndexResults(): IndexResults | undefined {\n        return this._cachedIndexResults;\n    }\n\n    cacheIndexResults(indexResults: IndexResults) {\n        this._cachedIndexResults = indexResults;\n    }\n\n    // Adds a new circular dependency for this file but only if\n    // it hasn't already been added.\n    addCircularDependency(circDependency: CircularDependency) {\n        let updatedDependencyList = false;\n\n        // Some topologies can result in a massive number of cycles. We'll cut it off.\n        if (this._circularDependencies.length < _maxImportCyclesPerFile) {\n            if (!this._circularDependencies.some((dep) => dep.isEqual(circDependency))) {\n                this._circularDependencies.push(circDependency);\n                updatedDependencyList = true;\n            }\n        }\n\n        if (updatedDependencyList) {\n            this._diagnosticVersion++;\n        }\n    }\n\n    setHitMaxImportDepth(maxImportDepth: number) {\n        this._hitMaxImportDepth = maxImportDepth;\n    }\n\n    // Parse the file and update the state. Callers should wait for completion\n    // (or at least cancel) prior to calling again. It returns true if a parse\n    // was required and false if the parse information was up to date already.\n    parse(configOptions: ConfigOptions, importResolver: ImportResolver): boolean {\n        return this._logTracker.log(`parsing: ${this._filePath}`, (logState) => {\n            // If the file is already parsed, we can skip.\n            if (!this.isParseRequired()) {\n                logState.suppress();\n                return false;\n            }\n\n            const diagSink = new DiagnosticSink();\n            let fileContents = this._fileContents;\n            if (this._clientVersion === null) {\n                try {\n                    timingStats.readFileTime.timeOperation(() => {\n                        // Read the file's contents.\n                        fileContents = this.fileSystem.readFileSync(this._filePath, 'utf8');\n\n                        // Remember the length and hash for comparison purposes.\n                        this._lastFileContentLength = fileContents.length;\n                        this._lastFileContentHash = StringUtils.hashString(fileContents);\n                    });\n                } catch (error) {\n                    diagSink.addError(`Source file could not be read`, getEmptyRange());\n                    fileContents = '';\n\n                    if (!this.fileSystem.existsSync(this._filePath)) {\n                        this._isFileDeleted = true;\n                    }\n                }\n            }\n\n            // Use the configuration options to determine the environment in which\n            // this source file will be executed.\n            const execEnvironment = configOptions.findExecEnvironment(this._filePath);\n\n            const parseOptions = new ParseOptions();\n            if (this._filePath.endsWith('pyi')) {\n                parseOptions.isStubFile = true;\n            }\n            parseOptions.pythonVersion = execEnvironment.pythonVersion;\n\n            try {\n                // Parse the token stream, building the abstract syntax tree.\n                const parser = new Parser();\n                const parseResults = parser.parseSourceFile(fileContents!, parseOptions, diagSink);\n                assert(parseResults !== undefined && parseResults.tokenizerOutput !== undefined);\n                this._parseResults = parseResults;\n\n                // Resolve imports.\n                timingStats.resolveImportsTime.timeOperation(() => {\n                    [\n                        this._imports,\n                        this._builtinsImport,\n                        this._typingModulePath,\n                        this._collectionsModulePath,\n                    ] = this._resolveImports(importResolver, parseResults.importedModules, execEnvironment);\n                    this._parseDiagnostics = diagSink.fetchAndClear();\n                });\n\n                // Is this file in a \"strict\" path?\n                const useStrict =\n                    configOptions.strict.find((strictFileSpec) => strictFileSpec.regExp.test(this._filePath)) !==\n                    undefined;\n\n                this._diagnosticRuleSet = CommentUtils.getFileLevelDirectives(\n                    this._parseResults.tokenizerOutput.tokens,\n                    configOptions.diagnosticRuleSet,\n                    useStrict\n                );\n            } catch (e) {\n                const message: string =\n                    (e.stack ? e.stack.toString() : undefined) ||\n                    (typeof e.message === 'string' ? e.message : undefined) ||\n                    JSON.stringify(e);\n                this._console.error(\n                    Localizer.Diagnostic.internalParseError().format({ file: this.getFilePath(), message })\n                );\n\n                // Create dummy parse results.\n                this._parseResults = {\n                    text: '',\n                    parseTree: ModuleNode.create({ start: 0, length: 0 }),\n                    importedModules: [],\n                    futureImports: new Map<string, boolean>(),\n                    tokenizerOutput: {\n                        tokens: new TextRangeCollection<Token>([]),\n                        lines: new TextRangeCollection<TextRange>([]),\n                        typeIgnoreAll: false,\n                        typeIgnoreLines: {},\n                        predominantEndOfLineSequence: '\\n',\n                        predominantTabSequence: '    ',\n                        predominantSingleQuoteCharacter: \"'\",\n                    },\n                    containsWildcardImport: false,\n                };\n                this._imports = undefined;\n                this._builtinsImport = undefined;\n\n                const diagSink = new DiagnosticSink();\n                diagSink.addError(\n                    Localizer.Diagnostic.internalParseError().format({ file: this.getFilePath(), message }),\n                    getEmptyRange()\n                );\n                this._parseDiagnostics = diagSink.fetchAndClear();\n\n                // Do not rethrow the exception, swallow it here. Callers are not\n                // prepared to handle an exception.\n            }\n\n            this._analyzedFileContentsVersion = this._fileContentsVersion;\n            this._indexingNeeded = true;\n            this._isBindingNeeded = true;\n            this._isCheckingNeeded = true;\n            this._parseTreeNeedsCleaning = false;\n            this._hitMaxImportDepth = undefined;\n            this._diagnosticVersion++;\n\n            return true;\n        });\n    }\n\n    index(importSymbolsOnly: boolean, token: CancellationToken): IndexResults | undefined {\n        // If we have no completed analysis job, there's nothing to do.\n        if (!this._parseResults || !this.isIndexingRequired()) {\n            return undefined;\n        }\n\n        this._indexingNeeded = false;\n        const symbols = DocumentSymbolProvider.indexSymbols(this._parseResults, importSymbolsOnly, token);\n\n        const name = stripFileExtension(getFileName(this._filePath));\n        const privateOrProtected = SymbolNameUtils.isPrivateOrProtectedName(name);\n        return { privateOrProtected, symbols };\n    }\n\n    getDefinitionsForPosition(\n        sourceMapper: SourceMapper,\n        position: Position,\n        evaluator: TypeEvaluator,\n        token: CancellationToken\n    ): DocumentRange[] | undefined {\n        // If we have no completed analysis job, there's nothing to do.\n        if (!this._parseResults) {\n            return undefined;\n        }\n\n        return DefinitionProvider.getDefinitionsForPosition(\n            sourceMapper,\n            this._parseResults,\n            position,\n            evaluator,\n            token\n        );\n    }\n\n    getDeclarationForPosition(\n        sourceMapper: SourceMapper,\n        position: Position,\n        evaluator: TypeEvaluator,\n        token: CancellationToken\n    ): ReferencesResult | undefined {\n        // If we have no completed analysis job, there's nothing to do.\n        if (!this._parseResults) {\n            return undefined;\n        }\n\n        return ReferencesProvider.getDeclarationForPosition(\n            sourceMapper,\n            this._parseResults,\n            this._filePath,\n            position,\n            evaluator,\n            token\n        );\n    }\n\n    addReferences(\n        referencesResult: ReferencesResult,\n        includeDeclaration: boolean,\n        evaluator: TypeEvaluator,\n        token: CancellationToken\n    ): void {\n        // If we have no completed analysis job, there's nothing to do.\n        if (!this._parseResults) {\n            return;\n        }\n\n        ReferencesProvider.addReferences(\n            this._parseResults,\n            this._filePath,\n            referencesResult,\n            includeDeclaration,\n            evaluator,\n            token\n        );\n    }\n\n    addHierarchicalSymbolsForDocument(symbolList: DocumentSymbol[], token: CancellationToken) {\n        // If we have no completed analysis job, there's nothing to do.\n        if (!this._parseResults && !this._cachedIndexResults) {\n            return;\n        }\n\n        DocumentSymbolProvider.addHierarchicalSymbolsForDocument(\n            this.getCachedIndexResults(),\n            this._parseResults,\n            symbolList,\n            token\n        );\n    }\n\n    addSymbolsForDocument(symbolList: SymbolInformation[], query: string, token: CancellationToken) {\n        // If we have no completed analysis job, there's nothing to do.\n        if (!this._parseResults && !this._cachedIndexResults) {\n            return;\n        }\n\n        DocumentSymbolProvider.addSymbolsForDocument(\n            this.getCachedIndexResults(),\n            this._parseResults,\n            this._filePath,\n            query,\n            symbolList,\n            token\n        );\n    }\n\n    getHoverForPosition(\n        sourceMapper: SourceMapper,\n        position: Position,\n        evaluator: TypeEvaluator,\n        token: CancellationToken\n    ): HoverResults | undefined {\n        // If this file hasn't been bound, no hover info is available.\n        if (this._isBindingNeeded || !this._parseResults) {\n            return undefined;\n        }\n\n        return HoverProvider.getHoverForPosition(sourceMapper, this._parseResults, position, evaluator, token);\n    }\n\n    getDocumentHighlight(\n        sourceMapper: SourceMapper,\n        position: Position,\n        evaluator: TypeEvaluator,\n        token: CancellationToken\n    ): DocumentHighlight[] | undefined {\n        // If this file hasn't been bound, no hover info is available.\n        if (this._isBindingNeeded || !this._parseResults) {\n            return undefined;\n        }\n\n        return DocumentHighlightProvider.getDocumentHighlight(this._parseResults, position, evaluator, token);\n    }\n\n    getSignatureHelpForPosition(\n        position: Position,\n        importLookup: ImportLookup,\n        evaluator: TypeEvaluator,\n        token: CancellationToken\n    ): SignatureHelpResults | undefined {\n        // If we have no completed analysis job, there's nothing to do.\n        if (!this._parseResults) {\n            return undefined;\n        }\n\n        return SignatureHelpProvider.getSignatureHelpForPosition(this._parseResults, position, evaluator, token);\n    }\n\n    getCompletionsForPosition(\n        position: Position,\n        workspacePath: string,\n        configOptions: ConfigOptions,\n        importResolver: ImportResolver,\n        importLookup: ImportLookup,\n        evaluator: TypeEvaluator,\n        sourceMapper: SourceMapper,\n        libraryMap: Map<string, IndexResults> | undefined,\n        moduleSymbolsCallback: () => ModuleSymbolMap,\n        token: CancellationToken\n    ): CompletionResults | undefined {\n        // If we have no completed analysis job, there's nothing to do.\n        if (!this._parseResults) {\n            return undefined;\n        }\n\n        // This command should be called only for open files, in which\n        // case we should have the file contents already loaded.\n        if (this._fileContents === undefined) {\n            return undefined;\n        }\n\n        const completionProvider = new CompletionProvider(\n            workspacePath,\n            this._parseResults,\n            this._fileContents,\n            importResolver,\n            position,\n            this._filePath,\n            configOptions,\n            importLookup,\n            evaluator,\n            sourceMapper,\n            libraryMap,\n            moduleSymbolsCallback,\n            token\n        );\n\n        return completionProvider.getCompletionsForPosition();\n    }\n\n    resolveCompletionItem(\n        configOptions: ConfigOptions,\n        importResolver: ImportResolver,\n        importLookup: ImportLookup,\n        evaluator: TypeEvaluator,\n        sourceMapper: SourceMapper,\n        libraryMap: Map<string, IndexResults> | undefined,\n        moduleSymbolsCallback: () => ModuleSymbolMap,\n        completionItem: CompletionItem,\n        token: CancellationToken\n    ) {\n        if (!this._parseResults || this._fileContents === undefined) {\n            return;\n        }\n\n        const completionData = completionItem.data as CompletionItemData;\n        const completionProvider = new CompletionProvider(\n            completionData.workspacePath,\n            this._parseResults,\n            this._fileContents,\n            importResolver,\n            completionData.position,\n            this._filePath,\n            configOptions,\n            importLookup,\n            evaluator,\n            sourceMapper,\n            libraryMap,\n            moduleSymbolsCallback,\n            token\n        );\n\n        completionProvider.resolveCompletionItem(completionItem);\n    }\n\n    performQuickAction(command: string, args: any[], token: CancellationToken): TextEditAction[] | undefined {\n        // If we have no completed analysis job, there's nothing to do.\n        if (!this._parseResults) {\n            return undefined;\n        }\n\n        // This command should be called only for open files, in which\n        // case we should have the file contents already loaded.\n        if (this._fileContents === undefined) {\n            return undefined;\n        }\n\n        return performQuickAction(command, args, this._parseResults, token);\n    }\n\n    bind(configOptions: ConfigOptions, importLookup: ImportLookup, builtinsScope: Scope | undefined) {\n        assert(!this.isParseRequired());\n        assert(this.isBindingRequired());\n        assert(!this._isBindingInProgress);\n        assert(this._parseResults !== undefined);\n\n        return this._logTracker.log(`binding: ${this._filePath}`, () => {\n            try {\n                // Perform name binding.\n                timingStats.bindTime.timeOperation(() => {\n                    this._cleanParseTreeIfRequired();\n\n                    const fileInfo = this._buildFileInfo(\n                        configOptions,\n                        this._parseResults!.text,\n                        importLookup,\n                        builtinsScope\n                    );\n                    AnalyzerNodeInfo.setFileInfo(this._parseResults!.parseTree, fileInfo);\n\n                    const binder = new Binder(fileInfo);\n                    this._isBindingInProgress = true;\n                    this._binderResults = binder.bindModule(this._parseResults!.parseTree);\n\n                    // If we're in \"test mode\" (used for unit testing), run an additional\n                    // \"test walker\" over the parse tree to validate its internal consistency.\n                    if (configOptions.internalTestMode) {\n                        const testWalker = new TestWalker();\n                        testWalker.walk(this._parseResults!.parseTree);\n                    }\n\n                    this._bindDiagnostics = fileInfo.diagnosticSink.fetchAndClear();\n                    const moduleScope = AnalyzerNodeInfo.getScope(this._parseResults!.parseTree);\n                    assert(moduleScope !== undefined);\n                    this._moduleSymbolTable = moduleScope!.symbolTable;\n                });\n            } catch (e) {\n                const message: string =\n                    (e.stack ? e.stack.toString() : undefined) ||\n                    (typeof e.message === 'string' ? e.message : undefined) ||\n                    JSON.stringify(e);\n                this._console.error(\n                    Localizer.Diagnostic.internalBindError().format({ file: this.getFilePath(), message })\n                );\n\n                const diagSink = new DiagnosticSink();\n                diagSink.addError(\n                    Localizer.Diagnostic.internalBindError().format({ file: this.getFilePath(), message }),\n                    getEmptyRange()\n                );\n                this._bindDiagnostics = diagSink.fetchAndClear();\n\n                // Do not rethrow the exception, swallow it here. Callers are not\n                // prepared to handle an exception.\n            } finally {\n                this._isBindingInProgress = false;\n            }\n\n            // Prepare for the next stage of the analysis.\n            this._diagnosticVersion++;\n            this._isCheckingNeeded = true;\n            this._indexingNeeded = true;\n            this._isBindingNeeded = false;\n        });\n    }\n\n    check(evaluator: TypeEvaluator) {\n        assert(!this.isParseRequired());\n        assert(!this.isBindingRequired());\n        assert(!this._isBindingInProgress);\n        assert(this.isCheckingRequired());\n        assert(this._parseResults !== undefined);\n\n        return this._logTracker.log(`checking: ${this._filePath}`, () => {\n            try {\n                timingStats.typeCheckerTime.timeOperation(() => {\n                    const checker = new Checker(this._parseResults!.parseTree, evaluator);\n                    checker.check();\n                    this._isCheckingNeeded = false;\n\n                    const fileInfo = AnalyzerNodeInfo.getFileInfo(this._parseResults!.parseTree)!;\n                    this._checkerDiagnostics = fileInfo.diagnosticSink.fetchAndClear();\n                });\n            } catch (e) {\n                const isCancellation = OperationCanceledException.is(e);\n                if (!isCancellation) {\n                    const message: string =\n                        (e.stack ? e.stack.toString() : undefined) ||\n                        (typeof e.message === 'string' ? e.message : undefined) ||\n                        JSON.stringify(e);\n                    this._console.error(\n                        Localizer.Diagnostic.internalTypeCheckingError().format({ file: this.getFilePath(), message })\n                    );\n                    const diagSink = new DiagnosticSink();\n                    diagSink.addError(\n                        Localizer.Diagnostic.internalTypeCheckingError().format({ file: this.getFilePath(), message }),\n                        getEmptyRange()\n                    );\n\n                    this._checkerDiagnostics = diagSink.fetchAndClear();\n\n                    // Mark the file as complete so we don't get into an infinite loop.\n                    this._isCheckingNeeded = false;\n                }\n\n                throw e;\n            } finally {\n                // Clear any circular dependencies associated with this file.\n                // These will be detected by the program module and associated\n                // with the source file right before it is finalized.\n                this._circularDependencies = [];\n                this._diagnosticVersion++;\n            }\n        });\n    }\n\n    private _buildFileInfo(\n        configOptions: ConfigOptions,\n        fileContents: string,\n        importLookup: ImportLookup,\n        builtinsScope?: Scope\n    ) {\n        assert(this._parseResults !== undefined);\n        const analysisDiagnostics = new TextRangeDiagnosticSink(this._parseResults!.tokenizerOutput.lines);\n\n        const fileInfo: AnalyzerFileInfo = {\n            importLookup,\n            futureImports: this._parseResults!.futureImports,\n            builtinsScope,\n            typingModulePath: this._typingModulePath,\n            collectionsModulePath: this._collectionsModulePath,\n            diagnosticSink: analysisDiagnostics,\n            executionEnvironment: configOptions.findExecEnvironment(this._filePath),\n            diagnosticRuleSet: this._diagnosticRuleSet,\n            fileContents,\n            lines: this._parseResults!.tokenizerOutput.lines,\n            filePath: this._filePath,\n            moduleName: this._moduleName,\n            isStubFile: this._isStubFile,\n            isTypingStubFile: this._isTypingStubFile,\n            isTypingExtensionsStubFile: this._isTypingExtensionsStubFile,\n            isBuiltInStubFile: this._isBuiltInStubFile,\n            isInPyTypedPackage: this._isThirdPartyPyTypedPresent,\n            accessedSymbolMap: new Map<number, true>(),\n        };\n        return fileInfo;\n    }\n\n    private _cleanParseTreeIfRequired() {\n        if (this._parseResults) {\n            if (this._parseTreeNeedsCleaning) {\n                const cleanerWalker = new ParseTreeCleanerWalker(this._parseResults.parseTree);\n                cleanerWalker.clean();\n                this._parseTreeNeedsCleaning = false;\n            }\n        }\n    }\n\n    private _resolveImports(\n        importResolver: ImportResolver,\n        moduleImports: ModuleImport[],\n        execEnv: ExecutionEnvironment\n    ): [ImportResult[], ImportResult?, string?, string?] {\n        const imports: ImportResult[] = [];\n\n        // Always include an implicit import of the builtins module.\n        let builtinsImportResult: ImportResult | undefined = importResolver.resolveImport(this._filePath, execEnv, {\n            leadingDots: 0,\n            nameParts: ['builtins'],\n            importedSymbols: undefined,\n        });\n\n        // Avoid importing builtins from the builtins.pyi file itself.\n        if (\n            builtinsImportResult.resolvedPaths.length === 0 ||\n            builtinsImportResult.resolvedPaths[0] !== this.getFilePath()\n        ) {\n            imports.push(builtinsImportResult);\n        } else {\n            builtinsImportResult = undefined;\n        }\n\n        // Always include an implicit import of the typing module.\n        const typingImportResult: ImportResult | undefined = importResolver.resolveImport(this._filePath, execEnv, {\n            leadingDots: 0,\n            nameParts: ['typing'],\n            importedSymbols: undefined,\n        });\n\n        // Avoid importing typing from the typing.pyi file itself.\n        let typingModulePath: string | undefined;\n        if (\n            typingImportResult.resolvedPaths.length === 0 ||\n            typingImportResult.resolvedPaths[0] !== this.getFilePath()\n        ) {\n            imports.push(typingImportResult);\n            typingModulePath = typingImportResult.resolvedPaths[0];\n        }\n\n        let collectionsModulePath: string | undefined;\n\n        for (const moduleImport of moduleImports) {\n            const importResult = importResolver.resolveImport(this._filePath, execEnv, {\n                leadingDots: moduleImport.leadingDots,\n                nameParts: moduleImport.nameParts,\n                importedSymbols: moduleImport.importedSymbols,\n            });\n\n            // If the file imports the stdlib 'collections' module, stash\n            // away its file path. The type analyzer may need this to\n            // access types defined in the collections module.\n            if (importResult.isImportFound && importResult.isTypeshedFile) {\n                if (moduleImport.nameParts.length >= 1 && moduleImport.nameParts[0] === 'collections') {\n                    collectionsModulePath = importResult.resolvedPaths[importResult.resolvedPaths.length - 1];\n                }\n            }\n\n            imports.push(importResult);\n\n            // Associate the import results with the module import\n            // name node in the parse tree so we can access it later\n            // (for hover and definition support).\n            AnalyzerNodeInfo.setImportInfo(moduleImport.nameNode, importResult);\n        }\n\n        return [imports, builtinsImportResult, typingModulePath, collectionsModulePath];\n    }\n}\n","/*\n * sourceMapper.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * Logic that maps a (.pyi) stub to its (.py) implementation source file.\n */\n\nimport * as AnalyzerNodeInfo from '../analyzer/analyzerNodeInfo';\nimport * as ParseTreeUtils from '../analyzer/parseTreeUtils';\nimport { ExecutionEnvironment } from '../common/configOptions';\nimport { getAnyExtensionFromPath } from '../common/pathUtils';\nimport { ClassNode, ModuleNode, ParseNode } from '../parser/parseNodes';\nimport { ClassDeclaration, Declaration, DeclarationType, FunctionDeclaration } from './declaration';\nimport { ImportResolver } from './importResolver';\nimport { SourceFile } from './sourceFile';\nimport { TypeEvaluator } from './typeEvaluator';\n\n// Creates and binds a shadowed file within the program.\nexport type ShadowFileBinder = (stubFilePath: string, implFilePath: string) => SourceFile | undefined;\n\nexport class SourceMapper {\n    constructor(\n        private _importResolver: ImportResolver,\n        private _execEnv: ExecutionEnvironment,\n        private _evaluator: TypeEvaluator,\n        private _fileBinder: ShadowFileBinder\n    ) {}\n\n    public findModules(stubFilePath: string): ModuleNode[] {\n        const sourceFiles = this._getBoundSourceFiles(stubFilePath);\n        return sourceFiles.map((sf) => sf.getParseResults()?.parseTree).filter(_isDefined);\n    }\n\n    public findDeclarations(stubDecl: Declaration): Declaration[] {\n        if (stubDecl.type === DeclarationType.Class) {\n            return this.findClassDeclarations(stubDecl);\n        } else if (stubDecl.type === DeclarationType.Function) {\n            return this.findFunctionDeclarations(stubDecl);\n        }\n\n        return [];\n    }\n\n    public findClassDeclarations(stubDecl: ClassDeclaration): ClassDeclaration[] {\n        const className = this._getFullClassName(stubDecl.node);\n\n        const sourceFiles = this._getBoundSourceFiles(stubDecl.path);\n        return sourceFiles.flatMap((sourceFile) => this._findClassDeclarations(sourceFile, className));\n    }\n\n    public findFunctionDeclarations(stubDecl: FunctionDeclaration): FunctionDeclaration[] {\n        const functionName = stubDecl.node.name.value;\n        const sourceFiles = this._getBoundSourceFiles(stubDecl.path);\n\n        if (stubDecl.isMethod) {\n            const classNode = ParseTreeUtils.getEnclosingClass(stubDecl.node);\n            if (classNode === undefined) {\n                return [];\n            }\n\n            const className = this._getFullClassName(classNode);\n\n            return sourceFiles.flatMap((sourceFile) =>\n                this._findMethodDeclarations(sourceFile, className, functionName)\n            );\n        } else {\n            return sourceFiles.flatMap((sourceFile) => this._findFunctionDeclarations(sourceFile, functionName));\n        }\n    }\n\n    private _findMethodDeclarations(\n        sourceFile: SourceFile,\n        className: string,\n        functionName: string\n    ): FunctionDeclaration[] {\n        const result: FunctionDeclaration[] = [];\n\n        const classDecls = this._findClassDeclarations(sourceFile, className);\n\n        for (const classDecl of classDecls) {\n            const methodDecls = this._lookUpSymbolDeclarations(classDecl.node, functionName);\n            for (const methodDecl of methodDecls) {\n                if (methodDecl.type === DeclarationType.Function && methodDecl.isMethod) {\n                    result.push(methodDecl);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    private _findFunctionDeclarations(sourceFile: SourceFile, functionName: string): FunctionDeclaration[] {\n        const result: FunctionDeclaration[] = [];\n\n        const functionDecls = this._lookUpSymbolDeclarations(sourceFile.getParseResults()?.parseTree, functionName);\n\n        for (const functionDecl of functionDecls) {\n            if (functionDecl.type === DeclarationType.Function) {\n                result.push(functionDecl);\n            } else if (functionDecl.type === DeclarationType.Alias) {\n                const resolvedDecl = this._evaluator.resolveAliasDeclaration(\n                    functionDecl,\n                    /* resolveLocalNames */ true\n                );\n                if (resolvedDecl) {\n                    if (resolvedDecl.type === DeclarationType.Function) {\n                        if (isStubFile(resolvedDecl.path)) {\n                            result.push(...this.findFunctionDeclarations(resolvedDecl));\n                        } else {\n                            result.push(resolvedDecl);\n                        }\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    private _findClassDeclarations(sourceFile: SourceFile, fullClassName: string): ClassDeclaration[] {\n        let result: ClassDeclaration[] = [];\n\n        // fullClassName is period delimited, for example: 'OuterClass.InnerClass'\n        const parentNode = sourceFile.getParseResults()?.parseTree;\n        if (parentNode) {\n            let classNameParts = fullClassName.split('.');\n            if (classNameParts.length > 0) {\n                result = this._findClassDeclarationsUnderNode(sourceFile, classNameParts[0], parentNode);\n                classNameParts = classNameParts.slice(1);\n            }\n\n            for (const classNamePart of classNameParts) {\n                result = this._findClassDeclarationsUnderClass(sourceFile, classNamePart, result);\n            }\n        }\n\n        return result;\n    }\n\n    private _findClassDeclarationsUnderClass(\n        sourceFile: SourceFile,\n        className: string,\n        parentClassDecls: ClassDeclaration[]\n    ): ClassDeclaration[] {\n        return parentClassDecls.flatMap((parentDecl) =>\n            this._findClassDeclarationsUnderNode(sourceFile, className, parentDecl.node)\n        );\n    }\n\n    private _findClassDeclarationsUnderNode(\n        sourceFile: SourceFile,\n        className: string,\n        parentNode: ParseNode\n    ): ClassDeclaration[] {\n        const result: ClassDeclaration[] = [];\n\n        for (const decl of this._lookUpSymbolDeclarations(parentNode, className)) {\n            if (decl.type === DeclarationType.Class) {\n                result.push(decl);\n            }\n        }\n\n        return result;\n    }\n\n    private _lookUpSymbolDeclarations(node: ParseNode | undefined, symbolName: string): Declaration[] {\n        if (node === undefined) {\n            return [];\n        }\n\n        const moduleScope = AnalyzerNodeInfo.getScope(node);\n        const symbol = moduleScope?.lookUpSymbol(symbolName);\n        const decls = symbol?.getDeclarations();\n\n        return decls ?? [];\n    }\n\n    private _getFullClassName(node: ClassNode) {\n        const fullName: string[] = [];\n\n        let current: ClassNode | undefined = node;\n        while (current !== undefined) {\n            fullName.push(current.name.value);\n            current = ParseTreeUtils.getEnclosingClass(current);\n        }\n\n        return fullName.reverse().join('.');\n    }\n\n    private _getBoundSourceFiles(stubFilePath: string): SourceFile[] {\n        const paths = this._importResolver.getSourceFilesFromStub(stubFilePath, this._execEnv);\n        return paths.map((fp) => this._fileBinder(stubFilePath, fp)).filter(_isDefined);\n    }\n}\n\nexport function isStubFile(filePath: string): boolean {\n    return getAnyExtensionFromPath(filePath, ['.pyi'], /* ignoreCase */ false) === '.pyi';\n}\n\nfunction _isDefined<T>(element: T | undefined): element is T {\n    return element !== undefined;\n}\n","/*\n * staticExpressions.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Collection of static methods that operate on expressions\n * (parse node trees).\n */\n\nimport { ExecutionEnvironment } from '../common/configOptions';\nimport { ExpressionNode, NumberNode, ParseNodeType, TupleNode } from '../parser/parseNodes';\nimport { KeywordType, OperatorType } from '../parser/tokenizerTypes';\n\n// Returns undefined if the expression cannot be evaluated\n// statically as a bool value or true/false if it can.\nexport function evaluateStaticBoolExpression(node: ExpressionNode, execEnv: ExecutionEnvironment): boolean | undefined {\n    if (node.nodeType === ParseNodeType.UnaryOperation) {\n        if (node.operator === OperatorType.Or || node.operator === OperatorType.And) {\n            const value = evaluateStaticBoolLikeExpression(node.expression, execEnv);\n            if (value !== undefined) {\n                return !value;\n            }\n        }\n    } else if (node.nodeType === ParseNodeType.BinaryOperation) {\n        // Is it an OR or AND expression?\n        if (node.operator === OperatorType.Or || node.operator === OperatorType.And) {\n            const leftValue = evaluateStaticBoolExpression(node.leftExpression, execEnv);\n            const rightValue = evaluateStaticBoolExpression(node.rightExpression, execEnv);\n\n            if (leftValue === undefined || rightValue === undefined) {\n                return undefined;\n            }\n\n            if (node.operator === OperatorType.Or) {\n                return leftValue || rightValue;\n            } else {\n                return leftValue && rightValue;\n            }\n        }\n\n        if (_isSysVersionInfoExpression(node.leftExpression) && node.rightExpression.nodeType === ParseNodeType.Tuple) {\n            // Handle the special case of \"sys.version_info >= (3, x)\"\n            const comparisonVersion = _convertTupleToVersion(node.rightExpression);\n            return _evaluateNumericBinaryOperation(node.operator, execEnv.pythonVersion, comparisonVersion);\n        } else if (\n            node.leftExpression.nodeType === ParseNodeType.Index &&\n            _isSysVersionInfoExpression(node.leftExpression.baseExpression) &&\n            node.leftExpression.items.items.length === 1 &&\n            node.leftExpression.items.items[0].nodeType === ParseNodeType.Number &&\n            !node.leftExpression.items.items[0].isImaginary &&\n            node.leftExpression.items.items[0].value === 0 &&\n            node.rightExpression.nodeType === ParseNodeType.Number\n        ) {\n            // Handle the special case of \"sys.version_info[0] >= X\"\n            return _evaluateNumericBinaryOperation(\n                node.operator,\n                Math.floor(execEnv.pythonVersion / 256),\n                node.rightExpression.value\n            );\n        } else if (\n            _isSysPlatformInfoExpression(node.leftExpression) &&\n            node.rightExpression.nodeType === ParseNodeType.StringList\n        ) {\n            // Handle the special case of \"sys.platform != 'X'\"\n            const comparisonPlatform = node.rightExpression.strings.map((s) => s.value).join('');\n            const expectedPlatformName = _getExpectedPlatformNameFromPlatform(execEnv);\n            return _evaluateStringBinaryOperation(node.operator, expectedPlatformName || '', comparisonPlatform);\n        } else if (\n            _isOsNameInfoExpression(node.leftExpression) &&\n            node.rightExpression.nodeType === ParseNodeType.StringList\n        ) {\n            // Handle the special case of \"os.name == 'X'\"\n            const comparisonOsName = node.rightExpression.strings.map((s) => s.value).join('');\n            const expectedOsName = _getExpectedOsNameFromPlatform(execEnv);\n            if (expectedOsName !== undefined) {\n                return _evaluateStringBinaryOperation(node.operator, expectedOsName, comparisonOsName);\n            }\n        }\n    } else if (node.nodeType === ParseNodeType.Constant) {\n        if (node.constType === KeywordType.True) {\n            return true;\n        } else if (node.constType === KeywordType.False) {\n            return false;\n        }\n    } else if (node.nodeType === ParseNodeType.Name) {\n        if (node.value === 'TYPE_CHECKING') {\n            return true;\n        }\n    } else if (\n        node.nodeType === ParseNodeType.MemberAccess &&\n        node.memberName.value === 'TYPE_CHECKING' &&\n        node.leftExpression.nodeType === ParseNodeType.Name &&\n        node.leftExpression.value === 'typing'\n    ) {\n        return true;\n    }\n\n    return undefined;\n}\n\n// Similar to evaluateStaticBoolExpression except that it handles\n// other non-bool values that are statically falsy or truthy\n// (like \"None\").\nexport function evaluateStaticBoolLikeExpression(\n    node: ExpressionNode,\n    execEnv: ExecutionEnvironment\n): boolean | undefined {\n    if (node.nodeType === ParseNodeType.Constant) {\n        if (node.constType === KeywordType.None) {\n            return false;\n        }\n    }\n\n    return evaluateStaticBoolExpression(node, execEnv);\n}\n\nfunction _convertTupleToVersion(node: TupleNode): number | undefined {\n    let comparisonVersion: number | undefined;\n    // Ignore patch versions.\n    if (node.expressions.length >= 2) {\n        if (\n            node.expressions[0].nodeType === ParseNodeType.Number &&\n            !node.expressions[0].isImaginary &&\n            node.expressions[1].nodeType === ParseNodeType.Number &&\n            !node.expressions[1].isImaginary\n        ) {\n            const majorVersion = node.expressions[0];\n            const minorVersion = node.expressions[1];\n            comparisonVersion = majorVersion.value * 256 + minorVersion.value;\n        }\n    } else if (node.expressions.length === 1) {\n        const majorVersion = node.expressions[0] as NumberNode;\n        comparisonVersion = majorVersion.value * 256;\n    }\n\n    return comparisonVersion;\n}\n\nfunction _evaluateNumericBinaryOperation(\n    operatorType: OperatorType,\n    leftValue: number | undefined,\n    rightValue: number | undefined\n): any | undefined {\n    if (leftValue !== undefined && rightValue !== undefined) {\n        if (operatorType === OperatorType.LessThan) {\n            return leftValue < rightValue;\n        } else if (operatorType === OperatorType.LessThanOrEqual) {\n            return leftValue <= rightValue;\n        } else if (operatorType === OperatorType.GreaterThan) {\n            return leftValue > rightValue;\n        } else if (operatorType === OperatorType.GreaterThanOrEqual) {\n            return leftValue >= rightValue;\n        } else if (operatorType === OperatorType.Equals) {\n            return leftValue === rightValue;\n        } else if (operatorType === OperatorType.NotEquals) {\n            return leftValue !== rightValue;\n        }\n    }\n\n    return undefined;\n}\n\nfunction _evaluateStringBinaryOperation(\n    operatorType: OperatorType,\n    leftValue: string | undefined,\n    rightValue: string | undefined\n): any | undefined {\n    if (leftValue !== undefined && rightValue !== undefined) {\n        if (operatorType === OperatorType.Equals) {\n            return leftValue === rightValue;\n        } else if (operatorType === OperatorType.NotEquals) {\n            return leftValue !== rightValue;\n        }\n    }\n\n    return undefined;\n}\n\nfunction _isSysVersionInfoExpression(node: ExpressionNode): boolean {\n    if (node.nodeType === ParseNodeType.MemberAccess) {\n        if (\n            node.leftExpression.nodeType === ParseNodeType.Name &&\n            node.leftExpression.value === 'sys' &&\n            node.memberName.value === 'version_info'\n        ) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nfunction _isSysPlatformInfoExpression(node: ExpressionNode): boolean {\n    if (node.nodeType === ParseNodeType.MemberAccess) {\n        if (\n            node.leftExpression.nodeType === ParseNodeType.Name &&\n            node.leftExpression.value === 'sys' &&\n            node.memberName.value === 'platform'\n        ) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nfunction _isOsNameInfoExpression(node: ExpressionNode): boolean {\n    if (node.nodeType === ParseNodeType.MemberAccess) {\n        if (\n            node.leftExpression.nodeType === ParseNodeType.Name &&\n            node.leftExpression.value === 'os' &&\n            node.memberName.value === 'name'\n        ) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nfunction _getExpectedPlatformNameFromPlatform(execEnv: ExecutionEnvironment): string | undefined {\n    if (execEnv.pythonPlatform === 'Darwin') {\n        return 'darwin';\n    } else if (execEnv.pythonPlatform === 'Windows') {\n        return 'win32';\n    } else if (execEnv.pythonPlatform === 'Linux') {\n        return 'linux';\n    }\n\n    return undefined;\n}\n\nfunction _getExpectedOsNameFromPlatform(execEnv: ExecutionEnvironment): string | undefined {\n    if (execEnv.pythonPlatform === 'Darwin') {\n        return 'posix';\n    } else if (execEnv.pythonPlatform === 'Windows') {\n        return 'nt';\n    } else if (execEnv.pythonPlatform === 'Linux') {\n        return 'posix';\n    }\n\n    return undefined;\n}\n","/*\n * symbol.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Represents an association between a name and the type\n * (or multiple types) that the symbol is associated with\n * in the program.\n */\n\nimport { Declaration, DeclarationType } from './declaration';\nimport { areDeclarationsSame, hasTypeForDeclaration } from './declarationUtils';\nimport { Type } from './types';\n\nexport const enum SymbolFlags {\n    None = 0,\n\n    // Indicates that the symbol is unbound at the start of\n    // execution. Some symbols are initialized by the module\n    // loader, so they are bound even before the first statement\n    // in the module is executed.\n    InitiallyUnbound = 1 << 0,\n\n    // Indicates that the symbol is not visible from other files.\n    // Used for module-level symbols.\n    ExternallyHidden = 1 << 1,\n\n    // Indicates that the symbol is a class member of a class.\n    ClassMember = 1 << 2,\n\n    // Indicates that the symbol is an instance member of a class.\n    InstanceMember = 1 << 3,\n\n    // Indicates that the symbol is considered \"private\" to the\n    // class and should not be accessed outside or overridden.\n    PrivateMember = 1 << 5,\n\n    // Indicates that the symbol is not considered for protocol\n    // matching. This applies to some built-in symbols like __class__.\n    IgnoredForProtocolMatch = 1 << 6,\n\n    // Indicates that the symbol is a ClassVar, so it cannot be\n    // set when accessed through a class instance.\n    ClassVar = 1 << 7,\n}\n\nlet nextSymbolId = 1;\nfunction getUniqueSymbolId() {\n    return nextSymbolId++;\n}\n\n// Symbol ID that indicates that there is no specific symbol.\nexport const indeterminateSymbolId = 0;\n\nexport class Symbol {\n    // Information about the node that declared the value -\n    // i.e. where the editor will take the user if \"show definition\"\n    // is selected. Multiple declarations can exist for variables,\n    // properties, and functions (in the case of @overload).\n    private _declarations?: Declaration[];\n\n    // Flags that provide information about the symbol.\n    private _flags: SymbolFlags;\n\n    // Unique numeric ID for each symbol allocated.\n    readonly id: number;\n\n    // Symbols that are completely synthesized (i.e. have no\n    // corresponding declarations in the program) can have\n    // a specified type.\n    private _synthesizedType?: Type;\n\n    constructor(flags = SymbolFlags.ClassMember) {\n        this.id = getUniqueSymbolId();\n        this._flags = flags;\n    }\n\n    static createWithType(flags: SymbolFlags, type: Type) {\n        const newSymbol = new Symbol(flags);\n        newSymbol._synthesizedType = type;\n        return newSymbol;\n    }\n\n    isInitiallyUnbound() {\n        return !!(this._flags & SymbolFlags.InitiallyUnbound);\n    }\n\n    setIsExternallyHidden() {\n        this._flags |= SymbolFlags.ExternallyHidden;\n    }\n\n    isExternallyHidden() {\n        return !!(this._flags & SymbolFlags.ExternallyHidden);\n    }\n\n    setIsIgnoredForProtocolMatch() {\n        this._flags |= SymbolFlags.IgnoredForProtocolMatch;\n    }\n\n    isIgnoredForProtocolMatch() {\n        return !!(this._flags & SymbolFlags.IgnoredForProtocolMatch);\n    }\n\n    setIsClassMember() {\n        this._flags |= SymbolFlags.ClassMember;\n    }\n\n    isClassMember() {\n        return !!(this._flags & SymbolFlags.ClassMember);\n    }\n\n    setIsInstanceMember() {\n        this._flags |= SymbolFlags.InstanceMember;\n    }\n\n    isInstanceMember() {\n        return !!(this._flags & SymbolFlags.InstanceMember);\n    }\n\n    setIsClassVar() {\n        this._flags |= SymbolFlags.ClassVar;\n    }\n\n    isClassVar() {\n        return !!(this._flags & SymbolFlags.ClassVar);\n    }\n\n    setIsPrivateMember() {\n        this._flags |= SymbolFlags.PrivateMember;\n    }\n\n    isPrivateMember() {\n        return !!(this._flags & SymbolFlags.PrivateMember);\n    }\n\n    addDeclaration(declaration: Declaration) {\n        if (this._declarations) {\n            // See if this node was already identified as a declaration. If so,\n            // replace it. Otherwise, add it as a new declaration to the end of\n            // the list.\n            const declIndex = this._declarations.findIndex((decl) => areDeclarationsSame(decl, declaration));\n            if (declIndex < 0) {\n                this._declarations.push(declaration);\n\n                // If there is more than one declaration for a symbol, we will\n                // assume it is not a type alias.\n                this._declarations.forEach((decl) => {\n                    if (decl.type === DeclarationType.Variable && decl.typeAliasName) {\n                        delete decl.typeAliasName;\n                    }\n                });\n            } else {\n                // If the new declaration has a defined type, it should replace\n                // the existing one.\n                const curDecl = this._declarations[declIndex];\n                if (hasTypeForDeclaration(declaration)) {\n                    this._declarations[declIndex] = declaration;\n                    if (curDecl.type === DeclarationType.Variable && declaration.type === DeclarationType.Variable) {\n                        if (!declaration.inferredTypeSource && curDecl.inferredTypeSource) {\n                            declaration.inferredTypeSource = curDecl.inferredTypeSource;\n                        }\n                    }\n                } else if (declaration.type === DeclarationType.Variable) {\n                    // If it's marked \"final\" or \"type alias\", this should be reflected\n                    // in the existing declaration. Likewise, if the existing declaration\n                    // doesn't have a type source, add it.\n                    if (curDecl.type === DeclarationType.Variable) {\n                        if (declaration.isFinal) {\n                            curDecl.isFinal = true;\n                        }\n\n                        if (declaration.typeAliasAnnotation) {\n                            curDecl.typeAliasAnnotation = declaration.typeAliasAnnotation;\n                        }\n\n                        if (!curDecl.inferredTypeSource && declaration.inferredTypeSource) {\n                            curDecl.inferredTypeSource = declaration.inferredTypeSource;\n                        }\n                    }\n                }\n            }\n        } else {\n            this._declarations = [declaration];\n        }\n    }\n\n    hasDeclarations() {\n        return this._declarations ? this._declarations.length > 0 : false;\n    }\n\n    getDeclarations() {\n        return this._declarations ? this._declarations : [];\n    }\n\n    hasTypedDeclarations() {\n        // We'll treat an synthesized type as an implicit declaration.\n        if (this._synthesizedType) {\n            return true;\n        }\n\n        return this.getDeclarations().some((decl) => hasTypeForDeclaration(decl));\n    }\n\n    getTypedDeclarations() {\n        return this.getDeclarations().filter((decl) => hasTypeForDeclaration(decl));\n    }\n\n    getSynthesizedType() {\n        return this._synthesizedType;\n    }\n}\n\n// Maps names to symbol information.\nexport type SymbolTable = Map<string, Symbol>;\n","/*\n * symbolNameUtils.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Static methods that apply to symbols or symbol names.\n */\n\nconst _constantRegEx = /^[A-Z0-9_]+$/;\nconst _underscoreOnlyRegEx = /^[_]+$/;\n\n// Private symbol names start with a double underscore.\nexport function isPrivateName(name: string) {\n    return name.length > 2 && name.startsWith('__') && !name.endsWith('__');\n}\n\n// Protected symbol names start with a single underscore.\nexport function isProtectedName(name: string) {\n    return name.length > 1 && name.startsWith('_') && !name.startsWith('__');\n}\n\nexport function isPrivateOrProtectedName(name: string) {\n    return isPrivateName(name) || isProtectedName(name);\n}\n\n// \"Dunder\" names start and end with two underscores.\nexport function isDunderName(name: string) {\n    return name.length > 4 && name.startsWith('__') && name.endsWith('__');\n}\n\n// Constants are all-caps with possible numbers and underscores.\nexport function isConstantName(name: string) {\n    return !!name.match(_constantRegEx) && !name.match(_underscoreOnlyRegEx);\n}\n","/*\n * symbolUtils.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Collection of functions that operate on Symbol objects.\n */\n\nimport { ParseNodeType } from '../parser/parseNodes';\nimport { Declaration, DeclarationType } from './declaration';\nimport { isFinalVariableDeclaration } from './declarationUtils';\nimport { Symbol, SymbolTable } from './symbol';\n\nexport function getLastTypedDeclaredForSymbol(symbol: Symbol): Declaration | undefined {\n    const typedDecls = symbol.getTypedDeclarations();\n\n    if (typedDecls.length > 0) {\n        return typedDecls[typedDecls.length - 1];\n    }\n\n    return undefined;\n}\n\n// Within TypedDict classes, member variables are not accessible as\n// normal attributes. Instead, they are accessed through index operations.\nexport function isTypedDictMemberAccessedThroughIndex(symbol: Symbol): boolean {\n    const typedDecls = symbol.getTypedDeclarations();\n\n    if (typedDecls.length > 0) {\n        const lastDecl = typedDecls[typedDecls.length - 1];\n        if (lastDecl.type === DeclarationType.Variable) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nexport function isFinalVariable(symbol: Symbol): boolean {\n    return symbol.getDeclarations().some((decl) => isFinalVariableDeclaration(decl));\n}\n\nexport function getNamesInDunderAll(symbolTable: SymbolTable): string[] | undefined {\n    const namesToImport: string[] = [];\n\n    const allSymbol = symbolTable.get('__all__');\n    if (allSymbol) {\n        const decls = allSymbol.getDeclarations();\n\n        // For now, we handle only the case where __all__ is defined\n        // through a simple assignment. Some libraries use more complex\n        // logic like __all__.extend(X) or __all__ += X. We'll punt on\n        // those for now.\n        if (decls.length === 1 && decls[0].type === DeclarationType.Variable) {\n            const firstDecl = decls[0];\n            if (firstDecl.node.parent && firstDecl.node.parent.nodeType === ParseNodeType.Assignment) {\n                const expr = firstDecl.node.parent.rightExpression;\n                if (expr.nodeType === ParseNodeType.List) {\n                    expr.entries.forEach((listEntryNode) => {\n                        if (\n                            listEntryNode.nodeType === ParseNodeType.StringList &&\n                            listEntryNode.strings.length === 1 &&\n                            listEntryNode.strings[0].nodeType === ParseNodeType.String\n                        ) {\n                            const entryName = listEntryNode.strings[0].value;\n                            if (symbolTable.get(entryName)) {\n                                namesToImport.push(entryName);\n                            }\n                        }\n                    });\n\n                    return namesToImport;\n                }\n            }\n        }\n    }\n\n    return undefined;\n}\n","/*\n * testWalker.ts\n *\n * Walks a parse tree to validate internal consistency and completeness.\n */\n\nimport { ParseTreeWalker } from '../analyzer/parseTreeWalker';\nimport { fail } from '../common/debug';\nimport { TextRange } from '../common/textRange';\nimport { ParseNode, ParseNodeArray, ParseNodeType } from '../parser/parseNodes';\n\nexport class TestWalker extends ParseTreeWalker {\n    constructor() {\n        super();\n    }\n\n    visitNode(node: ParseNode) {\n        const children = super.visitNode(node);\n        this._verifyParentChildLinks(node, children);\n        this._verifyChildRanges(node, children);\n\n        return children;\n    }\n\n    // Make sure that all of the children point to their parent.\n    private _verifyParentChildLinks(node: ParseNode, children: ParseNodeArray) {\n        children.forEach((child) => {\n            if (child) {\n                if (child.parent !== node) {\n                    fail(\n                        `Child node ${child.nodeType} does not ` + `contain a reference to its parent ${node.nodeType}`\n                    );\n                }\n            }\n        });\n    }\n\n    // Verify that:\n    //      Children are all contained within the parent\n    //      Children have non-overlapping ranges\n    //      Children are listed in increasing order\n    private _verifyChildRanges(node: ParseNode, children: ParseNodeArray) {\n        let prevNode: ParseNode | undefined;\n\n        children.forEach((child) => {\n            if (child) {\n                let skipCheck = false;\n\n                // There are a few exceptions we need to deal with here. Comment\n                // annotations can occur outside of an assignment node's range.\n                if (node.nodeType === ParseNodeType.Assignment) {\n                    if (child === node.typeAnnotationComment) {\n                        skipCheck = true;\n                    }\n                }\n\n                if (node.nodeType === ParseNodeType.StringList) {\n                    if (child === node.typeAnnotation) {\n                        skipCheck = true;\n                    }\n                }\n\n                if (!skipCheck) {\n                    // Make sure the child is contained within the parent.\n                    if (child.start < node.start || TextRange.getEnd(child) > TextRange.getEnd(node)) {\n                        fail(`Child node ${child.nodeType} is not ` + `contained within its parent ${node.nodeType}`);\n                    }\n                    if (prevNode) {\n                        // Make sure the child is after the previous child.\n                        if (child.start < TextRange.getEnd(prevNode)) {\n                            // Special-case the function annotation which can \"bleed\" into the suite.\n                            if (prevNode.nodeType !== ParseNodeType.FunctionAnnotation) {\n                                fail(`Child node is not after previous child node`);\n                            }\n                        }\n                    }\n\n                    prevNode = child;\n                }\n            }\n        });\n    }\n}\n","/*\n * typeCache.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Module used by the type evaluator that caches computed types\n * and stores them by node ID.\n */\n\nimport { assert } from '../common/debug';\nimport { ParseNode } from '../parser/parseNodes';\nimport { Type } from './types';\n\n// A type cache maps node IDs to types or pseudo-type objects.\nexport type TypeCache = Map<number, CachedType | undefined>;\n\n// An entry within the cache is either a type or an \"incomplete type\"\n// object that refers to a type.\nexport type CachedType = Type | IncompleteType;\n\nexport interface IncompleteType {\n    isIncompleteType?: true;\n\n    // Type computed so far\n    type: Type | undefined;\n\n    // Array of incomplete subtypes that have been computed so far\n    // (used for loops)\n    incompleteSubtypes: (Type | undefined)[];\n\n    // Tracks whether something has changed since this cache entry\n    // was written that might change the incomplete type; if this\n    // doesn't match the global \"incomplete generation count\", this\n    // cached value is stale\n    generationCount: number;\n}\n\n// Define a user type guard function for IncompleteType.\nexport function isIncompleteType(cachedType: CachedType): cachedType is IncompleteType {\n    return !!(cachedType as IncompleteType).isIncompleteType;\n}\n\n// Define an interface to track speculative entries that need to\n// be cleaned up when they go out of scope.\ninterface TypeCacheEntry {\n    cache: TypeCache;\n    id: number;\n}\n\ninterface SpeculativeContext {\n    speculativeRootNode: ParseNode;\n    entriesToUndo: TypeCacheEntry[];\n}\n\n// This class maintains a stack of \"speculative type contexts\". When\n// a context is popped off the stack, all of the speculative type cache\n// entries that were created within that context are removed from the\n// corresponding type caches because they are no longer valid.\nexport class SpeculativeTypeTracker {\n    private _speculativeContextStack: SpeculativeContext[] = [];\n\n    enterSpeculativeContext(speculativeRootNode: ParseNode) {\n        this._speculativeContextStack.push({ speculativeRootNode, entriesToUndo: [] });\n    }\n\n    leaveSpeculativeContext() {\n        assert(this._speculativeContextStack.length > 0);\n        const context = this._speculativeContextStack.pop();\n\n        // Delete all of the speculative type cache entries\n        // that were tracked in this context.\n        context!.entriesToUndo.forEach((entry) => {\n            entry.cache.delete(entry.id);\n        });\n    }\n\n    isSpeculative() {\n        return this._speculativeContextStack.length > 0;\n    }\n\n    getSpeculativeRootNode() {\n        const stackDepth = this._speculativeContextStack.length;\n        if (stackDepth > 0) {\n            // Return the speculative node associated with the most\n            // recent context pushed onto the stack.\n            return this._speculativeContextStack[stackDepth - 1].speculativeRootNode;\n        }\n\n        return undefined;\n    }\n\n    trackEntry(cache: TypeCache, id: number) {\n        const stackSize = this._speculativeContextStack.length;\n        if (stackSize > 0) {\n            this._speculativeContextStack[stackSize - 1].entriesToUndo.push({\n                cache,\n                id,\n            });\n        }\n    }\n\n    // Temporarily disables speculative mode, clearing the stack\n    // of speculative contexts. It returns the stack so the caller\n    // can later restore it by calling enableSpeculativeMode.\n    disableSpeculativeMode() {\n        const stack = this._speculativeContextStack;\n        this._speculativeContextStack = [];\n        return stack;\n    }\n\n    enableSpeculativeMode(stack: SpeculativeContext[]) {\n        assert(this._speculativeContextStack.length === 0);\n        this._speculativeContextStack = stack;\n    }\n}\n\n// This class tracks a list of cache entries that need to be\n// undone because they were based on an \"incomplete type\" -\n// a type that is calculated during code flow analysis and\n// is incomplete because not all paths have been exhaustively\n// explored.\nexport class IncompleteTypeTracker {\n    private _entriesToUndo: TypeCacheEntry[] = [];\n    private _requiresUndo = false;\n\n    trackEntry(cache: TypeCache, id: number) {\n        if (this._requiresUndo) {\n            this._entriesToUndo.push({\n                cache,\n                id,\n            });\n        }\n    }\n\n    leaveIncompleteTypeMode() {\n        this._entriesToUndo.forEach((entry) => {\n            entry.cache.delete(entry.id);\n        });\n\n        this._requiresUndo = false;\n        this._entriesToUndo = [];\n    }\n\n    enterIncompleteTypeMode() {\n        // Note that subsequent types are based on incomplete\n        // type information and should be tracked and ultimately\n        // removed from the cache.\n        this._requiresUndo = true;\n    }\n\n    isIncompleteTypeMode() {\n        return this._requiresUndo;\n    }\n}\n","/*\n * typeDocStringUtils.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * Logic that obtains the doc string for types by looking\n * at the declaration in the type stub, and if needed, in\n * the source file.\n */\n\nimport { ClassDeclaration, DeclarationBase, DeclarationType, FunctionDeclaration } from '../analyzer/declaration';\nimport * as ParseTreeUtils from '../analyzer/parseTreeUtils';\nimport { isStubFile, SourceMapper } from '../analyzer/sourceMapper';\nimport { ClassType, FunctionType, ModuleType, OverloadedFunctionType } from '../analyzer/types';\nimport { ModuleNode } from '../parser/parseNodes';\n\nexport function getOverloadedFunctionDocStrings(\n    type: OverloadedFunctionType,\n    resolvedDecl: DeclarationBase | undefined,\n    sourceMapper: SourceMapper\n) {\n    const docStrings: string[] = [];\n    if (type.overloads.some((o) => o.details.docString)) {\n        type.overloads.forEach((overload) => {\n            if (overload.details.docString) {\n                docStrings.push(overload.details.docString);\n            }\n        });\n    } else if (resolvedDecl && isStubFile(resolvedDecl.path) && resolvedDecl.type === DeclarationType.Function) {\n        const implDecls = sourceMapper.findFunctionDeclarations(resolvedDecl as FunctionDeclaration);\n        const docString = _getFunctionOrClassDeclDocString(implDecls);\n        if (docString) {\n            docStrings.push(docString);\n        }\n    }\n    return docStrings;\n}\n\nexport function getModuleDocString(\n    type: ModuleType,\n    resolvedDecl: DeclarationBase | undefined,\n    sourceMapper: SourceMapper\n) {\n    let docString = type.docString;\n    if (!docString) {\n        if (resolvedDecl && isStubFile(resolvedDecl.path)) {\n            const modules = sourceMapper.findModules(resolvedDecl.path);\n            docString = _getModuleNodeDocString(modules);\n        }\n    }\n    return docString;\n}\n\nexport function getClassDocString(\n    type: ClassType,\n    resolvedDecl: DeclarationBase | undefined,\n    sourceMapper: SourceMapper\n) {\n    let docString = type.details.docString;\n    if (!docString) {\n        if (resolvedDecl && isStubFile(resolvedDecl.path) && resolvedDecl.type === DeclarationType.Class) {\n            const implDecls = sourceMapper.findClassDeclarations(resolvedDecl as ClassDeclaration);\n            docString = _getFunctionOrClassDeclDocString(implDecls);\n        }\n    }\n    return docString;\n}\n\nexport function getFunctionDocStringFromType(type: FunctionType, sourceMapper: SourceMapper) {\n    let docString = type.details.docString;\n    if (!docString && type.details.declaration) {\n        docString = getFunctionDocStringFromDeclaration(type.details.declaration, sourceMapper);\n    }\n    return docString;\n}\n\nexport function getFunctionDocStringFromDeclaration(resolvedDecl: FunctionDeclaration, sourceMapper: SourceMapper) {\n    let docString = _getFunctionOrClassDeclDocString([resolvedDecl]);\n    if (!docString && isStubFile(resolvedDecl.path)) {\n        const implDecls = sourceMapper.findFunctionDeclarations(resolvedDecl);\n        docString = _getFunctionOrClassDeclDocString(implDecls);\n    }\n    return docString;\n}\n\nfunction _getFunctionOrClassDeclDocString(decls: FunctionDeclaration[] | ClassDeclaration[]): string | undefined {\n    for (const decl of decls) {\n        const docString = ParseTreeUtils.getDocString(decl.node?.suite?.statements);\n        if (docString) {\n            return docString;\n        }\n    }\n\n    return undefined;\n}\n\nfunction _getModuleNodeDocString(modules: ModuleNode[]): string | undefined {\n    for (const module of modules) {\n        if (module.statements) {\n            const docString = ParseTreeUtils.getDocString(module.statements);\n            if (docString) {\n                return docString;\n            }\n        }\n    }\n\n    return undefined;\n}\n","/*\n * typeEvaluator.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Module that evaluates types of parse tree nodes within\n * a program.\n *\n * Note: This is a gargantuan module - much larger than I would\n * normally create. It is written this way primarily for performance,\n * with the internal methods having access to the full closure of\n * the createTypeEvaluator function. This is the same approach\n * taken by the TypeScript compiler.\n */\n\nimport { CancellationToken } from 'vscode-languageserver';\n\nimport { Commands } from '../commands/commands';\nimport { throwIfCancellationRequested } from '../common/cancellationUtils';\nimport { DiagnosticLevel } from '../common/configOptions';\nimport { assert, fail } from '../common/debug';\nimport { AddMissingOptionalToParamAction, Diagnostic, DiagnosticAddendum } from '../common/diagnostic';\nimport { DiagnosticRule } from '../common/diagnosticRules';\nimport { convertOffsetsToRange } from '../common/positionUtils';\nimport { PythonVersion } from '../common/pythonVersion';\nimport { getEmptyRange, TextRange } from '../common/textRange';\nimport { TextRangeCollection } from '../common/textRangeCollection';\nimport { Localizer } from '../localization/localize';\nimport {\n    ArgumentCategory,\n    ArgumentNode,\n    AssignmentNode,\n    AugmentedAssignmentNode,\n    BinaryOperationNode,\n    CallNode,\n    ClassNode,\n    ConstantNode,\n    DecoratorNode,\n    DictionaryNode,\n    ExceptNode,\n    ExpressionNode,\n    ForNode,\n    FunctionNode,\n    ImportAsNode,\n    ImportFromAsNode,\n    ImportFromNode,\n    IndexItemsNode,\n    IndexNode,\n    isExpressionNode,\n    LambdaNode,\n    ListComprehensionNode,\n    ListNode,\n    MemberAccessNode,\n    NameNode,\n    ParameterCategory,\n    ParameterNode,\n    ParseNode,\n    ParseNodeType,\n    RaiseNode,\n    SetNode,\n    SliceNode,\n    StringListNode,\n    TernaryNode,\n    TupleNode,\n    TypeAnnotationNode,\n    UnaryOperationNode,\n    WithItemNode,\n    YieldFromNode,\n    YieldNode,\n} from '../parser/parseNodes';\nimport { ParseOptions, Parser } from '../parser/parser';\nimport { KeywordType, OperatorType, StringTokenFlags, Token, TokenType } from '../parser/tokenizerTypes';\nimport * as DeclarationUtils from './aliasDeclarationUtils';\nimport { AnalyzerFileInfo, ImportLookup } from './analyzerFileInfo';\nimport * as AnalyzerNodeInfo from './analyzerNodeInfo';\nimport {\n    createKeyForReference,\n    FlowAssignment,\n    FlowAssignmentAlias,\n    FlowCall,\n    FlowCondition,\n    FlowFlags,\n    FlowLabel,\n    FlowNode,\n    FlowPostFinally,\n    FlowPreFinallyGate,\n    FlowWildcardImport,\n    isCodeFlowSupportedForReference,\n} from './codeFlow';\nimport {\n    AliasDeclaration,\n    ClassDeclaration,\n    Declaration,\n    DeclarationType,\n    FunctionDeclaration,\n    ModuleLoaderActions,\n    VariableDeclaration,\n} from './declaration';\nimport { isExplicitTypeAliasDeclaration, isPossibleTypeAliasDeclaration } from './declarationUtils';\nimport * as ParseTreeUtils from './parseTreeUtils';\nimport { ScopeType } from './scope';\nimport * as ScopeUtils from './scopeUtils';\nimport { evaluateStaticBoolExpression } from './staticExpressions';\nimport { indeterminateSymbolId, Symbol, SymbolFlags } from './symbol';\nimport { isConstantName, isPrivateOrProtectedName } from './symbolNameUtils';\nimport { getLastTypedDeclaredForSymbol, isFinalVariable } from './symbolUtils';\nimport {\n    CachedType,\n    IncompleteType,\n    IncompleteTypeTracker,\n    isIncompleteType,\n    SpeculativeTypeTracker,\n    TypeCache,\n} from './typeCache';\nimport {\n    AnyType,\n    ClassType,\n    ClassTypeFlags,\n    combineTypes,\n    DataClassEntry,\n    EnumLiteral,\n    FunctionParameter,\n    FunctionType,\n    FunctionTypeFlags,\n    InheritanceChain,\n    isAnyOrUnknown,\n    isClass,\n    isFunction,\n    isModule,\n    isNever,\n    isNone,\n    isObject,\n    isPossiblyUnbound,\n    isSameWithoutLiteralValue,\n    isTypeSame,\n    isTypeVar,\n    isUnbound,\n    isUnionableType,\n    isUnknown,\n    LiteralValue,\n    maxTypeRecursionCount,\n    ModuleType,\n    NeverType,\n    NoneType,\n    ObjectType,\n    OverloadedFunctionType,\n    ParamSpecEntry,\n    removeNoneFromUnion,\n    removeUnboundFromUnion,\n    Type,\n    TypeBase,\n    TypeCategory,\n    TypedDictEntry,\n    TypeSourceId,\n    TypeVarType,\n    UnboundType,\n    UnknownType,\n} from './types';\nimport {\n    addTypeVarsToListIfUnique,\n    areTypesSame,\n    buildTypeVarMapFromSpecializedClass,\n    CanAssignFlags,\n    canBeFalsy,\n    canBeTruthy,\n    ClassMember,\n    ClassMemberLookupFlags,\n    computeMroLinearization,\n    convertToInstance,\n    convertToInstantiable,\n    derivesFromClassRecursive,\n    doForSubtypes,\n    enumerateLiteralsForType,\n    getConcreteTypeFromTypeVar,\n    getDeclaredGeneratorReturnType,\n    getDeclaredGeneratorSendType,\n    getSpecializedTupleType,\n    getTypeVarArgumentsRecursive,\n    isEllipsisType,\n    isLiteralType,\n    isNoReturnType,\n    isOptionalType,\n    isParamSpecType,\n    isPartlyUnknown,\n    isProperty,\n    isTupleClass,\n    isTypeAliasRecursive,\n    lookUpClassMember,\n    lookUpObjectMember,\n    makeTypeVarsConcrete,\n    partiallySpecializeType,\n    printLiteralType,\n    printLiteralValue,\n    removeFalsinessFromType,\n    removeTruthinessFromType,\n    requiresSpecialization,\n    requiresTypeArguments,\n    selfSpecializeClassType,\n    setTypeArgumentsRecursive,\n    specializeType,\n    stripFirstParameter,\n    stripLiteralTypeArgsValue,\n    stripLiteralValue,\n    transformPossibleRecursiveTypeAlias,\n    transformTypeObjectToClass,\n} from './typeUtils';\nimport { TypeVarMap } from './typeVarMap';\n\ninterface TypeResult {\n    type: Type;\n    node: ExpressionNode;\n\n    unpackedType?: Type;\n    typeList?: TypeResult[];\n    isResolutionCyclical?: boolean;\n    expectedTypeDiagAddendum?: DiagnosticAddendum;\n}\n\ninterface EffectiveTypeResult {\n    type: Type;\n    isResolutionCyclical: boolean;\n}\n\ninterface FunctionArgument {\n    argumentCategory: ArgumentCategory;\n    node?: ArgumentNode;\n    name?: NameNode;\n    type?: Type;\n    valueExpression?: ExpressionNode;\n    active?: boolean;\n}\n\ninterface ValidateArgTypeParams {\n    paramType: Type;\n    requiresTypeVarMatching: boolean;\n    argument: FunctionArgument;\n    errorNode: ExpressionNode;\n    paramName?: string;\n}\n\ninterface ClassMemberLookup {\n    // Type of value.\n    type: Type;\n\n    // True if class member, false otherwise.\n    isClassMember: boolean;\n}\n\n// Used to determine whether an abstract method has been\n// overridden by a non-abstract method.\ninterface AbstractMethod {\n    symbol: Symbol;\n    symbolName: string;\n    classType: Type;\n    isAbstract: boolean;\n}\n\ntype TypeNarrowingCallback = (type: Type) => Type | undefined;\n\nexport const enum EvaluatorFlags {\n    None = 0,\n\n    // Interpret an ellipsis type annotation to mean \"Any\".\n    ConvertEllipsisToAny = 1 << 0,\n\n    // Normally a generic named type is specialized with \"Any\"\n    // types. This flag indicates that specialization shouldn't take\n    // place.\n    DoNotSpecialize = 1 << 1,\n\n    // Allow forward references. Don't report unbound errors.\n    AllowForwardReferences = 1 << 2,\n\n    // Skip the check for unknown arguments.\n    DoNotCheckForUnknownArgs = 1 << 4,\n\n    // Treat string literal as a type.\n    EvaluateStringLiteralAsType = 1 << 5,\n\n    // 'Final' is not allowed in this context.\n    FinalDisallowed = 1 << 6,\n\n    // A ParamSpec isn't allowed in this context.\n    ParamSpecDisallowed = 1 << 7,\n\n    // Expression is expected to be a type (class) rather\n    // than an instance (object)\n    ExpectingType = 1 << 8,\n\n    // The Tuple type allows the use of a tuple literal\n    // expression \"()\" as a type argument. When this appears\n    // as a type argument in other contexts, it's illegal.\n    AllowEmptyTupleAsType = 1 << 9,\n\n    // Interpret an ellipsis type annotation to mean \"Unknown\".\n    ConvertEllipsisToUnknown = 1 << 10,\n\n    // The Generic class type is allowed in this context. It is\n    // normally not allowed if ExpectingType is set.\n    GenericClassTypeAllowed = 1 << 11,\n\n    // In most cases where ExpectingType is set, generic classes\n    // with missing type args are reported to the user, but there\n    // are cases where it is legitimate to leave off missing\n    // type args, such as with the \"bound\" parameter in a TypeArg.\n    AllowMissingTypeArgs = 1 << 12,\n\n    // TypeVars within this expression must not refer to type vars\n    // used in an outer scope that.\n    DisallowTypeVarsWithScopeId = 1 << 13,\n\n    // TypeVars within this expression must refer to type vars\n    // used in an outer scope that.\n    DisallowTypeVarsWithoutScopeId = 1 << 14,\n\n    // TypeVars within this expression that are otherwise not\n    // associated with an outer scope should be associated with\n    // the containing function's scope.\n    AssociateTypeVarsWithCurrentScope = 1 << 15,\n}\n\ninterface EvaluatorUsage {\n    method: 'get' | 'set' | 'del';\n\n    // Used only for set methods\n    setType?: Type;\n    setErrorNode?: ExpressionNode;\n    setExpectedTypeDiag?: DiagnosticAddendum;\n}\n\ninterface AliasMapEntry {\n    alias: string;\n    module: 'builtins' | 'collections' | 'self';\n}\n\nexport const enum MemberAccessFlags {\n    None = 0,\n\n    // By default, both class and instance members are considered.\n    // Set this flag to skip the instance members.\n    SkipInstanceMembers = 1 << 0,\n\n    // By default, members of base classes are also searched.\n    // Set this flag to consider only the specified class' members.\n    SkipBaseClasses = 1 << 1,\n\n    // Do not include the \"object\" base class in the search.\n    SkipObjectBaseClass = 1 << 2,\n\n    // By default, if the class has a __getattribute__ or __getattr__\n    // magic method, it is assumed to have any member.\n    SkipGetAttributeCheck = 1 << 3,\n\n    // Consider writes to symbols flagged as ClassVars as an error.\n    DisallowClassVarWrites = 1 << 4,\n\n    // This set of flags is appropriate for looking up methods.\n    SkipForMethodLookup = SkipInstanceMembers | SkipGetAttributeCheck,\n}\n\nexport const enum PrintTypeFlags {\n    None = 0,\n\n    // Avoid printing \"Unknown\" and always use \"Any\" instead.\n    PrintUnknownWithAny = 1 << 0,\n\n    // Omit type arguments for generic classes if they are \"Any\".\n    OmitTypeArgumentsIfAny = 1 << 1,\n\n    // Omit printing type for param if type is not specified.\n    OmitUnannotatedParamType = 1 << 2,\n\n    // Print Union and Optional in PEP 604 format.\n    PEP604 = 1 << 3,\n}\n\ninterface ParamAssignmentInfo {\n    argsNeeded: number;\n    argsReceived: number;\n}\n\nexport type SetAnalysisChangedCallback = (reason: string) => void;\n\nconst arithmeticOperatorMap: { [operator: number]: [string, string] } = {\n    [OperatorType.Add]: ['__add__', '__radd__'],\n    [OperatorType.Subtract]: ['__sub__', '__rsub__'],\n    [OperatorType.Multiply]: ['__mul__', '__rmul__'],\n    [OperatorType.FloorDivide]: ['__floordiv__', '__rfloordiv__'],\n    [OperatorType.Divide]: ['__truediv__', '__rtruediv__'],\n    [OperatorType.Mod]: ['__mod__', '__rmod__'],\n    [OperatorType.Power]: ['__pow__', '__rpow__'],\n    [OperatorType.MatrixMultiply]: ['__matmul__', '__rmatmul__'],\n};\n\nconst bitwiseOperatorMap: { [operator: number]: [string, string] } = {\n    [OperatorType.BitwiseAnd]: ['__and__', '__rand__'],\n    [OperatorType.BitwiseOr]: ['__or__', '__ror__'],\n    [OperatorType.BitwiseXor]: ['__xor__', '__rxor__'],\n    [OperatorType.LeftShift]: ['__lshift__', '__rlshift__'],\n    [OperatorType.RightShift]: ['__rshift__', '__rrshift__'],\n};\n\nconst comparisonOperatorMap: { [operator: number]: [string, string] } = {\n    [OperatorType.Equals]: ['__eq__', '__ne__'],\n    [OperatorType.NotEquals]: ['__ne__', '__eq__'],\n    [OperatorType.LessThan]: ['__lt__', '__gt__'],\n    [OperatorType.LessThanOrEqual]: ['__le__', '__ge__'],\n    [OperatorType.GreaterThan]: ['__gt__', '__lt__'],\n    [OperatorType.GreaterThanOrEqual]: ['__ge__', '__le__'],\n};\n\nconst booleanOperatorMap: { [operator: number]: boolean } = {\n    [OperatorType.And]: true,\n    [OperatorType.Or]: true,\n    [OperatorType.Is]: true,\n    [OperatorType.IsNot]: true,\n    [OperatorType.In]: true,\n    [OperatorType.NotIn]: true,\n};\n\n// This table contains the names of several built-in types that\n// are not subscriptable at runtime on older versions of Python.\n// It lists the first version of Python where subscripting is\n// allowed.\nconst nonSubscriptableBuiltinTypes: { [builtinName: string]: PythonVersion } = {\n    'asyncio.futures.Future': PythonVersion.V3_9,\n    'builtins.dict': PythonVersion.V3_9,\n    'builtins.frozenset': PythonVersion.V3_9,\n    'builtins.list': PythonVersion.V3_9,\n    'builtins._PathLike': PythonVersion.V3_9,\n    'builtins.set': PythonVersion.V3_9,\n    'builtins.tuple': PythonVersion.V3_9,\n    'collections.ChainMap': PythonVersion.V3_9,\n    'collections.Counter': PythonVersion.V3_9,\n    'collections.DefaultDict': PythonVersion.V3_9,\n    'collections.deque': PythonVersion.V3_9,\n    'collections.OrderedDict': PythonVersion.V3_9,\n    'queue.Queue': PythonVersion.V3_9,\n};\n\nexport interface ClassTypeResult {\n    classType: ClassType;\n    decoratedType: Type;\n}\n\nexport interface FunctionTypeResult {\n    functionType: FunctionType;\n    decoratedType: Type;\n}\n\nexport interface CallSignature {\n    type: FunctionType;\n    activeParam?: FunctionParameter;\n}\n\nexport interface CallSignatureInfo {\n    signatures: CallSignature[];\n    callNode: CallNode | DecoratorNode;\n}\n\nexport interface CallResult {\n    returnType?: Type;\n    argumentErrors: boolean;\n    activeParam?: FunctionParameter;\n}\n\nexport interface TypeEvaluator {\n    runWithCancellationToken<T>(token: CancellationToken, callback: () => T): T;\n\n    getType: (node: ExpressionNode) => Type | undefined;\n    getTypeOfClass: (node: ClassNode) => ClassTypeResult | undefined;\n    getTypeOfFunction: (node: FunctionNode) => FunctionTypeResult | undefined;\n    evaluateTypesForStatement: (node: ParseNode) => void;\n\n    getDeclaredTypeForExpression: (expression: ExpressionNode) => Type | undefined;\n    verifyRaiseExceptionType: (node: RaiseNode) => void;\n    verifyDeleteExpression: (node: ExpressionNode) => void;\n\n    isAfterNodeReachable: (node: ParseNode) => boolean;\n    isNodeReachable: (node: ParseNode) => boolean;\n    suppressDiagnostics: (callback: () => void) => void;\n\n    getDeclarationsForNameNode: (node: NameNode) => Declaration[] | undefined;\n    getTypeForDeclaration: (declaration: Declaration) => Type | undefined;\n    resolveAliasDeclaration: (declaration: Declaration, resolveLocalNames: boolean) => Declaration | undefined;\n    getTypeFromIterable: (\n        type: Type,\n        isAsync: boolean,\n        errorNode: ParseNode | undefined,\n        supportGetItem: boolean\n    ) => Type;\n    getTypedDictMembersForClass: (classType: ClassType) => Map<string, TypedDictEntry>;\n    getGetterTypeFromProperty: (propertyClass: ClassType, inferTypeIfNeeded: boolean) => Type | undefined;\n\n    getEffectiveTypeOfSymbol: (symbol: Symbol) => Type;\n    getFunctionDeclaredReturnType: (node: FunctionNode) => Type | undefined;\n    getFunctionInferredReturnType: (type: FunctionType) => Type;\n    getBuiltInType: (node: ParseNode, name: string) => Type;\n    getTypeOfMember: (member: ClassMember) => Type;\n    bindFunctionToClassOrObject: (\n        baseType: ClassType | ObjectType | undefined,\n        memberType: Type,\n        treatAsClassMember: boolean\n    ) => Type | undefined;\n    getBoundMethod: (\n        classType: ClassType,\n        memberName: string,\n        treatAsClassMember: boolean\n    ) => FunctionType | OverloadedFunctionType | undefined;\n    getCallSignatureInfo: (\n        node: ParseNode,\n        insertionOffset: number,\n        tokens: TextRangeCollection<Token>\n    ) => CallSignatureInfo | undefined;\n    getTypeAnnotationForParameter: (node: FunctionNode, paramIndex: number) => ExpressionNode | undefined;\n\n    canAssignType: (\n        destType: Type,\n        srcType: Type,\n        diag: DiagnosticAddendum,\n        typeVarMap?: TypeVarMap,\n        flags?: CanAssignFlags\n    ) => boolean;\n    canOverrideMethod: (baseMethod: Type, overrideMethod: FunctionType, diag: DiagnosticAddendum) => boolean;\n\n    addError: (message: string, node: ParseNode) => Diagnostic | undefined;\n    addWarning: (message: string, node: ParseNode) => Diagnostic | undefined;\n    addInformation: (message: string, node: ParseNode) => Diagnostic | undefined;\n    addUnusedCode: (node: ParseNode, textRange: TextRange) => void;\n\n    addDiagnostic: (\n        diagLevel: DiagnosticLevel,\n        rule: string,\n        message: string,\n        node: ParseNode\n    ) => Diagnostic | undefined;\n    addDiagnosticForTextRange: (\n        fileInfo: AnalyzerFileInfo,\n        diagLevel: DiagnosticLevel,\n        rule: string,\n        message: string,\n        range: TextRange\n    ) => Diagnostic | undefined;\n\n    printType: (type: Type, expandTypeAlias: boolean) => string;\n    printFunctionParts: (type: FunctionType) => [string[], string];\n\n    getTypeCacheSize: () => number;\n}\n\ninterface CodeFlowAnalyzer {\n    getTypeFromCodeFlow: (\n        reference: NameNode | MemberAccessNode,\n        targetSymbolId: number,\n        initialType: Type | undefined\n    ) => FlowNodeTypeResult;\n}\n\ninterface FlowNodeTypeResult {\n    type: Type | undefined;\n    isIncomplete: boolean;\n    generationCount?: number;\n    incompleteType?: Type;\n    incompleteSubtypes?: (Type | undefined)[];\n}\n\ninterface SymbolResolutionStackEntry {\n    // The symbol ID and declaration being resolved.\n    symbolId: number;\n    declaration: Declaration;\n\n    // Initially true, it's set to false if a recursion\n    // is detected.\n    isResultValid: boolean;\n\n    // Some limited forms of recursion are allowed. In these\n    // cases, a partially-constructed type can be registered.\n    partialType?: Type;\n}\n\ninterface ReturnTypeInferenceContext {\n    functionNode: FunctionNode;\n    codeFlowAnalyzer: CodeFlowAnalyzer;\n}\n\n// How many levels deep should we attempt to infer return\n// types based on call-site argument types? The deeper we go,\n// the more types we may be able to infer, but the worse the\n// performance.\nconst maxReturnTypeInferenceStackSize = 3;\n\nexport interface EvaluatorOptions {\n    disableInferenceForPyTypedSources: boolean;\n    printTypeFlags: PrintTypeFlags;\n}\n\nexport function createTypeEvaluator(importLookup: ImportLookup, evaluatorOptions: EvaluatorOptions): TypeEvaluator {\n    const symbolResolutionStack: SymbolResolutionStackEntry[] = [];\n    const isReachableRecursionMap = new Map<number, true>();\n    const functionRecursionMap = new Map<number, true>();\n    const callIsNoReturnCache = new Map<number, boolean>();\n    const codeFlowAnalyzerCache = new Map<number, CodeFlowAnalyzer>();\n    const typeCache: TypeCache = new Map<number, CachedType>();\n    const speculativeTypeTracker = new SpeculativeTypeTracker();\n    const incompleteTypeTracker = new IncompleteTypeTracker();\n    let cancellationToken: CancellationToken | undefined;\n    let isDiagnosticSuppressed = false;\n    let flowIncompleteGeneration = 1;\n\n    const returnTypeInferenceContextStack: ReturnTypeInferenceContext[] = [];\n    let returnTypeInferenceTypeCache: TypeCache | undefined;\n\n    function runWithCancellationToken<T>(token: CancellationToken, callback: () => T): T {\n        try {\n            cancellationToken = token;\n            return callback();\n        } finally {\n            cancellationToken = undefined;\n        }\n    }\n\n    function checkForCancellation() {\n        if (cancellationToken) {\n            throwIfCancellationRequested(cancellationToken);\n        }\n    }\n\n    function getTypeCacheSize(): number {\n        return typeCache.size;\n    }\n\n    function readTypeCache(node: ParseNode): Type | undefined {\n        let cachedType: CachedType | undefined;\n\n        // Should we use a temporary cache associated with a contextual\n        // analysis of a function, contextualized based on call-site argument types?\n        if (returnTypeInferenceTypeCache && isNodeInReturnTypeInferenceContext(node)) {\n            cachedType = returnTypeInferenceTypeCache.get(node.id);\n        } else {\n            cachedType = typeCache.get(node.id);\n        }\n\n        if (cachedType === undefined) {\n            return undefined;\n        }\n\n        assert(!isIncompleteType(cachedType));\n        return cachedType as Type;\n    }\n\n    function writeTypeCache(node: ParseNode, type: Type) {\n        // Should we use a temporary cache associated with a contextual\n        // analysis of a function, contextualized based on call-site argument types?\n        const typeCacheToUse =\n            returnTypeInferenceTypeCache && isNodeInReturnTypeInferenceContext(node)\n                ? returnTypeInferenceTypeCache\n                : typeCache;\n\n        typeCacheToUse.set(node.id, type);\n\n        // If the entry is located within a part of the parse tree that is currently being\n        // \"speculatively\" evaluated, track it so we delete the cached entry when we leave\n        // this speculative context.\n        const speculativeNode = speculativeTypeTracker.getSpeculativeRootNode();\n        if (speculativeNode && ParseTreeUtils.isNodeContainedWithin(node, speculativeNode)) {\n            speculativeTypeTracker.trackEntry(typeCacheToUse, node.id);\n        }\n\n        incompleteTypeTracker.trackEntry(typeCacheToUse, node.id);\n    }\n\n    // Determines whether the specified node is contained within\n    // the function node corresponding to the function that we\n    // are currently analyzing in the context of parameter types\n    // defined by a call site.\n    function isNodeInReturnTypeInferenceContext(node: ParseNode) {\n        const stackSize = returnTypeInferenceContextStack.length;\n        if (stackSize === 0) {\n            return false;\n        }\n\n        const contextNode = returnTypeInferenceContextStack[stackSize - 1];\n\n        let curNode: ParseNode | undefined = node;\n        while (curNode) {\n            if (curNode === contextNode.functionNode) {\n                return true;\n            }\n            curNode = curNode.parent;\n        }\n\n        return false;\n    }\n\n    function getCodeFlowAnalyzerForReturnTypeInferenceContext() {\n        const stackSize = returnTypeInferenceContextStack.length;\n        assert(stackSize > 0);\n        const contextNode = returnTypeInferenceContextStack[stackSize - 1];\n        return contextNode.codeFlowAnalyzer;\n    }\n\n    function getIndexOfSymbolResolution(symbol: Symbol, declaration: Declaration) {\n        return symbolResolutionStack.findIndex(\n            (entry) => entry.symbolId === symbol.id && entry.declaration === declaration\n        );\n    }\n\n    function pushSymbolResolution(symbol: Symbol, declaration: Declaration) {\n        const index = getIndexOfSymbolResolution(symbol, declaration);\n        if (index >= 0) {\n            // Mark all of the entries between these two as invalid.\n            for (let i = index + 1; i < symbolResolutionStack.length; i++) {\n                symbolResolutionStack[i].isResultValid = false;\n            }\n            return false;\n        }\n\n        symbolResolutionStack.push({\n            symbolId: symbol.id,\n            declaration,\n            isResultValid: true,\n        });\n        return true;\n    }\n\n    function popSymbolResolution(symbol: Symbol) {\n        const poppedEntry = symbolResolutionStack.pop()!;\n        assert(poppedEntry.symbolId === symbol.id);\n        return poppedEntry.isResultValid;\n    }\n\n    function setSymbolResolutionPartialType(symbol: Symbol, declaration: Declaration, type: Type) {\n        const index = getIndexOfSymbolResolution(symbol, declaration);\n        if (index >= 0) {\n            symbolResolutionStack[index].partialType = type;\n        }\n    }\n\n    function getSymbolResolutionPartialType(symbol: Symbol, declaration: Declaration): Type | undefined {\n        const index = getIndexOfSymbolResolution(symbol, declaration);\n        if (index >= 0) {\n            return symbolResolutionStack[index].partialType;\n        }\n\n        return undefined;\n    }\n\n    // Determines the type of the specified node by evaluating it in\n    // context, logging any errors in the process. This may require the\n    // type of surrounding statements to be evaluated.\n    function getType(node: ExpressionNode): Type | undefined {\n        evaluateTypesForExpressionInContext(node);\n\n        // We assume here that the type for the node in question\n        // will be populated in the cache. Some nodes don't have\n        // defined types (e.g. a raw list comprehension outside\n        // of its containing list), so we'll return undefined in those\n        // cases.\n        return readTypeCache(node);\n    }\n\n    function getTypeOfExpression(node: ExpressionNode, expectedType?: Type, flags = EvaluatorFlags.None): TypeResult {\n        // Is this type already cached?\n        const cachedType = readTypeCache(node);\n        if (cachedType) {\n            return { type: cachedType, node };\n        }\n\n        // This is a frequently-called routine, so it's a good place to call\n        // the cancellation check. If the operation is canceled, an exception\n        // will be thrown at this point.\n        checkForCancellation();\n\n        expectedType = transformPossibleRecursiveTypeAlias(expectedType);\n\n        let typeResult: TypeResult | undefined;\n        let reportExpectingTypeErrors = (flags & EvaluatorFlags.ExpectingType) !== 0;\n\n        switch (node.nodeType) {\n            case ParseNodeType.Name: {\n                typeResult = getTypeFromName(node, flags);\n                break;\n            }\n\n            case ParseNodeType.MemberAccess: {\n                typeResult = getTypeFromMemberAccess(node, flags);\n                break;\n            }\n\n            case ParseNodeType.Index: {\n                typeResult = getTypeFromIndex(node, flags);\n                break;\n            }\n\n            case ParseNodeType.Call: {\n                typeResult = getTypeFromCall(node, expectedType, flags);\n                break;\n            }\n\n            case ParseNodeType.Tuple: {\n                typeResult = getTypeFromTuple(node, expectedType);\n                break;\n            }\n\n            case ParseNodeType.Constant: {\n                typeResult = getTypeFromConstant(node, flags);\n                break;\n            }\n\n            case ParseNodeType.StringList: {\n                const expectingType =\n                    (flags & EvaluatorFlags.EvaluateStringLiteralAsType) !== 0 && !isAnnotationLiteralValue(node);\n\n                if (expectingType) {\n                    if (node.typeAnnotation) {\n                        typeResult = getTypeOfExpression(\n                            node.typeAnnotation,\n                            undefined,\n                            flags | EvaluatorFlags.AllowForwardReferences | EvaluatorFlags.ExpectingType\n                        );\n                    } else if (!node.typeAnnotation && node.strings.length === 1) {\n                        // We didn't know at parse time that this string node was going\n                        // to be evaluated as a forward-referenced type. We need\n                        // to re-invoke the parser at this stage.\n                        const expr = parseStringAsTypeAnnotation(node);\n                        if (expr) {\n                            typeResult = getTypeOfExpression(\n                                expr,\n                                undefined,\n                                flags | EvaluatorFlags.AllowForwardReferences | EvaluatorFlags.ExpectingType\n                            );\n                        }\n                    }\n\n                    if (!typeResult) {\n                        const fileInfo = getFileInfo(node);\n                        addDiagnostic(\n                            fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                            DiagnosticRule.reportGeneralTypeIssues,\n                            Localizer.Diagnostic.expectedTypeNotString(),\n                            node\n                        );\n                        typeResult = { node, type: UnknownType.create() };\n                    }\n\n                    // Don't report expecting type errors again. We will have already\n                    // reported them when analyzing the contents of the string.\n                    reportExpectingTypeErrors = false;\n                } else {\n                    // Evaluate the format string expressions in this context.\n                    node.strings.forEach((str) => {\n                        if (str.nodeType === ParseNodeType.FormatString) {\n                            str.expressions.forEach((expr) => {\n                                getTypeOfExpression(expr);\n                            });\n                        }\n                    });\n\n                    const isBytes = (node.strings[0].token.flags & StringTokenFlags.Bytes) !== 0;\n\n                    // Don't create a literal type if it's an f-string.\n                    if (node.strings.some((str) => str.nodeType === ParseNodeType.FormatString)) {\n                        typeResult = {\n                            node,\n                            type: getBuiltInObject(node, isBytes ? 'bytes' : 'str'),\n                        };\n                    } else {\n                        typeResult = {\n                            node,\n                            type: cloneBuiltinObjectWithLiteral(\n                                node,\n                                isBytes ? 'bytes' : 'str',\n                                node.strings.map((s) => s.value).join('')\n                            ),\n                        };\n                    }\n                }\n                break;\n            }\n\n            case ParseNodeType.Number: {\n                let builtInType = 'float';\n                if (node.isImaginary) {\n                    builtInType = 'complex';\n                } else if (node.isInteger) {\n                    builtInType = 'int';\n                }\n                typeResult = { node, type: cloneBuiltinObjectWithLiteral(node, builtInType, node.value) };\n                break;\n            }\n\n            case ParseNodeType.Ellipsis: {\n                if ((flags & EvaluatorFlags.ConvertEllipsisToAny) !== 0) {\n                    typeResult = { type: AnyType.create(true), node };\n                } else if ((flags & EvaluatorFlags.ConvertEllipsisToUnknown) !== 0) {\n                    typeResult = { type: UnknownType.create(), node };\n                } else {\n                    const ellipsisType = getBuiltInObject(node, 'ellipsis') || AnyType.create();\n                    typeResult = { type: ellipsisType, node };\n                }\n                break;\n            }\n\n            case ParseNodeType.UnaryOperation: {\n                typeResult = getTypeFromUnaryOperation(node, expectedType);\n                break;\n            }\n\n            case ParseNodeType.BinaryOperation: {\n                typeResult = getTypeFromBinaryOperation(node, expectedType, flags);\n                break;\n            }\n\n            case ParseNodeType.AugmentedAssignment: {\n                const type = getTypeFromAugmentedAssignment(node, expectedType);\n                assignTypeToExpression(node.destExpression, type, node.rightExpression);\n                typeResult = { type, node };\n                break;\n            }\n\n            case ParseNodeType.List: {\n                typeResult = getTypeFromList(node, expectedType);\n                break;\n            }\n\n            case ParseNodeType.Slice: {\n                typeResult = getTypeFromSlice(node);\n                break;\n            }\n\n            case ParseNodeType.Await: {\n                typeResult = getTypeOfExpression(node.expression, undefined, flags);\n                typeResult = {\n                    type: getTypeFromAwaitable(typeResult.type, node.expression),\n                    node,\n                };\n                break;\n            }\n\n            case ParseNodeType.Ternary: {\n                typeResult = getTypeFromTernary(node, flags, expectedType);\n                break;\n            }\n\n            case ParseNodeType.ListComprehension: {\n                typeResult = getTypeFromListComprehension(node);\n                break;\n            }\n\n            case ParseNodeType.Dictionary: {\n                typeResult = getTypeFromDictionary(node, expectedType);\n                break;\n            }\n\n            case ParseNodeType.Lambda: {\n                typeResult = getTypeFromLambda(node, expectedType);\n                break;\n            }\n\n            case ParseNodeType.Set: {\n                typeResult = getTypeFromSet(node, expectedType);\n                break;\n            }\n\n            case ParseNodeType.Assignment: {\n                typeResult = getTypeOfExpression(node.rightExpression);\n                assignTypeToExpression(node.leftExpression, typeResult.type, node.rightExpression);\n                break;\n            }\n\n            case ParseNodeType.AssignmentExpression: {\n                typeResult = getTypeOfExpression(node.rightExpression);\n                assignTypeToExpression(node.name, typeResult.type, node.rightExpression);\n                break;\n            }\n\n            case ParseNodeType.Yield: {\n                typeResult = getTypeFromYield(node);\n                break;\n            }\n\n            case ParseNodeType.YieldFrom: {\n                typeResult = getTypeFromYieldFrom(node);\n                break;\n            }\n\n            case ParseNodeType.Unpack: {\n                const iterType = getTypeOfExpression(node.expression, expectedType).type;\n                const type = getTypeFromIterable(iterType, /* isAsync */ false, node, /* supportGetItem */ false);\n                typeResult = { type, unpackedType: iterType, node };\n                break;\n            }\n\n            case ParseNodeType.TypeAnnotation: {\n                typeResult = getTypeOfExpression(\n                    node.typeAnnotation,\n                    undefined,\n                    EvaluatorFlags.EvaluateStringLiteralAsType |\n                        EvaluatorFlags.ParamSpecDisallowed |\n                        EvaluatorFlags.ExpectingType\n                );\n                break;\n            }\n\n            case ParseNodeType.Error: {\n                // Evaluate the child expression as best we can so the\n                // type information is cached for the completion handler.\n                suppressDiagnostics(() => {\n                    if (node.child) {\n                        getTypeOfExpression(node.child);\n                    }\n                });\n                typeResult = { type: UnknownType.create(), node };\n                break;\n            }\n        }\n\n        if (!typeResult) {\n            // We shouldn't get here. If we do, report an error.\n            fail(`Unhandled expression type '${ParseTreeUtils.printExpression(node)}'`);\n        }\n\n        if (reportExpectingTypeErrors) {\n            const resultType = transformTypeObjectToClass(typeResult.type);\n            if (!TypeBase.isInstantiable(resultType)) {\n                const isEmptyTuple =\n                    isObject(resultType) &&\n                    isTupleClass(resultType.classType) &&\n                    resultType.classType.typeArguments?.length === 0;\n\n                if ((flags & EvaluatorFlags.AllowEmptyTupleAsType) === 0 || !isEmptyTuple) {\n                    addExpectedClassDiagnostic(typeResult.type, node);\n                }\n            }\n        }\n\n        // Don't update the type cache with an unbound type that results from\n        // a resolution cycle. The cache will be updated when the stack unwinds\n        // and the type is fully evaluated.\n        if (!typeResult.isResolutionCyclical) {\n            writeTypeCache(node, typeResult.type);\n        }\n\n        return typeResult;\n    }\n\n    function isAnnotationEvaluationPostponed(fileInfo: AnalyzerFileInfo) {\n        return fileInfo.futureImports.get('annotations') !== undefined || fileInfo.isStubFile;\n    }\n\n    function getTypeOfAnnotation(node: ExpressionNode, allowFinal = false, associateTypeVarsWithScope = false): Type {\n        const fileInfo = getFileInfo(node);\n\n        // Special-case the typing.pyi file, which contains some special\n        // types that the type analyzer needs to interpret differently.\n        if (fileInfo.isTypingStubFile || fileInfo.isTypingExtensionsStubFile) {\n            const specialType = handleTypingStubTypeAnnotation(node);\n            if (specialType) {\n                writeTypeCache(node, specialType);\n                return specialType;\n            }\n        }\n\n        let evaluatorFlags =\n            EvaluatorFlags.ExpectingType |\n            EvaluatorFlags.ConvertEllipsisToAny |\n            EvaluatorFlags.EvaluateStringLiteralAsType |\n            EvaluatorFlags.ParamSpecDisallowed;\n\n        if (isAnnotationEvaluationPostponed(fileInfo)) {\n            evaluatorFlags |= EvaluatorFlags.AllowForwardReferences;\n        }\n\n        if (associateTypeVarsWithScope) {\n            evaluatorFlags |= EvaluatorFlags.AssociateTypeVarsWithCurrentScope;\n        } else {\n            evaluatorFlags |= EvaluatorFlags.DisallowTypeVarsWithoutScopeId;\n        }\n\n        // If the annotation is part of a comment, allow forward references\n        // even if it's not enclosed in quotes.\n        if (node?.parent?.nodeType === ParseNodeType.Assignment && node.parent.typeAnnotationComment === node) {\n            evaluatorFlags |= EvaluatorFlags.AllowForwardReferences;\n        } else if (node?.parent?.nodeType === ParseNodeType.FunctionAnnotation) {\n            if (node.parent.returnTypeAnnotation === node || node.parent.paramTypeAnnotations.some((n) => n === node)) {\n                evaluatorFlags |= EvaluatorFlags.AllowForwardReferences;\n            }\n        } else if (node?.parent?.nodeType === ParseNodeType.Parameter) {\n            if (node.parent.typeAnnotationComment === node) {\n                evaluatorFlags |= EvaluatorFlags.AllowForwardReferences;\n            }\n        }\n\n        if (!allowFinal) {\n            evaluatorFlags |= EvaluatorFlags.FinalDisallowed;\n        }\n\n        const classType = getTypeOfExpression(node, /* expectedType */ undefined, evaluatorFlags).type;\n\n        return convertToInstance(classType);\n    }\n\n    function getTypeFromDecorator(node: DecoratorNode, functionOrClassType: Type): Type {\n        const baseTypeResult = getTypeOfExpression(\n            node.leftExpression,\n            /* expectedType */ undefined,\n            EvaluatorFlags.DoNotSpecialize\n        );\n\n        let decoratorCall = baseTypeResult;\n\n        // If the decorator has arguments, evaluate that call first.\n        if (node.arguments) {\n            const argList = node.arguments.map((arg) => {\n                const functionArg: FunctionArgument = {\n                    valueExpression: arg.valueExpression,\n                    argumentCategory: arg.argumentCategory,\n                    name: arg.name,\n                };\n                return functionArg;\n            });\n\n            // Evaluate the decorator. Don't check for unknown arguments\n            // because these errors will already be reported as unknown\n            // parameters.\n            decoratorCall = getTypeFromCallWithBaseType(\n                node,\n                argList,\n                decoratorCall,\n                undefined,\n                EvaluatorFlags.DoNotCheckForUnknownArgs\n            );\n        }\n\n        const argList = [\n            {\n                argumentCategory: ArgumentCategory.Simple,\n                type: functionOrClassType,\n            },\n        ];\n\n        return getTypeFromCallWithBaseType(\n            node,\n            argList,\n            decoratorCall,\n            undefined,\n            EvaluatorFlags.DoNotCheckForUnknownArgs | EvaluatorFlags.DoNotSpecialize\n        ).type;\n    }\n\n    // Gets a member type from an object and if it's a function binds\n    // it to the object. If bindToClass is undefined, the binding is done\n    // using the objectType parameter. Callers can specify these separately\n    // to handle the case where we're fetching the object member from a\n    // metaclass but binding to the class.\n    function getTypeFromObjectMember(\n        errorNode: ExpressionNode,\n        objectType: ObjectType,\n        memberName: string,\n        usage: EvaluatorUsage,\n        diag: DiagnosticAddendum,\n        memberAccessFlags = MemberAccessFlags.None,\n        bindToClass?: ClassType\n    ): Type | undefined {\n        const memberInfo = getTypeFromClassMemberName(\n            errorNode,\n            objectType.classType,\n            memberName,\n            usage,\n            diag,\n            memberAccessFlags | MemberAccessFlags.DisallowClassVarWrites\n        );\n\n        let resultType = memberInfo ? memberInfo.type : undefined;\n        if (resultType) {\n            if (\n                resultType.category === TypeCategory.Function ||\n                resultType.category === TypeCategory.OverloadedFunction\n            ) {\n                if (memberInfo!.isClassMember) {\n                    resultType = bindFunctionToClassOrObject(\n                        bindToClass || objectType,\n                        resultType,\n                        !!bindToClass,\n                        errorNode\n                    );\n                }\n            }\n        }\n\n        return resultType;\n    }\n\n    // Gets a member type from a class and if it's a function binds\n    // it to the object.\n    function getTypeFromClassMember(\n        errorNode: ExpressionNode,\n        classType: ClassType,\n        memberName: string,\n        usage: EvaluatorUsage,\n        diag: DiagnosticAddendum,\n        memberAccessFlags = MemberAccessFlags.None\n    ): Type | undefined {\n        let memberInfo = getTypeFromClassMemberName(\n            errorNode,\n            classType,\n            memberName,\n            usage,\n            diag,\n            memberAccessFlags | MemberAccessFlags.SkipInstanceMembers | MemberAccessFlags.SkipGetAttributeCheck\n        );\n        let isMetaclassMember = false;\n\n        // If it wasn't found on the class, see if it's part of the metaclass.\n        if (!memberInfo) {\n            const metaclass = classType.details.effectiveMetaclass;\n            if (metaclass && isClass(metaclass)) {\n                memberInfo = getTypeFromClassMemberName(\n                    errorNode,\n                    metaclass,\n                    memberName,\n                    usage,\n                    new DiagnosticAddendum(),\n                    memberAccessFlags,\n                    classType\n                );\n                isMetaclassMember = true;\n            }\n        }\n\n        let resultType = memberInfo ? memberInfo.type : undefined;\n        if (resultType) {\n            if (\n                resultType.category === TypeCategory.Function ||\n                resultType.category === TypeCategory.OverloadedFunction\n            ) {\n                if (memberInfo!.isClassMember) {\n                    resultType = bindFunctionToClassOrObject(\n                        classType,\n                        resultType,\n                        /* treatAsClassMember */ isMetaclassMember,\n                        errorNode\n                    );\n                }\n            }\n        }\n\n        return resultType;\n    }\n\n    function getBoundMethod(\n        classType: ClassType,\n        memberName: string,\n        treatAsClassMember: boolean\n    ): FunctionType | OverloadedFunctionType | undefined {\n        const aliasClass = classType.details.aliasClass;\n        if (aliasClass) {\n            classType = aliasClass;\n        }\n\n        const memberInfo = lookUpClassMember(\n            classType,\n            memberName,\n            ClassMemberLookupFlags.SkipInstanceVariables | ClassMemberLookupFlags.SkipObjectBaseClass\n        );\n\n        if (memberInfo) {\n            const unboundMethodType = getTypeOfMember(memberInfo);\n            if (\n                unboundMethodType.category === TypeCategory.Function ||\n                unboundMethodType.category === TypeCategory.OverloadedFunction\n            ) {\n                const boundMethod = bindFunctionToClassOrObject(\n                    ObjectType.create(classType),\n                    unboundMethodType,\n                    treatAsClassMember\n                );\n\n                if (boundMethod) {\n                    if (\n                        boundMethod.category === TypeCategory.Function ||\n                        boundMethod.category === TypeCategory.OverloadedFunction\n                    ) {\n                        return boundMethod;\n                    }\n                }\n            }\n        }\n\n        return undefined;\n    }\n\n    function getTypeAnnotationForParameter(node: FunctionNode, paramIndex: number): ExpressionNode | undefined {\n        if (paramIndex >= node.parameters.length) {\n            return undefined;\n        }\n\n        const param = node.parameters[paramIndex];\n        if (param.typeAnnotation) {\n            return param.typeAnnotation;\n        } else if (param.typeAnnotationComment) {\n            return param.typeAnnotationComment;\n        }\n\n        if (!node.functionAnnotationComment || node.functionAnnotationComment.isParamListEllipsis) {\n            return undefined;\n        }\n\n        // We may need to skip the first parameter if this is a method.\n        const containingClassNode = ParseTreeUtils.getEnclosingClass(node, true);\n        const functionFlags = getFunctionFlagsFromDecorators(node, !!containingClassNode);\n\n        let firstCommentAnnotationIndex = 0;\n        if (containingClassNode && (functionFlags & FunctionTypeFlags.StaticMethod) === 0) {\n            firstCommentAnnotationIndex = 1;\n        }\n\n        const paramAnnotations = node.functionAnnotationComment.paramTypeAnnotations;\n        const adjIndex = paramIndex - firstCommentAnnotationIndex;\n        if (adjIndex < 0 || adjIndex >= paramAnnotations.length) {\n            return undefined;\n        }\n\n        return paramAnnotations[adjIndex];\n    }\n\n    // Returns the signature(s) associated with a call node that contains\n    // the specified node. It also returns the index of the argument\n    // that contains the node.\n    function getCallSignatureInfo(\n        node: ParseNode,\n        insertionOffset: number,\n        tokens: TextRangeCollection<Token>\n    ): CallSignatureInfo | undefined {\n        // Find the call node that contains the specified node.\n        let curNode: ParseNode | undefined = node;\n        let callNode: CallNode | DecoratorNode | undefined;\n        while (curNode !== undefined) {\n            if (curNode.nodeType === ParseNodeType.Call || curNode.nodeType === ParseNodeType.Decorator) {\n                callNode = curNode;\n                break;\n            }\n            curNode = curNode.parent;\n        }\n\n        if (!callNode || !callNode.arguments) {\n            return undefined;\n        }\n\n        if (insertionOffset >= TextRange.getEnd(callNode)) {\n            return undefined;\n        }\n\n        const exprNode = callNode.leftExpression;\n        const callType = getType(exprNode);\n        if (callType === undefined) {\n            return undefined;\n        }\n\n        const argList: FunctionArgument[] = [];\n        let addedActive = false;\n        let previousCategory = ArgumentCategory.Simple;\n\n        // Empty arguments do not enter the AST as nodes, but instead are left blank.\n        // Instead, we detect when we appear to be between two known arguments or at the\n        // end of the argument list and insert a fake argument of an unknown type to have\n        // something to match later.\n        function addFakeArg() {\n            argList.push({\n                argumentCategory: previousCategory,\n                type: UnknownType.create(),\n                active: true,\n            });\n        }\n\n        callNode.arguments.forEach((arg) => {\n            let active = false;\n\n            if (!addedActive) {\n                // Calculate the argument's bounds including whitespace and colons.\n                let start = arg.start;\n                const startTokenIndex = tokens.getItemAtPosition(start);\n                if (startTokenIndex >= 0) {\n                    start = TextRange.getEnd(tokens.getItemAt(startTokenIndex - 1));\n                }\n\n                let end = TextRange.getEnd(arg);\n                const endTokenIndex = tokens.getItemAtPosition(end);\n                if (endTokenIndex >= 0) {\n                    // Find the true end of the argument by searching for the\n                    // terminating comma or parenthesis.\n                    for (let i = endTokenIndex; i < tokens.count; i++) {\n                        const tok = tokens.getItemAt(i);\n\n                        switch (tok.type) {\n                            case TokenType.Comma:\n                            case TokenType.CloseParenthesis:\n                                break;\n                            default:\n                                continue;\n                        }\n\n                        end = TextRange.getEnd(tok);\n                        break;\n                    }\n                }\n\n                if (insertionOffset < end) {\n                    if (insertionOffset >= start) {\n                        active = true;\n                    } else {\n                        addFakeArg();\n                    }\n                    addedActive = true;\n                }\n            }\n\n            previousCategory = arg.argumentCategory;\n\n            argList.push({\n                valueExpression: arg.valueExpression,\n                argumentCategory: arg.argumentCategory,\n                name: arg.name,\n                active: active,\n            });\n        });\n\n        if (!addedActive) {\n            addFakeArg();\n        }\n\n        const signatures: CallSignature[] = [];\n\n        function addOneFunctionToSignature(type: FunctionType) {\n            let callResult: CallResult | undefined;\n\n            useSpeculativeMode(callNode!, () => {\n                callResult = validateFunctionArguments(\n                    exprNode,\n                    argList,\n                    type,\n                    new TypeVarMap(),\n                    /* skipUnknownArgCheck */ true,\n                    /* inferReturnTypeIfNeeded */ true,\n                    undefined\n                );\n            });\n\n            signatures.push({\n                type,\n                activeParam: callResult?.activeParam,\n            });\n        }\n\n        function addFunctionToSignature(type: FunctionType | OverloadedFunctionType) {\n            if (type.category === TypeCategory.Function) {\n                addOneFunctionToSignature(type);\n            } else {\n                type.overloads.forEach(addOneFunctionToSignature);\n            }\n        }\n\n        doForSubtypes(callType, (subtype) => {\n            switch (subtype.category) {\n                case TypeCategory.Function:\n                case TypeCategory.OverloadedFunction: {\n                    addFunctionToSignature(subtype);\n                    break;\n                }\n\n                case TypeCategory.Class: {\n                    let methodType: FunctionType | OverloadedFunctionType | undefined;\n\n                    // Try to get the __init__ method first because it typically has\n                    // more type information than __new__.\n                    methodType = getBoundMethod(subtype, '__init__', /* treatAsClassMember */ false);\n\n                    if (!methodType) {\n                        // If there was no __init__ method, use the __new__ method\n                        // instead.\n                        methodType = getBoundMethod(subtype, '__new__', /* treatAsClassMember */ true);\n                    }\n\n                    if (methodType) {\n                        addFunctionToSignature(methodType);\n                    }\n                    break;\n                }\n\n                case TypeCategory.Object: {\n                    const methodType = getBoundMethod(subtype.classType, '__call__', /* treatAsClassMember */ false);\n                    if (methodType) {\n                        addFunctionToSignature(methodType);\n                    }\n                    break;\n                }\n            }\n\n            return undefined;\n        });\n\n        if (signatures.length === 0) {\n            return undefined;\n        }\n\n        return {\n            callNode,\n            signatures,\n        };\n    }\n\n    // Determines whether the specified expression is an explicit TypeAlias declaration.\n    function isDeclaredTypeAlias(expression: ExpressionNode): boolean {\n        if (expression.nodeType === ParseNodeType.TypeAnnotation) {\n            if (expression.valueExpression.nodeType === ParseNodeType.Name) {\n                const symbolWithScope = lookUpSymbolRecursive(\n                    expression,\n                    expression.valueExpression.value,\n                    /* honorCodeFlow */ false\n                );\n                if (symbolWithScope) {\n                    const symbol = symbolWithScope.symbol;\n                    return symbol.getDeclarations().find((decl) => isExplicitTypeAliasDeclaration(decl)) !== undefined;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    // Determines whether the specified expression is possibly an implicit type alias.\n    // In Python, type aliases look the same as simple assignments, but we use some heuristics\n    // to tell them apart.\n    function isPossibleImplicitTypeAlias(expression: ExpressionNode): boolean {\n        if (expression.nodeType === ParseNodeType.Name) {\n            const symbolWithScope = lookUpSymbolRecursive(expression, expression.value, /* honorCodeFlow */ false);\n            if (symbolWithScope) {\n                const symbol = symbolWithScope.symbol;\n                return symbol.getDeclarations().find((decl) => isPossibleTypeAliasDeclaration(decl)) !== undefined;\n            }\n        }\n\n        return false;\n    }\n\n    // Determines whether the specified expression is a symbol with a declared type\n    // (either a simple name or a member variable). If so, the type is returned.\n    function getDeclaredTypeForExpression(expression: ExpressionNode): Type | undefined {\n        let symbol: Symbol | undefined;\n        let classOrObjectBase: ClassType | ObjectType | undefined;\n\n        switch (expression.nodeType) {\n            case ParseNodeType.Name: {\n                const symbolWithScope = lookUpSymbolRecursive(expression, expression.value, /* honorCodeFlow */ true);\n                if (symbolWithScope) {\n                    symbol = symbolWithScope.symbol;\n                }\n                break;\n            }\n\n            case ParseNodeType.TypeAnnotation: {\n                return getDeclaredTypeForExpression(expression.valueExpression);\n            }\n\n            case ParseNodeType.MemberAccess: {\n                const baseType = makeTypeVarsConcrete(getTypeOfExpression(expression.leftExpression).type);\n                let classMemberInfo: ClassMember | undefined;\n\n                if (isObject(baseType)) {\n                    classMemberInfo = lookUpObjectMember(\n                        baseType,\n                        expression.memberName.value,\n                        ClassMemberLookupFlags.DeclaredTypesOnly\n                    );\n                    classOrObjectBase = baseType;\n                } else if (isClass(baseType)) {\n                    classMemberInfo = lookUpClassMember(\n                        baseType,\n                        expression.memberName.value,\n                        ClassMemberLookupFlags.SkipInstanceVariables | ClassMemberLookupFlags.DeclaredTypesOnly\n                    );\n                    classOrObjectBase = baseType;\n                }\n\n                if (classMemberInfo) {\n                    symbol = classMemberInfo.symbol;\n                }\n                break;\n            }\n\n            case ParseNodeType.Index: {\n                const baseType = getDeclaredTypeForExpression(expression.baseExpression);\n                if (baseType && isObject(baseType)) {\n                    const setItemMember = lookUpClassMember(baseType.classType, '__setitem__');\n                    if (setItemMember) {\n                        const setItemType = getTypeOfMember(setItemMember);\n                        if (setItemType.category === TypeCategory.Function) {\n                            const boundFunction = bindFunctionToClassOrObject(\n                                baseType,\n                                setItemType,\n                                /* treatAsClassMember */ false,\n                                expression\n                            );\n                            if (boundFunction && boundFunction.category === TypeCategory.Function) {\n                                if (boundFunction.details.parameters.length === 2) {\n                                    const paramType = FunctionType.getEffectiveParameterType(boundFunction, 1);\n                                    if (!isAnyOrUnknown(paramType)) {\n                                        return paramType;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                break;\n            }\n        }\n\n        if (symbol) {\n            let declaredType = getDeclaredTypeOfSymbol(symbol);\n            if (declaredType) {\n                // If it's a property, we need to get the fset type.\n                if (isProperty(declaredType)) {\n                    const setterInfo = lookUpClassMember((declaredType as ObjectType).classType, 'fset');\n                    const setter = setterInfo ? getTypeOfMember(setterInfo) : undefined;\n                    if (!setter || setter.category !== TypeCategory.Function || setter.details.parameters.length < 2) {\n                        return undefined;\n                    }\n\n                    declaredType = setter.details.parameters[1].type;\n                }\n\n                if (classOrObjectBase) {\n                    declaredType = bindFunctionToClassOrObject(\n                        classOrObjectBase,\n                        declaredType,\n                        /* treatAsClassMember */ false,\n                        expression\n                    );\n                }\n\n                return declaredType;\n            }\n        }\n\n        return undefined;\n    }\n\n    // Applies an \"await\" operation to the specified type and returns\n    // the result. According to PEP 492, await operates on:\n    // 1) a generator object\n    // 2) an Awaitable (object that provides an __await__ that\n    //    returns a generator object)\n    // If errorNode is undefined, no errors are reported.\n    function getTypeFromAwaitable(type: Type, errorNode?: ParseNode): Type {\n        return doForSubtypes(type, (subtype) => {\n            if (isAnyOrUnknown(subtype)) {\n                return subtype;\n            }\n\n            const generatorReturnType = getReturnTypeFromGenerator(subtype);\n            if (generatorReturnType) {\n                return generatorReturnType;\n            }\n\n            if (isObject(subtype)) {\n                const awaitReturnType = getSpecializedReturnType(subtype, '__await__', errorNode);\n                if (awaitReturnType) {\n                    if (isAnyOrUnknown(awaitReturnType)) {\n                        return awaitReturnType;\n                    }\n\n                    if (isObject(awaitReturnType)) {\n                        const iterReturnType = getSpecializedReturnType(awaitReturnType, '__iter__', errorNode);\n\n                        if (iterReturnType) {\n                            const generatorReturnType = getReturnTypeFromGenerator(awaitReturnType);\n                            if (generatorReturnType) {\n                                return generatorReturnType;\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (errorNode) {\n                const fileInfo = getFileInfo(errorNode);\n                addDiagnostic(\n                    fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                    DiagnosticRule.reportGeneralTypeIssues,\n                    Localizer.Diagnostic.typeNotAwaitable().format({ type: printType(subtype) }),\n                    errorNode\n                );\n            }\n\n            return UnknownType.create();\n        });\n    }\n\n    // Validates that the type is iterable and returns the iterated type.\n    // If errorNode is undefined, no errors are reported.\n    function getTypeFromIterable(\n        type: Type,\n        isAsync: boolean,\n        errorNode: ParseNode | undefined,\n        supportGetItem: boolean\n    ): Type {\n        const iterMethodName = isAsync ? '__aiter__' : '__iter__';\n        const nextMethodName = isAsync ? '__anext__' : '__next__';\n        const getItemMethodName = supportGetItem ? '__getitem__' : '';\n\n        type = makeTypeVarsConcrete(type);\n\n        if (type.category === TypeCategory.Union && type.subtypes.some((t) => isNone(t))) {\n            if (errorNode) {\n                addDiagnostic(\n                    getFileInfo(errorNode).diagnosticRuleSet.reportOptionalIterable,\n                    DiagnosticRule.reportOptionalIterable,\n                    Localizer.Diagnostic.noneNotIterable(),\n                    errorNode\n                );\n            }\n            type = removeNoneFromUnion(type);\n        }\n\n        const getIteratorReturnType = (\n            objType: ObjectType,\n            metaclass: ClassType | undefined,\n            diag: DiagnosticAddendum\n        ): Type | undefined => {\n            const iterReturnType = metaclass\n                ? getSpecializedReturnTypeForMetaclassMethod(metaclass, objType.classType, iterMethodName, errorNode)\n                : getSpecializedReturnType(objType, iterMethodName, errorNode);\n            if (!iterReturnType) {\n                // There was no __iter__. See if we can fall back to\n                // the __getitem__ method instead.\n                if (getItemMethodName) {\n                    const getItemReturnType = getSpecializedReturnType(objType, getItemMethodName, errorNode);\n                    if (getItemReturnType) {\n                        return getItemReturnType;\n                    }\n                }\n\n                diag.addMessage(Localizer.Diagnostic.methodNotDefined().format({ name: iterMethodName }));\n            } else {\n                if (isAnyOrUnknown(iterReturnType)) {\n                    return iterReturnType;\n                }\n\n                if (isObject(iterReturnType)) {\n                    const nextReturnType = getSpecializedReturnType(iterReturnType, nextMethodName, errorNode);\n\n                    if (!nextReturnType) {\n                        diag.addMessage(\n                            Localizer.Diagnostic.methodNotDefinedOnType().format({\n                                name: nextMethodName,\n                                type: printType(iterReturnType),\n                            })\n                        );\n                    } else {\n                        if (!isAsync) {\n                            return nextReturnType;\n                        }\n\n                        // If it's an async iteration, there's an implicit\n                        // 'await' operator applied.\n                        return getTypeFromAwaitable(nextReturnType, errorNode);\n                    }\n                } else {\n                    diag.addMessage(Localizer.Diagnostic.methodReturnsNonObject().format({ name: iterMethodName }));\n                }\n            }\n\n            return undefined;\n        };\n\n        return doForSubtypes(type, (subtype) => {\n            if (isAnyOrUnknown(subtype)) {\n                return subtype;\n            }\n\n            const diag = new DiagnosticAddendum();\n            if (isAnyOrUnknown(subtype)) {\n                return subtype;\n            } else if (isObject(subtype)) {\n                const returnType = getIteratorReturnType(subtype, undefined, diag);\n                if (returnType) {\n                    return returnType;\n                }\n            } else if (isClass(subtype)) {\n                // Handle the case where the class itself is iterable.\n                // This is true for classes that derive from Enum, for example.\n                const metaclassType = subtype.details.effectiveMetaclass;\n                if (metaclassType && isClass(metaclassType)) {\n                    const returnType = getIteratorReturnType(ObjectType.create(subtype), metaclassType, diag);\n                    if (returnType) {\n                        return returnType;\n                    }\n                }\n            }\n\n            if (errorNode) {\n                addDiagnostic(\n                    getFileInfo(errorNode).diagnosticRuleSet.reportGeneralTypeIssues,\n                    DiagnosticRule.reportGeneralTypeIssues,\n                    Localizer.Diagnostic.typeNotIterable().format({ type: printType(subtype) }) + diag.getString(),\n                    errorNode\n                );\n            }\n\n            return UnknownType.create();\n        });\n    }\n\n    // Validates fields for compatibility with a dataclass and synthesizes\n    // an appropriate __new__ and __init__ methods plus a __dataclass_fields__\n    // class variable.\n    function synthesizeDataClassMethods(node: ClassNode, classType: ClassType, skipSynthesizeInit: boolean) {\n        assert(ClassType.isDataClass(classType));\n\n        const newType = FunctionType.createInstance(\n            '__new__',\n            '',\n            FunctionTypeFlags.ConstructorMethod | FunctionTypeFlags.SynthesizedMethod\n        );\n        const initType = FunctionType.createInstance('__init__', '', FunctionTypeFlags.SynthesizedMethod);\n\n        FunctionType.addParameter(newType, {\n            category: ParameterCategory.Simple,\n            name: 'cls',\n            type: classType,\n        });\n        FunctionType.addDefaultParameters(newType);\n        newType.details.declaredReturnType = ObjectType.create(classType);\n\n        FunctionType.addParameter(initType, {\n            category: ParameterCategory.Simple,\n            name: 'self',\n            type: ObjectType.create(classType),\n        });\n        initType.details.declaredReturnType = NoneType.createInstance();\n\n        // Maintain a list of all dataclass entries (including\n        // those from inherited classes) plus a list of only those\n        // entries added by this class.\n        const localDataClassEntries: DataClassEntry[] = [];\n        const fullDataClassEntries: DataClassEntry[] = [];\n        const allAncestorsKnown = addInheritedDataClassEntries(classType, fullDataClassEntries);\n\n        if (!allAncestorsKnown) {\n            // If one or more ancestor classes have an unknown type, we cannot\n            // safely determine the parameter list, so we'll accept any parameters\n            // to avoid a false positive.\n            FunctionType.addDefaultParameters(initType);\n        }\n\n        // Maintain a list of \"type evaluators\".\n        type TypeEvaluator = () => Type;\n        const localEntryTypeEvaluator: { entry: DataClassEntry; evaluator: TypeEvaluator }[] = [];\n\n        node.suite.statements.forEach((statementList) => {\n            if (statementList.nodeType === ParseNodeType.StatementList) {\n                statementList.statements.forEach((statement) => {\n                    let variableNameNode: NameNode | undefined;\n                    let variableTypeEvaluator: TypeEvaluator | undefined;\n                    let hasDefaultValue = false;\n                    let includeInInit = true;\n\n                    if (statement.nodeType === ParseNodeType.Assignment) {\n                        if (\n                            statement.leftExpression.nodeType === ParseNodeType.TypeAnnotation &&\n                            statement.leftExpression.valueExpression.nodeType === ParseNodeType.Name\n                        ) {\n                            variableNameNode = statement.leftExpression.valueExpression;\n                            variableTypeEvaluator = () =>\n                                getTypeOfAnnotation(\n                                    (statement.leftExpression as TypeAnnotationNode).typeAnnotation,\n                                    /* allowFinal */ true\n                                );\n                        }\n\n                        hasDefaultValue = true;\n\n                        // If the RHS of the assignment is assigning a field instance where the\n                        // \"init\" parameter is set to false, do not include it in the init method.\n                        if (statement.rightExpression.nodeType === ParseNodeType.Call) {\n                            const callType = getTypeOfExpression(statement.rightExpression.leftExpression).type;\n                            if (\n                                callType.category === TypeCategory.OverloadedFunction &&\n                                callType.overloads[0].details.builtInName === 'field'\n                            ) {\n                                const initArg = statement.rightExpression.arguments.find(\n                                    (arg) => arg.name?.value === 'init'\n                                );\n                                if (initArg && initArg.valueExpression) {\n                                    const value = evaluateStaticBoolExpression(\n                                        initArg.valueExpression,\n                                        getFileInfo(node).executionEnvironment\n                                    );\n                                    if (value === false) {\n                                        includeInInit = false;\n                                    }\n                                }\n\n                                hasDefaultValue = statement.rightExpression.arguments.some(\n                                    (arg) => arg.name?.value === 'default' || arg.name?.value === 'default_factory'\n                                );\n                            }\n                        }\n                    } else if (statement.nodeType === ParseNodeType.TypeAnnotation) {\n                        if (statement.valueExpression.nodeType === ParseNodeType.Name) {\n                            variableNameNode = statement.valueExpression;\n                            variableTypeEvaluator = () =>\n                                getTypeOfAnnotation(statement.typeAnnotation, /* allowFinal */ true);\n                        }\n                    }\n\n                    if (variableNameNode && variableTypeEvaluator) {\n                        const variableName = variableNameNode.value;\n\n                        // Don't include class vars. PEP 557 indicates that they shouldn't\n                        // be considered data class entries.\n                        const variableSymbol = classType.details.fields.get(variableName);\n                        if (!variableSymbol?.isClassVar()) {\n                            // Create a new data class entry, but defer evaluation of the type until\n                            // we've compiled the full list of data class entries for this class. This\n                            // allows us to handle circular references in types.\n                            const dataClassEntry: DataClassEntry = {\n                                name: variableName,\n                                hasDefault: hasDefaultValue,\n                                includeInInit,\n                                type: UnknownType.create(),\n                            };\n                            localEntryTypeEvaluator.push({ entry: dataClassEntry, evaluator: variableTypeEvaluator });\n\n                            // Add the new entry to the local entry list.\n                            let insertIndex = localDataClassEntries.findIndex((e) => e.name === variableName);\n                            if (insertIndex >= 0) {\n                                localDataClassEntries[insertIndex] = dataClassEntry;\n                            } else {\n                                localDataClassEntries.push(dataClassEntry);\n                            }\n\n                            // Add the new entry to the full entry list.\n                            insertIndex = fullDataClassEntries.findIndex((p) => p.name === variableName);\n                            if (insertIndex >= 0) {\n                                fullDataClassEntries[insertIndex] = dataClassEntry;\n                            } else {\n                                fullDataClassEntries.push(dataClassEntry);\n                                insertIndex = fullDataClassEntries.length - 1;\n                            }\n\n                            // If we've already seen a entry with a default value defined,\n                            // all subsequent entries must also have default values.\n                            const firstDefaultValueIndex = fullDataClassEntries.findIndex(\n                                (p) => p.hasDefault && p.includeInInit\n                            );\n                            if (\n                                includeInInit &&\n                                !hasDefaultValue &&\n                                firstDefaultValueIndex >= 0 &&\n                                firstDefaultValueIndex < insertIndex\n                            ) {\n                                addError(Localizer.Diagnostic.dataClassFieldWithDefault(), variableNameNode);\n                            }\n                        }\n                    }\n                });\n            }\n        });\n\n        classType.details.dataClassEntries = localDataClassEntries;\n\n        // Now that the dataClassEntries field has been set with a complete list\n        // of local data class entries for this class, perform deferred type\n        // evaluations. This could involve circular type dependencies, so it's\n        // required that the list be complete (even if types are not yet accurate)\n        // before we perform the type evaluations.\n        localEntryTypeEvaluator.forEach((entryEvaluator) => {\n            entryEvaluator.entry.type = entryEvaluator.evaluator();\n        });\n\n        const symbolTable = classType.details.fields;\n        if (!skipSynthesizeInit && allAncestorsKnown) {\n            fullDataClassEntries.forEach((entry) => {\n                if (entry.includeInInit) {\n                    const functionParam: FunctionParameter = {\n                        category: ParameterCategory.Simple,\n                        name: entry.name,\n                        hasDefault: entry.hasDefault,\n                        hasDeclaredType: true,\n                        type: entry.type,\n                    };\n\n                    FunctionType.addParameter(initType, functionParam);\n                }\n            });\n\n            symbolTable.set('__init__', Symbol.createWithType(SymbolFlags.ClassMember, initType));\n            symbolTable.set('__new__', Symbol.createWithType(SymbolFlags.ClassMember, newType));\n        }\n\n        let dictType = getBuiltInType(node, 'Dict');\n        if (isClass(dictType)) {\n            dictType = ObjectType.create(\n                ClassType.cloneForSpecialization(\n                    dictType,\n                    [getBuiltInObject(node, 'str'), AnyType.create()],\n                    /* isTypeArgumentExplicit */ false\n                )\n            );\n        }\n        symbolTable.set('__dataclass_fields__', Symbol.createWithType(SymbolFlags.ClassMember, dictType));\n\n        // If this dataclass derived from a NamedTuple, update the NamedTuple with\n        // the specialized entry types.\n        updateNamedTupleBaseClass(\n            classType,\n            fullDataClassEntries.map((entry) => entry.type),\n            /* isTypeArgumentExplicit */ true\n        );\n    }\n\n    function synthesizeTypedDictClassMethods(node: ClassNode | ExpressionNode, classType: ClassType) {\n        assert(ClassType.isTypedDictClass(classType));\n\n        // Synthesize a __new__ method.\n        const newType = FunctionType.createInstance(\n            '__new__',\n            '',\n            FunctionTypeFlags.ConstructorMethod | FunctionTypeFlags.SynthesizedMethod\n        );\n        FunctionType.addParameter(newType, {\n            category: ParameterCategory.Simple,\n            name: 'cls',\n            type: classType,\n        });\n        FunctionType.addDefaultParameters(newType);\n        newType.details.declaredReturnType = ObjectType.create(classType);\n\n        // Synthesize an __init__ method.\n        const initType = FunctionType.createInstance('__init__', '', FunctionTypeFlags.SynthesizedMethod);\n        FunctionType.addParameter(initType, {\n            category: ParameterCategory.Simple,\n            name: 'self',\n            type: ObjectType.create(classType),\n        });\n        initType.details.declaredReturnType = NoneType.createInstance();\n\n        // All parameters must be named, so insert an empty \"*\".\n        FunctionType.addParameter(initType, {\n            category: ParameterCategory.VarArgList,\n            type: AnyType.create(),\n        });\n\n        const entries = getTypedDictMembersForClass(classType);\n        entries.forEach((entry, name) => {\n            FunctionType.addParameter(initType, {\n                category: ParameterCategory.Simple,\n                name,\n                hasDefault: !entry.isRequired,\n                type: entry.valueType,\n            });\n        });\n\n        const symbolTable = classType.details.fields;\n        symbolTable.set('__init__', Symbol.createWithType(SymbolFlags.ClassMember, initType));\n        symbolTable.set('__new__', Symbol.createWithType(SymbolFlags.ClassMember, newType));\n\n        const strClass = getBuiltInType(node, 'str');\n\n        // Synthesize a \"get\", pop, and setdefault method for each named entry.\n        if (isClass(strClass)) {\n            const selfParam: FunctionParameter = {\n                category: ParameterCategory.Simple,\n                name: 'self',\n                type: ObjectType.create(classType),\n            };\n            const defaultTypeVar = TypeVarType.createInstance(\n                `__${classType.details.name}_default`,\n                /* isParamSpec */ false\n            );\n\n            const createGetMethod = (keyType: Type, valueType: Type) => {\n                const getOverload = FunctionType.createInstance(\n                    'get',\n                    '',\n                    FunctionTypeFlags.SynthesizedMethod | FunctionTypeFlags.Overloaded\n                );\n                FunctionType.addParameter(getOverload, selfParam);\n                FunctionType.addParameter(getOverload, {\n                    category: ParameterCategory.Simple,\n                    name: 'k',\n                    hasDeclaredType: true,\n                    type: keyType,\n                });\n                FunctionType.addParameter(getOverload, {\n                    category: ParameterCategory.Simple,\n                    name: 'default',\n                    hasDeclaredType: true,\n                    type: valueType,\n                    hasDefault: true,\n                });\n                getOverload.details.declaredReturnType = valueType;\n                return getOverload;\n            };\n\n            const createPopMethods = (keyType: Type, valueType: Type) => {\n                const keyParam: FunctionParameter = {\n                    category: ParameterCategory.Simple,\n                    name: 'k',\n                    hasDeclaredType: true,\n                    type: keyType,\n                };\n\n                const popOverload1 = FunctionType.createInstance(\n                    'pop',\n                    '',\n                    FunctionTypeFlags.SynthesizedMethod | FunctionTypeFlags.Overloaded\n                );\n                FunctionType.addParameter(popOverload1, selfParam);\n                FunctionType.addParameter(popOverload1, keyParam);\n                popOverload1.details.declaredReturnType = valueType;\n\n                const popOverload2 = FunctionType.createInstance(\n                    'pop',\n                    '',\n                    FunctionTypeFlags.SynthesizedMethod | FunctionTypeFlags.Overloaded\n                );\n                FunctionType.addParameter(popOverload2, selfParam);\n                FunctionType.addParameter(popOverload2, keyParam);\n                FunctionType.addParameter(popOverload2, {\n                    category: ParameterCategory.Simple,\n                    name: 'default',\n                    hasDeclaredType: true,\n                    type: defaultTypeVar,\n                    hasDefault: true,\n                });\n                popOverload2.details.declaredReturnType = combineTypes([valueType, defaultTypeVar]);\n                return [popOverload1, popOverload2];\n            };\n\n            const createSetDefaultMethod = (keyType: Type, valueType: Type) => {\n                const setDefaultOverload = FunctionType.createInstance(\n                    'setdefault',\n                    '',\n                    FunctionTypeFlags.SynthesizedMethod | FunctionTypeFlags.Overloaded\n                );\n                FunctionType.addParameter(setDefaultOverload, selfParam);\n                FunctionType.addParameter(setDefaultOverload, {\n                    category: ParameterCategory.Simple,\n                    name: 'k',\n                    hasDeclaredType: true,\n                    type: keyType,\n                });\n                FunctionType.addParameter(setDefaultOverload, {\n                    category: ParameterCategory.Simple,\n                    name: 'default',\n                    hasDeclaredType: true,\n                    type: defaultTypeVar,\n                    hasDefault: true,\n                });\n                setDefaultOverload.details.declaredReturnType = combineTypes([valueType, defaultTypeVar]);\n                return setDefaultOverload;\n            };\n\n            const createDelItemMethod = (keyType: Type) => {\n                const delItemOverload = FunctionType.createInstance(\n                    'delitem',\n                    '',\n                    FunctionTypeFlags.SynthesizedMethod | FunctionTypeFlags.Overloaded\n                );\n                FunctionType.addParameter(delItemOverload, selfParam);\n                FunctionType.addParameter(delItemOverload, {\n                    category: ParameterCategory.Simple,\n                    name: 'k',\n                    hasDeclaredType: true,\n                    type: keyType,\n                });\n                delItemOverload.details.declaredReturnType = NoneType.createInstance();\n                return delItemOverload;\n            };\n\n            const getOverloads: FunctionType[] = [];\n            const popOverloads: FunctionType[] = [];\n            const setDefaultOverloads: FunctionType[] = [];\n\n            entries.forEach((entry, name) => {\n                const nameLiteralType = ObjectType.create(ClassType.cloneWithLiteral(strClass, name));\n\n                getOverloads.push(createGetMethod(nameLiteralType, entry.valueType));\n                popOverloads.push(...createPopMethods(nameLiteralType, entry.valueType));\n                setDefaultOverloads.push(createSetDefaultMethod(nameLiteralType, entry.valueType));\n            });\n\n            // Provide a final overload that handles the general case where the key is\n            // a str but the literal value isn't known.\n            const strType = ObjectType.create(strClass);\n            getOverloads.push(createGetMethod(strType, AnyType.create()));\n            popOverloads.push(...createPopMethods(strType, AnyType.create()));\n            setDefaultOverloads.push(createSetDefaultMethod(strType, AnyType.create()));\n\n            symbolTable.set(\n                'get',\n                Symbol.createWithType(SymbolFlags.ClassMember, OverloadedFunctionType.create(getOverloads))\n            );\n            symbolTable.set(\n                'pop',\n                Symbol.createWithType(SymbolFlags.ClassMember, OverloadedFunctionType.create(popOverloads))\n            );\n            symbolTable.set(\n                'setdefault',\n                Symbol.createWithType(SymbolFlags.ClassMember, OverloadedFunctionType.create(setDefaultOverloads))\n            );\n            symbolTable.set(\n                '__delitem__',\n                Symbol.createWithType(SymbolFlags.ClassMember, createDelItemMethod(strType))\n            );\n        }\n    }\n\n    function getTypingType(node: ParseNode, symbolName: string): Type | undefined {\n        const fileInfo = getFileInfo(node);\n        const typingImportPath = fileInfo.typingModulePath;\n        if (!typingImportPath) {\n            return undefined;\n        }\n\n        const lookupResult = importLookup(typingImportPath);\n        if (!lookupResult) {\n            return undefined;\n        }\n\n        const symbol = lookupResult.symbolTable.get(symbolName);\n        if (!symbol) {\n            return undefined;\n        }\n\n        return getEffectiveTypeOfSymbol(symbol);\n    }\n\n    function isNodeReachable(node: ParseNode): boolean {\n        const flowNode = AnalyzerNodeInfo.getFlowNode(node);\n        if (!flowNode) {\n            return true;\n        }\n\n        return isFlowNodeReachable(flowNode);\n    }\n\n    function isAfterNodeReachable(node: ParseNode): boolean {\n        const returnFlowNode = AnalyzerNodeInfo.getAfterFlowNode(node);\n        if (!returnFlowNode) {\n            return false;\n        }\n\n        return isFlowNodeReachable(returnFlowNode);\n    }\n\n    // Determines whether there is a code flow path from sourceNode to sinkNode.\n    function isFlowPathBetweenNodes(sourceNode: ParseNode, sinkNode: ParseNode) {\n        const sourceFlowNode = AnalyzerNodeInfo.getFlowNode(sourceNode);\n        const sinkFlowNode = AnalyzerNodeInfo.getFlowNode(sinkNode);\n        if (!sourceFlowNode || !sinkFlowNode) {\n            return false;\n        }\n        if (sourceFlowNode === sinkFlowNode) {\n            return true;\n        }\n\n        return isFlowNodeReachable(sinkFlowNode, sourceFlowNode);\n    }\n\n    // Determines whether the specified string literal is part\n    // of a Literal['xxx'] statement. If so, we will not treat\n    // the string as a normal forward-declared type annotation.\n    function isAnnotationLiteralValue(node: StringListNode): boolean {\n        if (node.parent && node.parent.nodeType === ParseNodeType.IndexItems) {\n            const indexItemsNode = node.parent;\n            if (indexItemsNode.parent && indexItemsNode.parent.nodeType === ParseNodeType.Index) {\n                const indexNode = indexItemsNode.parent;\n                const baseType = getTypeOfExpression(indexNode.baseExpression).type;\n                if (baseType && isClass(baseType)) {\n                    if (ClassType.isSpecialBuiltIn(baseType, 'Literal')) {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    function addInformation(message: string, node: ParseNode, range?: TextRange) {\n        return addDiagnosticWithSuppressionCheck('information', message, node, range);\n    }\n\n    function addWarning(message: string, node: ParseNode, range?: TextRange) {\n        return addDiagnosticWithSuppressionCheck('warning', message, node, range);\n    }\n\n    function addError(message: string, node: ParseNode, range?: TextRange) {\n        return addDiagnosticWithSuppressionCheck('error', message, node, range);\n    }\n\n    function addUnusedCode(node: ParseNode, textRange: TextRange) {\n        if (!isDiagnosticSuppressedForNode(node)) {\n            const fileInfo = getFileInfo(node);\n            fileInfo.diagnosticSink.addUnusedCodeWithTextRange(Localizer.Diagnostic.unreachableCode(), textRange);\n        }\n    }\n\n    function addDiagnosticWithSuppressionCheck(\n        diagLevel: DiagnosticLevel,\n        message: string,\n        node: ParseNode,\n        range?: TextRange\n    ) {\n        if (!isDiagnosticSuppressedForNode(node)) {\n            const fileInfo = getFileInfo(node);\n            return fileInfo.diagnosticSink.addDiagnosticWithTextRange(diagLevel, message, range || node);\n        }\n\n        return undefined;\n    }\n\n    function isDiagnosticSuppressedForNode(node: ParseNode) {\n        return isDiagnosticSuppressed || isSpeculativeMode(node) || incompleteTypeTracker.isIncompleteTypeMode();\n    }\n\n    function addDiagnostic(diagLevel: DiagnosticLevel, rule: string, message: string, node: ParseNode) {\n        if (diagLevel === 'none') {\n            return undefined;\n        }\n\n        const diagnostic = addDiagnosticWithSuppressionCheck(diagLevel, message, node);\n        if (diagnostic) {\n            diagnostic.setRule(rule);\n        }\n\n        return diagnostic;\n    }\n\n    function addDiagnosticForTextRange(\n        fileInfo: AnalyzerFileInfo,\n        diagLevel: DiagnosticLevel,\n        rule: string,\n        message: string,\n        range: TextRange\n    ) {\n        if (diagLevel === 'none') {\n            return undefined;\n        }\n\n        const diagnostic = fileInfo.diagnosticSink.addDiagnosticWithTextRange(diagLevel, message, range);\n        diagnostic.setRule(rule);\n\n        return diagnostic;\n    }\n\n    function addExpectedClassDiagnostic(type: Type, node: ParseNode) {\n        const fileInfo = getFileInfo(node);\n        const diag = new DiagnosticAddendum();\n        if (type.category === TypeCategory.Union) {\n            type.subtypes.forEach((subtype) => {\n                if (!TypeBase.isInstantiable(subtype)) {\n                    diag.addMessage(Localizer.DiagnosticAddendum.typeNotClass().format({ type: printType(subtype) }));\n                }\n            });\n        }\n\n        addDiagnostic(\n            fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n            DiagnosticRule.reportGeneralTypeIssues,\n            Localizer.Diagnostic.typeExpectedClass().format({ type: printType(type) }) + diag.getString(),\n            node\n        );\n    }\n\n    function assignTypeToNameNode(\n        nameNode: NameNode,\n        type: Type,\n        srcExpression?: ParseNode,\n        expectedTypeDiagAddendum?: DiagnosticAddendum\n    ) {\n        const nameValue = nameNode.value;\n\n        const symbolWithScope = lookUpSymbolRecursive(nameNode, nameValue, /* honorCodeFlow */ false);\n        if (!symbolWithScope) {\n            // This can happen when we are evaluating a piece of code that was\n            // determined to be unreachable by the binder.\n            return;\n        }\n\n        const declarations = symbolWithScope.symbol.getDeclarations();\n        const declaredType = getDeclaredTypeOfSymbol(symbolWithScope.symbol);\n        const fileInfo = getFileInfo(nameNode);\n\n        // We found an existing declared type. Make sure the type is assignable.\n        let destType = type;\n        if (declaredType && srcExpression) {\n            let diagAddendum = new DiagnosticAddendum();\n\n            if (!canAssignType(declaredType, type, diagAddendum)) {\n                // If there was an expected type mismatch, use that diagnostic\n                // addendum because it will be more informative.\n                if (expectedTypeDiagAddendum) {\n                    diagAddendum = expectedTypeDiagAddendum;\n                }\n\n                addDiagnostic(\n                    fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                    DiagnosticRule.reportGeneralTypeIssues,\n                    Localizer.Diagnostic.typeAssignmentMismatch().format({\n                        sourceType: printType(type),\n                        destType: printType(declaredType),\n                    }) + diagAddendum.getString(),\n                    srcExpression || nameNode\n                );\n\n                // If the user has requested that no general type issues be\n                // reported, don't replace the destType with the declaredType\n                // because they won't understand why subsequent errors are\n                // generated.\n                if (fileInfo.diagnosticRuleSet.reportGeneralTypeIssues !== 'none') {\n                    destType = declaredType;\n                }\n            } else {\n                // Constrain the resulting type to match the declared type.\n                destType = narrowTypeBasedOnAssignment(declaredType, type);\n            }\n        } else {\n            // If this is a member name (within a class scope) and the member name\n            // appears to be a constant, use the strict source type. If it's a member\n            // variable that can be overridden by a child class, use the more general\n            // version by stripping off the literal.\n            const scope = ScopeUtils.getScopeForNode(nameNode);\n            if (scope?.type === ScopeType.Class) {\n                const isConstant = isConstantName(nameValue);\n                const isPrivate = isPrivateOrProtectedName(nameValue);\n\n                if (\n                    !isConstant &&\n                    (!isPrivate || getFileInfo(nameNode).diagnosticRuleSet.reportPrivateUsage === 'none')\n                ) {\n                    destType = stripLiteralValue(destType);\n                }\n            }\n        }\n\n        const varDecl: Declaration | undefined = declarations.find((decl) => decl.type === DeclarationType.Variable);\n\n        if (varDecl && varDecl.type === DeclarationType.Variable && srcExpression) {\n            if (varDecl.isConstant) {\n                // A constant variable can be assigned only once. If this\n                // isn't the first assignment, generate an error.\n                if (nameNode !== declarations[0].node) {\n                    addDiagnostic(\n                        fileInfo.diagnosticRuleSet.reportConstantRedefinition,\n                        DiagnosticRule.reportConstantRedefinition,\n                        Localizer.Diagnostic.constantRedefinition().format({ name: nameValue }),\n                        nameNode\n                    );\n                }\n            }\n        }\n\n        writeTypeCache(nameNode, destType);\n    }\n\n    function assignTypeToMemberAccessNode(\n        target: MemberAccessNode,\n        type: Type,\n        srcExpr?: ExpressionNode,\n        expectedTypeDiagAddendum?: DiagnosticAddendum\n    ) {\n        const baseTypeResult = getTypeOfExpression(target.leftExpression);\n        const baseType = makeTypeVarsConcrete(baseTypeResult.type);\n\n        // Handle member accesses (e.g. self.x or cls.y).\n        if (target.leftExpression.nodeType === ParseNodeType.Name) {\n            // Determine whether we're writing to a class or instance member.\n            const enclosingClassNode = ParseTreeUtils.getEnclosingClass(target);\n\n            if (enclosingClassNode) {\n                const classTypeResults = getTypeOfClass(enclosingClassNode);\n\n                if (classTypeResults && isClass(classTypeResults.classType)) {\n                    if (isObject(baseType)) {\n                        if (ClassType.isSameGenericClass(baseType.classType, classTypeResults.classType)) {\n                            assignTypeToMemberVariable(target, type, true, srcExpr);\n                        }\n                    } else if (isClass(baseType)) {\n                        if (ClassType.isSameGenericClass(baseType, classTypeResults.classType)) {\n                            assignTypeToMemberVariable(target, type, false, srcExpr);\n                        }\n                    }\n\n                    // Assignments to instance or class variables through \"self\" or \"cls\" is not\n                    // allowed for protocol classes.\n                    if (ClassType.isProtocolClass(classTypeResults.classType)) {\n                        addError(Localizer.Diagnostic.assignmentInProtocol(), target.memberName);\n                    }\n                }\n            }\n        }\n\n        getTypeFromMemberAccessWithBaseType(\n            target,\n            baseTypeResult,\n            { method: 'set', setType: type, setErrorNode: srcExpr, setExpectedTypeDiag: expectedTypeDiagAddendum },\n            EvaluatorFlags.None\n        );\n\n        writeTypeCache(target.memberName, type);\n        writeTypeCache(target, type);\n    }\n\n    function assignTypeToMemberVariable(\n        node: MemberAccessNode,\n        srcType: Type,\n        isInstanceMember: boolean,\n        srcExprNode?: ExpressionNode\n    ) {\n        const memberName = node.memberName.value;\n        const fileInfo = getFileInfo(node);\n\n        const classDef = ParseTreeUtils.getEnclosingClass(node);\n        if (!classDef) {\n            return;\n        }\n\n        const classTypeInfo = getTypeOfClass(classDef);\n        if (classTypeInfo && isClass(classTypeInfo.classType)) {\n            let memberInfo = lookUpClassMember(\n                classTypeInfo.classType,\n                memberName,\n                isInstanceMember ? ClassMemberLookupFlags.Default : ClassMemberLookupFlags.SkipInstanceVariables\n            );\n\n            const memberFields = classTypeInfo.classType.details.fields;\n            if (memberInfo) {\n                // Are we accessing an existing member on this class, or is\n                // it a member on a parent class?\n                const isThisClass =\n                    isClass(memberInfo.classType) &&\n                    ClassType.isSameGenericClass(classTypeInfo.classType, memberInfo.classType);\n\n                if (isThisClass && memberInfo.isInstanceMember === isInstanceMember) {\n                    const symbol = memberFields.get(memberName)!;\n                    assert(symbol !== undefined);\n\n                    const typedDecls = symbol.getDeclarations();\n                    let isFinalVar = isFinalVariable(symbol);\n\n                    // Check for an attempt to overwrite a constant or final member variable.\n                    if (\n                        typedDecls.length > 0 &&\n                        typedDecls[0].type === DeclarationType.Variable &&\n                        srcExprNode &&\n                        node.memberName !== typedDecls[0].node\n                    ) {\n                        if (typedDecls[0].isConstant) {\n                            addDiagnostic(\n                                fileInfo.diagnosticRuleSet.reportConstantRedefinition,\n                                DiagnosticRule.reportConstantRedefinition,\n                                Localizer.Diagnostic.constantRedefinition().format({ name: node.memberName.value }),\n                                node.memberName\n                            );\n                        }\n\n                        // If a Final instance variable is declared in the class body but is\n                        // being assigned within an __init__ method, it's allowed.\n                        const enclosingFunctionNode = ParseTreeUtils.getEnclosingFunction(node);\n                        if (enclosingFunctionNode && enclosingFunctionNode.name.value === '__init__') {\n                            isFinalVar = false;\n                        }\n\n                        if (isFinalVar) {\n                            addError(\n                                Localizer.Diagnostic.finalReassigned().format({ name: node.memberName.value }),\n                                node.memberName\n                            );\n                        }\n                    }\n                } else {\n                    // Is the target a property?\n                    const declaredType = getDeclaredTypeOfSymbol(memberInfo.symbol);\n                    if (declaredType && !isProperty(declaredType)) {\n                        // Handle the case where there is a class variable defined with the same\n                        // name, but there's also now an instance variable introduced. Combine the\n                        // type of the class variable with that of the new instance variable.\n                        if (!memberInfo.isInstanceMember && isInstanceMember) {\n                            // The class variable is accessed in this case.\n                            setSymbolAccessed(fileInfo, memberInfo.symbol, node.memberName);\n                            const memberType = getTypeOfMember(memberInfo);\n                            srcType = combineTypes([srcType, memberType]);\n                        }\n                    }\n                }\n            }\n\n            // Look up the member info again, now that we've potentially updated it.\n            memberInfo = lookUpClassMember(\n                classTypeInfo.classType,\n                memberName,\n                ClassMemberLookupFlags.DeclaredTypesOnly\n            );\n\n            if (!memberInfo && srcExprNode) {\n                reportPossibleUnknownAssignment(\n                    fileInfo.diagnosticRuleSet.reportUnknownMemberType,\n                    DiagnosticRule.reportUnknownMemberType,\n                    node.memberName,\n                    srcType,\n                    node\n                );\n            }\n        }\n    }\n\n    function assignTypeToTupleNode(target: TupleNode, type: Type, srcExpr?: ExpressionNode) {\n        // Initialize the array of target types, one for each target.\n        const targetTypes: Type[][] = new Array(target.expressions.length);\n        for (let i = 0; i < target.expressions.length; i++) {\n            targetTypes[i] = [];\n        }\n\n        // Do any of the targets use an unpack operator? If so, it will consume all of the\n        // entries at that location.\n        const unpackIndex = target.expressions.findIndex((expr) => expr.nodeType === ParseNodeType.Unpack);\n\n        doForSubtypes(type, (subtype) => {\n            // Is this subtype a tuple?\n            const tupleType = getSpecializedTupleType(subtype);\n            if (tupleType && tupleType.typeArguments) {\n                const sourceEntryTypes = tupleType.typeArguments;\n                const sourceEntryCount = sourceEntryTypes.length;\n\n                // Is this a homogenous tuple of indeterminate length?\n                if (sourceEntryCount === 2 && isEllipsisType(sourceEntryTypes[1])) {\n                    for (let index = 0; index < target.expressions.length; index++) {\n                        targetTypes[index].push(sourceEntryTypes[0]);\n                    }\n                } else {\n                    let sourceIndex = 0;\n                    let targetIndex = 0;\n                    for (targetIndex = 0; targetIndex < target.expressions.length; targetIndex++) {\n                        if (targetIndex === unpackIndex) {\n                            // Consume as many source entries as necessary to\n                            // make the remaining tuple entry counts match.\n                            const remainingTargetEntries = target.expressions.length - targetIndex - 1;\n                            const remainingSourceEntries = sourceEntryCount - sourceIndex;\n                            let entriesToPack = Math.max(remainingSourceEntries - remainingTargetEntries, 0);\n                            while (entriesToPack > 0) {\n                                targetTypes[targetIndex].push(sourceEntryTypes[sourceIndex]);\n                                sourceIndex++;\n                                entriesToPack--;\n                            }\n                        } else {\n                            if (sourceIndex >= sourceEntryCount) {\n                                // No more source entries to assign.\n                                break;\n                            }\n\n                            targetTypes[targetIndex].push(sourceEntryTypes[sourceIndex]);\n                            sourceIndex++;\n                        }\n                    }\n\n                    // Have we accounted for all of the targets and sources? If not, we have a size mismatch.\n                    if (targetIndex < target.expressions.length || sourceIndex < sourceEntryCount) {\n                        const fileInfo = getFileInfo(target);\n                        const expectedEntryCount =\n                            unpackIndex >= 0 ? target.expressions.length - 1 : target.expressions.length;\n                        addDiagnostic(\n                            fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                            DiagnosticRule.reportGeneralTypeIssues,\n                            Localizer.Diagnostic.tupleSizeMismatch().format({\n                                expected: expectedEntryCount,\n                                received: sourceEntryCount,\n                            }),\n                            target\n                        );\n                    }\n                }\n            } else {\n                // The assigned expression isn't a tuple, so it had better\n                // be some iterable type.\n                const iterableType = getTypeFromIterable(\n                    subtype,\n                    /* isAsync */ false,\n                    srcExpr,\n                    /* supportGetItem */ false\n                );\n                for (let index = 0; index < target.expressions.length; index++) {\n                    targetTypes[index].push(iterableType);\n                }\n            }\n\n            // We need to return something to satisfy doForSubtypes.\n            return undefined;\n        });\n\n        // Assign the resulting types to the individual names in the tuple target expression.\n        target.expressions.forEach((expr, index) => {\n            const typeList = targetTypes[index];\n            let targetType = typeList.length === 0 ? UnknownType.create() : combineTypes(typeList);\n\n            // If the target uses an unpack operator, wrap the target type in a list.\n            if (index === unpackIndex) {\n                const listType = getBuiltInType(expr, 'List');\n                if (isClass(listType)) {\n                    targetType = ObjectType.create(\n                        ClassType.cloneForSpecialization(listType, [targetType], /* isTypeArgumentExplicit */ false)\n                    );\n                }\n            }\n\n            assignTypeToExpression(expr, targetType, srcExpr);\n        });\n\n        writeTypeCache(target, type);\n    }\n\n    function assignTypeToExpression(\n        target: ExpressionNode,\n        type: Type,\n        srcExpr?: ExpressionNode,\n        expectedTypeDiagAddendum?: DiagnosticAddendum\n    ) {\n        // Is the source expression a TypeVar() call?\n        if (isTypeVar(type)) {\n            if (srcExpr && srcExpr.nodeType === ParseNodeType.Call) {\n                const callType = getTypeOfExpression(srcExpr.leftExpression).type;\n                if (\n                    isClass(callType) &&\n                    (ClassType.isBuiltIn(callType, 'TypeVar') || ClassType.isBuiltIn(callType, 'ParamSpec'))\n                ) {\n                    if (target.nodeType !== ParseNodeType.Name || target.value !== type.details.name) {\n                        addError(\n                            type.details.isParamSpec\n                                ? Localizer.Diagnostic.paramSpecAssignedName().format({ name: type.details.name })\n                                : Localizer.Diagnostic.typeVarAssignedName().format({ name: type.details.name }),\n                            target\n                        );\n                    }\n                }\n            }\n        }\n\n        // If the type was partially unbound, an error will have already been logged.\n        // Remove the unbound before assigning to the target expression so the unbound\n        // error doesn't propagate.\n        type = removeUnboundFromUnion(type);\n\n        switch (target.nodeType) {\n            case ParseNodeType.Name: {\n                const name = target;\n                // Handle '__all__' as a special case in the module scope.\n                if (name.value === '__all__' && srcExpr) {\n                    const scope = ScopeUtils.getScopeForNode(target);\n                    if (scope?.type === ScopeType.Module) {\n                        // It's common for modules to include the expression\n                        // __all__ = ['a', 'b', 'c']\n                        // We will mark the symbols referenced by these strings as accessed.\n                        if (srcExpr.nodeType === ParseNodeType.List) {\n                            const fileInfo = getFileInfo(target);\n                            srcExpr.entries.forEach((entryExpr) => {\n                                if (\n                                    entryExpr.nodeType === ParseNodeType.StringList ||\n                                    entryExpr.nodeType === ParseNodeType.String\n                                ) {\n                                    const symbolName =\n                                        entryExpr.nodeType === ParseNodeType.String\n                                            ? entryExpr.value\n                                            : entryExpr.strings.map((s) => s.value).join('');\n                                    const symbolInScope = scope.lookUpSymbolRecursive(symbolName);\n                                    if (symbolInScope) {\n                                        setSymbolAccessed(fileInfo, symbolInScope.symbol, target);\n                                    }\n                                }\n                            });\n                        }\n                    }\n                }\n\n                reportPossibleUnknownAssignment(\n                    getFileInfo(target).diagnosticRuleSet.reportUnknownVariableType,\n                    DiagnosticRule.reportUnknownVariableType,\n                    target,\n                    type,\n                    target\n                );\n\n                assignTypeToNameNode(target, type, srcExpr, expectedTypeDiagAddendum);\n                break;\n            }\n\n            case ParseNodeType.MemberAccess: {\n                assignTypeToMemberAccessNode(target, type, srcExpr, expectedTypeDiagAddendum);\n                break;\n            }\n\n            case ParseNodeType.Index: {\n                const baseTypeResult = getTypeOfExpression(\n                    target.baseExpression,\n                    undefined,\n                    EvaluatorFlags.DoNotSpecialize\n                );\n\n                const indexTypeResult = getTypeFromIndexWithBaseType(\n                    target,\n                    baseTypeResult.type,\n                    {\n                        method: 'set',\n                        setType: type,\n                        setErrorNode: srcExpr,\n                        setExpectedTypeDiag: expectedTypeDiagAddendum,\n                    },\n                    EvaluatorFlags.None\n                );\n\n                writeTypeCache(target, indexTypeResult.type);\n                break;\n            }\n\n            case ParseNodeType.Tuple: {\n                assignTypeToTupleNode(target, type, srcExpr);\n                break;\n            }\n\n            case ParseNodeType.TypeAnnotation: {\n                const typeHintType = getTypeOfAnnotation(\n                    target.typeAnnotation,\n                    ParseTreeUtils.isFinalAllowedForAssignmentTarget(target.valueExpression)\n                );\n                const diagAddendum = new DiagnosticAddendum();\n                if (canAssignType(typeHintType, type, diagAddendum)) {\n                    // Don't attempt to narrow based on the annotated type if the type\n                    // is a enum because the annotated type in an enum doesn't reflect\n                    // the type of the symbol.\n                    if (!isObject(type) || !ClassType.isEnumClass(type.classType)) {\n                        type = narrowTypeBasedOnAssignment(typeHintType, type);\n                    }\n                }\n\n                assignTypeToExpression(target.valueExpression, type, srcExpr, expectedTypeDiagAddendum);\n                break;\n            }\n\n            case ParseNodeType.Unpack: {\n                if (target.expression.nodeType === ParseNodeType.Name) {\n                    assignTypeToNameNode(target.expression, type, srcExpr);\n                }\n                break;\n            }\n\n            case ParseNodeType.List: {\n                // The assigned expression had better be some iterable type.\n                const iteratedType = getTypeFromIterable(\n                    type,\n                    /* isAsync */ false,\n                    srcExpr,\n                    /* supportGetItem */ false\n                );\n\n                target.entries.forEach((entry) => {\n                    assignTypeToExpression(entry, iteratedType, srcExpr);\n                });\n                break;\n            }\n\n            case ParseNodeType.Error: {\n                // Evaluate the child expression as best we can so the\n                // type information is cached for the completion handler.\n                suppressDiagnostics(() => {\n                    if (target.child) {\n                        getTypeOfExpression(target.child);\n                    }\n                });\n                break;\n            }\n\n            default: {\n                const fileInfo = getFileInfo(target);\n                addDiagnostic(\n                    fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                    DiagnosticRule.reportGeneralTypeIssues,\n                    Localizer.Diagnostic.assignmentTargetExpr(),\n                    target\n                );\n                break;\n            }\n        }\n    }\n\n    function verifyRaiseExceptionType(node: RaiseNode) {\n        const baseExceptionType = getBuiltInType(node, 'BaseException');\n\n        if (node.typeExpression) {\n            const exceptionType = getType(node.typeExpression);\n\n            // Validate that the argument of \"raise\" is an exception object or class.\n            // If it is a class, validate that the class's constructor accepts zero\n            // arguments.\n            if (exceptionType && baseExceptionType && isClass(baseExceptionType)) {\n                const diagAddendum = new DiagnosticAddendum();\n\n                doForSubtypes(exceptionType, (subtype) => {\n                    if (!isAnyOrUnknown(subtype)) {\n                        if (isClass(subtype)) {\n                            if (!derivesFromClassRecursive(subtype, baseExceptionType, /* ignoreUnknown */ false)) {\n                                diagAddendum.addMessage(\n                                    Localizer.Diagnostic.exceptionTypeIncorrect().format({\n                                        type: printType(subtype, /* expandTypeAlias */ false),\n                                    })\n                                );\n                            } else {\n                                let callResult: CallResult | undefined;\n                                suppressDiagnostics(() => {\n                                    callResult = validateConstructorArguments(\n                                        node.typeExpression!,\n                                        [],\n                                        subtype,\n                                        /* skipUnknownArgCheck */ false,\n                                        /* expectedType */ undefined\n                                    );\n                                });\n\n                                if (callResult && callResult.argumentErrors) {\n                                    diagAddendum.addMessage(\n                                        Localizer.Diagnostic.exceptionTypeNotInstantiable().format({\n                                            type: printType(subtype, /* expandTypeAlias */ false),\n                                        })\n                                    );\n                                }\n                            }\n                        } else if (isObject(subtype)) {\n                            if (\n                                !derivesFromClassRecursive(\n                                    subtype.classType,\n                                    baseExceptionType,\n                                    /* ignoreUnknown */ false\n                                )\n                            ) {\n                                diagAddendum.addMessage(\n                                    Localizer.Diagnostic.exceptionTypeIncorrect().format({\n                                        type: printType(subtype, /* expandTypeAlias */ false),\n                                    })\n                                );\n                            }\n                        } else {\n                            diagAddendum.addMessage(\n                                Localizer.Diagnostic.exceptionTypeIncorrect().format({\n                                    type: printType(subtype, /* expandTypeAlias */ false),\n                                })\n                            );\n                        }\n                    }\n\n                    return subtype;\n                });\n\n                if (!diagAddendum.isEmpty()) {\n                    const fileInfo = getFileInfo(node);\n                    addDiagnostic(\n                        fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                        DiagnosticRule.reportGeneralTypeIssues,\n                        Localizer.Diagnostic.expectedExceptionClass() + diagAddendum.getString(),\n                        node.typeExpression\n                    );\n                }\n            }\n        }\n    }\n\n    function verifyDeleteExpression(node: ExpressionNode) {\n        switch (node.nodeType) {\n            case ParseNodeType.Name: {\n                // Get the type to evaluate whether it's bound\n                // and to mark it accessed.\n                getTypeOfExpression(node);\n                break;\n            }\n\n            case ParseNodeType.MemberAccess: {\n                const baseTypeResult = getTypeOfExpression(node.leftExpression);\n                const memberType = getTypeFromMemberAccessWithBaseType(\n                    node,\n                    baseTypeResult,\n                    { method: 'del' },\n                    EvaluatorFlags.None\n                );\n                writeTypeCache(node.memberName, memberType.type);\n                break;\n            }\n\n            case ParseNodeType.Index: {\n                const baseTypeResult = getTypeOfExpression(\n                    node.baseExpression,\n                    undefined,\n                    EvaluatorFlags.DoNotSpecialize\n                );\n                getTypeFromIndexWithBaseType(node, baseTypeResult.type, { method: 'del' }, EvaluatorFlags.None);\n                writeTypeCache(node, UnboundType.create());\n                break;\n            }\n\n            case ParseNodeType.Error: {\n                // Evaluate the child expression as best we can so the\n                // type information is cached for the completion handler.\n                suppressDiagnostics(() => {\n                    if (node.child) {\n                        getTypeOfExpression(node.child);\n                    }\n                });\n                break;\n            }\n\n            default: {\n                const fileInfo = getFileInfo(node);\n                addDiagnostic(\n                    fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                    DiagnosticRule.reportGeneralTypeIssues,\n                    Localizer.Diagnostic.delTargetExpr(),\n                    node\n                );\n                break;\n            }\n        }\n    }\n\n    function setSymbolAccessed(fileInfo: AnalyzerFileInfo, symbol: Symbol, node: ParseNode) {\n        if (!isSpeculativeMode(node) && !incompleteTypeTracker.isIncompleteTypeMode()) {\n            fileInfo.accessedSymbolMap.set(symbol.id, true);\n        }\n    }\n\n    // Builds a sorted list of dataclass entries that are inherited by\n    // the specified class. These entries must be unique and in reverse-MRO\n    // order. Returns true if all of the class types in the hierarchy are\n    // known, false if one or more are unknown.\n    function addInheritedDataClassEntries(classType: ClassType, entries: DataClassEntry[]) {\n        let allAncestorsAreKnown = true;\n\n        for (let i = classType.details.mro.length - 1; i >= 0; i--) {\n            const mroClass = classType.details.mro[i];\n\n            if (isClass(mroClass)) {\n                const dataClassEntries = ClassType.getDataClassEntries(mroClass);\n\n                // Add the entries to the end of the list, replacing same-named\n                // entries if found.\n                dataClassEntries.forEach((entry) => {\n                    const existingIndex = entries.findIndex((e) => e.name === entry.name);\n                    if (existingIndex >= 0) {\n                        entries[existingIndex] = entry;\n                    } else {\n                        entries.push(entry);\n                    }\n                });\n            } else {\n                allAncestorsAreKnown = false;\n            }\n        }\n        return allAncestorsAreKnown;\n    }\n\n    function getReturnTypeFromGenerator(type: Type): Type | undefined {\n        if (isAnyOrUnknown(type)) {\n            return type;\n        }\n\n        if (isObject(type)) {\n            // Is this a Generator? If so, return the third\n            // type argument, which is the await response type.\n            const classType = type.classType;\n            if (ClassType.isBuiltIn(classType, 'Generator')) {\n                const typeArgs = classType.typeArguments;\n                if (typeArgs && typeArgs.length >= 3) {\n                    return typeArgs[2];\n                }\n            }\n        }\n\n        return undefined;\n    }\n\n    function getSpecializedReturnType(objType: ObjectType, memberName: string, errorNode: ParseNode | undefined) {\n        const classMember = lookUpObjectMember(objType, memberName, ClassMemberLookupFlags.SkipInstanceVariables);\n        if (!classMember) {\n            return undefined;\n        }\n\n        const memberType = getTypeOfMember(classMember);\n        if (isAnyOrUnknown(memberType)) {\n            return memberType;\n        }\n\n        if (memberType.category === TypeCategory.Function) {\n            const methodType = bindFunctionToClassOrObject(\n                objType,\n                memberType,\n                /* treatAsClassMember */ false,\n                errorNode\n            );\n            if (methodType) {\n                return getFunctionEffectiveReturnType(methodType as FunctionType);\n            }\n        }\n\n        return undefined;\n    }\n\n    // This is similar to _getSpecializedReturnType except that\n    // the method lookup occurs on a metaclass rather than\n    // the object that derives from it.\n    function getSpecializedReturnTypeForMetaclassMethod(\n        metaclass: ClassType,\n        classType: ClassType,\n        memberName: string,\n        errorNode: ParseNode | undefined\n    ) {\n        const classMember = lookUpObjectMember(\n            ObjectType.create(metaclass),\n            memberName,\n            ClassMemberLookupFlags.SkipInstanceVariables\n        );\n        if (!classMember) {\n            return undefined;\n        }\n\n        const memberType = getTypeOfMember(classMember);\n        if (isAnyOrUnknown(memberType)) {\n            return memberType;\n        }\n\n        if (memberType.category === TypeCategory.Function) {\n            const methodType = bindFunctionToClassOrObject(\n                classType,\n                memberType,\n                /* treatAsClassMember */ true,\n                errorNode\n            );\n            if (methodType) {\n                return getFunctionEffectiveReturnType(methodType as FunctionType);\n            }\n        }\n\n        return undefined;\n    }\n\n    function getTypeFromName(node: NameNode, flags: EvaluatorFlags): TypeResult {\n        const fileInfo = getFileInfo(node);\n        const name = node.value;\n        let type: Type | undefined;\n        let isResolutionCyclical = false;\n        const allowForwardReferences = (flags & EvaluatorFlags.AllowForwardReferences) !== 0;\n\n        // Look for the scope that contains the value definition and\n        // see if it has a declared type.\n        const symbolWithScope = lookUpSymbolRecursive(node, name, !allowForwardReferences);\n\n        if (symbolWithScope) {\n            let useCodeFlowAnalysis = !allowForwardReferences;\n\n            // If the symbol is implicitly imported from the builtin\n            // scope, there's no need to use code flow analysis.\n            if (symbolWithScope.scope.type === ScopeType.Builtin) {\n                useCodeFlowAnalysis = false;\n            }\n\n            if (fileInfo.isStubFile) {\n                // Type stubs allow forward references of classes, so\n                // don't use code flow analysis in this case.\n                const decl = getLastTypedDeclaredForSymbol(symbolWithScope.symbol);\n                if (decl && decl.type === DeclarationType.Class) {\n                    useCodeFlowAnalysis = false;\n                }\n            }\n\n            const symbol = symbolWithScope.symbol;\n\n            // Get the effective type (either the declared type or the inferred type).\n            // If we're using code flow analysis, pass the usage node so we consider\n            // only the assignment nodes that are reachable from this usage.\n            const effectiveTypeInfo = getEffectiveTypeOfSymbolForUsage(symbol, useCodeFlowAnalysis ? node : undefined);\n            const effectiveType = effectiveTypeInfo.type;\n\n            if (effectiveTypeInfo.isResolutionCyclical) {\n                isResolutionCyclical = true;\n            }\n\n            const isSpecialBuiltIn =\n                !!effectiveType && isClass(effectiveType) && ClassType.isSpecialBuiltIn(effectiveType);\n\n            type = effectiveType;\n            if (useCodeFlowAnalysis && !isSpecialBuiltIn) {\n                // See if code flow analysis can tell us anything more about the type.\n                // If the symbol is declared outside of our execution scope, use its effective\n                // type. If it's declared inside our execution scope, it generally starts\n                // as unbound at the start of the code flow.\n                const typeAtStart =\n                    symbolWithScope.isBeyondExecutionScope || !symbol.isInitiallyUnbound()\n                        ? effectiveType\n                        : UnboundType.create();\n                const codeFlowType = getFlowTypeOfReference(node, symbol.id, typeAtStart);\n                if (codeFlowType) {\n                    type = codeFlowType;\n                }\n            }\n\n            if (!(flags & EvaluatorFlags.DoNotSpecialize)) {\n                if (isClass(type)) {\n                    if (\n                        (flags & EvaluatorFlags.ExpectingType) !== 0 &&\n                        (flags & EvaluatorFlags.AllowMissingTypeArgs) === 0\n                    ) {\n                        if (requiresTypeArguments(type) && !type.typeArguments) {\n                            addDiagnostic(\n                                fileInfo.diagnosticRuleSet.reportMissingTypeArgument,\n                                DiagnosticRule.reportMissingTypeArgument,\n                                Localizer.Diagnostic.typeArgsMissingForClass().format({\n                                    name: type.details.name,\n                                }),\n                                node\n                            );\n                        }\n                    }\n                    if (!type.typeArguments) {\n                        type = createSpecializedClassType(type, undefined, flags, node);\n                    }\n                } else if (isObject(type)) {\n                    // If this is an object that contains a Type[X], transform it\n                    // into class X.\n                    const typeType = getClassFromPotentialTypeObject(type);\n                    if (typeType) {\n                        type = typeType;\n                    }\n                } else if (\n                    (flags & EvaluatorFlags.ExpectingType) !== 0 &&\n                    type.typeAliasInfo &&\n                    type.typeAliasInfo.typeParameters &&\n                    type.typeAliasInfo.typeParameters.length > 0 &&\n                    !type.typeAliasInfo.typeArguments\n                ) {\n                    addDiagnostic(\n                        fileInfo.diagnosticRuleSet.reportMissingTypeArgument,\n                        DiagnosticRule.reportMissingTypeArgument,\n                        Localizer.Diagnostic.typeArgsMissingForAlias().format({\n                            name: type.typeAliasInfo.aliasName,\n                        }),\n                        node\n                    );\n                }\n            }\n\n            // If there is a resolution cycle, don't report it as an unbound symbol\n            // at this time. It will be re-evaluated as the call stack unwinds, and\n            // its actual type will be known then.\n            if (!isResolutionCyclical) {\n                if (isUnbound(type)) {\n                    addDiagnostic(\n                        fileInfo.diagnosticRuleSet.reportUnboundVariable,\n                        DiagnosticRule.reportUnboundVariable,\n                        Localizer.Diagnostic.symbolIsUnbound().format({ name }),\n                        node\n                    );\n                } else if (isPossiblyUnbound(type)) {\n                    addDiagnostic(\n                        fileInfo.diagnosticRuleSet.reportUnboundVariable,\n                        DiagnosticRule.reportUnboundVariable,\n                        Localizer.Diagnostic.symbolIsPossiblyUnbound().format({ name }),\n                        node\n                    );\n                }\n            }\n\n            setSymbolAccessed(fileInfo, symbol, node);\n        } else {\n            // Handle the special case of \"reveal_type\".\n            if (name !== 'reveal_type') {\n                addDiagnostic(\n                    fileInfo.diagnosticRuleSet.reportUndefinedVariable,\n                    DiagnosticRule.reportUndefinedVariable,\n                    Localizer.Diagnostic.symbolIsUndefined().format({ name }),\n                    node\n                );\n            }\n            type = UnknownType.create();\n        }\n\n        if (isTypeVar(type) && type.details.isParamSpec) {\n            if (flags & EvaluatorFlags.ParamSpecDisallowed) {\n                addError(Localizer.Diagnostic.paramSpecContext(), node);\n            }\n        }\n\n        if ((flags & EvaluatorFlags.ExpectingType) !== 0) {\n            if ((flags & EvaluatorFlags.GenericClassTypeAllowed) === 0) {\n                if (isClass(type) && ClassType.isBuiltIn(type, 'Generic')) {\n                    addDiagnostic(\n                        getFileInfo(node).diagnosticRuleSet.reportGeneralTypeIssues,\n                        DiagnosticRule.reportGeneralTypeIssues,\n                        Localizer.Diagnostic.genericNotAllowed(),\n                        node\n                    );\n                }\n            }\n        }\n\n        // If this is a TypeVar, try to match it against a TypeVar\n        // defined by an enclosing scope (either a class or function).\n        if (isTypeVar(type) && TypeBase.isInstantiable(type)) {\n            type = findScopedTypeVar(node, type);\n            if ((flags & EvaluatorFlags.DisallowTypeVarsWithScopeId) !== 0 && type.scopeId) {\n                if (!type.details.isSynthesized && !type.details.isParamSpec) {\n                    addDiagnostic(\n                        getFileInfo(node).diagnosticRuleSet.reportGeneralTypeIssues,\n                        DiagnosticRule.reportGeneralTypeIssues,\n                        Localizer.Diagnostic.typeVarUsedByOuterScope().format({ name: type.details.name }),\n                        node\n                    );\n                }\n            } else if ((flags & EvaluatorFlags.AssociateTypeVarsWithCurrentScope) !== 0) {\n                if (!type.scopeId) {\n                    const enclosingScope = ParseTreeUtils.getEnclosingClassOrFunction(node);\n                    if (enclosingScope) {\n                        type = TypeVarType.cloneForScopeId(type, enclosingScope.id);\n                    } else {\n                        fail('AssociateTypeVarsWithCurrentScope flag was set but enclosing scope not found');\n                    }\n                }\n            } else if ((flags & EvaluatorFlags.DisallowTypeVarsWithoutScopeId) !== 0) {\n                if (!type.scopeId && !type.details.isSynthesized && !type.details.isParamSpec) {\n                    addDiagnostic(\n                        getFileInfo(node).diagnosticRuleSet.reportGeneralTypeIssues,\n                        DiagnosticRule.reportGeneralTypeIssues,\n                        Localizer.Diagnostic.typeVarNotUsedByOuterScope().format({ name: type.details.name }),\n                        node\n                    );\n                }\n            }\n        }\n\n        return { type, node, isResolutionCyclical };\n    }\n\n    // Walks up the parse tree to find a function or class that provides\n    // the context for a type variable.\n    function findScopedTypeVar(node: NameNode, type: TypeVarType): TypeVarType {\n        let curNode: ParseNode | undefined = node;\n\n        assert(TypeBase.isInstantiable(type));\n\n        while (curNode) {\n            curNode = ParseTreeUtils.getTypeVarScopeNode(curNode);\n            if (!curNode) {\n                break;\n            }\n\n            let typeVarsForScope: TypeVarType[] | undefined;\n\n            if (curNode.nodeType === ParseNodeType.Class) {\n                const classTypeInfo = getTypeOfClass(curNode);\n                if (classTypeInfo) {\n                    typeVarsForScope = classTypeInfo.classType.details.typeParameters;\n                }\n            } else if (curNode.nodeType === ParseNodeType.Function) {\n                const functionTypeInfo = getTypeOfFunction(curNode);\n                if (functionTypeInfo) {\n                    typeVarsForScope = [];\n                    functionTypeInfo.functionType.details.parameters.forEach((param) => {\n                        if (param.hasDeclaredType) {\n                            addTypeVarsToListIfUnique(typeVarsForScope!, getTypeVarArgumentsRecursive(param.type));\n                        }\n                    });\n                }\n            } else if (curNode.nodeType === ParseNodeType.Module) {\n                break;\n            }\n\n            if (typeVarsForScope) {\n                const match = typeVarsForScope.find((typeVar) => typeVar.details.name === type.details.name);\n\n                if (match) {\n                    return convertToInstantiable(match) as TypeVarType;\n                }\n            }\n\n            curNode = curNode.parent;\n        }\n\n        // Return the original type.\n        return type;\n    }\n\n    function getTypeFromMemberAccess(node: MemberAccessNode, flags: EvaluatorFlags): TypeResult {\n        const baseTypeFlags =\n            EvaluatorFlags.DoNotSpecialize |\n            (flags & (EvaluatorFlags.ExpectingType | EvaluatorFlags.AllowForwardReferences));\n        const baseTypeResult = getTypeOfExpression(node.leftExpression, undefined, baseTypeFlags);\n        const memberTypeResult = getTypeFromMemberAccessWithBaseType(node, baseTypeResult, { method: 'get' }, flags);\n\n        if (isCodeFlowSupportedForReference(node)) {\n            // Before performing code flow analysis, update the cache to prevent recursion.\n            writeTypeCache(node, memberTypeResult.type);\n            writeTypeCache(node.memberName, memberTypeResult.type);\n\n            // If the type is initially unbound, see if there's a parent class that\n            // potentially initialized the value.\n            let initialType = memberTypeResult.type;\n            if (isUnbound(initialType)) {\n                const baseType = makeTypeVarsConcrete(baseTypeResult.type);\n\n                let classMemberInfo: ClassMember | undefined;\n                if (isClass(baseType)) {\n                    classMemberInfo = lookUpClassMember(\n                        baseType,\n                        node.memberName.value,\n                        ClassMemberLookupFlags.SkipOriginalClass\n                    );\n                } else if (isObject(baseType)) {\n                    classMemberInfo = lookUpObjectMember(\n                        baseType,\n                        node.memberName.value,\n                        ClassMemberLookupFlags.SkipOriginalClass\n                    );\n                }\n\n                if (classMemberInfo) {\n                    initialType = getTypeOfMember(classMemberInfo);\n                }\n            }\n\n            // See if we can refine the type based on code flow analysis.\n            const codeFlowType = getFlowTypeOfReference(node, indeterminateSymbolId, initialType);\n            if (codeFlowType) {\n                memberTypeResult.type = codeFlowType;\n            }\n        }\n\n        // Cache the type information in the member name node as well.\n        writeTypeCache(node.memberName, memberTypeResult.type);\n\n        return memberTypeResult;\n    }\n\n    function getTypeFromMemberAccessWithBaseType(\n        node: MemberAccessNode,\n        baseTypeResult: TypeResult,\n        usage: EvaluatorUsage,\n        flags: EvaluatorFlags\n    ): TypeResult {\n        const baseType = baseTypeResult.type;\n        const memberName = node.memberName.value;\n        let diag = new DiagnosticAddendum();\n        const fileInfo = getFileInfo(node);\n        let type: Type | undefined;\n\n        switch (baseType.category) {\n            case TypeCategory.Any:\n            case TypeCategory.Unknown: {\n                type = baseType;\n                break;\n            }\n\n            case TypeCategory.Class: {\n                type = getTypeFromClassMember(node.memberName, baseType, memberName, usage, diag);\n                break;\n            }\n\n            case TypeCategory.TypeVar: {\n                if (baseType.details.isParamSpec) {\n                    if (memberName === 'args' || memberName === 'kwargs') {\n                        return { type: AnyType.create(), node };\n                    }\n                    addDiagnostic(\n                        fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                        DiagnosticRule.reportGeneralTypeIssues,\n                        Localizer.Diagnostic.paramSpecUnknownMember().format({ name: memberName }),\n                        node.memberName\n                    );\n                    return { type: UnknownType.create(), node };\n                }\n\n                return getTypeFromMemberAccessWithBaseType(\n                    node,\n                    {\n                        type: specializeType(baseType, /* typeVarMap */ undefined, /* makeConcrete */ true),\n                        node,\n                    },\n                    usage,\n                    EvaluatorFlags.None\n                );\n            }\n\n            case TypeCategory.Object: {\n                const classFromTypeObject = getClassFromPotentialTypeObject(baseType);\n                if (classFromTypeObject) {\n                    // Handle the case where the object is a 'Type' object, which\n                    // represents a class.\n                    return getTypeFromMemberAccessWithBaseType(\n                        node,\n                        { type: classFromTypeObject, node: baseTypeResult.node },\n                        usage,\n                        flags\n                    );\n                }\n\n                type = getTypeFromObjectMember(node.memberName, baseType, memberName, usage, diag);\n                break;\n            }\n\n            case TypeCategory.Module: {\n                const symbol = ModuleType.getField(baseType, memberName);\n                if (symbol) {\n                    if (usage.method === 'get') {\n                        setSymbolAccessed(getFileInfo(node), symbol, node.memberName);\n                    }\n\n                    type = getEffectiveTypeOfSymbol(symbol);\n\n                    // If the type resolved to \"unbound\", treat it as \"unknown\" in\n                    // the case of a module reference because if it's truly unbound,\n                    // that error will be reported within the module and should not\n                    // leak into other modules that import it.\n                    if (isUnbound(type)) {\n                        type = UnknownType.create();\n                    }\n                } else {\n                    // Does the stub file export a top-level __getattr__ function?\n                    if (usage.method === 'get') {\n                        const getAttrSymbol = ModuleType.getField(baseType, '__getattr__');\n                        if (getAttrSymbol) {\n                            const decls = getAttrSymbol.getDeclarations();\n\n                            // Only honor the __getattr__ if it's in a stub file.\n                            if (decls.some((decl) => decl.path.toLowerCase().endsWith('.pyi'))) {\n                                const getAttrType = getEffectiveTypeOfSymbol(getAttrSymbol);\n                                if (getAttrType.category === TypeCategory.Function) {\n                                    type = getFunctionEffectiveReturnType(getAttrType);\n                                }\n                            }\n                        }\n                    }\n\n                    if (!type) {\n                        addDiagnostic(\n                            fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                            DiagnosticRule.reportGeneralTypeIssues,\n                            Localizer.Diagnostic.moduleUnknownMember().format({ name: memberName }),\n                            node.memberName\n                        );\n                        type = UnknownType.create();\n                    }\n                }\n                break;\n            }\n\n            case TypeCategory.Union: {\n                type = doForSubtypes(baseType, (subtype) => {\n                    if (isNone(subtype)) {\n                        addDiagnostic(\n                            getFileInfo(node).diagnosticRuleSet.reportOptionalMemberAccess,\n                            DiagnosticRule.reportOptionalMemberAccess,\n                            Localizer.Diagnostic.noneUnknownMember().format({ name: memberName }),\n                            node.memberName\n                        );\n                        return undefined;\n                    } else if (isUnbound(subtype)) {\n                        // Don't do anything if it's unbound. The error will already\n                        // be reported elsewhere.\n                        return undefined;\n                    } else {\n                        const typeResult = getTypeFromMemberAccessWithBaseType(\n                            node,\n                            {\n                                type: subtype,\n                                node,\n                            },\n                            usage,\n                            EvaluatorFlags.None\n                        );\n                        return typeResult.type;\n                    }\n                });\n                break;\n            }\n\n            case TypeCategory.Function:\n            case TypeCategory.OverloadedFunction: {\n                // TODO - not yet sure what to do about members of functions,\n                // which have associated dictionaries.\n                type = AnyType.create();\n                break;\n            }\n\n            default:\n                diag.addMessage(Localizer.DiagnosticAddendum.typeUnsupported().format({ type: printType(baseType) }));\n                break;\n        }\n\n        if (!type) {\n            let diagMessage = Localizer.Diagnostic.memberAccess();\n            if (usage.method === 'set') {\n                diagMessage = Localizer.Diagnostic.memberSet();\n            } else if (usage.method === 'del') {\n                diagMessage = Localizer.Diagnostic.memberDelete();\n            }\n\n            // If there is an expected type diagnostic addendum (used for assignments),\n            // use that rather than the local diagnostic addendum because it will be\n            // more informative.\n            if (usage.setExpectedTypeDiag) {\n                diag = usage.setExpectedTypeDiag;\n            }\n\n            addDiagnostic(\n                fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                DiagnosticRule.reportGeneralTypeIssues,\n                diagMessage.format({ name: memberName, type: printType(baseType) }) + diag.getString(),\n                node.memberName\n            );\n            type = UnknownType.create();\n        }\n\n        // Should we specialize the class?\n        if ((flags & EvaluatorFlags.DoNotSpecialize) === 0) {\n            if (isClass(type) && !type.typeArguments) {\n                type = createSpecializedClassType(type, undefined, flags, node);\n            }\n        }\n\n        if (usage.method === 'get') {\n            reportPossibleUnknownAssignment(\n                fileInfo.diagnosticRuleSet.reportUnknownMemberType,\n                DiagnosticRule.reportUnknownMemberType,\n                node.memberName,\n                type,\n                node\n            );\n        }\n\n        return { type, node };\n    }\n\n    // If the object type is a 'Type' object, converts it to the corresponding\n    // class that it represents and returns that class. Otherwise returns undefined.\n    function getClassFromPotentialTypeObject(potentialTypeObject: ObjectType): Type | undefined {\n        const objectClass = potentialTypeObject.classType;\n        if (ClassType.isBuiltIn(objectClass, 'Type')) {\n            const typeArgs = objectClass.typeArguments;\n\n            if (typeArgs && typeArgs.length > 0) {\n                let firstTypeArg = typeArgs[0];\n\n                // If the type arg is a type var itself, specialize it in case it's bound.\n                if (isTypeVar(firstTypeArg)) {\n                    firstTypeArg = getConcreteTypeFromTypeVar(firstTypeArg);\n                }\n\n                if (isObject(firstTypeArg)) {\n                    return firstTypeArg.classType;\n                }\n            }\n\n            return AnyType.create();\n        }\n\n        return undefined;\n    }\n\n    function getTypeFromClassMemberName(\n        errorNode: ExpressionNode,\n        classType: ClassType,\n        memberName: string,\n        usage: EvaluatorUsage,\n        diag: DiagnosticAddendum,\n        flags: MemberAccessFlags,\n        bindToClass?: ClassType\n    ): ClassMemberLookup | undefined {\n        // If this is a special type (like \"List\") that has an alias class (like\n        // \"list\"), switch to the alias, which defines the members.\n        classType = classType.details.aliasClass || classType;\n\n        let classLookupFlags = ClassMemberLookupFlags.Default;\n        if (flags & MemberAccessFlags.SkipInstanceMembers) {\n            classLookupFlags |= ClassMemberLookupFlags.SkipInstanceVariables;\n        }\n        if (flags & MemberAccessFlags.SkipBaseClasses) {\n            classLookupFlags |= ClassMemberLookupFlags.SkipBaseClasses;\n        }\n        if (flags & MemberAccessFlags.SkipObjectBaseClass) {\n            classLookupFlags |= ClassMemberLookupFlags.SkipObjectBaseClass;\n        }\n\n        // Always look for a member with a declared type first.\n        let memberInfo = lookUpClassMember(\n            classType,\n            memberName,\n            classLookupFlags | ClassMemberLookupFlags.DeclaredTypesOnly\n        );\n\n        // If we couldn't find a symbol with a declared type, use\n        // a symbol with an inferred type.\n        if (!memberInfo) {\n            memberInfo = lookUpClassMember(classType, memberName, classLookupFlags);\n        }\n\n        if (memberInfo) {\n            let type: Type;\n            if (usage.method === 'get') {\n                type = getTypeOfMember(memberInfo);\n            } else {\n                // If the usage indicates a 'set' or 'delete', use only the declared\n                // type to avoid circular type evaluation.\n                type = getDeclaredTypeOfSymbol(memberInfo.symbol) || UnknownType.create();\n            }\n\n            if (usage.method === 'set' && memberInfo.symbol.isClassVar()) {\n                if (flags & MemberAccessFlags.DisallowClassVarWrites) {\n                    diag.addMessage(Localizer.DiagnosticAddendum.memberSetClassVar().format({ name: memberName }));\n                    return undefined;\n                }\n            }\n\n            // Don't include variables within typed dict classes.\n            if (ClassType.isTypedDictClass(classType)) {\n                const typedDecls = memberInfo.symbol.getTypedDeclarations();\n                if (typedDecls.length > 0 && typedDecls[0].type === DeclarationType.Variable) {\n                    diag.addMessage(Localizer.DiagnosticAddendum.memberUnknown().format({ name: memberName }));\n                    return undefined;\n                }\n            }\n\n            if (usage.method === 'get') {\n                // Mark the member accessed if it's not coming from a parent class.\n                if (isClass(memberInfo.classType) && ClassType.isSameGenericClass(memberInfo.classType, classType)) {\n                    setSymbolAccessed(getFileInfo(errorNode), memberInfo.symbol, errorNode);\n                }\n            }\n\n            const objectAccessType = applyObjectAccessMethod(\n                type,\n                memberInfo,\n                classType,\n                (flags & MemberAccessFlags.SkipInstanceMembers) === 0,\n                errorNode,\n                memberName,\n                usage,\n                diag,\n                bindToClass\n            );\n\n            if (!objectAccessType) {\n                return undefined;\n            }\n            type = objectAccessType;\n\n            if (usage.method === 'set') {\n                // Verify that the assigned type is compatible.\n                if (!canAssignType(type, usage.setType!, diag.createAddendum())) {\n                    diag.addMessage(\n                        Localizer.DiagnosticAddendum.memberAssignment().format({\n                            type: printType(usage.setType!),\n                            name: memberName,\n                            classType: printObjectTypeForClass(classType),\n                        })\n                    );\n                    return undefined;\n                }\n            }\n\n            return {\n                type,\n                isClassMember: !memberInfo.isInstanceMember,\n            };\n        }\n\n        if (!(flags & MemberAccessFlags.SkipGetAttributeCheck)) {\n            const generalAttrType = applyGeneralAttributeAccess(classType, errorNode, usage);\n            if (generalAttrType) {\n                return {\n                    type: generalAttrType,\n                    isClassMember: false,\n                };\n            }\n        }\n\n        diag.addMessage(Localizer.DiagnosticAddendum.memberUnknown().format({ name: memberName }));\n        return undefined;\n    }\n\n    // Applies special access methods \"__get__\", \"__set__\", or \"__delete__\".\n    function applyObjectAccessMethod(\n        type: Type,\n        memberInfo: ClassMember,\n        classType: ClassType,\n        isAccessedThroughObject: boolean,\n        errorNode: ExpressionNode,\n        memberName: string,\n        usage: EvaluatorUsage,\n        diag: DiagnosticAddendum,\n        bindToClass?: ClassType\n    ): Type | undefined {\n        let isTypeValid = true;\n\n        type = doForSubtypes(type, (subtype) => {\n            if (isObject(subtype)) {\n                let accessMethodName: string;\n\n                if (usage.method === 'get') {\n                    accessMethodName = '__get__';\n                } else if (usage.method === 'set') {\n                    accessMethodName = '__set__';\n                } else {\n                    accessMethodName = '__delete__';\n                }\n\n                const memberClassType = subtype.classType;\n                const accessMethod = lookUpClassMember(\n                    memberClassType,\n                    accessMethodName,\n                    ClassMemberLookupFlags.SkipInstanceVariables\n                );\n\n                // Handle properties specially.\n                if (ClassType.isPropertyClass(subtype.classType)) {\n                    if (usage.method === 'set') {\n                        if (!accessMethod) {\n                            diag.addMessage(\n                                Localizer.DiagnosticAddendum.propertyMissingSetter().format({ name: memberName })\n                            );\n                            isTypeValid = false;\n                            return undefined;\n                        }\n                    } else if (usage.method === 'del') {\n                        if (!accessMethod) {\n                            diag.addMessage(\n                                Localizer.DiagnosticAddendum.propertyMissingDeleter().format({ name: memberName })\n                            );\n                            isTypeValid = false;\n                            return undefined;\n                        }\n                    }\n                }\n\n                if (accessMethod) {\n                    let accessMethodType = getTypeOfMember(accessMethod);\n                    const argList: FunctionArgument[] = [\n                        {\n                            argumentCategory: ArgumentCategory.Simple,\n                            type: ObjectType.create(memberClassType),\n                        },\n                        {\n                            argumentCategory: ArgumentCategory.Simple,\n                            type: isAccessedThroughObject ? ObjectType.create(classType) : NoneType.createInstance(),\n                        },\n                        {\n                            argumentCategory: ArgumentCategory.Simple,\n                            type: AnyType.create(),\n                        },\n                    ];\n\n                    // If it's an overloaded function, determine which overload to use.\n                    if (accessMethodType.category === TypeCategory.OverloadedFunction) {\n                        const overload = findOverloadedFunctionType(\n                            errorNode,\n                            argList,\n                            accessMethodType,\n                            /* expectedType */ undefined\n                        );\n                        if (overload) {\n                            accessMethodType = overload;\n                        }\n                    }\n\n                    if (accessMethodType && accessMethodType.category === TypeCategory.Function) {\n                        // Bind the accessor to the base object type.\n                        const boundMethodType = bindFunctionToClassOrObject(\n                            ObjectType.create(bindToClass || classType),\n                            accessMethodType,\n                            !bindToClass,\n                            errorNode\n                        );\n\n                        if (boundMethodType) {\n                            accessMethodType = boundMethodType as FunctionType;\n\n                            if (usage.method === 'get') {\n                                const returnType =\n                                    validateFunctionArguments(\n                                        errorNode,\n                                        argList.slice(1),\n                                        accessMethodType,\n                                        new TypeVarMap(),\n                                        /* skipUnknownArgCheck */ true,\n                                        /* inferReturnTypeIfNeeded */ true,\n                                        /* expectedType */ undefined\n                                    ).returnType || UnknownType.create();\n                                if (isClass(memberInfo!.classType)) {\n                                    return partiallySpecializeType(returnType, memberInfo!.classType);\n                                }\n                                return returnType;\n                            } else {\n                                if (usage.method === 'set') {\n                                    // Verify that the setter's parameter type matches\n                                    // the type of the value being assigned.\n                                    if (accessMethodType.details.parameters.length >= 2) {\n                                        const setValueType = accessMethodType.details.parameters[1].type;\n                                        if (!canAssignType(setValueType, usage.setType!, diag)) {\n                                            isTypeValid = false;\n                                            return undefined;\n                                        }\n                                    }\n                                }\n\n                                // The type isn't important for set or delete usage.\n                                // We just need to return some defined type.\n                                return AnyType.create();\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (usage.method === 'set') {\n                let enforceTargetType = false;\n\n                if (memberInfo!.symbol.hasTypedDeclarations()) {\n                    // If the member has a declared type, we will enforce it.\n                    enforceTargetType = true;\n                } else {\n                    // If the member has no declared type, we will enforce it\n                    // if this assignment isn't within the enclosing class. If\n                    // it is within the enclosing class, the assignment is used\n                    // to infer the type of the member.\n                    if (!memberInfo!.symbol.getDeclarations().some((decl) => decl.node === errorNode)) {\n                        enforceTargetType = true;\n                    }\n                }\n\n                if (enforceTargetType) {\n                    let effectiveType = subtype;\n\n                    // If the code is patching a method (defined on the class)\n                    // with an object-level function, strip the \"self\" parameter\n                    // off the original type. This is sometimes done for test\n                    // purposes to override standard behaviors of specific methods.\n                    if (isAccessedThroughObject) {\n                        if (!memberInfo!.isInstanceMember && subtype.category === TypeCategory.Function) {\n                            if (FunctionType.isClassMethod(subtype) || FunctionType.isInstanceMethod(subtype)) {\n                                effectiveType = stripFirstParameter(subtype);\n                            }\n                        }\n                    }\n\n                    return effectiveType;\n                }\n            }\n\n            return subtype;\n        });\n\n        return isTypeValid ? type : undefined;\n    }\n\n    // Applies the __getattr__, __setattr__ or __delattr__ method if present.\n    function applyGeneralAttributeAccess(\n        classType: ClassType,\n        errorNode: ExpressionNode,\n        usage: EvaluatorUsage\n    ): Type | undefined {\n        if (usage.method === 'get') {\n            // See if the class has a \"__getattribute__\" or \"__getattr__\" method.\n            // If so, arbitrary members are supported.\n            const getAttribType = getTypeFromClassMember(\n                errorNode,\n                classType,\n                '__getattribute__',\n                { method: 'get' },\n                new DiagnosticAddendum(),\n                MemberAccessFlags.SkipForMethodLookup | MemberAccessFlags.SkipObjectBaseClass\n            );\n\n            if (getAttribType && getAttribType.category === TypeCategory.Function) {\n                return getFunctionEffectiveReturnType(getAttribType);\n            }\n\n            const getAttrType = getTypeFromClassMember(\n                errorNode,\n                classType,\n                '__getattr__',\n                { method: 'get' },\n                new DiagnosticAddendum(),\n                MemberAccessFlags.SkipForMethodLookup\n            );\n            if (getAttrType && getAttrType.category === TypeCategory.Function) {\n                return getFunctionEffectiveReturnType(getAttrType);\n            }\n        } else if (usage.method === 'set') {\n            const setAttrType = getTypeFromClassMember(\n                errorNode,\n                classType,\n                '__setattr__',\n                { method: 'get' },\n                new DiagnosticAddendum(),\n                MemberAccessFlags.SkipForMethodLookup | MemberAccessFlags.SkipObjectBaseClass\n            );\n            if (setAttrType) {\n                // The type doesn't matter for a set usage. We just need\n                // to return a defined type.\n                return AnyType.create();\n            }\n        } else {\n            assert(usage.method === 'del');\n            const delAttrType = getTypeFromClassMember(\n                errorNode,\n                classType,\n                '__detattr__',\n                { method: 'get' },\n                new DiagnosticAddendum(),\n                MemberAccessFlags.SkipForMethodLookup | MemberAccessFlags.SkipObjectBaseClass\n            );\n            if (delAttrType) {\n                // The type doesn't matter for a delete usage. We just need\n                // to return a defined type.\n                return AnyType.create();\n            }\n        }\n\n        return undefined;\n    }\n\n    function getTypeFromIndex(node: IndexNode, flags = EvaluatorFlags.None): TypeResult {\n        const baseTypeResult = getTypeOfExpression(\n            node.baseExpression,\n            undefined,\n            flags | EvaluatorFlags.DoNotSpecialize\n        );\n\n        // Check for builtin classes that will generate runtime exceptions if subscripted.\n        if ((flags & EvaluatorFlags.AllowForwardReferences) === 0) {\n            const fileInfo = getFileInfo(node);\n            if (isClass(baseTypeResult.type) && ClassType.isBuiltIn(baseTypeResult.type)) {\n                const minPythonVersion = nonSubscriptableBuiltinTypes[baseTypeResult.type.details.fullName];\n                if (minPythonVersion !== undefined && fileInfo.executionEnvironment.pythonVersion < minPythonVersion) {\n                    addDiagnostic(\n                        fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                        DiagnosticRule.reportGeneralTypeIssues,\n                        Localizer.Diagnostic.classNotRuntimeSubscriptable().format({\n                            name: baseTypeResult.type.details.name,\n                        }),\n                        node.baseExpression\n                    );\n                }\n            }\n        }\n\n        return getTypeFromIndexWithBaseType(node, baseTypeResult.type, { method: 'get' }, flags);\n    }\n\n    function getTypeFromIndexWithBaseType(\n        node: IndexNode,\n        baseType: Type,\n        usage: EvaluatorUsage,\n        flags: EvaluatorFlags\n    ): TypeResult {\n        // Handle the case where we're specializing a generic union\n        // of classes, a callable, or a specialized class.\n        if (\n            baseType.category === TypeCategory.Union ||\n            baseType.category === TypeCategory.Function ||\n            (isClass(baseType) && baseType.typeArguments)\n        ) {\n            const isUnionOfClasses = isUnionableType([baseType]);\n\n            if (isUnionOfClasses) {\n                const typeParameters: TypeVarType[] = [];\n                doForSubtypes(baseType, (subtype) => {\n                    addTypeVarsToListIfUnique(typeParameters, getTypeVarArgumentsRecursive(subtype));\n                    return undefined;\n                });\n\n                if (typeParameters.length > 0) {\n                    const typeArgs = getTypeArgs(node.items, flags);\n\n                    if (typeArgs.length > typeParameters.length) {\n                        addError(\n                            Localizer.Diagnostic.typeArgsTooMany().format({\n                                name: printType(baseType),\n                                expected: typeParameters.length,\n                                received: typeArgs.length,\n                            }),\n                            typeArgs[typeParameters.length].node\n                        );\n                    }\n\n                    const typeVarMap = new TypeVarMap();\n                    const diag = new DiagnosticAddendum();\n                    typeParameters.forEach((param, index) => {\n                        assignTypeToTypeVar(\n                            param,\n                            index < typeArgs.length ? convertToInstance(typeArgs[index].type) : UnknownType.create(),\n                            /* canNarrowType */ false,\n                            diag,\n                            typeVarMap\n                        );\n                    });\n\n                    if (!diag.isEmpty()) {\n                        addError(\n                            Localizer.Diagnostic.typeNotSpecializable().format({ type: printType(baseType) }) +\n                                diag.getString(),\n                            node.items\n                        );\n                    }\n\n                    let type = specializeType(baseType, typeVarMap);\n                    if (baseType.typeAliasInfo && type !== baseType) {\n                        const typeArgs: Type[] = [];\n                        baseType.typeAliasInfo.typeParameters?.forEach((typeParam) => {\n                            typeArgs.push(typeVarMap.getTypeVar(typeParam) || UnknownType.create());\n                        });\n\n                        type = TypeBase.cloneForTypeAlias(\n                            type,\n                            baseType.typeAliasInfo.aliasName,\n                            baseType.typeAliasInfo.typeParameters,\n                            typeArgs\n                        );\n                    }\n\n                    return { type, node };\n                }\n            }\n        }\n\n        const type = doForSubtypes(baseType, (subtype) => {\n            subtype = makeTypeVarsConcrete(subtype);\n\n            if (isAnyOrUnknown(subtype)) {\n                return subtype;\n            }\n\n            if (isClass(subtype)) {\n                // Setting the value of an indexed class will always result\n                // in an exception.\n                if (usage.method === 'set') {\n                    addError(Localizer.Diagnostic.genericClassAssigned(), node.baseExpression);\n                } else if (usage.method === 'del') {\n                    addError(Localizer.Diagnostic.genericClassDeleted(), node.baseExpression);\n                }\n\n                if (ClassType.isSpecialBuiltIn(subtype, 'Literal')) {\n                    // Special-case Literal types.\n                    return createLiteralType(node);\n                }\n\n                if (ClassType.isBuiltIn(subtype, 'InitVar')) {\n                    // Special-case InitVar, used in data classes.\n                    const typeArgs = getTypeArgs(node.items, flags);\n                    if (typeArgs.length === 1) {\n                        return typeArgs[0].type;\n                    } else {\n                        addError(\n                            Localizer.Diagnostic.typeArgsMismatchOne().format({ received: typeArgs.length }),\n                            node.baseExpression\n                        );\n                        return UnknownType.create();\n                    }\n                }\n\n                if (ClassType.isEnumClass(subtype)) {\n                    // Special-case Enum types.\n                    // TODO - validate that there's only one index entry\n                    // that is a str type.\n                    // TODO - validate that literal strings are referencing\n                    // a known enum member.\n                    return ObjectType.create(subtype);\n                }\n\n                // Handle the case where the base type is \"Tuple\". We need to\n                // perform special processing of the type args in this case to permit\n                // empty tuples.\n                let adjustedFlags = flags;\n                if (isClass(subtype) && isTupleClass(subtype)) {\n                    adjustedFlags |= EvaluatorFlags.AllowEmptyTupleAsType;\n                }\n\n                const isAnnotatedClass = isClass(subtype) && ClassType.isBuiltIn(subtype, 'Annotated');\n\n                const typeArgs = getTypeArgs(node.items, adjustedFlags, isAnnotatedClass);\n                return createSpecializedClassType(subtype, typeArgs, flags, node);\n            }\n\n            if (isObject(subtype)) {\n                return getTypeFromIndexedObject(node, subtype, usage);\n            }\n\n            if (isNever(subtype)) {\n                return UnknownType.create();\n            }\n\n            if (isNone(subtype)) {\n                addDiagnostic(\n                    getFileInfo(node).diagnosticRuleSet.reportOptionalSubscript,\n                    DiagnosticRule.reportOptionalSubscript,\n                    Localizer.Diagnostic.noneNotSubscriptable(),\n                    node.baseExpression\n                );\n\n                return UnknownType.create();\n            }\n\n            if (!isUnbound(subtype)) {\n                const fileInfo = getFileInfo(node);\n                addDiagnostic(\n                    fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                    DiagnosticRule.reportGeneralTypeIssues,\n                    Localizer.Diagnostic.typeNotSubscriptable().format({ type: printType(subtype) }),\n                    node.baseExpression\n                );\n            }\n\n            return UnknownType.create();\n        });\n\n        // In case we didn't walk the list items above, do so now.\n        // If we have, this information will be cached.\n        node.items.items.forEach((item) => {\n            getTypeOfExpression(item, /* expectedType */ undefined, flags & EvaluatorFlags.AllowForwardReferences);\n        });\n\n        return { type, node };\n    }\n\n    function getTypeFromIndexedObject(node: IndexNode, baseType: ObjectType, usage: EvaluatorUsage): Type {\n        // Handle index operations for TypedDict classes specially.\n        if (ClassType.isTypedDictClass(baseType.classType)) {\n            if (node.items.items.length !== 1) {\n                addError(\n                    Localizer.Diagnostic.typeArgsMismatchOne().format({ received: node.items.items.length }),\n                    node\n                );\n                return UnknownType.create();\n            }\n\n            const entries = getTypedDictMembersForClass(baseType.classType);\n\n            const indexType = getTypeOfExpression(node.items.items[0]).type;\n            let diag = new DiagnosticAddendum();\n            const resultingType = doForSubtypes(indexType, (subtype) => {\n                if (isAnyOrUnknown(subtype)) {\n                    return subtype;\n                }\n\n                if (isObject(subtype) && ClassType.isBuiltIn(subtype.classType, 'str')) {\n                    if (subtype.classType.literalValue === undefined) {\n                        // If it's a plain str with no literal value, we can't\n                        // make any determination about the resulting type.\n                        return UnknownType.create();\n                    }\n\n                    // Look up the entry in the typed dict to get its type.\n                    const entryName = subtype.classType.literalValue as string;\n                    const entry = entries.get(entryName);\n                    if (!entry) {\n                        diag.addMessage(\n                            Localizer.DiagnosticAddendum.keyUndefined().format({\n                                name: entryName,\n                                type: printType(baseType),\n                            })\n                        );\n                        return UnknownType.create();\n                    }\n\n                    if (usage.method === 'set') {\n                        canAssignType(entry.valueType, usage.setType!, diag);\n                    } else if (usage.method === 'del' && entry.isRequired) {\n                        const fileInfo = getFileInfo(node);\n                        addDiagnostic(\n                            fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                            DiagnosticRule.reportGeneralTypeIssues,\n                            Localizer.Diagnostic.keyRequiredDeleted().format({ name: entryName }),\n                            node\n                        );\n                    }\n\n                    return entry.valueType;\n                }\n\n                diag.addMessage(\n                    Localizer.DiagnosticAddendum.typeNotStringLiteral().format({ type: printType(subtype) })\n                );\n                return UnknownType.create();\n            });\n\n            // If we have an \"expected type\" diagnostic addendum (used for assignments),\n            // use that rather than the local diagnostic information because it will\n            // be more informative.\n            if (usage.setExpectedTypeDiag) {\n                diag = usage.setExpectedTypeDiag;\n            }\n\n            if (!diag.isEmpty()) {\n                let typedDictDiag: string;\n                if (usage.method === 'set') {\n                    typedDictDiag = Localizer.Diagnostic.typedDictSet();\n                } else if (usage.method === 'del') {\n                    typedDictDiag = Localizer.Diagnostic.typedDictDelete();\n                } else {\n                    typedDictDiag = Localizer.Diagnostic.typedDictAccess();\n                }\n\n                const fileInfo = getFileInfo(node);\n                addDiagnostic(\n                    fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                    DiagnosticRule.reportGeneralTypeIssues,\n                    typedDictDiag + diag.getString(),\n                    node\n                );\n            }\n\n            return resultingType;\n        }\n\n        let magicMethodName: string;\n        if (usage.method === 'get') {\n            magicMethodName = '__getitem__';\n        } else if (usage.method === 'set') {\n            magicMethodName = '__setitem__';\n        } else {\n            assert(usage.method === 'del');\n            magicMethodName = '__delitem__';\n        }\n\n        const itemMethodType = getTypeFromObjectMember(\n            node,\n            baseType,\n            magicMethodName,\n            { method: 'get' },\n            new DiagnosticAddendum(),\n            MemberAccessFlags.SkipForMethodLookup\n        );\n\n        if (!itemMethodType) {\n            const fileInfo = getFileInfo(node);\n            addDiagnostic(\n                fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                DiagnosticRule.reportGeneralTypeIssues,\n                Localizer.Diagnostic.methodNotDefinedOnType().format({\n                    name: magicMethodName,\n                    type: printType(baseType),\n                }),\n                node.baseExpression\n            );\n            return UnknownType.create();\n        }\n\n        const indexTypeList = node.items.items.map((item) => getTypeOfExpression(item).type);\n\n        let indexType: Type;\n        if (indexTypeList.length === 1) {\n            indexType = indexTypeList[0];\n\n            // Handle the special case where the object is a Tuple and\n            // the index is a constant number. In such case, we can determine\n            // the exact type by indexing into the tuple type array.\n            const baseTypeClass = baseType.classType;\n\n            if (\n                node.items.items[0].nodeType === ParseNodeType.Number &&\n                node.items.items[0].isInteger &&\n                !node.items.items[0].isImaginary\n            ) {\n                const tupleType = getSpecializedTupleType(baseTypeClass);\n                if (tupleType && tupleType.typeArguments && tupleType.typeArguments.length > 0) {\n                    const numberNode = node.items.items[0];\n\n                    if (numberNode.isInteger && numberNode.value >= 0) {\n                        if (tupleType.typeArguments.length === 2 && isEllipsisType(tupleType.typeArguments[1])) {\n                            return tupleType.typeArguments[0];\n                        } else if (numberNode.value < tupleType.typeArguments.length) {\n                            return tupleType.typeArguments[numberNode.value];\n                        }\n                    }\n                }\n            }\n        } else {\n            // Handle the case where the index expression is a tuple. This\n            // isn't used in most cases, but it is supported by the language.\n            const builtInTupleType = getBuiltInType(node, 'Tuple');\n            if (isClass(builtInTupleType)) {\n                indexType = convertToInstance(\n                    cloneTupleForSpecialization(builtInTupleType, indexTypeList, /* isTypeArgumentExplicit */ false)\n                );\n            } else {\n                indexType = UnknownType.create();\n            }\n        }\n\n        const argList: FunctionArgument[] = [\n            {\n                argumentCategory: ArgumentCategory.Simple,\n                type: indexType,\n            },\n        ];\n\n        if (usage.method === 'set') {\n            argList.push({\n                argumentCategory: ArgumentCategory.Simple,\n                type: usage.setType || AnyType.create(),\n            });\n        }\n\n        const callResult = validateCallArguments(\n            node,\n            argList,\n            itemMethodType,\n            new TypeVarMap(),\n            /* skipUnknownArgCheck */ false,\n            /* inferReturnTypeIfNeeded */ true,\n            /* expectedType */ undefined\n        );\n\n        return callResult.returnType || UnknownType.create();\n    }\n\n    function getTypeArgs(node: IndexItemsNode, flags: EvaluatorFlags, isAnnotatedClass = false): TypeResult[] {\n        const typeArgs: TypeResult[] = [];\n        const adjFlags = flags & ~EvaluatorFlags.ParamSpecDisallowed;\n\n        node.items.forEach((expr, index) => {\n            // If it's an Annotated[a, b, c], only the first index should be treated\n            // as a type. The others can be regular (non-type) objects.\n            if (isAnnotatedClass && index > 0) {\n                typeArgs.push(\n                    getTypeOfExpression(\n                        expr,\n                        /* expectedType */ undefined,\n                        EvaluatorFlags.ParamSpecDisallowed | EvaluatorFlags.DoNotSpecialize\n                    )\n                );\n            } else {\n                typeArgs.push(getTypeArg(expr, adjFlags));\n            }\n        });\n\n        return typeArgs;\n    }\n\n    function getTypeArg(node: ExpressionNode, flags: EvaluatorFlags): TypeResult {\n        let typeResult: TypeResult;\n\n        let adjustedFlags =\n            flags |\n            EvaluatorFlags.ExpectingType |\n            EvaluatorFlags.ConvertEllipsisToAny |\n            EvaluatorFlags.EvaluateStringLiteralAsType |\n            EvaluatorFlags.FinalDisallowed;\n\n        const fileInfo = getFileInfo(node);\n        if (isAnnotationEvaluationPostponed(fileInfo)) {\n            adjustedFlags |= EvaluatorFlags.AllowForwardReferences;\n        }\n\n        if (node.nodeType === ParseNodeType.List) {\n            typeResult = {\n                type: UnknownType.create(),\n                typeList: node.entries.map((entry) => getTypeOfExpression(entry, undefined, adjustedFlags)),\n                node,\n            };\n        } else {\n            typeResult = getTypeOfExpression(node, /* expectedType */ undefined, adjustedFlags);\n        }\n\n        return typeResult;\n    }\n\n    function getTypeFromTuple(node: TupleNode, expectedType: Type | undefined): TypeResult {\n        // Build an array of expected types.\n        const expectedTypes: Type[] = [];\n        if (expectedType && isObject(expectedType)) {\n            const tupleClass = expectedType.classType;\n\n            if (isTupleClass(tupleClass) && tupleClass.typeArguments) {\n                // Is this a homogeneous tuple of indeterminate length? If so,\n                // match the number of expected types to the number of entries\n                // in the tuple expression.\n                if (tupleClass.typeArguments.length === 2 && isEllipsisType(tupleClass.typeArguments[1])) {\n                    for (let i = 0; i < node.expressions.length; i++) {\n                        expectedTypes.push(transformPossibleRecursiveTypeAlias(tupleClass.typeArguments[0]));\n                    }\n                } else {\n                    tupleClass.typeArguments.forEach((typeArg) => {\n                        expectedTypes.push(transformPossibleRecursiveTypeAlias(typeArg));\n                    });\n                }\n            }\n        }\n\n        const entryTypeResults = node.expressions.map((expr, index) =>\n            getTypeOfExpression(expr, index < expectedTypes.length ? expectedTypes[index] : undefined)\n        );\n\n        let type: Type = UnknownType.create();\n        const builtInTupleType = getBuiltInType(node, 'Tuple');\n\n        if (isClass(builtInTupleType)) {\n            let tupleTypes: Type[] = [];\n            for (const typeResult of entryTypeResults) {\n                if (typeResult.unpackedType) {\n                    // Is this an unpacked tuple? If so, we can append the individual\n                    // unpacked entries onto the new tuple. If it's not an upacked tuple\n                    // but some other iterator (e.g. a List), we won't know the number of\n                    // items, so we'll need to leave the Tuple open-ended.\n                    if (isObject(typeResult.unpackedType) && isTupleClass(typeResult.unpackedType.classType)) {\n                        const typeArgs = typeResult.unpackedType.classType.typeArguments;\n\n                        // If the Tuple wasn't specialized or has a \"...\" type parameter, we can't\n                        // make any determination about its contents.\n                        if (!typeArgs || typeArgs.some((t) => isEllipsisType(t))) {\n                            tupleTypes = [AnyType.create(false), AnyType.create(true)];\n                            break;\n                        }\n\n                        for (const typeArg of typeArgs) {\n                            tupleTypes.push(typeArg);\n                        }\n                    } else {\n                        tupleTypes = [AnyType.create(false), AnyType.create(true)];\n                        break;\n                    }\n                } else {\n                    tupleTypes.push(typeResult.type);\n                }\n            }\n\n            type = convertToInstance(\n                cloneTupleForSpecialization(builtInTupleType, tupleTypes, /* isTypeArgumentExplicit */ true)\n            );\n        }\n\n        return { type, node };\n    }\n\n    // Classes of type Tuple and tuple require special handling because they\n    // support variadic type parameters (including a form that represents homogenous\n    // arbitrary-length tuples).\n    function cloneTupleForSpecialization(\n        tupleClass: ClassType,\n        typeArgs: Type[],\n        isTypeArgumentExplicit: boolean\n    ): ClassType {\n        // Create a copy of the Tuple class that overrides the normal MRO\n        // entries with a version of Tuple and/or tuple that are specialized\n        // appropriately.\n        let combinedTupleType: Type = AnyType.create(false);\n        if (typeArgs.length === 2 && isEllipsisType(typeArgs[1])) {\n            combinedTupleType = typeArgs[0];\n        } else {\n            combinedTupleType = combineTypes(typeArgs);\n        }\n\n        const effectiveTypeArguments = [combinedTupleType];\n        const specializedTuple = ClassType.cloneForSpecialization(\n            tupleClass,\n            typeArgs,\n            isTypeArgumentExplicit,\n            /* skipAbstractClassTest */ undefined,\n            effectiveTypeArguments\n        );\n        specializedTuple.details = { ...specializedTuple.details };\n        specializedTuple.details.mro = [...specializedTuple.details.mro];\n        specializedTuple.details.mro[0] = specializedTuple;\n\n        // Handle the specialization of \"Tuple\" which inherits from \"tuple\".\n        if (ClassType.isBuiltIn(tupleClass, 'Tuple')) {\n            if (\n                tupleClass.details.mro.length >= 2 &&\n                isClass(tupleClass.details.mro[0]) &&\n                ClassType.isBuiltIn(tupleClass.details.mro[0], 'Tuple') &&\n                isClass(tupleClass.details.mro[1]) &&\n                ClassType.isBuiltIn(tupleClass.details.mro[1], 'tuple')\n            ) {\n                specializedTuple.details.mro[1] = ClassType.cloneForSpecialization(\n                    specializedTuple.details.mro[1] as ClassType,\n                    [combinedTupleType],\n                    isTypeArgumentExplicit,\n                    /* skipAbstractClassTest */ undefined,\n                    effectiveTypeArguments\n                );\n\n                return specializedTuple;\n            }\n        }\n\n        // Handle the specialization of \"tuple\" directly.\n        if (ClassType.isBuiltIn(tupleClass, 'tuple')) {\n            if (\n                tupleClass.details.mro.length >= 1 &&\n                isClass(tupleClass.details.mro[0]) &&\n                ClassType.isBuiltIn(tupleClass.details.mro[0], 'tuple')\n            ) {\n                return specializedTuple;\n            }\n        }\n\n        return tupleClass;\n    }\n\n    function updateNamedTupleBaseClass(classType: ClassType, typeArgs: Type[], isTypeArgumentExplicit: boolean) {\n        // Search for the NamedTuple base class.\n        const namedTupleIndex = classType.details.mro.findIndex(\n            (c) => isClass(c) && ClassType.isBuiltIn(c, 'NamedTuple')\n        );\n        if (namedTupleIndex < 0 || classType.details.mro.length < namedTupleIndex + 2) {\n            return;\n        }\n\n        const namedTupleClass = classType.details.mro[namedTupleIndex] as ClassType;\n        const typedTupleClass = classType.details.mro[namedTupleIndex + 1];\n        const tupleClass = classType.details.mro[namedTupleIndex + 2];\n\n        if (\n            !isClass(typedTupleClass) ||\n            !ClassType.isBuiltIn(typedTupleClass, 'Tuple') ||\n            !isClass(tupleClass) ||\n            !ClassType.isBuiltIn(tupleClass, 'tuple')\n        ) {\n            return;\n        }\n\n        const updatedTupleClass = cloneTupleForSpecialization(typedTupleClass, typeArgs, isTypeArgumentExplicit);\n\n        // Create a copy of the NamedTuple class that overrides the normal MRO\n        // entries with a version of Tuple and tuple that are specialized\n        // appropriately.\n        const clonedNamedTupleClass = ClassType.cloneForSpecialization(namedTupleClass, [], isTypeArgumentExplicit);\n        clonedNamedTupleClass.details = { ...clonedNamedTupleClass.details };\n        clonedNamedTupleClass.details.mro = [...clonedNamedTupleClass.details.mro];\n        clonedNamedTupleClass.details.mro[1] = updatedTupleClass.details.mro[0];\n        clonedNamedTupleClass.details.mro[2] = updatedTupleClass.details.mro[1];\n\n        classType.details.mro[namedTupleIndex] = clonedNamedTupleClass;\n        classType.details.mro[namedTupleIndex + 1] = updatedTupleClass.details.mro[0];\n        classType.details.mro[namedTupleIndex + 2] = updatedTupleClass.details.mro[1];\n    }\n\n    function getTypeFromCall(node: CallNode, expectedType: Type | undefined, flags: EvaluatorFlags): TypeResult {\n        const baseTypeResult = getTypeOfExpression(node.leftExpression, undefined, EvaluatorFlags.DoNotSpecialize);\n\n        // Handle the built-in \"super\" call specially.\n        if (node.leftExpression.nodeType === ParseNodeType.Name && node.leftExpression.value === 'super') {\n            return {\n                type: getTypeFromSuperCall(node),\n                node,\n            };\n        }\n\n        // Handle the special-case \"reveal_type\" call.\n        if (\n            isAnyOrUnknown(baseTypeResult.type) &&\n            node.leftExpression.nodeType === ParseNodeType.Name &&\n            node.leftExpression.value === 'reveal_type' &&\n            node.arguments.length === 1 &&\n            node.arguments[0].argumentCategory === ArgumentCategory.Simple &&\n            node.arguments[0].name === undefined\n        ) {\n            const type = getTypeOfExpression(node.arguments[0].valueExpression).type;\n            const exprString = ParseTreeUtils.printExpression(node.arguments[0].valueExpression);\n            const typeString = printType(type);\n            addInformation(`Type of \"${exprString}\" is \"${typeString}\"`, node.arguments[0]);\n\n            // Return a literal string with the type. We can use this in unit tests\n            // to validate the exact type.\n            const strType = getBuiltInType(node, 'str');\n            if (isClass(strType)) {\n                return { type: ObjectType.create(ClassType.cloneWithLiteral(strType, typeString)), node };\n            }\n            return { type: AnyType.create(), node };\n        }\n\n        const argList = node.arguments.map((arg) => {\n            const functionArg: FunctionArgument = {\n                valueExpression: arg.valueExpression,\n                argumentCategory: arg.argumentCategory,\n                name: arg.name,\n            };\n            return functionArg;\n        });\n\n        return getTypeFromCallWithBaseType(\n            node,\n            argList,\n            baseTypeResult,\n            expectedType,\n            flags & ~EvaluatorFlags.DoNotSpecialize\n        );\n    }\n\n    function getTypeFromSuperCall(node: CallNode): Type {\n        if (node.arguments.length > 2) {\n            addError(Localizer.Diagnostic.superCallArgCount(), node.arguments[2]);\n        }\n\n        // Determine which class the \"super\" call is applied to. If\n        // there is no first argument, then the class is implicit.\n        let targetClassType: Type;\n        if (node.arguments.length > 0) {\n            targetClassType = getTypeOfExpression(node.arguments[0].valueExpression).type;\n\n            if (!isAnyOrUnknown(targetClassType) && !isClass(targetClassType)) {\n                addError(\n                    Localizer.Diagnostic.superCallFirstArg().format({ type: printType(targetClassType) }),\n                    node.arguments[0].valueExpression\n                );\n            }\n        } else {\n            const enclosingClass = ParseTreeUtils.getEnclosingClass(node);\n            if (enclosingClass) {\n                const classTypeInfo = getTypeOfClass(enclosingClass);\n                targetClassType = classTypeInfo ? classTypeInfo.classType : UnknownType.create();\n            } else {\n                addError(Localizer.Diagnostic.superCallZeroArgForm(), node.leftExpression);\n                targetClassType = UnknownType.create();\n            }\n        }\n\n        // Determine whether to further narrow the type.\n        let narrowedClassType: Type;\n        if (node.arguments.length > 1) {\n            narrowedClassType = specializeType(\n                getTypeOfExpression(node.arguments[1].valueExpression).type,\n                /* typeVarMap */ undefined\n            );\n\n            let reportError = false;\n\n            if (isAnyOrUnknown(narrowedClassType)) {\n                // Ignore unknown or any types.\n            } else if (isObject(narrowedClassType)) {\n                const childClassType = narrowedClassType.classType;\n                if (isClass(targetClassType)) {\n                    if (!derivesFromClassRecursive(childClassType, targetClassType, /* ignoreUnknown */ true)) {\n                        reportError = true;\n                    }\n                }\n            } else if (isClass(narrowedClassType)) {\n                if (isClass(targetClassType)) {\n                    if (!derivesFromClassRecursive(narrowedClassType, targetClassType, /* ignoreUnknown */ true)) {\n                        reportError = true;\n                    }\n                }\n            } else {\n                reportError = true;\n            }\n\n            if (reportError) {\n                const fileInfo = getFileInfo(node);\n                addDiagnostic(\n                    fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                    DiagnosticRule.reportGeneralTypeIssues,\n                    Localizer.Diagnostic.superCallSecondArg().format({ type: printType(targetClassType) }),\n                    node.arguments[1].valueExpression\n                );\n            }\n        }\n\n        // Python docs indicate that super() isn't valid for\n        // operations other than member accesses or attribute lookups.\n        const parentNode = node.parent!;\n        if (parentNode.nodeType === ParseNodeType.MemberAccess) {\n            const memberName = parentNode.memberName.value;\n            const lookupResults = lookUpClassMember(\n                targetClassType,\n                memberName,\n                ClassMemberLookupFlags.SkipOriginalClass\n            );\n            if (lookupResults && isClass(lookupResults.classType)) {\n                return ObjectType.create(lookupResults.classType);\n            }\n        }\n\n        // If the lookup failed, try to return the first base class. An error\n        // will be reported by the member lookup logic at a later time.\n        if (isClass(targetClassType)) {\n            // If the class derives from one or more unknown classes,\n            // return unknown here to prevent spurious errors.\n            if (targetClassType.details.mro.some((mroBase) => isAnyOrUnknown(mroBase))) {\n                return UnknownType.create();\n            }\n\n            const baseClasses = targetClassType.details.baseClasses;\n            if (baseClasses.length > 0) {\n                const baseClassType = baseClasses[0];\n                if (isClass(baseClassType)) {\n                    return ObjectType.create(baseClassType);\n                }\n            }\n        }\n\n        return UnknownType.create();\n    }\n\n    function getTypeFromCallWithBaseType(\n        errorNode: ExpressionNode,\n        argList: FunctionArgument[],\n        baseTypeResult: TypeResult,\n        expectedType: Type | undefined,\n        flags: EvaluatorFlags\n    ): TypeResult {\n        let type: Type | undefined;\n        const callType = makeTypeVarsConcrete(baseTypeResult.type);\n        const skipUnknownArgCheck = (flags & EvaluatorFlags.DoNotCheckForUnknownArgs) !== 0;\n\n        switch (callType.category) {\n            case TypeCategory.Class: {\n                if (ClassType.isBuiltIn(callType)) {\n                    const className = callType.details.name;\n\n                    if (className === 'type') {\n                        // Validate the constructor arguments.\n                        validateConstructorArguments(errorNode, argList, callType, skipUnknownArgCheck, expectedType);\n\n                        // Handle the 'type' call specially.\n                        if (argList.length === 1) {\n                            // The one-parameter form of \"type\" returns the class\n                            // for the specified object.\n                            const argType = getTypeForArgument(argList[0]);\n                            if (isObject(argType)) {\n                                type = argType.classType;\n                            } else if (argType.category === TypeCategory.None) {\n                                type = NoneType.createType();\n                            }\n                        } else if (argList.length >= 2) {\n                            // The two-parameter form of \"type\" returns a new class type\n                            // built from the specified base types.\n                            type = createType(errorNode, argList);\n                        }\n\n                        // If the parameter to type() is not statically known,\n                        // fall back to Any.\n                        if (!type) {\n                            type = AnyType.create();\n                        }\n                    } else if (className === 'TypeVar') {\n                        type = createTypeVarType(errorNode, argList, /* isParamSpec */ false);\n                    } else if (className === 'ParamSpec') {\n                        type = createTypeVarType(errorNode, argList, /* isParamSpec */ true);\n                    } else if (className === 'NamedTuple') {\n                        type = createNamedTupleType(errorNode, argList, true);\n                    } else if (\n                        className === 'Protocol' ||\n                        className === 'Generic' ||\n                        className === 'Callable' ||\n                        className === 'Concatenate' ||\n                        className === 'Type'\n                    ) {\n                        const fileInfo = getFileInfo(errorNode);\n                        addDiagnostic(\n                            fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                            DiagnosticRule.reportGeneralTypeIssues,\n                            Localizer.Diagnostic.typeNotIntantiable().format({ type: className }),\n                            errorNode\n                        );\n                    } else if (\n                        className === 'Enum' ||\n                        className === 'IntEnum' ||\n                        className === 'Flag' ||\n                        className === 'IntFlag'\n                    ) {\n                        type = createEnumType(errorNode, callType, argList);\n                    } else if (className === 'TypedDict') {\n                        type = createTypedDictType(errorNode, callType, argList);\n                    } else if (className === 'auto' && argList.length === 0) {\n                        type = getBuiltInObject(errorNode, 'int');\n                    }\n                } else if (isClass(baseTypeResult.type) && ClassType.hasAbstractMethods(callType)) {\n                    // If the class is abstract, it can't be instantiated.\n                    const abstractMethods = getAbstractMethods(callType);\n\n                    const diagAddendum = new DiagnosticAddendum();\n                    const errorsToDisplay = 2;\n\n                    abstractMethods.forEach((abstractMethod, index) => {\n                        if (index === errorsToDisplay) {\n                            diagAddendum.addMessage(\n                                Localizer.DiagnosticAddendum.memberIsAbstractMore().format({\n                                    count: abstractMethods.length - errorsToDisplay,\n                                })\n                            );\n                        } else if (index < errorsToDisplay) {\n                            if (isClass(abstractMethod.classType)) {\n                                const className = abstractMethod.classType.details.name;\n                                diagAddendum.addMessage(\n                                    Localizer.DiagnosticAddendum.memberIsAbstract().format({\n                                        type: className,\n                                        name: abstractMethod.symbolName,\n                                    })\n                                );\n                            }\n                        }\n                    });\n\n                    const fileInfo = getFileInfo(errorNode);\n                    addDiagnostic(\n                        fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                        DiagnosticRule.reportGeneralTypeIssues,\n                        Localizer.Diagnostic.typeAbstract().format({ type: callType.details.name }) +\n                            diagAddendum.getString(),\n                        errorNode\n                    );\n                }\n\n                // Assume this is a call to the constructor.\n                if (!type) {\n                    type = validateConstructorArguments(errorNode, argList, callType, skipUnknownArgCheck, expectedType)\n                        .returnType;\n                }\n\n                // If we instantiated a type, transform it into a class.\n                // This can happen if someone directly instantiates a metaclass\n                // deriving from type.\n                if (\n                    type &&\n                    isObject(type) &&\n                    type.classType.details.mro.some(\n                        (baseClass) => isClass(baseClass) && ClassType.isBuiltIn(baseClass, 'type')\n                    )\n                ) {\n                    // We don't know the name of the new class in this case.\n                    const newClassName = '__class_' + type.classType.details.name;\n                    const newClassType = ClassType.create(\n                        newClassName,\n                        '',\n                        '',\n                        ClassTypeFlags.None,\n                        errorNode.id,\n                        type.classType,\n                        type.classType\n                    );\n                    type = newClassType;\n                }\n                break;\n            }\n\n            case TypeCategory.Function: {\n                // The stdlib collections/__init__.pyi stub file defines namedtuple\n                // as a function rather than a class, so we need to check for it here.\n                if (callType.details.builtInName === 'namedtuple') {\n                    addDiagnostic(\n                        getFileInfo(errorNode).diagnosticRuleSet.reportUntypedNamedTuple,\n                        DiagnosticRule.reportUntypedNamedTuple,\n                        Localizer.Diagnostic.namedTupleNoTypes(),\n                        errorNode\n                    );\n                    type = createNamedTupleType(errorNode, argList, false);\n                } else if (callType.details.builtInName === 'NewType') {\n                    const callResult = validateCallArguments(\n                        errorNode,\n                        argList,\n                        callType,\n                        new TypeVarMap(),\n                        skipUnknownArgCheck,\n                        /* inferReturnTypeIfNeeded */ true,\n                        expectedType\n                    );\n\n                    // If the call's arguments were validated, replace the\n                    // type with a new synthesized subclass.\n                    type = callResult.argumentErrors ? callResult.returnType : createNewType(errorNode, argList);\n                } else {\n                    type = validateCallArguments(\n                        errorNode,\n                        argList,\n                        callType,\n                        new TypeVarMap(),\n                        skipUnknownArgCheck,\n                        /* inferReturnTypeIfNeeded */ true,\n                        expectedType\n                    ).returnType;\n\n                    if (callType.details.builtInName === '__import__') {\n                        // For the special __import__ type, we'll override the return type to be \"Any\".\n                        // This is required because we don't know what module was imported, and we don't\n                        // want to fail type checks when accessing members of the resulting module type.\n                        type = AnyType.create();\n                    }\n                }\n\n                if (!type) {\n                    type = UnknownType.create();\n                }\n                break;\n            }\n\n            case TypeCategory.OverloadedFunction: {\n                // Determine which of the overloads (if any) match.\n                const functionType = findOverloadedFunctionType(errorNode, argList, callType, expectedType);\n\n                if (functionType) {\n                    if (functionType.details.builtInName === 'cast' && argList.length === 2) {\n                        // Verify that the cast is necessary.\n                        const castToType = getTypeForArgumentExpectingType(argList[0], getFileInfo(errorNode));\n                        const castFromType = getTypeForArgument(argList[1]);\n                        if (isClass(castToType) && isObject(castFromType)) {\n                            if (isTypeSame(castToType, castFromType.classType)) {\n                                addDiagnostic(\n                                    getFileInfo(errorNode).diagnosticRuleSet.reportUnnecessaryCast,\n                                    DiagnosticRule.reportUnnecessaryCast,\n                                    Localizer.Diagnostic.unnecessaryCast().format({ type: printType(castFromType) }),\n                                    errorNode\n                                );\n                            }\n                        }\n\n                        type = convertToInstance(castToType);\n                    } else {\n                        type = validateCallArguments(\n                            errorNode,\n                            argList,\n                            functionType,\n                            new TypeVarMap(),\n                            skipUnknownArgCheck,\n                            /* inferReturnTypeIfNeeded */ true,\n                            expectedType\n                        ).returnType;\n                        if (!type) {\n                            type = UnknownType.create();\n                        }\n                    }\n                } else {\n                    const exprString = ParseTreeUtils.printExpression(errorNode);\n                    const diagAddendum = new DiagnosticAddendum();\n                    const argTypes = argList.map((t) => printType(getTypeForArgument(t)));\n\n                    if (errorNode.nodeType !== ParseNodeType.Call && callType.overloads[0].details.name) {\n                        // If the expression isn't an explicit call, it is probably an implicit\n                        // call to a magic method. Provide additional information in this case\n                        // to make it clear that a call was being evaluated.\n                        diagAddendum.addMessage(\n                            Localizer.DiagnosticAddendum.overloadCallName().format({\n                                name: callType.overloads[0].details.name,\n                            })\n                        );\n                    }\n\n                    diagAddendum.addMessage(\n                        Localizer.DiagnosticAddendum.argumentTypes().format({ types: argTypes.join(', ') })\n                    );\n                    const fileInfo = getFileInfo(errorNode);\n                    addDiagnostic(\n                        fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                        DiagnosticRule.reportGeneralTypeIssues,\n                        Localizer.Diagnostic.noOverload().format({ expression: exprString }) + diagAddendum.getString(),\n                        errorNode\n                    );\n                    type = UnknownType.create();\n                }\n                break;\n            }\n\n            case TypeCategory.Object: {\n                // Handle the \"Type\" object specially.\n                const classFromTypeObject = getClassFromPotentialTypeObject(callType);\n                if (classFromTypeObject) {\n                    if (isAnyOrUnknown(classFromTypeObject)) {\n                        type = classFromTypeObject;\n                    } else if (isClass(classFromTypeObject)) {\n                        type = validateConstructorArguments(\n                            errorNode,\n                            argList,\n                            classFromTypeObject,\n                            skipUnknownArgCheck,\n                            expectedType\n                        ).returnType;\n                    }\n                } else {\n                    const memberType = getTypeFromObjectMember(\n                        errorNode,\n                        callType,\n                        '__call__',\n                        { method: 'get' },\n                        new DiagnosticAddendum(),\n                        MemberAccessFlags.SkipForMethodLookup\n                    );\n                    if (memberType) {\n                        type = validateCallArguments(\n                            errorNode,\n                            argList,\n                            memberType,\n                            new TypeVarMap(),\n                            skipUnknownArgCheck,\n                            /* inferReturnTypeIfNeeded */ true,\n                            expectedType\n                        ).returnType;\n                        if (!type) {\n                            type = UnknownType.create();\n                        }\n                    }\n                }\n                break;\n            }\n\n            case TypeCategory.Union: {\n                const returnTypes: Type[] = [];\n                callType.subtypes.forEach((typeEntry) => {\n                    if (isNone(typeEntry)) {\n                        addDiagnostic(\n                            getFileInfo(errorNode).diagnosticRuleSet.reportOptionalCall,\n                            DiagnosticRule.reportOptionalCall,\n                            Localizer.Diagnostic.noneNotCallable(),\n                            errorNode\n                        );\n                    } else {\n                        const typeResult = getTypeFromCallWithBaseType(\n                            errorNode,\n                            argList,\n                            {\n                                type: typeEntry,\n                                node: baseTypeResult.node,\n                            },\n                            expectedType,\n                            flags\n                        );\n                        if (typeResult) {\n                            returnTypes.push(typeResult.type);\n                        }\n                    }\n                });\n\n                if (returnTypes.length > 0) {\n                    type = combineTypes(returnTypes);\n                }\n                break;\n            }\n\n            case TypeCategory.Any:\n            case TypeCategory.Unknown: {\n                // Mark the arguments accessed.\n                argList.forEach((arg) => getTypeForArgument(arg));\n                type = callType;\n                break;\n            }\n        }\n\n        if (!type) {\n            const fileInfo = getFileInfo(errorNode);\n            addDiagnostic(\n                fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                DiagnosticRule.reportGeneralTypeIssues,\n                Localizer.Diagnostic.typeNotCallable().format({\n                    expression: ParseTreeUtils.printExpression(errorNode),\n                    type: printType(callType),\n                }),\n                errorNode\n            );\n            type = UnknownType.create();\n\n            // Evaluate the arguments to generate errors and mark\n            // symbols as referenced.\n            argList.forEach((arg) => {\n                if (!arg.type && arg.valueExpression) {\n                    getTypeOfExpression(arg.valueExpression);\n                }\n            });\n        }\n\n        // Should we specialize the class?\n        if ((flags & EvaluatorFlags.DoNotSpecialize) === 0) {\n            if (isClass(type)) {\n                type = createSpecializedClassType(type, undefined, flags, errorNode);\n            }\n        }\n\n        return { type, node: baseTypeResult.node };\n    }\n\n    function findOverloadedFunctionType(\n        errorNode: ExpressionNode,\n        argList: FunctionArgument[],\n        callType: OverloadedFunctionType,\n        expectedType: Type | undefined\n    ): FunctionType | undefined {\n        let validOverload: FunctionType | undefined;\n\n        for (const overload of callType.overloads) {\n            // Only iterate through the functions that have the @overload\n            // decorator, not the final function that omits the overload.\n            // This is the intended behavior according to PEP 484.\n            if (FunctionType.isOverloaded(overload)) {\n                // Temporarily disable diagnostic output.\n                useSpeculativeMode(errorNode, () => {\n                    const callResult = validateCallArguments(\n                        errorNode,\n                        argList,\n                        overload,\n                        new TypeVarMap(),\n                        /* skipUnknownArgCheck */ true,\n                        /* inferReturnTypeIfNeeded */ false,\n                        expectedType\n                    );\n                    if (!callResult.argumentErrors) {\n                        validOverload = overload;\n                    }\n                });\n\n                if (validOverload) {\n                    break;\n                }\n            }\n        }\n\n        return validOverload;\n    }\n\n    // Tries to match the arguments of a call to the constructor for a class.\n    // If successful, it returns the resulting (specialized) object type that\n    // is allocated by the constructor. If unsuccessful, it records diagnostic\n    // information and returns undefined.\n    function validateConstructorArguments(\n        errorNode: ExpressionNode,\n        argList: FunctionArgument[],\n        type: ClassType,\n        skipUnknownArgCheck: boolean,\n        expectedType: Type | undefined\n    ): CallResult {\n        let validatedTypes = false;\n        let returnType: Type | undefined;\n        let reportedErrors = false;\n\n        // Create a helper function that determines whether we should skip argument\n        // validation for either __init__ or __new__. This is required for certain\n        // synthesized constructor types, namely NamedTuples.\n        const skipConstructorCheck = (type: Type) => {\n            if (type.category !== TypeCategory.Function) {\n                return false;\n            }\n            return FunctionType.isSkipConstructorCheck(type);\n        };\n\n        // Validate __init__\n        // We validate __init__ before __new__ because the former typically has\n        // more specific type annotations, and we want to evaluate the arguments\n        // in the context of these types. The __new__ method often uses generic\n        // vargs and kwargs.\n        const initMethodType = getTypeFromObjectMember(\n            errorNode,\n            ObjectType.create(type),\n            '__init__',\n            { method: 'get' },\n            new DiagnosticAddendum(),\n            MemberAccessFlags.SkipForMethodLookup | MemberAccessFlags.SkipObjectBaseClass\n        );\n\n        if (initMethodType && !skipConstructorCheck(initMethodType)) {\n            const typeVarMap = new TypeVarMap();\n\n            if (expectedType) {\n                populateTypeVarMapBasedOnExpectedType(ObjectType.create(type), expectedType, typeVarMap);\n            }\n\n            const callResult = validateCallArguments(\n                errorNode,\n                argList,\n                initMethodType,\n                typeVarMap,\n                skipUnknownArgCheck,\n                /* inferReturnTypeIfNeeded */ true,\n                NoneType.createInstance()\n            );\n            if (!callResult.argumentErrors) {\n                const specializedClassType = applyExpectedTypeForConstructor(\n                    specializeType(type, typeVarMap, /* makeConcrete */ true) as ClassType,\n                    expectedType\n                );\n                returnType = ObjectType.create(specializedClassType);\n            } else {\n                reportedErrors = true;\n            }\n            validatedTypes = true;\n            skipUnknownArgCheck = true;\n        }\n\n        // Validate __new__\n        // Don't report errors for __new__ if __init__ already generated errors. They're\n        // probably going to be entirely redundant anyway.\n        if (!reportedErrors) {\n            const constructorMethodInfo = getTypeFromClassMemberName(\n                errorNode,\n                type,\n                '__new__',\n                { method: 'get' },\n                new DiagnosticAddendum(),\n                MemberAccessFlags.SkipForMethodLookup | MemberAccessFlags.SkipObjectBaseClass\n            );\n            if (constructorMethodInfo && !skipConstructorCheck(constructorMethodInfo.type)) {\n                const constructorMethodType = bindFunctionToClassOrObject(\n                    type,\n                    constructorMethodInfo.type,\n                    /* treatAsClassMember */ true,\n                    errorNode\n                );\n                const typeVarMap = new TypeVarMap();\n\n                if (constructorMethodType) {\n                    // Skip the unknown argument check if we've already checked for __init__.\n                    const callResult = validateCallArguments(\n                        errorNode,\n                        argList,\n                        constructorMethodType,\n                        typeVarMap,\n                        skipUnknownArgCheck,\n                        /* inferReturnTypeIfNeeded */ true,\n                        expectedType\n                    );\n\n                    if (callResult.argumentErrors) {\n                        reportedErrors = true;\n                    } else {\n                        let newReturnType = callResult.returnType;\n\n                        // If the constructor returned an object whose type matches the class of\n                        // the original type being constructed, use the return type in case it was\n                        // specialized. If it doesn't match, we'll fall back on the assumption that\n                        // the constructed type is an instance of the class type. We need to do this\n                        // in cases where we're inferring the return type based on a call to\n                        // super().__new__().\n                        if (newReturnType) {\n                            if (\n                                isObject(newReturnType) &&\n                                ClassType.isSameGenericClass(newReturnType.classType, type)\n                            ) {\n                                // If the specialized return type derived from the __init__\n                                // method is \"better\" than the return type provided by the\n                                // __new__ method (where \"better\" means that the type arguments\n                                // are all known), stick with the __init__ result.\n                                if (\n                                    (!isPartlyUnknown(newReturnType) && !requiresSpecialization(newReturnType)) ||\n                                    returnType === undefined\n                                ) {\n                                    // Special-case the 'tuple' type specialization to use\n                                    // the homogenous arbitrary-length form.\n                                    if (\n                                        isObject(newReturnType) &&\n                                        ClassType.isBuiltIn(newReturnType.classType, 'tuple') &&\n                                        newReturnType.classType.typeArguments &&\n                                        newReturnType.classType.typeArguments.length === 1\n                                    ) {\n                                        newReturnType = ObjectType.create(\n                                            cloneTupleForSpecialization(\n                                                newReturnType.classType,\n                                                [\n                                                    newReturnType.classType.typeArguments[0],\n                                                    AnyType.create(/* isEllipsis */ true),\n                                                ],\n                                                /* isTypeArgumentExplicit */ true\n                                            )\n                                        );\n                                    }\n\n                                    returnType = newReturnType;\n                                }\n                            }\n                        }\n                    }\n\n                    if (!returnType) {\n                        const specializedClassType = applyExpectedTypeForConstructor(\n                            specializeType(type, typeVarMap, /* makeConcrete */ true) as ClassType,\n                            expectedType\n                        );\n                        returnType = ObjectType.create(specializedClassType);\n                    }\n                    validatedTypes = true;\n                }\n            }\n        }\n\n        // If we weren't able to validate the args, analyze the expressions\n        // here to mark symbols as referenced and report expression-level errors.\n        if (!validatedTypes) {\n            argList.forEach((arg) => {\n                if (arg.valueExpression) {\n                    getTypeOfExpression(arg.valueExpression);\n                }\n            });\n        }\n\n        if (!validatedTypes && argList.length > 0) {\n            const fileInfo = getFileInfo(errorNode);\n            addDiagnostic(\n                fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                DiagnosticRule.reportGeneralTypeIssues,\n                Localizer.Diagnostic.constructorNoArgs().format({ type: type.details.name }),\n                errorNode\n            );\n        } else if (!returnType) {\n            // There was no __new__ or __init__, so fall back on the\n            // object.__new__ which takes no parameters.\n            const specializedClassType = applyExpectedTypeForConstructor(type, expectedType);\n            returnType = ObjectType.create(specializedClassType);\n        }\n\n        return { argumentErrors: reportedErrors, returnType };\n    }\n\n    function applyExpectedTypeForConstructor(type: ClassType, expectedType: Type | undefined): ClassType {\n        if (!expectedType) {\n            return type;\n        }\n\n        // It's common for the expected type to contain a None. Strip\n        // this out because we're trying to match the non-optional part.\n        const expectedTypeWithoutNone = removeNoneFromUnion(expectedType);\n        if (!isObject(expectedTypeWithoutNone)) {\n            return type;\n        }\n        const expectedClass = expectedTypeWithoutNone.classType;\n\n        const typeVarMap = new TypeVarMap();\n        if (canAssignType(expectedClass, type, new DiagnosticAddendum(), typeVarMap)) {\n            return specializeType(expectedClass, typeVarMap) as ClassType;\n        }\n\n        // If it's the same generic class, see if we can assign the type arguments\n        // without the variance rules that canAssignType uses.\n        if (\n            ClassType.isSameGenericClass(type, expectedClass) &&\n            expectedClass.typeArguments &&\n            type.typeArguments &&\n            !type.isTypeArgumentExplicit &&\n            expectedClass.typeArguments.length === type.typeArguments.length\n        ) {\n            const typeVarMap = new TypeVarMap();\n            let isAssignable = true;\n            expectedClass.typeArguments.forEach((expectedTypeArg, index) => {\n                const typeTypeArg = type.typeArguments![index];\n                if (!canAssignType(expectedTypeArg, typeTypeArg, new DiagnosticAddendum(), typeVarMap)) {\n                    isAssignable = false;\n                }\n            });\n\n            if (isAssignable) {\n                return specializeType(expectedClass, typeVarMap) as ClassType;\n            }\n        }\n\n        return type;\n    }\n\n    // In cases where the expected type is a specialized base class of the\n    // source type, we need to determine which type arguments in the derived\n    // class will make it compatible with the specialized base class. This method\n    // performs this reverse mapping of type arguments and populates the type var\n    // map for the target type.\n    function populateTypeVarMapBasedOnExpectedType(type: ObjectType, expectedType: Type, typeVarMap: TypeVarMap) {\n        // It's common for the expected type to be Optional. Remove the None\n        // to see if the resulting type is an object.\n        const expectedTypeWithoutNone = removeNoneFromUnion(expectedType);\n\n        // If the resulting type isn't an object, we can't proceed.\n        if (!isObject(expectedTypeWithoutNone)) {\n            return;\n        }\n\n        // If the target type isn't generic, there's nothing for us to do.\n        if (!requiresSpecialization(type)) {\n            return;\n        }\n\n        // If the expected type is generic (not specialized), we can't proceed.\n        const expectedTypeArgs =\n            expectedTypeWithoutNone.classType.effectiveTypeArguments || expectedTypeWithoutNone.classType.typeArguments;\n        if (expectedTypeArgs === undefined) {\n            return;\n        }\n\n        // If the expected type is the same as the target type (commonly the case),\n        // we can use a faster method.\n        if (ClassType.isSameGenericClass(expectedTypeWithoutNone.classType, type.classType)) {\n            canAssignType(type, expectedTypeWithoutNone, new DiagnosticAddendum(), typeVarMap);\n            return;\n        }\n\n        // Create a generic (not specialized) version of the expected type.\n        const genericExpectedType = ClassType.cloneForSpecialization(\n            expectedTypeWithoutNone.classType,\n            undefined,\n            /* isTypeArgumentExplicit */ false\n        );\n\n        // For each type param in the target type, create a placeholder type variable.\n        const typeArgs = type.classType.details.typeParameters.map((_, index) => {\n            const typeVar = TypeVarType.createInstance(`__${index}`, /* isParamSpec */ false, /* isSynthesized */ true);\n            typeVar.details.synthesizedIndex = index;\n            return typeVar;\n        });\n\n        const specializedType = ClassType.cloneForSpecialization(\n            type.classType,\n            typeArgs,\n            /* isTypeArgumentExplicit */ true\n        );\n        const syntheticTypeVarMap = new TypeVarMap();\n        if (canAssignType(genericExpectedType, specializedType, new DiagnosticAddendum(), syntheticTypeVarMap)) {\n            genericExpectedType.details.typeParameters.forEach((typeVar, index) => {\n                const synthTypeVar = syntheticTypeVarMap.getTypeVar(typeVar);\n\n                // Is this one of the synthesized type vars we allocated above? If so,\n                // the type arg that corresponds to this type var maps back to the target type.\n                if (\n                    synthTypeVar &&\n                    isTypeVar(synthTypeVar) &&\n                    synthTypeVar.details.isSynthesized &&\n                    synthTypeVar.details.synthesizedIndex !== undefined\n                ) {\n                    const targetTypeVar = specializedType.details.typeParameters[synthTypeVar.details.synthesizedIndex];\n                    if (index < expectedTypeArgs.length) {\n                        typeVarMap.setTypeVar(targetTypeVar, expectedTypeArgs[index], /* isNarrowable */ false);\n                    }\n                }\n            });\n        }\n    }\n\n    // Validates that the arguments can be assigned to the call's parameter\n    // list, specializes the call based on arg types, and returns the\n    // specialized type of the return value. If it detects an error along\n    // the way, it emits a diagnostic and returns undefined.\n    function validateCallArguments(\n        errorNode: ExpressionNode,\n        argList: FunctionArgument[],\n        callType: Type,\n        typeVarMap: TypeVarMap,\n        skipUnknownArgCheck: boolean,\n        inferReturnTypeIfNeeded = true,\n        expectedType: Type | undefined\n    ): CallResult {\n        let callResult: CallResult = { argumentErrors: false };\n\n        switch (callType.category) {\n            case TypeCategory.Unknown:\n            case TypeCategory.Any: {\n                // Touch all of the args so they're marked accessed.\n                argList.forEach((arg) => getTypeForArgument(arg));\n                callResult.returnType = callType;\n                break;\n            }\n\n            case TypeCategory.Function: {\n                callResult = validateFunctionArguments(\n                    errorNode,\n                    argList,\n                    callType,\n                    typeVarMap,\n                    skipUnknownArgCheck,\n                    inferReturnTypeIfNeeded,\n                    expectedType\n                );\n                break;\n            }\n\n            case TypeCategory.OverloadedFunction: {\n                const overloadedFunctionType = findOverloadedFunctionType(errorNode, argList, callType, expectedType);\n                if (overloadedFunctionType) {\n                    callResult = validateFunctionArguments(\n                        errorNode,\n                        argList,\n                        overloadedFunctionType,\n                        typeVarMap,\n                        skipUnknownArgCheck,\n                        inferReturnTypeIfNeeded,\n                        expectedType\n                    );\n                } else {\n                    const exprString = ParseTreeUtils.printExpression(errorNode);\n                    const diagAddendum = new DiagnosticAddendum();\n                    const argTypes = argList.map((t) => printType(getTypeForArgument(t)));\n\n                    if (errorNode.nodeType !== ParseNodeType.Call && callType.overloads[0].details.name) {\n                        // If the expression isn't an explicit call, it is probably an implicit\n                        // call to a magic method. Provide additional information in this case\n                        // to make it clear that a call was being evaluated.\n                        diagAddendum.addMessage(\n                            Localizer.DiagnosticAddendum.overloadCallName().format({\n                                name: callType.overloads[0].details.name,\n                            })\n                        );\n                    }\n\n                    diagAddendum.addMessage(\n                        Localizer.DiagnosticAddendum.argumentTypes().format({ types: argTypes.join(', ') })\n                    );\n                    const fileInfo = getFileInfo(errorNode);\n                    addDiagnostic(\n                        fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                        DiagnosticRule.reportGeneralTypeIssues,\n                        Localizer.Diagnostic.noOverload().format({ expression: exprString }) + diagAddendum.getString(),\n                        errorNode\n                    );\n                }\n                break;\n            }\n\n            case TypeCategory.Class: {\n                if (!ClassType.isSpecialBuiltIn(callType)) {\n                    callResult = validateConstructorArguments(\n                        errorNode,\n                        argList,\n                        callType,\n                        skipUnknownArgCheck,\n                        expectedType\n                    );\n                } else {\n                    const fileInfo = getFileInfo(errorNode);\n                    addDiagnostic(\n                        fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                        DiagnosticRule.reportGeneralTypeIssues,\n                        Localizer.Diagnostic.typeNotIntantiable().format({ type: callType.details.name }),\n                        errorNode\n                    );\n                }\n                break;\n            }\n\n            case TypeCategory.Object: {\n                const memberType = getTypeFromObjectMember(\n                    errorNode,\n                    callType,\n                    '__call__',\n                    { method: 'get' },\n                    new DiagnosticAddendum(),\n                    MemberAccessFlags.SkipForMethodLookup\n                );\n\n                if (memberType && memberType.category === TypeCategory.Function) {\n                    const callMethodType = stripFirstParameter(memberType);\n                    callResult = validateCallArguments(\n                        errorNode,\n                        argList,\n                        callMethodType,\n                        typeVarMap,\n                        skipUnknownArgCheck,\n                        inferReturnTypeIfNeeded,\n                        expectedType\n                    );\n                } else {\n                    const fileInfo = getFileInfo(errorNode);\n                    addDiagnostic(\n                        fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                        DiagnosticRule.reportGeneralTypeIssues,\n                        Localizer.Diagnostic.objectNotCallable().format({ type: printType(callType) }),\n                        errorNode\n                    );\n                }\n                break;\n            }\n\n            case TypeCategory.Union: {\n                const returnTypes: Type[] = [];\n\n                for (const type of callType.subtypes) {\n                    if (isNone(type)) {\n                        addDiagnostic(\n                            getFileInfo(errorNode).diagnosticRuleSet.reportOptionalCall,\n                            DiagnosticRule.reportOptionalCall,\n                            Localizer.Diagnostic.noneNotCallable(),\n                            errorNode\n                        );\n                    } else {\n                        const subtypeCallResult = validateCallArguments(\n                            errorNode,\n                            argList,\n                            type,\n                            typeVarMap,\n                            skipUnknownArgCheck,\n                            inferReturnTypeIfNeeded,\n                            expectedType\n                        );\n                        if (subtypeCallResult.returnType) {\n                            returnTypes.push(subtypeCallResult.returnType);\n                        }\n                    }\n                }\n\n                if (returnTypes.length > 0) {\n                    callResult.returnType = combineTypes(returnTypes);\n                }\n                break;\n            }\n        }\n\n        if (!callResult.returnType) {\n            // Touch all of the args so they're marked accessed.\n            argList.forEach((arg) => getTypeForArgument(arg));\n        }\n\n        return callResult;\n    }\n\n    // Tries to assign the call arguments to the function parameter\n    // list and reports any mismatches in types or counts. Returns the\n    // specialized return type of the call.\n    // This logic is based on PEP 3102: https://www.python.org/dev/peps/pep-3102/\n    function validateFunctionArguments(\n        errorNode: ExpressionNode,\n        argList: FunctionArgument[],\n        type: FunctionType,\n        typeVarMap: TypeVarMap,\n        skipUnknownArgCheck: boolean,\n        inferReturnTypeIfNeeded = true,\n        expectedType: Type | undefined\n    ): CallResult {\n        let argIndex = 0;\n        const typeParams = type.details.parameters;\n\n        if (expectedType && !requiresSpecialization(expectedType) && type.details.declaredReturnType) {\n            // Prepopulate the typeVarMap based on the specialized expected type if the callee has a declared\n            // return type. This will allow us to more closely match the expected type if possible.\n            canAssignType(type.details.declaredReturnType, expectedType, new DiagnosticAddendum(), typeVarMap);\n        }\n\n        // The last parameter might be a var arg dictionary. If so, strip it off.\n        const varArgDictParam = typeParams.find((param) => param.category === ParameterCategory.VarArgDictionary);\n        let reportedArgError = false;\n\n        // Build a map of parameters by name.\n        const paramMap = new Map<string, ParamAssignmentInfo>();\n        typeParams.forEach((param) => {\n            if (param.name) {\n                paramMap.set(param.name, {\n                    argsNeeded: param.category === ParameterCategory.Simple && !param.hasDefault ? 1 : 0,\n                    argsReceived: 0,\n                });\n            }\n        });\n\n        // Is there a bare (nameless) \"*\" parameter? If so, it signifies the end\n        // of the positional parameter list.\n        let positionalParamCount = typeParams.findIndex(\n            (param) => param.category === ParameterCategory.VarArgList && !param.name\n        );\n\n        // Is there a positional-only \"/\" parameter? If so, it separates the\n        // positional-only from positional or keyword parameters.\n        const positionalOnlyIndex = typeParams.findIndex(\n            (param) => param.category === ParameterCategory.Simple && !param.name\n        );\n\n        // Is there a var-arg (named \"*\") parameter? If so, it is the last of\n        // the positional parameters.\n        if (positionalParamCount < 0) {\n            positionalParamCount = typeParams.findIndex((param) => param.category === ParameterCategory.VarArgList);\n            if (positionalParamCount >= 0) {\n                positionalParamCount++;\n            }\n        }\n\n        // Is there a keyword var-arg (\"**\") parameter? If so, it's not included\n        // in the list of positional parameters.\n        if (positionalParamCount < 0) {\n            positionalParamCount = typeParams.findIndex(\n                (param) => param.category === ParameterCategory.VarArgDictionary\n            );\n        }\n\n        // If we didn't see any special cases, then all parameters are positional.\n        if (positionalParamCount < 0) {\n            positionalParamCount = typeParams.length;\n        }\n\n        // Determine how many positional args are being passed before\n        // we see a named arg.\n        let positionalArgCount = argList.findIndex(\n            (arg) => arg.argumentCategory === ArgumentCategory.UnpackedDictionary || arg.name !== undefined\n        );\n        if (positionalArgCount < 0) {\n            positionalArgCount = argList.length;\n        }\n\n        // If there weren't enough positional arguments to populate all of\n        // the positional-only parameters, force the named parameters\n        // into positional-only slots so we can report errors for them.\n        if (positionalOnlyIndex >= 0 && positionalArgCount < positionalOnlyIndex) {\n            const firstParamWithDefault = typeParams.findIndex((param) => param.hasDefault);\n            const positionOnlyWithoutDefaultsCount =\n                firstParamWithDefault >= 0 && firstParamWithDefault < positionalOnlyIndex\n                    ? firstParamWithDefault\n                    : positionalOnlyIndex;\n            positionalArgCount = Math.min(positionOnlyWithoutDefaultsCount, argList.length);\n        }\n\n        const validateArgTypeParams: ValidateArgTypeParams[] = [];\n\n        let activeParam: FunctionParameter | undefined;\n        function trySetActive(arg: FunctionArgument, param: FunctionParameter) {\n            if (arg.active) {\n                activeParam = param;\n            }\n        }\n\n        let foundUnpackedListArg =\n            argList.find((arg) => arg.argumentCategory === ArgumentCategory.UnpackedList) !== undefined;\n\n        // Map the positional args to parameters.\n        let paramIndex = 0;\n        let unpackedArgIndex = 0;\n        while (argIndex < positionalArgCount) {\n            if (paramIndex === positionalOnlyIndex) {\n                paramIndex++;\n                continue;\n            }\n\n            if (argIndex < positionalOnlyIndex && argList[argIndex].name) {\n                const fileInfo = getFileInfo(argList[argIndex].name!);\n                addDiagnostic(\n                    fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                    DiagnosticRule.reportGeneralTypeIssues,\n                    Localizer.Diagnostic.argPositional(),\n                    argList[argIndex].name!\n                );\n            }\n\n            if (paramIndex >= positionalParamCount) {\n                if (!foundUnpackedListArg || argList[argIndex].argumentCategory !== ArgumentCategory.UnpackedList) {\n                    const adjustedCount = positionalParamCount;\n                    const fileInfo = getFileInfo(errorNode);\n                    addDiagnostic(\n                        fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                        DiagnosticRule.reportGeneralTypeIssues,\n                        adjustedCount === 1\n                            ? Localizer.Diagnostic.argPositionalExpectedOne()\n                            : Localizer.Diagnostic.argPositionalExpectedCount().format({ expected: adjustedCount }),\n                        argList[argIndex].valueExpression || errorNode\n                    );\n                    reportedArgError = true;\n                }\n                break;\n            }\n\n            const paramType = FunctionType.getEffectiveParameterType(type, paramIndex);\n            if (argList[argIndex].argumentCategory === ArgumentCategory.UnpackedList) {\n                if (!argList[argIndex].valueExpression) {\n                    break;\n                }\n\n                const argType = getTypeForArgument(argList[argIndex]);\n                let listElementType: Type;\n                let advanceToNextArg = false;\n\n                // If this is a tuple with specified element types, use those\n                // specified types rather than using the more generic iterator\n                // type which will be a union of all element types.\n                if (\n                    isObject(argType) &&\n                    isTupleClass(argType.classType) &&\n                    argType.classType.typeArguments &&\n                    argType.classType.typeArguments.length > 0 &&\n                    !isEllipsisType(argType.classType.typeArguments[argType.classType.typeArguments.length - 1])\n                ) {\n                    listElementType = argType.classType.typeArguments[unpackedArgIndex];\n\n                    // Determine if there are any more unpacked list arguments after\n                    // this one. If not, we'll clear this flag because this unpacked\n                    // list arg is bounded in length.\n                    foundUnpackedListArg =\n                        argList.find(\n                            (arg, index) => index > argIndex && arg.argumentCategory === ArgumentCategory.UnpackedList\n                        ) !== undefined;\n\n                    unpackedArgIndex++;\n                    if (unpackedArgIndex >= argType.classType.typeArguments.length) {\n                        unpackedArgIndex = 0;\n                        advanceToNextArg = true;\n                    }\n                } else {\n                    listElementType = getTypeFromIterable(\n                        argType,\n                        /* isAsync */ false,\n                        argList[argIndex].valueExpression!,\n                        /* supportGetItem */ false\n                    );\n                }\n\n                const funcArg: FunctionArgument = {\n                    argumentCategory: ArgumentCategory.Simple,\n                    type: listElementType,\n                };\n\n                const paramName = typeParams[paramIndex].name;\n                validateArgTypeParams.push({\n                    paramType,\n                    requiresTypeVarMatching: requiresSpecialization(paramType),\n                    argument: funcArg,\n                    errorNode: argList[argIndex].valueExpression || errorNode,\n                    paramName: typeParams[paramIndex].isNameSynthesized ? undefined : paramName,\n                });\n\n                trySetActive(argList[argIndex], typeParams[paramIndex]);\n\n                // Note that the parameter has received an argument.\n                if (paramName) {\n                    paramMap.get(paramName)!.argsReceived++;\n                }\n\n                if (advanceToNextArg || typeParams[paramIndex].category === ParameterCategory.VarArgList) {\n                    argIndex++;\n                }\n\n                if (typeParams[paramIndex].category !== ParameterCategory.VarArgList) {\n                    paramIndex++;\n                }\n            } else if (typeParams[paramIndex].category === ParameterCategory.VarArgList) {\n                validateArgTypeParams.push({\n                    paramType,\n                    requiresTypeVarMatching: requiresSpecialization(paramType),\n                    argument: argList[argIndex],\n                    errorNode: argList[argIndex].valueExpression || errorNode,\n                    paramName: typeParams[paramIndex].name,\n                });\n                trySetActive(argList[argIndex], typeParams[paramIndex]);\n\n                argIndex++;\n            } else {\n                const paramName = typeParams[paramIndex].name;\n                validateArgTypeParams.push({\n                    paramType,\n                    requiresTypeVarMatching: requiresSpecialization(paramType),\n                    argument: argList[argIndex],\n                    errorNode: argList[argIndex].valueExpression || errorNode,\n                    paramName: typeParams[paramIndex].isNameSynthesized ? undefined : paramName,\n                });\n                trySetActive(argList[argIndex], typeParams[paramIndex]);\n\n                // Note that the parameter has received an argument.\n                if (paramName) {\n                    paramMap.get(paramName)!.argsReceived++;\n                }\n\n                argIndex++;\n                paramIndex++;\n            }\n        }\n\n        if (!reportedArgError) {\n            let foundUnpackedDictionaryArg = false;\n\n            // Now consume any named parameters.\n            while (argIndex < argList.length) {\n                if (argList[argIndex].argumentCategory === ArgumentCategory.UnpackedDictionary) {\n                    // Mark the arg as accessed.\n                    getTypeForArgument(argList[argIndex]);\n                    foundUnpackedDictionaryArg = true;\n                } else {\n                    // Protect against the case where a non-named argument appears after\n                    // a named argument. This will have already been reported as a parse\n                    // error, but we need to protect against it here.\n                    const paramName = argList[argIndex].name;\n                    if (paramName) {\n                        const paramNameValue = paramName.value;\n                        const paramEntry = paramMap.get(paramNameValue);\n                        if (paramEntry) {\n                            if (paramEntry.argsReceived > 0) {\n                                addDiagnostic(\n                                    getFileInfo(paramName).diagnosticRuleSet.reportGeneralTypeIssues,\n                                    DiagnosticRule.reportGeneralTypeIssues,\n                                    Localizer.Diagnostic.paramAlreadyAssigned().format({ name: paramNameValue }),\n                                    paramName\n                                );\n                                reportedArgError = true;\n                            } else {\n                                paramMap.get(paramName.value)!.argsReceived++;\n\n                                const paramInfoIndex = typeParams.findIndex((param) => param.name === paramNameValue);\n                                assert(paramInfoIndex >= 0);\n                                const paramType = FunctionType.getEffectiveParameterType(type, paramInfoIndex);\n\n                                validateArgTypeParams.push({\n                                    paramType,\n                                    requiresTypeVarMatching: requiresSpecialization(paramType),\n                                    argument: argList[argIndex],\n                                    errorNode: argList[argIndex].valueExpression || errorNode,\n                                    paramName: paramNameValue,\n                                });\n                                trySetActive(argList[argIndex], typeParams[paramInfoIndex]);\n                            }\n                        } else if (varArgDictParam) {\n                            validateArgTypeParams.push({\n                                paramType: varArgDictParam.type,\n                                requiresTypeVarMatching: requiresSpecialization(varArgDictParam.type),\n                                argument: argList[argIndex],\n                                errorNode: argList[argIndex].valueExpression || errorNode,\n                                paramName: paramNameValue,\n                            });\n                            trySetActive(argList[argIndex], varArgDictParam);\n                        } else {\n                            addDiagnostic(\n                                getFileInfo(paramName).diagnosticRuleSet.reportGeneralTypeIssues,\n                                DiagnosticRule.reportGeneralTypeIssues,\n                                Localizer.Diagnostic.paramNameMissing().format({ name: paramName.value }),\n                                paramName\n                            );\n                            reportedArgError = true;\n                        }\n                    }\n                }\n\n                argIndex++;\n            }\n\n            // Determine whether there are any parameters that require arguments\n            // but have not yet received them. If we received a dictionary argument\n            // (i.e. an arg starting with a \"**\") or a list argument (i.e. an arg\n            // starting with a \"*\"), we will assume that all parameters are matched.\n            if (\n                !foundUnpackedDictionaryArg &&\n                !foundUnpackedListArg &&\n                !FunctionType.isDefaultParameterCheckDisabled(type)\n            ) {\n                const unassignedParams = [...paramMap.keys()].filter((name) => {\n                    const entry = paramMap.get(name)!;\n                    return entry.argsReceived < entry.argsNeeded;\n                });\n\n                if (unassignedParams.length > 0) {\n                    const missingParamNames = unassignedParams.map((p) => `\"${p}\"`).join(', ');\n                    addDiagnostic(\n                        getFileInfo(errorNode).diagnosticRuleSet.reportGeneralTypeIssues,\n                        DiagnosticRule.reportGeneralTypeIssues,\n                        unassignedParams.length === 1\n                            ? Localizer.Diagnostic.argMissingForParam().format({ name: missingParamNames })\n                            : Localizer.Diagnostic.argMissingForParams().format({ names: missingParamNames }),\n                        errorNode\n                    );\n                    reportedArgError = true;\n                }\n\n                // Add any implicit (default) arguments that are needed for resolving\n                // generic types. For example, if the function is defined as\n                // def foo(v1: _T = 'default')\n                // and _T is a TypeVar, we need to match the TypeVar to the default\n                // value's type if it's not provided by the caller.\n                typeParams.forEach((param) => {\n                    if (param.category === ParameterCategory.Simple && param.name) {\n                        const entry = paramMap.get(param.name)!;\n                        if (entry.argsNeeded === 0 && entry.argsReceived === 0) {\n                            if (param.defaultType && requiresSpecialization(param.type)) {\n                                validateArgTypeParams.push({\n                                    paramType: param.type,\n                                    requiresTypeVarMatching: true,\n                                    argument: {\n                                        argumentCategory: ArgumentCategory.Simple,\n                                        type: param.defaultType,\n                                    },\n                                    errorNode: errorNode,\n                                    paramName: param.isNameSynthesized ? undefined : param.name,\n                                });\n                            }\n                        }\n                    }\n                });\n            }\n        }\n\n        // Special-case a few built-in calls that are often used for\n        // casting or checking for unknown types.\n        if (['cast', 'isinstance', 'issubclass'].some((name) => name === type.details.builtInName)) {\n            skipUnknownArgCheck = true;\n        }\n\n        // Run through all args and validate them against their matched parameter.\n        // We'll do two passes. The first one will match any type arguments. The second\n        // will perform the actual validation. We can skip the first pass if there\n        // are no type vars to match.\n        const typeVarMatchingCount = validateArgTypeParams.filter((arg) => arg.requiresTypeVarMatching).length;\n        if (typeVarMatchingCount > 0) {\n            // In theory, we may need to do up to n passes where n is the number of\n            // arguments that need type var matching. That's because later matches\n            // can provide bidirectional type hints for earlier matches. The best\n            // example of this is the built-in \"map\" method whose first parameter is\n            // a lambda and second parameter indicates what type the lambda should accept.\n            // In practice, we will limit the number of passes to 2 because it can get\n            // very expensive to go beyond this, and we don't see generally see cases\n            // where more than two passes are needed.\n            const passCount = Math.min(typeVarMatchingCount, 2);\n            for (let i = 0; i < passCount; i++) {\n                useSpeculativeMode(errorNode, () => {\n                    validateArgTypeParams.forEach((argParam) => {\n                        if (argParam.requiresTypeVarMatching) {\n                            validateArgType(argParam, typeVarMap, type.details.name, skipUnknownArgCheck);\n                        }\n                    });\n                });\n            }\n\n            // Lock the type var map so it cannot be modified and revalidate the\n            // arguments in a second pass.\n            typeVarMap.lock();\n        }\n\n        validateArgTypeParams.forEach((argParam) => {\n            if (!validateArgType(argParam, typeVarMap, type.details.name, skipUnknownArgCheck)) {\n                reportedArgError = true;\n            }\n        });\n\n        // Run through all the args that were not validated and evaluate their types\n        // to ensure that we haven't missed any (due to arg/param mismatches). This will\n        // ensure that referenced symbols are not reported as unaccessed.\n        if (!isSpeculativeMode(undefined) && !incompleteTypeTracker.isIncompleteTypeMode()) {\n            argList.forEach((arg) => {\n                if (arg.valueExpression) {\n                    if (!validateArgTypeParams.some((validatedArg) => validatedArg.argument === arg)) {\n                        getTypeOfExpression(arg.valueExpression);\n                    }\n                }\n            });\n        }\n\n        // Calculate the return type. If there was an error matching arguments to\n        // parameters, don't bother attempting to infer the return type.\n        const returnType = getFunctionEffectiveReturnType(\n            type,\n            validateArgTypeParams,\n            inferReturnTypeIfNeeded && !reportedArgError\n        );\n        const specializedReturnType = specializeType(returnType, typeVarMap);\n\n        return { argumentErrors: reportedArgError, returnType: specializedReturnType, activeParam };\n    }\n\n    function validateArgType(\n        argParam: ValidateArgTypeParams,\n        typeVarMap: TypeVarMap,\n        functionName: string,\n        skipUnknownCheck: boolean\n    ): boolean {\n        let argType: Type | undefined;\n        let expectedTypeDiag: DiagnosticAddendum | undefined;\n\n        if (argParam.argument.valueExpression) {\n            let expectedType: Type | undefined = specializeType(argParam.paramType, typeVarMap);\n\n            // If the expected type is unknown, don't use an expected type. Instead,\n            // use default rules for evaluating the expression type.\n            if (isUnknown(expectedType)) {\n                expectedType = undefined;\n            }\n\n            const exprType = getTypeOfExpression(argParam.argument.valueExpression, expectedType);\n            argType = exprType.type;\n            expectedTypeDiag = exprType.expectedTypeDiagAddendum;\n\n            if (argParam.argument && argParam.argument.name && !isSpeculativeMode(argParam.errorNode)) {\n                writeTypeCache(argParam.argument.name, expectedType || argType);\n            }\n        } else {\n            argType = getTypeForArgument(argParam.argument);\n        }\n\n        let diag = new DiagnosticAddendum();\n\n        if (!canAssignType(argParam.paramType, argType, diag.createAddendum(), typeVarMap)) {\n            if (!isDiagnosticSuppressedForNode(argParam.errorNode)) {\n                const fileInfo = getFileInfo(argParam.errorNode);\n                const argTypeText = printType(argType);\n                const paramTypeText = printType(argParam.paramType);\n\n                let message: string;\n                if (argParam.paramName) {\n                    if (functionName) {\n                        message = Localizer.Diagnostic.argAssignmentParamFunction().format({\n                            argType: argTypeText,\n                            paramType: paramTypeText,\n                            functionName,\n                            paramName: argParam.paramName,\n                        });\n                    } else {\n                        message = Localizer.Diagnostic.argAssignmentParam().format({\n                            argType: argTypeText,\n                            paramType: paramTypeText,\n                            paramName: argParam.paramName,\n                        });\n                    }\n                } else {\n                    if (functionName) {\n                        message = Localizer.Diagnostic.argAssignmentFunction().format({\n                            argType: argTypeText,\n                            paramType: paramTypeText,\n                            functionName,\n                        });\n                    } else {\n                        message = Localizer.Diagnostic.argAssignment().format({\n                            argType: argTypeText,\n                            paramType: paramTypeText,\n                        });\n                    }\n                }\n\n                // If we have an expected type diagnostic addendum, use that\n                // instead of the local diagnostic addendum because it will\n                // be more informative.\n                if (expectedTypeDiag) {\n                    diag = expectedTypeDiag;\n                }\n\n                addDiagnostic(\n                    fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                    DiagnosticRule.reportGeneralTypeIssues,\n                    message + diag.getString(),\n                    argParam.errorNode\n                );\n            }\n            return false;\n        } else if (!skipUnknownCheck) {\n            const simplifiedType = removeUnboundFromUnion(argType);\n            const fileInfo = getFileInfo(argParam.errorNode);\n\n            const diagAddendum = new DiagnosticAddendum();\n            if (argParam.paramName) {\n                diagAddendum.addMessage(\n                    (functionName\n                        ? Localizer.DiagnosticAddendum.argParamFunction().format({\n                              paramName: argParam.paramName,\n                              functionName,\n                          })\n                        : Localizer.DiagnosticAddendum.argParam().format({ paramName: argParam.paramName })) +\n                        diagAddendum.getString()\n                );\n            }\n\n            if (isUnknown(simplifiedType)) {\n                addDiagnostic(\n                    fileInfo.diagnosticRuleSet.reportUnknownArgumentType,\n                    DiagnosticRule.reportUnknownArgumentType,\n                    Localizer.Diagnostic.argTypeUnknown() + diagAddendum.getString(),\n                    argParam.errorNode\n                );\n            } else if (isPartlyUnknown(simplifiedType, true)) {\n                // Don't report an error if the type is a partially-specialized\n                // class. This comes up frequently in cases where a type is passed\n                // as an argument (e.g. \"defaultdict(list)\").\n\n                // If the parameter type is also partially unknown, don't report\n                // the error because it's likely that the partially-unknown type\n                // arose due to bidirectional type matching.\n                if (!isPartlyUnknown(argParam.paramType) && !isClass(simplifiedType)) {\n                    diagAddendum.addMessage(\n                        Localizer.DiagnosticAddendum.argumentType().format({\n                            type: printType(simplifiedType, /* expandTypeAlias */ true),\n                        })\n                    );\n                    addDiagnostic(\n                        fileInfo.diagnosticRuleSet.reportUnknownArgumentType,\n                        DiagnosticRule.reportUnknownArgumentType,\n                        Localizer.Diagnostic.argTypePartiallyUnknown() + diagAddendum.getString(),\n                        argParam.errorNode\n                    );\n                }\n            }\n        }\n\n        return true;\n    }\n\n    function createTypeVarType(\n        errorNode: ExpressionNode,\n        argList: FunctionArgument[],\n        isParamSpec: boolean\n    ): Type | undefined {\n        let typeVarName = '';\n        let firstConstraintArg: FunctionArgument | undefined;\n\n        if (isParamSpec) {\n            const fileInfo = getFileInfo(errorNode);\n            if (!fileInfo.isStubFile && fileInfo.executionEnvironment.pythonVersion < PythonVersion.V3_9) {\n                addError(Localizer.Diagnostic.paramSpecIllegal(), errorNode);\n            }\n        }\n\n        if (argList.length === 0) {\n            addError(\n                isParamSpec ? Localizer.Diagnostic.paramSpecFirstArg() : Localizer.Diagnostic.typeVarFirstArg(),\n                errorNode\n            );\n            return undefined;\n        }\n\n        const firstArg = argList[0];\n        if (firstArg.valueExpression && firstArg.valueExpression.nodeType === ParseNodeType.StringList) {\n            typeVarName = firstArg.valueExpression.strings.map((s) => s.value).join('');\n        } else {\n            addError(\n                isParamSpec ? Localizer.Diagnostic.paramSpecFirstArg() : Localizer.Diagnostic.typeVarFirstArg(),\n                firstArg.valueExpression || errorNode\n            );\n        }\n\n        const typeVar = TypeVarType.createInstantiable(typeVarName, isParamSpec);\n\n        // Parse the remaining parameters.\n        for (let i = 1; i < argList.length; i++) {\n            const paramNameNode = argList[i].name;\n            const paramName = paramNameNode ? paramNameNode.value : undefined;\n            const paramNameMap = new Map<string, string>();\n\n            if (paramName) {\n                if (paramNameMap.get(paramName)) {\n                    addError(\n                        Localizer.Diagnostic.duplicateParam().format({ name: paramName }),\n                        argList[i].valueExpression || errorNode\n                    );\n                }\n\n                if (paramName === 'bound' && !isParamSpec) {\n                    if (typeVar.details.constraints.length > 0) {\n                        addError(\n                            Localizer.Diagnostic.typeVarBoundAndConstrained(),\n                            argList[i].valueExpression || errorNode\n                        );\n                    } else {\n                        const argType = getTypeForArgumentExpectingType(\n                            argList[i],\n                            getFileInfo(errorNode),\n                            /* allowMissingTypeArgs */ true\n                        );\n                        if (requiresSpecialization(argType)) {\n                            addError(Localizer.Diagnostic.typeVarGeneric(), argList[i].valueExpression || errorNode);\n                        }\n                        typeVar.details.boundType = convertToInstance(argType);\n                    }\n                } else if (paramName === 'covariant' && !isParamSpec) {\n                    if (argList[i].valueExpression && getBooleanValue(argList[i].valueExpression!)) {\n                        if (typeVar.details.isContravariant) {\n                            addError(Localizer.Diagnostic.typeVarVariance(), argList[i].valueExpression!);\n                        } else {\n                            typeVar.details.isCovariant = true;\n                        }\n                    }\n                } else if (paramName === 'contravariant' && !isParamSpec) {\n                    if (argList[i].valueExpression && getBooleanValue(argList[i].valueExpression!)) {\n                        if (typeVar.details.isContravariant) {\n                            addError(Localizer.Diagnostic.typeVarVariance(), argList[i].valueExpression!);\n                        } else {\n                            typeVar.details.isContravariant = true;\n                        }\n                    }\n                } else {\n                    addError(\n                        isParamSpec\n                            ? Localizer.Diagnostic.paramSpecUnknownParam().format({ name: paramName })\n                            : Localizer.Diagnostic.typeVarUnknownParam().format({ name: paramName }),\n                        argList[i].valueExpression || errorNode\n                    );\n                }\n\n                paramNameMap.set(paramName, paramName);\n            } else if (!isParamSpec) {\n                if (typeVar.details.boundType) {\n                    addError(\n                        Localizer.Diagnostic.typeVarBoundAndConstrained(),\n                        argList[i].valueExpression || errorNode\n                    );\n                } else {\n                    const argType = getTypeForArgumentExpectingType(argList[i], getFileInfo(errorNode));\n                    if (requiresSpecialization(argType)) {\n                        addError(Localizer.Diagnostic.typeVarGeneric(), argList[i].valueExpression || errorNode);\n                    }\n                    TypeVarType.addConstraint(typeVar, convertToInstance(argType));\n                    if (firstConstraintArg === undefined) {\n                        firstConstraintArg = argList[i];\n                    }\n                }\n            } else {\n                addError(Localizer.Diagnostic.paramSpecUnknownArg(), argList[i].valueExpression || errorNode);\n                break;\n            }\n        }\n\n        if (!isParamSpec && typeVar.details.constraints.length === 1 && firstConstraintArg) {\n            addDiagnostic(\n                getFileInfo(errorNode).diagnosticRuleSet.reportGeneralTypeIssues,\n                DiagnosticRule.reportGeneralTypeIssues,\n                Localizer.Diagnostic.typeVarSingleConstraint(),\n                firstConstraintArg.valueExpression || errorNode\n            );\n        }\n\n        return typeVar;\n    }\n\n    function getBooleanValue(node: ExpressionNode): boolean {\n        if (node.nodeType === ParseNodeType.Constant) {\n            if (node.constType === KeywordType.False) {\n                return false;\n            } else if (node.constType === KeywordType.True) {\n                return true;\n            }\n        }\n\n        addError(Localizer.Diagnostic.expectedBoolLiteral(), node);\n        return false;\n    }\n\n    function getClassFullName(classNode: ParseNode, moduleName: string, className: string): string {\n        const nameParts: string[] = [className];\n\n        let curNode: ParseNode | undefined = classNode;\n\n        // Walk the parse tree looking for classes.\n        while (curNode) {\n            curNode = ParseTreeUtils.getEnclosingClass(curNode);\n            if (curNode) {\n                nameParts.push(curNode.name.value);\n            }\n        }\n\n        nameParts.push(moduleName);\n\n        return nameParts.reverse().join('.');\n    }\n\n    // Creates a new custom enum class with named values.\n    function createEnumType(errorNode: ExpressionNode, enumClass: ClassType, argList: FunctionArgument[]): ClassType {\n        const fileInfo = getFileInfo(errorNode);\n        let className = 'enum';\n        if (argList.length === 0) {\n            addError(Localizer.Diagnostic.enumFirstArg(), errorNode);\n        } else {\n            const nameArg = argList[0];\n            if (nameArg.argumentCategory !== ArgumentCategory.Simple) {\n                addError(Localizer.Diagnostic.enumFirstArg(), argList[0].valueExpression || errorNode);\n            } else if (nameArg.valueExpression && nameArg.valueExpression.nodeType === ParseNodeType.StringList) {\n                className = nameArg.valueExpression.strings.map((s) => s.value).join('');\n            }\n        }\n\n        const classType = ClassType.create(\n            className,\n            getClassFullName(errorNode, fileInfo.moduleName, className),\n            fileInfo.moduleName,\n            ClassTypeFlags.EnumClass,\n            errorNode.id,\n            /* declaredMetaclass */ undefined,\n            enumClass.details.effectiveMetaclass\n        );\n        classType.details.baseClasses.push(enumClass);\n        computeMroLinearization(classType);\n\n        const classFields = classType.details.fields;\n        classFields.set(\n            '__class__',\n            Symbol.createWithType(SymbolFlags.ClassMember | SymbolFlags.IgnoredForProtocolMatch, classType)\n        );\n\n        if (argList.length < 2) {\n            addError(Localizer.Diagnostic.enumSecondArg(), errorNode);\n        } else {\n            const entriesArg = argList[1];\n            if (\n                entriesArg.argumentCategory !== ArgumentCategory.Simple ||\n                !entriesArg.valueExpression ||\n                entriesArg.valueExpression.nodeType !== ParseNodeType.StringList\n            ) {\n                // Technically, the Enum constructor supports a bunch of different\n                // ways to specify the items: space-delimited string, a string\n                // iterator, an iterator of name/value tuples, and a dictionary\n                // of name/value pairs. We support only the simple space-delimited\n                // string here. For users who are interested in type checking, we\n                // recommend using the more standard class declaration syntax.\n                // This diagnostic is part of the reportGeneralTypeIssues since\n                // it is of interest only to those who care about types.\n                addDiagnostic(\n                    fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                    DiagnosticRule.reportGeneralTypeIssues,\n                    Localizer.Diagnostic.enumSecondArg(),\n                    argList[1].valueExpression || errorNode\n                );\n            } else {\n                const entries = entriesArg.valueExpression.strings\n                    .map((s) => s.value)\n                    .join('')\n                    .split(' ');\n                entries.forEach((entryName) => {\n                    entryName = entryName.trim();\n                    if (entryName) {\n                        const entryType = UnknownType.create();\n                        const newSymbol = Symbol.createWithType(SymbolFlags.ClassMember, entryType);\n\n                        // We need to associate the declaration with a parse node.\n                        // In this case it's just part of a string literal value.\n                        // The definition provider won't necessarily take the\n                        // user to the exact spot in the string, but it's close enough.\n                        const stringNode = entriesArg.valueExpression!;\n                        assert(stringNode.nodeType === ParseNodeType.StringList);\n                        const fileInfo = getFileInfo(errorNode);\n                        const declaration: VariableDeclaration = {\n                            type: DeclarationType.Variable,\n                            node: stringNode as StringListNode,\n                            path: fileInfo.filePath,\n                            range: convertOffsetsToRange(\n                                stringNode.start,\n                                TextRange.getEnd(stringNode),\n                                fileInfo.lines\n                            ),\n                            moduleName: fileInfo.moduleName,\n                        };\n                        newSymbol.addDeclaration(declaration);\n                        classFields.set(entryName, newSymbol);\n                    }\n                });\n            }\n        }\n\n        return classType;\n    }\n\n    // Implements the semantics of the NewType call as documented\n    // in the Python specification: The static type checker will treat\n    // the new type as if it were a subclass of the original type.\n    function createNewType(errorNode: ExpressionNode, argList: FunctionArgument[]): ClassType | undefined {\n        const fileInfo = getFileInfo(errorNode);\n        let className = '_';\n        if (argList.length >= 1) {\n            const nameArg = argList[0];\n            if (nameArg.argumentCategory === ArgumentCategory.Simple) {\n                if (nameArg.valueExpression && nameArg.valueExpression.nodeType === ParseNodeType.StringList) {\n                    className = nameArg.valueExpression.strings.map((s) => s.value).join('');\n                }\n            }\n        }\n\n        if (argList.length >= 2) {\n            const baseClass = getTypeForArgumentExpectingType(argList[1], getFileInfo(errorNode));\n\n            if (isClass(baseClass)) {\n                const classFlags =\n                    baseClass.details.flags & ~(ClassTypeFlags.BuiltInClass | ClassTypeFlags.SpecialBuiltIn);\n                const classType = ClassType.create(\n                    className,\n                    getClassFullName(errorNode, fileInfo.moduleName, className),\n                    fileInfo.moduleName,\n                    classFlags,\n                    errorNode.id,\n                    /* declaredMetaclass */ undefined,\n                    baseClass.details.effectiveMetaclass\n                );\n                classType.details.baseClasses.push(baseClass);\n                computeMroLinearization(classType);\n\n                // Synthesize an __init__ method that accepts only the specified type.\n                const initType = FunctionType.createInstance('__init__', '', FunctionTypeFlags.SynthesizedMethod);\n                FunctionType.addParameter(initType, {\n                    category: ParameterCategory.Simple,\n                    name: 'self',\n                    type: ObjectType.create(classType),\n                });\n                FunctionType.addParameter(initType, {\n                    category: ParameterCategory.Simple,\n                    name: '_x',\n                    type: ObjectType.create(baseClass),\n                });\n                initType.details.declaredReturnType = NoneType.createInstance();\n                classType.details.fields.set('__init__', Symbol.createWithType(SymbolFlags.ClassMember, initType));\n\n                // Synthesize a trivial __new__ method.\n                const newType = FunctionType.createInstance(\n                    '__new__',\n                    '',\n                    FunctionTypeFlags.ConstructorMethod | FunctionTypeFlags.SynthesizedMethod\n                );\n                FunctionType.addParameter(newType, {\n                    category: ParameterCategory.Simple,\n                    name: 'cls',\n                    type: classType,\n                });\n                FunctionType.addDefaultParameters(newType);\n                newType.details.declaredReturnType = ObjectType.create(classType);\n                classType.details.fields.set('__new__', Symbol.createWithType(SymbolFlags.ClassMember, newType));\n                return classType;\n            }\n        }\n\n        return undefined;\n    }\n\n    // Implements the semantics of the multi-parameter variant of the \"type\" call.\n    function createType(errorNode: ExpressionNode, argList: FunctionArgument[]): ClassType | undefined {\n        const fileInfo = getFileInfo(errorNode);\n        const arg0Type = getTypeForArgument(argList[0]);\n        if (!isObject(arg0Type) || !ClassType.isBuiltIn(arg0Type.classType, 'str')) {\n            return undefined;\n        }\n        const className = (arg0Type.classType.literalValue as string) || '_';\n\n        const arg1Type = getTypeForArgument(argList[1]);\n        if (\n            !isObject(arg1Type) ||\n            !isTupleClass(arg1Type.classType) ||\n            arg1Type.classType.typeArguments === undefined\n        ) {\n            return undefined;\n        }\n\n        const classType = ClassType.create(\n            className,\n            getClassFullName(errorNode, fileInfo.moduleName, className),\n            fileInfo.moduleName,\n            ClassTypeFlags.None,\n            errorNode.id,\n            /* declaredMetaclass */ undefined,\n            arg1Type.classType.details.effectiveMetaclass\n        );\n        arg1Type.classType.typeArguments.forEach((baseClass) => {\n            if (isClass(baseClass) || isAnyOrUnknown(baseClass)) {\n                classType.details.baseClasses.push(baseClass);\n            } else {\n                addExpectedClassDiagnostic(baseClass, argList[1].valueExpression || errorNode);\n            }\n        });\n\n        if (!computeMroLinearization(classType)) {\n            addError(Localizer.Diagnostic.methodOrdering(), errorNode);\n        }\n\n        return classType;\n    }\n\n    // Creates a new custom TypedDict factory class.\n    function createTypedDictType(\n        errorNode: ExpressionNode,\n        typedDictClass: ClassType,\n        argList: FunctionArgument[]\n    ): ClassType {\n        const fileInfo = getFileInfo(errorNode);\n\n        // TypedDict supports two different syntaxes:\n        // Point2D = TypedDict('Point2D', {'x': int, 'y': int, 'label': str})\n        // Point2D = TypedDict('Point2D', x=int, y=int, label=str)\n        let className = 'TypedDict';\n        if (argList.length === 0) {\n            addError(Localizer.Diagnostic.typedDictFirstArg(), errorNode);\n        } else {\n            const nameArg = argList[0];\n            if (\n                nameArg.argumentCategory !== ArgumentCategory.Simple ||\n                !nameArg.valueExpression ||\n                nameArg.valueExpression.nodeType !== ParseNodeType.StringList\n            ) {\n                addError(Localizer.Diagnostic.typedDictFirstArg(), argList[0].valueExpression || errorNode);\n            } else {\n                className = nameArg.valueExpression.strings.map((s) => s.value).join('');\n            }\n        }\n\n        const classType = ClassType.create(\n            className,\n            getClassFullName(errorNode, fileInfo.moduleName, className),\n            fileInfo.moduleName,\n            ClassTypeFlags.TypedDictClass,\n            errorNode.id,\n            /* declaredMetaclass */ undefined,\n            typedDictClass.details.effectiveMetaclass\n        );\n        classType.details.baseClasses.push(typedDictClass);\n        computeMroLinearization(classType);\n\n        const classFields = classType.details.fields;\n        classFields.set(\n            '__class__',\n            Symbol.createWithType(SymbolFlags.ClassMember | SymbolFlags.IgnoredForProtocolMatch, classType)\n        );\n\n        let usingDictSyntax = false;\n        if (argList.length < 2) {\n            addError(Localizer.Diagnostic.typedDictSecondArgDict(), errorNode);\n        } else {\n            const entriesArg = argList[1];\n            const entryMap = new Map<string, boolean>();\n\n            if (\n                entriesArg.argumentCategory === ArgumentCategory.Simple &&\n                entriesArg.valueExpression &&\n                entriesArg.valueExpression.nodeType === ParseNodeType.Dictionary\n            ) {\n                usingDictSyntax = true;\n                const entryDict = entriesArg.valueExpression;\n\n                entryDict.entries.forEach((entry) => {\n                    if (entry.nodeType !== ParseNodeType.DictionaryKeyEntry) {\n                        addError(Localizer.Diagnostic.typedDictSecondArgDictEntry(), entry);\n                        return;\n                    }\n\n                    if (entry.keyExpression.nodeType !== ParseNodeType.StringList) {\n                        addError(Localizer.Diagnostic.typedDictEntryName(), entry.keyExpression);\n                        return;\n                    }\n\n                    const entryName = entry.keyExpression.strings.map((s) => s.value).join('');\n                    if (!entryName) {\n                        addError(Localizer.Diagnostic.typedDictEmptyName(), entry.keyExpression);\n                        return;\n                    }\n\n                    if (entryMap.has(entryName)) {\n                        addError(Localizer.Diagnostic.typedDictEntryUnique(), entry.keyExpression);\n                        return;\n                    }\n\n                    // Record names in a map to detect duplicates.\n                    entryMap.set(entryName, true);\n\n                    // Cache the annotation type.\n                    getTypeOfAnnotation(entry.valueExpression, /* allowFinal */ true);\n\n                    const newSymbol = new Symbol(SymbolFlags.InstanceMember);\n                    const declaration: VariableDeclaration = {\n                        type: DeclarationType.Variable,\n                        node: entry.keyExpression,\n                        path: fileInfo.filePath,\n                        typeAnnotationNode: entry.valueExpression,\n                        range: convertOffsetsToRange(\n                            entry.keyExpression.start,\n                            TextRange.getEnd(entry.keyExpression),\n                            fileInfo.lines\n                        ),\n                        moduleName: fileInfo.moduleName,\n                    };\n                    newSymbol.addDeclaration(declaration);\n\n                    classFields.set(entryName, newSymbol);\n                });\n            } else if (entriesArg.name) {\n                for (let i = 1; i < argList.length; i++) {\n                    const entry = argList[i];\n                    if (!entry.name || !entry.valueExpression) {\n                        continue;\n                    }\n\n                    if (entryMap.has(entry.name.value)) {\n                        addError(Localizer.Diagnostic.typedDictEntryUnique(), entry.valueExpression);\n                        continue;\n                    }\n\n                    // Record names in a map to detect duplicates.\n                    entryMap.set(entry.name.value, true);\n\n                    // Cache the annotation type.\n                    getTypeOfAnnotation(entry.valueExpression, /* allowFinal */ true);\n\n                    const newSymbol = new Symbol(SymbolFlags.InstanceMember);\n                    const fileInfo = getFileInfo(errorNode);\n                    const declaration: VariableDeclaration = {\n                        type: DeclarationType.Variable,\n                        node: entry.name,\n                        path: fileInfo.filePath,\n                        typeAnnotationNode: entry.valueExpression,\n                        range: convertOffsetsToRange(\n                            entry.name.start,\n                            TextRange.getEnd(entry.valueExpression),\n                            fileInfo.lines\n                        ),\n                        moduleName: fileInfo.moduleName,\n                    };\n                    newSymbol.addDeclaration(declaration);\n\n                    classFields.set(entry.name.value, newSymbol);\n                }\n            } else {\n                addError(Localizer.Diagnostic.typedDictSecondArgDict(), errorNode);\n            }\n        }\n\n        if (usingDictSyntax) {\n            if (argList.length >= 3) {\n                if (\n                    !argList[2].name ||\n                    argList[2].name.value !== 'total' ||\n                    !argList[2].valueExpression ||\n                    argList[2].valueExpression.nodeType !== ParseNodeType.Constant ||\n                    !(\n                        argList[2].valueExpression.constType === KeywordType.False ||\n                        argList[2].valueExpression.constType === KeywordType.True\n                    )\n                ) {\n                    addError(Localizer.Diagnostic.typedDictTotalParam(), argList[2].valueExpression || errorNode);\n                } else if (argList[2].valueExpression.constType === KeywordType.False) {\n                    classType.details.flags |= ClassTypeFlags.CanOmitDictValues;\n                }\n            }\n\n            if (argList.length > 3) {\n                addError(Localizer.Diagnostic.typedDictExtraArgs(), argList[3].valueExpression || errorNode);\n            }\n        }\n\n        synthesizeTypedDictClassMethods(errorNode, classType);\n\n        return classType;\n    }\n\n    // Creates a new custom tuple factory class with named values.\n    // Supports both typed and untyped variants.\n    function createNamedTupleType(\n        errorNode: ExpressionNode,\n        argList: FunctionArgument[],\n        includesTypes: boolean\n    ): ClassType {\n        const fileInfo = getFileInfo(errorNode);\n        let className = 'namedtuple';\n        if (argList.length === 0) {\n            addError(Localizer.Diagnostic.namedTupleFirstArg(), errorNode);\n        } else {\n            const nameArg = argList[0];\n            if (nameArg.argumentCategory !== ArgumentCategory.Simple) {\n                addError(Localizer.Diagnostic.namedTupleFirstArg(), argList[0].valueExpression || errorNode);\n            } else if (nameArg.valueExpression && nameArg.valueExpression.nodeType === ParseNodeType.StringList) {\n                className = nameArg.valueExpression.strings.map((s) => s.value).join('');\n            }\n        }\n\n        const namedTupleType = getTypingType(errorNode, 'NamedTuple') || UnknownType.create();\n\n        const classType = ClassType.create(\n            className,\n            getClassFullName(errorNode, fileInfo.moduleName, className),\n            fileInfo.moduleName,\n            ClassTypeFlags.None,\n            errorNode.id,\n            /* declaredMetaclass */ undefined,\n            isClass(namedTupleType) ? namedTupleType.details.effectiveMetaclass : UnknownType.create()\n        );\n        classType.details.baseClasses.push(namedTupleType);\n\n        const classFields = classType.details.fields;\n        classFields.set(\n            '__class__',\n            Symbol.createWithType(SymbolFlags.ClassMember | SymbolFlags.IgnoredForProtocolMatch, classType)\n        );\n\n        const constructorType = FunctionType.createInstance(\n            '__new__',\n            '',\n            FunctionTypeFlags.ConstructorMethod | FunctionTypeFlags.SynthesizedMethod\n        );\n        constructorType.details.declaredReturnType = ObjectType.create(classType);\n        if (ParseTreeUtils.isAssignmentToDefaultsFollowingNamedTuple(errorNode)) {\n            constructorType.details.flags |= FunctionTypeFlags.DisableDefaultChecks;\n        }\n        FunctionType.addParameter(constructorType, {\n            category: ParameterCategory.Simple,\n            name: 'cls',\n            type: classType,\n        });\n\n        const selfParameter: FunctionParameter = {\n            category: ParameterCategory.Simple,\n            name: 'self',\n            type: ObjectType.create(classType),\n        };\n\n        let addGenericGetAttribute = false;\n        const entryTypes: Type[] = [];\n\n        if (argList.length < 2) {\n            addError(Localizer.Diagnostic.namedTupleSecondArg(), errorNode);\n            addGenericGetAttribute = true;\n        } else {\n            const entriesArg = argList[1];\n            if (entriesArg.argumentCategory !== ArgumentCategory.Simple) {\n                addGenericGetAttribute = true;\n            } else {\n                if (\n                    !includesTypes &&\n                    entriesArg.valueExpression &&\n                    entriesArg.valueExpression.nodeType === ParseNodeType.StringList\n                ) {\n                    const entries = entriesArg.valueExpression.strings\n                        .map((s) => s.value)\n                        .join('')\n                        .split(/[,\\s]+/);\n                    entries.forEach((entryName) => {\n                        entryName = entryName.trim();\n                        if (entryName) {\n                            const entryType = UnknownType.create();\n                            const paramInfo: FunctionParameter = {\n                                category: ParameterCategory.Simple,\n                                name: entryName,\n                                hasDeclaredType: includesTypes,\n                                type: entryType,\n                            };\n\n                            FunctionType.addParameter(constructorType, paramInfo);\n                            const newSymbol = Symbol.createWithType(SymbolFlags.InstanceMember, entryType);\n\n                            // We need to associate the declaration with a parse node.\n                            // In this case it's just part of a string literal value.\n                            // The definition provider won't necessarily take the\n                            // user to the exact spot in the string, but it's close enough.\n                            const stringNode = entriesArg.valueExpression!;\n                            const declaration: VariableDeclaration = {\n                                type: DeclarationType.Variable,\n                                node: stringNode as StringListNode,\n                                path: fileInfo.filePath,\n                                range: convertOffsetsToRange(\n                                    stringNode.start,\n                                    TextRange.getEnd(stringNode),\n                                    fileInfo.lines\n                                ),\n                                moduleName: fileInfo.moduleName,\n                            };\n                            newSymbol.addDeclaration(declaration);\n                            classFields.set(entryName, newSymbol);\n                            entryTypes.push(entryType);\n                        }\n                    });\n                } else if (entriesArg.valueExpression && entriesArg.valueExpression.nodeType === ParseNodeType.List) {\n                    const entryList = entriesArg.valueExpression;\n                    const entryMap = new Map<string, string>();\n\n                    entryList.entries.forEach((entry, index) => {\n                        let entryTypeNode: ExpressionNode | undefined;\n                        let entryType: Type | undefined;\n                        let entryNameNode: ExpressionNode | undefined;\n                        let entryName = '';\n\n                        if (includesTypes) {\n                            // Handle the variant that includes name/type tuples.\n                            if (entry.nodeType === ParseNodeType.Tuple && entry.expressions.length === 2) {\n                                entryNameNode = entry.expressions[0];\n                                entryTypeNode = entry.expressions[1];\n                                const entryTypeInfo = getTypeOfExpression(\n                                    entryTypeNode,\n                                    undefined,\n                                    EvaluatorFlags.ExpectingType |\n                                        EvaluatorFlags.EvaluateStringLiteralAsType |\n                                        EvaluatorFlags.ParamSpecDisallowed\n                                );\n                                if (entryTypeInfo) {\n                                    entryType = convertToInstance(entryTypeInfo.type);\n                                }\n                            } else {\n                                addError(Localizer.Diagnostic.namedTupleNameType(), entry);\n                            }\n                        } else {\n                            entryNameNode = entry;\n                            entryType = UnknownType.create();\n                        }\n\n                        if (entryNameNode && entryNameNode.nodeType === ParseNodeType.StringList) {\n                            entryName = entryNameNode.strings.map((s) => s.value).join('');\n                            if (!entryName) {\n                                addError(Localizer.Diagnostic.namedTupleEmptyName(), entryNameNode);\n                            }\n                        } else {\n                            addError(Localizer.Diagnostic.namedTupleNameString(), entryNameNode || entry);\n                        }\n\n                        if (!entryName) {\n                            entryName = `_${index.toString()}`;\n                        }\n\n                        if (entryMap.has(entryName)) {\n                            addError(Localizer.Diagnostic.namedTupleNameUnique(), entryNameNode || entry);\n                        }\n\n                        // Record names in a map to detect duplicates.\n                        entryMap.set(entryName, entryName);\n\n                        if (!entryType) {\n                            entryType = UnknownType.create();\n                        }\n\n                        const paramInfo: FunctionParameter = {\n                            category: ParameterCategory.Simple,\n                            name: entryName,\n                            hasDeclaredType: includesTypes,\n                            type: entryType,\n                        };\n\n                        FunctionType.addParameter(constructorType, paramInfo);\n                        entryTypes.push(entryType);\n\n                        const newSymbol = Symbol.createWithType(SymbolFlags.InstanceMember, entryType);\n                        if (entryNameNode && entryNameNode.nodeType === ParseNodeType.StringList) {\n                            const declaration: VariableDeclaration = {\n                                type: DeclarationType.Variable,\n                                node: entryNameNode,\n                                path: fileInfo.filePath,\n                                typeAnnotationNode: entryTypeNode,\n                                range: convertOffsetsToRange(\n                                    entryNameNode.start,\n                                    TextRange.getEnd(entryNameNode),\n                                    fileInfo.lines\n                                ),\n                                moduleName: fileInfo.moduleName,\n                            };\n                            newSymbol.addDeclaration(declaration);\n                        }\n                        classFields.set(entryName, newSymbol);\n                    });\n                } else {\n                    // A dynamic expression was used, so we can't evaluate\n                    // the named tuple statically.\n                    addGenericGetAttribute = true;\n                }\n            }\n        }\n\n        if (addGenericGetAttribute) {\n            FunctionType.addDefaultParameters(constructorType);\n            entryTypes.push(AnyType.create(/* isEllipsis */ false));\n            entryTypes.push(AnyType.create(/* isEllipsis */ true));\n        }\n\n        // Always use generic parameters for __init__. The __new__ method\n        // will handle property type checking. We may need to disable default\n        // parameter processing for __new__ (see isAssignmentToDefaultsFollowingNamedTuple),\n        // and we don't want to do it for __init__ as well.\n        const initType = FunctionType.createInstance(\n            '__init__',\n            '',\n            FunctionTypeFlags.SynthesizedMethod | FunctionTypeFlags.SkipConstructorCheck\n        );\n        FunctionType.addParameter(initType, selfParameter);\n        FunctionType.addDefaultParameters(initType);\n        initType.details.declaredReturnType = NoneType.createInstance();\n\n        classFields.set('__new__', Symbol.createWithType(SymbolFlags.ClassMember, constructorType));\n        classFields.set('__init__', Symbol.createWithType(SymbolFlags.ClassMember, initType));\n\n        const keysItemType = FunctionType.createInstance('keys', '', FunctionTypeFlags.SynthesizedMethod);\n        const itemsItemType = FunctionType.createInstance('items', '', FunctionTypeFlags.SynthesizedMethod);\n        keysItemType.details.declaredReturnType = getBuiltInObject(errorNode, 'List', [\n            getBuiltInObject(errorNode, 'str'),\n        ]);\n        itemsItemType.details.declaredReturnType = keysItemType.details.declaredReturnType;\n        classFields.set('keys', Symbol.createWithType(SymbolFlags.InstanceMember, keysItemType));\n        classFields.set('items', Symbol.createWithType(SymbolFlags.InstanceMember, itemsItemType));\n\n        const lenType = FunctionType.createInstance('__len__', '', FunctionTypeFlags.SynthesizedMethod);\n        lenType.details.declaredReturnType = getBuiltInObject(errorNode, 'int');\n        FunctionType.addParameter(lenType, selfParameter);\n        classFields.set('__len__', Symbol.createWithType(SymbolFlags.ClassMember, lenType));\n\n        if (addGenericGetAttribute) {\n            const getAttribType = FunctionType.createInstance(\n                '__getattribute__',\n                '',\n                FunctionTypeFlags.SynthesizedMethod\n            );\n            getAttribType.details.declaredReturnType = AnyType.create();\n            FunctionType.addParameter(getAttribType, selfParameter);\n            FunctionType.addParameter(getAttribType, {\n                category: ParameterCategory.Simple,\n                name: 'name',\n                type: getBuiltInObject(errorNode, 'str'),\n            });\n            classFields.set('__getattribute__', Symbol.createWithType(SymbolFlags.ClassMember, getAttribType));\n        }\n\n        computeMroLinearization(classType);\n\n        updateNamedTupleBaseClass(classType, entryTypes, !addGenericGetAttribute);\n\n        return classType;\n    }\n\n    function getTypeFromConstant(node: ConstantNode, flags: EvaluatorFlags): TypeResult | undefined {\n        let type: Type | undefined;\n\n        if (node.constType === KeywordType.None) {\n            type = (flags & EvaluatorFlags.ExpectingType) !== 0 ? NoneType.createType() : NoneType.createInstance();\n        } else if (\n            node.constType === KeywordType.True ||\n            node.constType === KeywordType.False ||\n            node.constType === KeywordType.Debug\n        ) {\n            type = getBuiltInObject(node, 'bool');\n\n            // For True and False, we can create truthy and falsy\n            // versions of 'bool'.\n            if (type && isObject(type)) {\n                if (node.constType === KeywordType.True) {\n                    type = ObjectType.create(ClassType.cloneWithLiteral(type.classType, true));\n                } else if (node.constType === KeywordType.False) {\n                    type = ObjectType.create(ClassType.cloneWithLiteral(type.classType, false));\n                }\n            }\n        }\n\n        if (!type) {\n            return undefined;\n        }\n\n        return { type, node };\n    }\n\n    function getTypeFromUnaryOperation(node: UnaryOperationNode, expectedType: Type | undefined): TypeResult {\n        let exprType = makeTypeVarsConcrete(getTypeOfExpression(node.expression).type);\n\n        // Map unary operators to magic functions. Note that the bitwise\n        // invert has two magic functions that are aliases of each other.\n        const unaryOperatorMap: { [operator: number]: string } = {\n            [OperatorType.Add]: '__pos__',\n            [OperatorType.Subtract]: '__neg__',\n            [OperatorType.BitwiseInvert]: '__invert__',\n        };\n\n        let type: Type | undefined;\n\n        if (node.operator !== OperatorType.Not) {\n            if (isOptionalType(exprType)) {\n                addDiagnostic(\n                    getFileInfo(node).diagnosticRuleSet.reportOptionalOperand,\n                    DiagnosticRule.reportOptionalOperand,\n                    Localizer.Diagnostic.noneOperator().format({\n                        operator: ParseTreeUtils.printOperator(node.operator),\n                    }),\n                    node.expression\n                );\n                exprType = removeNoneFromUnion(exprType);\n            }\n        }\n\n        // __not__ always returns a boolean.\n        if (node.operator === OperatorType.Not) {\n            type = getBuiltInObject(node, 'bool');\n            if (!type) {\n                type = UnknownType.create();\n            }\n        } else {\n            if (isAnyOrUnknown(exprType)) {\n                type = exprType;\n            } else {\n                const magicMethodName = unaryOperatorMap[node.operator];\n                type = getTypeFromMagicMethodReturn(exprType, [], magicMethodName, node, expectedType);\n            }\n\n            if (!type) {\n                const fileInfo = getFileInfo(node);\n                addDiagnostic(\n                    fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                    DiagnosticRule.reportGeneralTypeIssues,\n                    Localizer.Diagnostic.typeNotSupportUnaryOperator().format({\n                        operator: ParseTreeUtils.printOperator(node.operator),\n                        type: printType(exprType),\n                    }),\n                    node\n                );\n                type = UnknownType.create();\n            }\n        }\n\n        // Handle the special case where the unary operator is + or -, the operand\n        // is a literal int, and the resulting type is an int. In these cases, we'll\n        // want to interpret the resulting type as a literal.\n        if (node.operator === OperatorType.Add || node.operator === OperatorType.Subtract) {\n            if (\n                isObject(type) &&\n                ClassType.isBuiltIn(type.classType, 'int') &&\n                isObject(exprType) &&\n                ClassType.isBuiltIn(exprType.classType, 'int') &&\n                typeof exprType.classType.literalValue === 'number'\n            ) {\n                const value =\n                    node.operator === OperatorType.Add\n                        ? exprType.classType.literalValue\n                        : -exprType.classType.literalValue;\n                type = ObjectType.create(ClassType.cloneWithLiteral(type.classType, value));\n            }\n        }\n\n        return { type, node };\n    }\n\n    function getTypeFromBinaryOperation(\n        node: BinaryOperationNode,\n        expectedType: Type | undefined,\n        flags: EvaluatorFlags\n    ): TypeResult {\n        let leftExpression = node.leftExpression;\n\n        // If this is a comparison and the left expression is also a comparison,\n        // we need to change the behavior to accommodate python's \"chained\n        // comparisons\" feature.\n        if (comparisonOperatorMap[node.operator]) {\n            if (\n                node.leftExpression.nodeType === ParseNodeType.BinaryOperation &&\n                !node.leftExpression.parenthesized &&\n                comparisonOperatorMap[node.leftExpression.operator]\n            ) {\n                // Evaluate the left expression so it is type checked.\n                getTypeFromBinaryOperation(node.leftExpression, expectedType, flags);\n\n                // Use the right side of the left expression for comparison purposes.\n                leftExpression = node.leftExpression.rightExpression;\n            }\n        }\n\n        let leftType = makeTypeVarsConcrete(getTypeOfExpression(leftExpression).type);\n        let rightType = makeTypeVarsConcrete(getTypeOfExpression(node.rightExpression).type);\n\n        // Is this a \"|\" operator used in a context where it is supposed to be\n        // interpreted as a union operator?\n        if (node.operator === OperatorType.BitwiseOr) {\n            let adjustedRightType = rightType;\n            if (!isNone(leftType) && isNone(rightType) && TypeBase.isInstance(rightType)) {\n                // Handle the special case where \"None\" is being added to the union\n                // with something else. Even though \"None\" will normally be interpreted\n                // as the None singleton object in contexts where a type annotation isn't\n                // assumed, we'll allow it here.\n                adjustedRightType = NoneType.createType();\n            }\n\n            if (isUnionableType([leftType, adjustedRightType])) {\n                const fileInfo = getFileInfo(node);\n                const unionNotationSupported =\n                    fileInfo.isStubFile || fileInfo.executionEnvironment.pythonVersion >= PythonVersion.V3_10;\n                if (!unionNotationSupported) {\n                    addError(Localizer.Diagnostic.unionSyntaxIllegal(), node, node.operatorToken);\n                }\n\n                return {\n                    type: combineTypes([leftType, adjustedRightType]),\n                    node,\n                };\n            }\n        }\n\n        // Optional checks apply to all operations except for boolean operations.\n        if (booleanOperatorMap[node.operator] === undefined) {\n            if (isOptionalType(leftType)) {\n                // Skip the optional error reporting for == and !=, since\n                // None is a valid operand for these operators.\n                if (node.operator !== OperatorType.Equals && node.operator !== OperatorType.NotEquals) {\n                    addDiagnostic(\n                        getFileInfo(node).diagnosticRuleSet.reportOptionalOperand,\n                        DiagnosticRule.reportOptionalOperand,\n                        Localizer.Diagnostic.noneOperator().format({\n                            operator: ParseTreeUtils.printOperator(node.operator),\n                        }),\n                        node.leftExpression\n                    );\n                }\n                leftType = removeNoneFromUnion(leftType);\n            }\n\n            // None is a valid operand for == and != even if the type stub says otherwise.\n            if (node.operator === OperatorType.Equals || node.operator === OperatorType.NotEquals) {\n                rightType = removeNoneFromUnion(rightType);\n            }\n        }\n\n        return {\n            type: validateBinaryOperation(node.operator, leftType, rightType, node, expectedType),\n            node,\n        };\n    }\n\n    function getTypeFromAugmentedAssignment(node: AugmentedAssignmentNode, expectedType: Type | undefined): Type {\n        const operatorMap: { [operator: number]: [string, OperatorType] } = {\n            [OperatorType.AddEqual]: ['__iadd__', OperatorType.Add],\n            [OperatorType.SubtractEqual]: ['__isub__', OperatorType.Subtract],\n            [OperatorType.MultiplyEqual]: ['__imul__', OperatorType.Multiply],\n            [OperatorType.FloorDivideEqual]: ['__ifloordiv__', OperatorType.FloorDivide],\n            [OperatorType.DivideEqual]: ['__itruediv__', OperatorType.Divide],\n            [OperatorType.ModEqual]: ['__imod__', OperatorType.Mod],\n            [OperatorType.PowerEqual]: ['__ipow__', OperatorType.Power],\n            [OperatorType.MatrixMultiplyEqual]: ['__imatmul__', OperatorType.MatrixMultiply],\n            [OperatorType.BitwiseAndEqual]: ['__iand__', OperatorType.BitwiseAnd],\n            [OperatorType.BitwiseOrEqual]: ['__ior__', OperatorType.BitwiseOr],\n            [OperatorType.BitwiseXorEqual]: ['__ixor__', OperatorType.BitwiseXor],\n            [OperatorType.LeftShiftEqual]: ['__ilshift__', OperatorType.LeftShift],\n            [OperatorType.RightShiftEqual]: ['__irshift__', OperatorType.RightShift],\n        };\n\n        let type: Type | undefined;\n\n        const leftType = makeTypeVarsConcrete(getTypeOfExpression(node.leftExpression).type);\n        const rightType = makeTypeVarsConcrete(getTypeOfExpression(node.rightExpression).type);\n\n        type = doForSubtypes(leftType!, (leftSubtype) => {\n            return doForSubtypes(rightType, (rightSubtype) => {\n                if (isAnyOrUnknown(leftSubtype) || isAnyOrUnknown(rightSubtype)) {\n                    // If either type is \"Unknown\" (versus Any), propagate the Unknown.\n                    if (isUnknown(leftSubtype) || isUnknown(rightSubtype)) {\n                        return UnknownType.create();\n                    } else {\n                        return AnyType.create();\n                    }\n                }\n\n                const magicMethodName = operatorMap[node.operator][0];\n                return getTypeFromMagicMethodReturn(leftSubtype, [rightSubtype], magicMethodName, node, expectedType);\n            });\n        });\n\n        // If the LHS class didn't support the magic method for augmented\n        // assignment, fall back on the normal binary expression evaluator.\n        if (!type || isNever(type)) {\n            const binaryOperator = operatorMap[node.operator][1];\n            type = validateBinaryOperation(binaryOperator, leftType!, rightType, node, expectedType);\n        }\n\n        return type;\n    }\n\n    function validateBinaryOperation(\n        operator: OperatorType,\n        leftType: Type,\n        rightType: Type,\n        errorNode: ExpressionNode,\n        expectedType: Type | undefined\n    ): Type {\n        let type: Type | undefined;\n\n        if (arithmeticOperatorMap[operator]) {\n            type = doForSubtypes(leftType, (leftSubtype) => {\n                return doForSubtypes(rightType, (rightSubtype) => {\n                    if (isAnyOrUnknown(leftSubtype) || isAnyOrUnknown(rightSubtype)) {\n                        // If either type is \"Unknown\" (versus Any), propagate the Unknown.\n                        if (isUnknown(leftSubtype) || isUnknown(rightSubtype)) {\n                            return UnknownType.create();\n                        } else {\n                            return AnyType.create();\n                        }\n                    }\n\n                    const magicMethodName = arithmeticOperatorMap[operator][0];\n                    const resultType = getTypeFromMagicMethodReturn(\n                        leftSubtype,\n                        [rightSubtype],\n                        magicMethodName,\n                        errorNode,\n                        expectedType\n                    );\n                    if (resultType) {\n                        return resultType;\n                    }\n\n                    const altMagicMethodName = arithmeticOperatorMap[operator][1];\n                    return getTypeFromMagicMethodReturn(\n                        rightSubtype,\n                        [leftSubtype],\n                        altMagicMethodName,\n                        errorNode,\n                        expectedType\n                    );\n                });\n            });\n        } else if (bitwiseOperatorMap[operator]) {\n            type = doForSubtypes(leftType, (leftSubtype) => {\n                return doForSubtypes(rightType, (rightSubtype) => {\n                    if (isAnyOrUnknown(leftSubtype) || isAnyOrUnknown(rightSubtype)) {\n                        // If either type is \"Unknown\" (versus Any), propagate the Unknown.\n                        if (isUnknown(leftSubtype) || isUnknown(rightSubtype)) {\n                            return UnknownType.create();\n                        } else {\n                            return AnyType.create();\n                        }\n                    }\n\n                    // Handle the general case.\n                    const magicMethodName = bitwiseOperatorMap[operator][0];\n                    return getTypeFromMagicMethodReturn(\n                        leftSubtype,\n                        [rightSubtype],\n                        magicMethodName,\n                        errorNode,\n                        expectedType\n                    );\n                });\n            });\n        } else if (comparisonOperatorMap[operator]) {\n            type = doForSubtypes(leftType, (leftSubtype) => {\n                return doForSubtypes(rightType, (rightSubtype) => {\n                    if (isAnyOrUnknown(leftSubtype) || isAnyOrUnknown(rightSubtype)) {\n                        // If either type is \"Unknown\" (versus Any), propagate the Unknown.\n                        if (isUnknown(leftSubtype) || isUnknown(rightSubtype)) {\n                            return UnknownType.create();\n                        } else {\n                            return AnyType.create();\n                        }\n                    }\n\n                    const magicMethodName = comparisonOperatorMap[operator][0];\n                    const resultType = getTypeFromMagicMethodReturn(\n                        leftSubtype,\n                        [rightSubtype],\n                        magicMethodName,\n                        errorNode,\n                        expectedType\n                    );\n                    if (resultType) {\n                        return resultType;\n                    }\n\n                    const altMagicMethodName = comparisonOperatorMap[operator][1];\n                    return getTypeFromMagicMethodReturn(\n                        rightSubtype,\n                        [leftSubtype],\n                        altMagicMethodName,\n                        errorNode,\n                        expectedType\n                    );\n                });\n            });\n        } else if (booleanOperatorMap[operator]) {\n            // If it's an AND or OR, we need to handle short-circuiting by\n            // eliminating any known-truthy or known-falsy types.\n            if (operator === OperatorType.And) {\n                leftType = removeTruthinessFromType(leftType);\n\n                // If the LHS evaluates to False, the And expression will\n                // always return the type of the right-hand side.\n                if (isNever(leftType)) {\n                    return rightType;\n                }\n            } else if (operator === OperatorType.Or) {\n                leftType = removeFalsinessFromType(leftType);\n\n                // If the LHS evaluates to True, the Or expression will\n                // always return the type of the right-hand side.\n                if (isNever(leftType)) {\n                    return rightType;\n                }\n            }\n\n            // The \"in\" and \"not in\" operators make use of the __contains__\n            // magic method.\n            if (operator === OperatorType.In || operator === OperatorType.NotIn) {\n                type = doForSubtypes(rightType, (rightSubtype) => {\n                    return doForSubtypes(leftType, (leftSubtype) => {\n                        if (isAnyOrUnknown(rightSubtype) || isAnyOrUnknown(leftSubtype)) {\n                            // If either type is \"Unknown\" (versus Any), propagate the Unknown.\n                            if (isUnknown(leftSubtype) || isUnknown(rightSubtype)) {\n                                return UnknownType.create();\n                            } else {\n                                return AnyType.create();\n                            }\n                        }\n\n                        let returnType = getTypeFromMagicMethodReturn(\n                            rightSubtype,\n                            [leftSubtype],\n                            '__contains__',\n                            errorNode,\n                            /* expectedType */ undefined\n                        );\n\n                        if (!returnType) {\n                            // If __contains__ was not supported, fall back\n                            // on an iterable.\n                            const iteratorType = getTypeFromIterable(\n                                rightSubtype,\n                                /* isAsync */ false,\n                                errorNode,\n                                /* supportGetItem */ false\n                            );\n\n                            if (iteratorType && canAssignType(iteratorType, leftSubtype, new DiagnosticAddendum())) {\n                                returnType = iteratorType;\n                            }\n                        }\n\n                        return returnType;\n                    });\n                });\n\n                // Assume that a bool is returned even if the type is unknown\n                if (type && !isNever(type)) {\n                    type = getBuiltInObject(errorNode, 'bool');\n                }\n            } else {\n                type = doForSubtypes(leftType, (leftSubtype) => {\n                    return doForSubtypes(rightType, (rightSubtype) => {\n                        // If the operator is an AND or OR, we need to combine the two types.\n                        if (operator === OperatorType.And || operator === OperatorType.Or) {\n                            return combineTypes([leftSubtype, rightSubtype]);\n                        }\n                        // The other boolean operators always return a bool value.\n                        return getBuiltInObject(errorNode, 'bool');\n                    });\n                });\n            }\n        }\n\n        if (!type || isNever(type)) {\n            const fileInfo = getFileInfo(errorNode);\n            addDiagnostic(\n                fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                DiagnosticRule.reportGeneralTypeIssues,\n                Localizer.Diagnostic.typeNotSupportBinaryOperator().format({\n                    operator: ParseTreeUtils.printOperator(operator),\n                    leftType: printType(leftType),\n                    rightType: printType(rightType),\n                }),\n                errorNode\n            );\n            type = UnknownType.create();\n        }\n\n        return type;\n    }\n\n    function getTypeFromMagicMethodReturn(\n        objType: Type,\n        args: Type[],\n        magicMethodName: string,\n        errorNode: ExpressionNode,\n        expectedType: Type | undefined\n    ): Type | undefined {\n        let magicMethodSupported = true;\n\n        // Create a helper lambda for object subtypes.\n        const handleObjectSubtype = (subtype: ObjectType, bindToClassType?: ClassType) => {\n            const magicMethodType = getTypeFromObjectMember(\n                errorNode,\n                subtype,\n                magicMethodName,\n                { method: 'get' },\n                new DiagnosticAddendum(),\n                MemberAccessFlags.SkipForMethodLookup,\n                bindToClassType\n            );\n\n            if (magicMethodType) {\n                const functionArgs = args.map((arg) => {\n                    return {\n                        argumentCategory: ArgumentCategory.Simple,\n                        type: arg,\n                    };\n                });\n\n                let callResult: CallResult | undefined;\n\n                suppressDiagnostics(() => {\n                    callResult = validateCallArguments(\n                        errorNode,\n                        functionArgs,\n                        magicMethodType,\n                        new TypeVarMap(),\n                        /* skipUnknownArgCheck */ true,\n                        /* inferFunctionReturnType */ true,\n                        expectedType\n                    );\n                });\n\n                if (callResult!.argumentErrors) {\n                    magicMethodSupported = false;\n                }\n\n                return callResult!.returnType;\n            }\n\n            magicMethodSupported = false;\n            return undefined;\n        };\n\n        const returnType = doForSubtypes(objType, (subtype) => {\n            if (isAnyOrUnknown(subtype)) {\n                return subtype;\n            }\n\n            if (isObject(subtype)) {\n                return handleObjectSubtype(subtype);\n            } else if (isClass(subtype)) {\n                // See if the class has a metaclass that handles the operation.\n                const metaclass = subtype.details.effectiveMetaclass;\n                if (metaclass && isClass(metaclass)) {\n                    return handleObjectSubtype(ObjectType.create(metaclass), subtype);\n                }\n            } else if (isNone(subtype)) {\n                // NoneType derives from 'object', so do the lookup on 'object'\n                // in this case.\n                const obj = getBuiltInObject(errorNode, 'object');\n                if (isObject(obj)) {\n                    return handleObjectSubtype(obj);\n                }\n            }\n\n            magicMethodSupported = false;\n            return undefined;\n        });\n\n        if (!magicMethodSupported) {\n            return undefined;\n        }\n\n        return returnType;\n    }\n\n    function getTypeFromSet(node: SetNode, expectedType: Type | undefined): TypeResult {\n        const entryTypes = node.entries.map((entryNode) => {\n            if (entryNode.nodeType === ParseNodeType.ListComprehension) {\n                return getElementTypeFromListComprehension(entryNode);\n            }\n            return getTypeOfExpression(entryNode).type;\n        });\n\n        // If there is an expected type, see if we can match it.\n        if (expectedType && entryTypes.length > 0) {\n            const narrowedExpectedType = doForSubtypes(expectedType, (subtype) => {\n                if (isObject(subtype)) {\n                    const classAlias = subtype.classType.details.aliasClass || subtype.classType;\n                    if (ClassType.isBuiltIn(classAlias, 'set') && subtype.classType.typeArguments) {\n                        const typeArg = subtype.classType.typeArguments[0];\n                        const typeVarMap = new TypeVarMap();\n\n                        for (const entryType of entryTypes) {\n                            if (!canAssignType(typeArg, entryType, new DiagnosticAddendum(), typeVarMap)) {\n                                return undefined;\n                            }\n                        }\n\n                        return specializeType(subtype, typeVarMap);\n                    }\n                }\n\n                return undefined;\n            });\n\n            if (!isNever(narrowedExpectedType)) {\n                return { type: narrowedExpectedType, node };\n            }\n        }\n\n        let inferredEntryType =\n            entryTypes.length > 0 ? combineTypes(entryTypes.map((t) => stripLiteralValue(t))) : AnyType.create();\n\n        // If we weren't provided an expected type, strip away any\n        // literals from the set.\n        if (!expectedType) {\n            inferredEntryType = stripLiteralValue(inferredEntryType);\n        }\n\n        const type = getBuiltInObject(node, 'Set', [inferredEntryType]);\n\n        return { type, node };\n    }\n\n    function getTypeFromDictionary(node: DictionaryNode, expectedType: Type | undefined): TypeResult {\n        let keyType: Type = AnyType.create();\n        let valueType: Type = AnyType.create();\n\n        let keyTypes: Type[] = [];\n        let valueTypes: Type[] = [];\n\n        let expectedKeyType: Type | undefined;\n        let expectedValueType: Type | undefined;\n        let expectedTypedDictEntries: Map<string, TypedDictEntry> | undefined;\n        const diagAddendum = new DiagnosticAddendum();\n\n        if (expectedType) {\n            doForSubtypes(expectedType, (subtype) => {\n                if (isObject(subtype)) {\n                    const expectedClass = subtype.classType;\n                    if (\n                        ClassType.isBuiltIn(expectedClass, 'Mapping') ||\n                        ClassType.isBuiltIn(expectedClass, 'Dict') ||\n                        ClassType.isBuiltIn(expectedClass, 'dict')\n                    ) {\n                        if (expectedClass.typeArguments && expectedClass.typeArguments.length === 2) {\n                            expectedKeyType = specializeType(\n                                expectedClass.typeArguments[0],\n                                /* typeVarMap */ undefined\n                            );\n                            expectedValueType = specializeType(\n                                expectedClass.typeArguments[1],\n                                /* typeVarMap */ undefined\n                            );\n                        }\n                    } else if (ClassType.isTypedDictClass(expectedClass)) {\n                        expectedTypedDictEntries = getTypedDictMembersForClass(expectedClass);\n                    }\n                }\n\n                return undefined;\n            });\n        }\n\n        // Infer the key and value types if possible.\n        node.entries.forEach((entryNode) => {\n            let addUnknown = true;\n\n            if (entryNode.nodeType === ParseNodeType.DictionaryKeyEntry) {\n                let keyType = getTypeOfExpression(entryNode.keyExpression, expectedKeyType).type;\n                if (expectedKeyType) {\n                    const adjExpectedKeyType = makeTypeVarsConcrete(expectedKeyType);\n                    if (!isAnyOrUnknown(adjExpectedKeyType)) {\n                        if (canAssignType(adjExpectedKeyType, keyType, new DiagnosticAddendum(), undefined)) {\n                            keyType = adjExpectedKeyType;\n                        }\n                    }\n                }\n                let valueType: Type | undefined;\n\n                if (\n                    expectedTypedDictEntries &&\n                    isObject(keyType) &&\n                    ClassType.isBuiltIn(keyType.classType, 'str') &&\n                    keyType.classType.literalValue &&\n                    expectedTypedDictEntries.has(keyType.classType.literalValue as string)\n                ) {\n                    valueType = getTypeOfExpression(\n                        entryNode.valueExpression,\n                        expectedTypedDictEntries.get(keyType.classType.literalValue as string)!.valueType\n                    ).type;\n                } else {\n                    valueType = getTypeOfExpression(entryNode.valueExpression, expectedValueType).type;\n                }\n\n                keyTypes.push(keyType);\n                valueTypes.push(valueType);\n                addUnknown = false;\n            } else if (entryNode.nodeType === ParseNodeType.DictionaryExpandEntry) {\n                const unexpandedType = getTypeOfExpression(entryNode.expandExpression).type;\n                if (isAnyOrUnknown(unexpandedType)) {\n                    addUnknown = false;\n                } else {\n                    if (isObject(unexpandedType)) {\n                        const classType = unexpandedType.classType;\n                        const aliasType = classType.details.aliasClass || classType;\n\n                        if (ClassType.isBuiltIn(aliasType, 'dict')) {\n                            const typeArgs = classType.typeArguments;\n                            if (typeArgs && typeArgs.length >= 2) {\n                                keyTypes.push(typeArgs[0]);\n                                valueTypes.push(typeArgs[1]);\n                                addUnknown = false;\n                            }\n                        }\n                    }\n                }\n            } else if (entryNode.nodeType === ParseNodeType.ListComprehension) {\n                const dictEntryType = getElementTypeFromListComprehension(entryNode);\n\n                // The result should be a Tuple\n                if (isObject(dictEntryType)) {\n                    const classType = dictEntryType.classType;\n                    if (isTupleClass(classType)) {\n                        const typeArgs = classType.typeArguments;\n                        if (typeArgs && typeArgs.length === 2) {\n                            keyTypes.push(typeArgs[0]);\n                            valueTypes.push(typeArgs[1]);\n                            addUnknown = false;\n                        }\n                    }\n                }\n            }\n\n            if (addUnknown) {\n                keyTypes.push(UnknownType.create());\n                valueTypes.push(UnknownType.create());\n            }\n        });\n\n        // If there is an expected type, see if we can match any parts of it.\n        if (expectedType) {\n            const narrowedExpectedType = doForSubtypes(expectedType, (subtype) => {\n                if (!isObject(subtype)) {\n                    return undefined;\n                }\n\n                if (\n                    ClassType.isTypedDictClass(subtype.classType) &&\n                    canAssignToTypedDict(subtype.classType, keyTypes, valueTypes, diagAddendum)\n                ) {\n                    return subtype;\n                }\n\n                const classAlias = subtype.classType.details.aliasClass || subtype.classType;\n                if (ClassType.isBuiltIn(classAlias, 'dict') && subtype.classType.typeArguments) {\n                    const typeArg0 = transformPossibleRecursiveTypeAlias(subtype.classType.typeArguments[0]);\n                    const typeArg1 = transformPossibleRecursiveTypeAlias(subtype.classType.typeArguments[1]);\n                    const typeVarMap = new TypeVarMap();\n\n                    for (const keyType of keyTypes) {\n                        if (!canAssignType(typeArg0, keyType, new DiagnosticAddendum(), typeVarMap)) {\n                            return undefined;\n                        }\n                    }\n\n                    for (const valueType of valueTypes) {\n                        if (!canAssignType(typeArg1, valueType, new DiagnosticAddendum(), typeVarMap)) {\n                            return undefined;\n                        }\n                    }\n\n                    return specializeType(subtype, typeVarMap);\n                }\n\n                return undefined;\n            });\n\n            if (!isNever(narrowedExpectedType)) {\n                return { type: narrowedExpectedType, node };\n            }\n        }\n\n        // Strip any literal values.\n        keyTypes = keyTypes.map((t) => stripLiteralValue(t));\n        valueTypes = valueTypes.map((t) => stripLiteralValue(t));\n\n        keyType = keyTypes.length > 0 ? combineTypes(keyTypes) : AnyType.create();\n\n        // If the value type differs and we're not using \"strict inference mode\",\n        // we need to back off because we can't properly represent the mappings\n        // between different keys and associated value types. If all the values\n        // are the same type, we'll assume that all values in this dictionary should\n        // be the same.\n        if (valueTypes.length > 0) {\n            if (getFileInfo(node).diagnosticRuleSet.strictDictionaryInference) {\n                valueType = combineTypes(valueTypes);\n            } else {\n                valueType = areTypesSame(valueTypes) ? valueTypes[0] : UnknownType.create();\n            }\n        } else {\n            valueType = AnyType.create();\n        }\n\n        // If we weren't provided an expected type, strip away any\n        // literals from the key and value.\n        if (!expectedType) {\n            keyType = stripLiteralValue(keyType);\n            valueType = stripLiteralValue(valueType);\n        }\n\n        const type = getBuiltInObject(node, 'Dict', [keyType, valueType]);\n\n        return { type, node, expectedTypeDiagAddendum: !diagAddendum.isEmpty() ? diagAddendum : undefined };\n    }\n\n    function getTypeFromList(node: ListNode, expectedType: Type | undefined): TypeResult {\n        // Define a local helper function that determines whether a\n        // type is a list and returns the list element type if it is.\n        const getListTypeArg = (potentialList: Type) => {\n            return doForSubtypes(potentialList, (subtype) => {\n                subtype = transformPossibleRecursiveTypeAlias(subtype);\n                if (!isObject(subtype)) {\n                    return undefined;\n                }\n\n                const classAlias = subtype.classType.details.aliasClass || subtype.classType;\n                if (!ClassType.isBuiltIn(classAlias, 'list') || !subtype.classType.typeArguments) {\n                    return undefined;\n                }\n\n                return subtype.classType.typeArguments[0];\n            });\n        };\n\n        const expectedEntryType = expectedType ? getListTypeArg(expectedType) : undefined;\n\n        let entryTypes = node.entries.map((entry) => {\n            if (entry.nodeType === ParseNodeType.ListComprehension) {\n                return getElementTypeFromListComprehension(entry, expectedEntryType);\n            }\n            return getTypeOfExpression(entry, expectedEntryType).type;\n        });\n\n        // If there is an expected type, see if we can match it.\n        if (expectedType && entryTypes.length > 0) {\n            const narrowedExpectedType = doForSubtypes(expectedType, (subtype) => {\n                const expectedListElementType = getListTypeArg(subtype);\n                if (expectedListElementType) {\n                    const typeVarMap = new TypeVarMap();\n\n                    for (const entryType of entryTypes) {\n                        let assignedNonLiteral = false;\n\n                        // If the entry type is a literal value, try to assign a non-literal\n                        // type first to avoid over-narrowing. This may not work if the expected\n                        // element type is a literal or a TypeVar bound to a literal.\n                        const nonLiteralEntryType = stripLiteralValue(entryType);\n                        if (entryType !== nonLiteralEntryType) {\n                            if (\n                                canAssignType(\n                                    expectedListElementType,\n                                    nonLiteralEntryType,\n                                    new DiagnosticAddendum(),\n                                    typeVarMap\n                                )\n                            ) {\n                                assignedNonLiteral = true;\n                            }\n                        }\n\n                        if (!assignedNonLiteral) {\n                            if (\n                                !canAssignType(expectedListElementType, entryType, new DiagnosticAddendum(), typeVarMap)\n                            ) {\n                                return undefined;\n                            }\n                        }\n                    }\n\n                    return specializeType(subtype, typeVarMap);\n                }\n\n                return undefined;\n            });\n\n            if (!isNever(narrowedExpectedType)) {\n                return { type: narrowedExpectedType, node };\n            }\n        }\n\n        entryTypes = entryTypes.map((t) => stripLiteralValue(t));\n\n        let inferredEntryType: Type = AnyType.create();\n        if (entryTypes.length > 0) {\n            // If there was an expected type or we're using strict list inference,\n            // combine the types into a union.\n            if (expectedType || getFileInfo(node).diagnosticRuleSet.strictListInference) {\n                inferredEntryType = combineTypes(entryTypes);\n            } else {\n                // Is the list homogeneous? If so, use stricter rules. Otherwise relax the rules.\n                inferredEntryType = areTypesSame(entryTypes) ? entryTypes[0] : UnknownType.create();\n            }\n        }\n\n        // If we weren't provided an expected type, strip away any\n        // literals from the list. The user is probably not expecting\n        // ['a'] to be interpreted as type List[Literal['a']] but\n        // instead List[str].\n        if (!expectedType) {\n            inferredEntryType = stripLiteralValue(inferredEntryType);\n        }\n\n        const type = getBuiltInObject(node, 'List', [inferredEntryType]);\n\n        return { type, node };\n    }\n\n    function getTypeFromTernary(node: TernaryNode, flags: EvaluatorFlags, expectedType: Type | undefined): TypeResult {\n        getTypeOfExpression(node.testExpression);\n\n        const ifType = getTypeOfExpression(node.ifExpression, expectedType, flags);\n        const elseType = getTypeOfExpression(node.elseExpression, expectedType, flags);\n\n        const type = combineTypes([ifType.type, elseType.type]);\n        return { type, node };\n    }\n\n    function getTypeFromYield(node: YieldNode): TypeResult {\n        let sentType: Type | undefined;\n\n        const enclosingFunction = ParseTreeUtils.getEnclosingFunction(node);\n        if (enclosingFunction) {\n            const functionTypeInfo = getTypeOfFunction(enclosingFunction);\n            if (functionTypeInfo) {\n                sentType = getDeclaredGeneratorSendType(functionTypeInfo.functionType);\n            }\n        }\n\n        if (!sentType) {\n            sentType = UnknownType.create();\n        }\n\n        if (node.expression) {\n            getTypeOfExpression(node.expression, sentType);\n        }\n\n        return { type: sentType, node };\n    }\n\n    function getTypeFromYieldFrom(node: YieldFromNode): TypeResult {\n        let sentType: Type | undefined;\n\n        const enclosingFunction = ParseTreeUtils.getEnclosingFunction(node);\n        if (enclosingFunction) {\n            const functionTypeInfo = getTypeOfFunction(enclosingFunction);\n            if (functionTypeInfo) {\n                sentType = getDeclaredGeneratorSendType(functionTypeInfo.functionType);\n            }\n        }\n\n        if (!sentType) {\n            sentType = UnknownType.create();\n        }\n\n        if (node.expression) {\n            getTypeOfExpression(node.expression, sentType);\n        }\n\n        return { type: sentType, node };\n    }\n\n    function getTypeFromLambda(node: LambdaNode, expectedType: Type | undefined): TypeResult {\n        const functionType = FunctionType.createInstance('', '', FunctionTypeFlags.None);\n\n        // Pre-cache the newly-created function type.\n        writeTypeCache(node, functionType);\n\n        let expectedFunctionType: FunctionType | undefined;\n        if (expectedType) {\n            if (expectedType.category === TypeCategory.Function) {\n                expectedFunctionType = expectedType;\n            } else if (expectedType.category === TypeCategory.Union) {\n                // It's not clear what we should do with a union type. For now,\n                // simply use the first function in the union.\n                expectedFunctionType = expectedType.subtypes.find(\n                    (t) => t.category === TypeCategory.Function\n                ) as FunctionType;\n            }\n        }\n\n        node.parameters.forEach((param, index) => {\n            let paramType: Type = UnknownType.create();\n            if (expectedFunctionType && index < expectedFunctionType.details.parameters.length) {\n                paramType = FunctionType.getEffectiveParameterType(expectedFunctionType, index);\n                paramType = specializeType(paramType, /* typeVarMap */ undefined, /* makeConcrete */ true);\n            }\n\n            if (param.name) {\n                writeTypeCache(param.name, paramType);\n            }\n\n            if (param.defaultValue) {\n                // Evaluate the default value if it's present.\n                getTypeOfExpression(param.defaultValue, undefined, EvaluatorFlags.ConvertEllipsisToAny);\n            }\n\n            const functionParam: FunctionParameter = {\n                category: param.category,\n                name: param.name ? param.name.value : undefined,\n                hasDefault: !!param.defaultValue,\n                type: paramType,\n            };\n            FunctionType.addParameter(functionType, functionParam);\n        });\n\n        const expectedReturnType = expectedFunctionType\n            ? getFunctionEffectiveReturnType(expectedFunctionType)\n            : undefined;\n        functionType.inferredReturnType = getTypeOfExpression(node.expression, expectedReturnType).type;\n\n        return { type: functionType, node };\n    }\n\n    function getTypeFromListComprehension(node: ListComprehensionNode): TypeResult {\n        const elementType = getElementTypeFromListComprehension(node);\n\n        const isAsync = node.comprehensions.some((comp) => {\n            return comp.nodeType === ParseNodeType.ListComprehensionFor && comp.isAsync;\n        });\n        let type: Type = UnknownType.create();\n        const builtInIteratorType = getTypingType(node, isAsync ? 'AsyncGenerator' : 'Generator');\n\n        if (builtInIteratorType && isClass(builtInIteratorType)) {\n            type = ObjectType.create(\n                ClassType.cloneForSpecialization(builtInIteratorType, [elementType], /* isTypeArgumentExplicit */ false)\n            );\n        }\n\n        return { type, node };\n    }\n\n    function reportPossibleUnknownAssignment(\n        diagLevel: DiagnosticLevel,\n        rule: string,\n        target: NameNode,\n        type: Type,\n        errorNode: ExpressionNode\n    ) {\n        // Don't bother if the feature is disabled.\n        if (diagLevel === 'none') {\n            return;\n        }\n\n        const nameValue = target.value;\n\n        // Sometimes variables contain an \"unbound\" type if they're\n        // assigned only within conditional statements. Remove this\n        // to avoid confusion.\n        const simplifiedType = removeUnboundFromUnion(type);\n\n        if (isUnknown(simplifiedType)) {\n            addDiagnostic(diagLevel, rule, Localizer.Diagnostic.typeUnknown().format({ name: nameValue }), errorNode);\n        } else if (isPartlyUnknown(simplifiedType)) {\n            const diagAddendum = new DiagnosticAddendum();\n            diagAddendum.addMessage(\n                Localizer.DiagnosticAddendum.typeOfSymbol().format({\n                    name: nameValue,\n                    type: printType(simplifiedType, /* expandTypeAlias */ true),\n                })\n            );\n            addDiagnostic(\n                diagLevel,\n                rule,\n                Localizer.Diagnostic.typePartiallyUnknown().format({ name: nameValue }) + diagAddendum.getString(),\n                errorNode\n            );\n        }\n    }\n\n    // Returns the type of one entry returned by the list comprehension,\n    // as opposed to the entire list.\n    function getElementTypeFromListComprehension(node: ListComprehensionNode, expectedElementType?: Type): Type {\n        // \"Execute\" the list comprehensions from start to finish.\n        for (const comprehension of node.comprehensions) {\n            if (comprehension.nodeType === ParseNodeType.ListComprehensionFor) {\n                const iterableType = stripLiteralValue(getTypeOfExpression(comprehension.iterableExpression).type);\n                const itemType = getTypeFromIterable(\n                    iterableType,\n                    !!comprehension.isAsync,\n                    comprehension.iterableExpression,\n                    /* supportGetItem */ false\n                );\n\n                const targetExpr = comprehension.targetExpression;\n                assignTypeToExpression(targetExpr, itemType, comprehension.iterableExpression);\n            } else {\n                assert(comprehension.nodeType === ParseNodeType.ListComprehensionIf);\n\n                // Evaluate the test expression to validate it and mark symbols\n                // as referenced. Don't bother doing this if we're in speculative\n                // mode because it doesn't affect the element type.\n                if (!isSpeculativeMode(comprehension.testExpression)) {\n                    getTypeOfExpression(comprehension.testExpression);\n                }\n            }\n        }\n\n        let type: Type = UnknownType.create();\n        if (node.expression.nodeType === ParseNodeType.DictionaryKeyEntry) {\n            // Create a tuple with the key/value types.\n            const keyType = stripLiteralValue(getTypeOfExpression(node.expression.keyExpression).type);\n            const valueType = stripLiteralValue(getTypeOfExpression(node.expression.valueExpression).type);\n\n            type = getBuiltInType(node, 'Tuple');\n            if (isClass(type)) {\n                type = convertToInstance(\n                    cloneTupleForSpecialization(type, [keyType, valueType], /* isTypeArgumentExplicit */ true)\n                );\n            }\n        } else if (node.expression.nodeType === ParseNodeType.DictionaryExpandEntry) {\n            // The parser should have reported an error in this case because it's not allowed.\n            getTypeOfExpression(node.expression.expandExpression);\n        } else if (isExpressionNode(node)) {\n            type = stripLiteralValue(getTypeOfExpression(node.expression as ExpressionNode, expectedElementType).type);\n        }\n\n        return type;\n    }\n\n    function getTypeFromSlice(node: SliceNode): TypeResult {\n        // Evaluate the expressions to report errors and record symbol references.\n        if (node.startValue) {\n            getTypeOfExpression(node.startValue);\n        }\n\n        if (node.endValue) {\n            getTypeOfExpression(node.endValue);\n        }\n\n        if (node.stepValue) {\n            getTypeOfExpression(node.stepValue);\n        }\n\n        return { type: getBuiltInObject(node, 'slice'), node };\n    }\n\n    // Converts the type parameters for a Callable type. It should\n    // have zero to two parameters. The first parameter, if present, should be\n    // either an ellipsis or a list of parameter types. The second parameter, if\n    // present, should specify the return type.\n    function createCallableType(typeArgs?: TypeResult[]): FunctionType {\n        const functionType = FunctionType.createInstantiable('', '', FunctionTypeFlags.None);\n        functionType.details.declaredReturnType = AnyType.create();\n\n        if (typeArgs && typeArgs.length > 0) {\n            if (typeArgs[0].typeList) {\n                typeArgs[0].typeList.forEach((entry, index) => {\n                    if (isEllipsisType(entry.type)) {\n                        addError(Localizer.Diagnostic.ellipsisContext(), entry.node);\n                    } else if (isModule(entry.type)) {\n                        addError(Localizer.Diagnostic.moduleContext(), entry.node);\n                    } else if (isParamSpecType(entry.type)) {\n                        addError(Localizer.Diagnostic.paramSpecContext(), entry.node);\n                    }\n\n                    FunctionType.addParameter(functionType, {\n                        category: ParameterCategory.Simple,\n                        name: `p${index.toString()}`,\n                        isNameSynthesized: true,\n                        type: convertToInstance(entry.type),\n                        hasDeclaredType: true,\n                    });\n                });\n            } else if (isEllipsisType(typeArgs[0].type)) {\n                FunctionType.addDefaultParameters(functionType);\n                functionType.details.flags |= FunctionTypeFlags.SkipParamCompatibilityCheck;\n            } else if (isParamSpecType(typeArgs[0].type)) {\n                functionType.details.paramSpec = typeArgs[0].type as TypeVarType;\n            } else {\n                if (isClass(typeArgs[0].type) && ClassType.isBuiltIn(typeArgs[0].type, 'Concatenate')) {\n                    const concatTypeArgs = typeArgs[0].type.typeArguments;\n                    if (concatTypeArgs && concatTypeArgs.length > 0) {\n                        concatTypeArgs.forEach((typeArg, index) => {\n                            if (index === concatTypeArgs.length - 1) {\n                                if (isParamSpecType(typeArg)) {\n                                    functionType.details.paramSpec = typeArg as TypeVarType;\n                                }\n                            } else {\n                                FunctionType.addParameter(functionType, {\n                                    category: ParameterCategory.Simple,\n                                    name: `__p${index}`,\n                                    isNameSynthesized: true,\n                                    hasDeclaredType: true,\n                                    type: typeArg,\n                                });\n                            }\n                        });\n                    }\n                } else {\n                    addError(Localizer.Diagnostic.callableFirstArg(), typeArgs[0].node);\n                }\n            }\n        } else {\n            FunctionType.addDefaultParameters(functionType, /* useUnknown */ true);\n            functionType.details.flags |= FunctionTypeFlags.SkipParamCompatibilityCheck;\n        }\n\n        if (typeArgs && typeArgs.length > 1) {\n            if (isEllipsisType(typeArgs[1].type)) {\n                addError(Localizer.Diagnostic.ellipsisContext(), typeArgs[1].node);\n            } else if (isModule(typeArgs[1].type)) {\n                addError(Localizer.Diagnostic.moduleContext(), typeArgs[1].node);\n            } else if (isParamSpecType(typeArgs[1].type)) {\n                addError(Localizer.Diagnostic.paramSpecContext(), typeArgs[1].node);\n            }\n            functionType.details.declaredReturnType = convertToInstance(typeArgs[1].type);\n        } else {\n            functionType.details.declaredReturnType = UnknownType.create();\n        }\n\n        if (typeArgs && typeArgs.length > 2) {\n            addError(Localizer.Diagnostic.callableExtraArgs(), typeArgs[2].node);\n        }\n\n        return functionType;\n    }\n\n    // Creates an Optional[X, Y, Z] type.\n    function createOptionalType(errorNode: ParseNode, typeArgs?: TypeResult[]): Type {\n        if (!typeArgs || typeArgs.length !== 1) {\n            addError(Localizer.Diagnostic.optionalExtraArgs(), errorNode);\n            return UnknownType.create();\n        }\n\n        if (isEllipsisType(typeArgs[0].type)) {\n            addError(Localizer.Diagnostic.ellipsisContext(), typeArgs[0].node);\n        } else if (isModule(typeArgs[0].type)) {\n            addError(Localizer.Diagnostic.moduleContext(), typeArgs[0].node);\n        } else if (isParamSpecType(typeArgs[0].type)) {\n            addError(Localizer.Diagnostic.paramSpecContext(), typeArgs[0].node);\n        } else if (!TypeBase.isInstantiable(typeArgs[0].type)) {\n            addExpectedClassDiagnostic(typeArgs[0].type, typeArgs[0].node);\n        }\n\n        return combineTypes([typeArgs[0].type, NoneType.createType()]);\n    }\n\n    function cloneBuiltinObjectWithLiteral(node: ParseNode, builtInName: string, value: LiteralValue): Type {\n        const type = getBuiltInObject(node, builtInName);\n        if (isObject(type)) {\n            return ObjectType.create(ClassType.cloneWithLiteral(type.classType, value));\n        }\n\n        return UnknownType.create();\n    }\n\n    function cloneBuiltinClassWithLiteral(node: ParseNode, builtInName: string, value: LiteralValue): Type {\n        const type = getBuiltInObject(node, builtInName);\n        if (isObject(type)) {\n            return ClassType.cloneWithLiteral(type.classType, value);\n        }\n\n        return UnknownType.create();\n    }\n\n    // Creates a type that represents a Literal. This is not an officially-supported\n    // feature of Python but is instead a mypy extension described here:\n    // https://mypy.readthedocs.io/en/latest/literal_types.html\n    function createLiteralType(node: IndexNode): Type {\n        if (node.items.items.length === 0) {\n            addError(Localizer.Diagnostic.literalEmptyArgs(), node.baseExpression);\n            return UnknownType.create();\n        }\n\n        // As per the specification, we support None, int, bool, str, bytes literals\n        // plus enum values.\n        const literalTypes: Type[] = [];\n\n        for (const item of node.items.items) {\n            let type: Type | undefined;\n\n            if (item.nodeType === ParseNodeType.StringList) {\n                const isBytes = (item.strings[0].token.flags & StringTokenFlags.Bytes) !== 0;\n                const value = item.strings.map((s) => s.value).join('');\n                if (isBytes) {\n                    type = cloneBuiltinClassWithLiteral(node, 'bytes', value);\n                } else {\n                    type = cloneBuiltinClassWithLiteral(node, 'str', value);\n                }\n            } else if (item.nodeType === ParseNodeType.Number) {\n                if (!item.isImaginary && item.isInteger) {\n                    type = cloneBuiltinClassWithLiteral(node, 'int', item.value);\n                }\n            } else if (item.nodeType === ParseNodeType.Constant) {\n                if (item.constType === KeywordType.True) {\n                    type = cloneBuiltinClassWithLiteral(node, 'bool', true);\n                } else if (item.constType === KeywordType.False) {\n                    type = cloneBuiltinClassWithLiteral(node, 'bool', false);\n                } else if (item.constType === KeywordType.None) {\n                    type = NoneType.createType();\n                }\n            } else if (item.nodeType === ParseNodeType.UnaryOperation && item.operator === OperatorType.Subtract) {\n                if (item.expression.nodeType === ParseNodeType.Number) {\n                    if (!item.expression.isImaginary && item.expression.isInteger) {\n                        type = cloneBuiltinClassWithLiteral(node, 'int', -item.expression.value);\n                    }\n                }\n            }\n\n            if (!type) {\n                const exprType = getTypeOfExpression(item);\n\n                // Is this an enum type?\n                if (\n                    isObject(exprType.type) &&\n                    ClassType.isEnumClass(exprType.type.classType) &&\n                    exprType.type.classType.literalValue !== undefined\n                ) {\n                    type = exprType.type.classType;\n                } else {\n                    // Is this a type alias to an existing literal type?\n                    let isLiteralType = true;\n\n                    doForSubtypes(exprType.type, (subtype) => {\n                        if (!isClass(subtype) || subtype.literalValue === undefined) {\n                            isLiteralType = false;\n                        }\n                        return undefined;\n                    });\n\n                    if (isLiteralType) {\n                        type = exprType.type;\n                    }\n                }\n            }\n\n            if (!type) {\n                addError(Localizer.Diagnostic.literalUnsupportedType(), item);\n                type = UnknownType.create();\n            }\n\n            literalTypes.push(type);\n        }\n\n        return combineTypes(literalTypes);\n    }\n\n    // Creates a ClassVar type.\n    function createClassVarType(errorNode: ParseNode, typeArgs: TypeResult[] | undefined): Type {\n        if (!typeArgs || typeArgs.length === 0) {\n            addError(Localizer.Diagnostic.classVarFirstArgMissing(), errorNode);\n            return UnknownType.create();\n        } else if (typeArgs.length > 1) {\n            addError(Localizer.Diagnostic.classVarTooManyArgs(), typeArgs[1].node);\n            return UnknownType.create();\n        }\n\n        let type = typeArgs[0].type;\n\n        if (requiresSpecialization(type)) {\n            // A ClassVar should not allow generic types, but the typeshed\n            // stubs use this in a few cases. For now, just specialize\n            // it in a general way.\n            type = specializeType(type, /* typeVarMap */ undefined);\n        }\n\n        return type;\n    }\n\n    // Creates a \"Final\" type.\n    function createFinalType(errorNode: ParseNode, typeArgs: TypeResult[] | undefined, flags: EvaluatorFlags): Type {\n        if (flags & EvaluatorFlags.FinalDisallowed) {\n            addError(Localizer.Diagnostic.finalContext(), errorNode);\n            return AnyType.create();\n        }\n\n        if (!typeArgs || typeArgs.length === 0) {\n            return AnyType.create();\n        }\n\n        if (typeArgs.length > 1) {\n            addError(Localizer.Diagnostic.finalTooManyArgs(), errorNode);\n        }\n\n        return typeArgs[0].type;\n    }\n\n    function createConcatenateType(\n        errorNode: ParseNode,\n        classType: ClassType,\n        typeArgs: TypeResult[] | undefined\n    ): Type {\n        if (!typeArgs || typeArgs.length === 0) {\n            addError(Localizer.Diagnostic.concatenateTypeArgsMissing(), errorNode);\n        } else {\n            typeArgs.forEach((typeArg, index) => {\n                if (index === typeArgs.length - 1) {\n                    if (!isParamSpecType(typeArg.type)) {\n                        addError(Localizer.Diagnostic.concatenateParamSpecMissing(), typeArg.node);\n                    }\n                } else {\n                    if (isParamSpecType(typeArg.type)) {\n                        addError(Localizer.Diagnostic.paramSpecContext(), typeArg.node);\n                    }\n                }\n            });\n        }\n\n        return createSpecialType(classType, typeArgs, /* paramLimit */ undefined, /* allowParamSpec */ true);\n    }\n\n    function createAnnotatedType(errorNode: ParseNode, typeArgs: TypeResult[] | undefined): Type {\n        if (!typeArgs || typeArgs.length < 1) {\n            addError(Localizer.Diagnostic.annotatedTypeArgMissing(), errorNode);\n            return AnyType.create();\n        }\n\n        if (isEllipsisType(typeArgs[0].type)) {\n            addError(Localizer.Diagnostic.ellipsisContext(), typeArgs[0].node);\n        } else if (isModule(typeArgs[0].type)) {\n            addError(Localizer.Diagnostic.moduleContext(), typeArgs[0].node);\n        } else if (isParamSpecType(typeArgs[0].type)) {\n            addError(Localizer.Diagnostic.paramSpecContext(), typeArgs[1].node);\n        }\n\n        return typeArgs[0].type;\n    }\n\n    // Creates one of several \"special\" types that are defined in typing.pyi\n    // but not declared in their entirety. This includes the likes of \"Tuple\",\n    // \"Dict\", etc.\n    function createSpecialType(\n        classType: ClassType,\n        typeArgs: TypeResult[] | undefined,\n        paramLimit?: number,\n        allowParamSpec = false\n    ): Type {\n        const isTuple = isTupleClass(classType);\n\n        if (typeArgs) {\n            // Verify that we didn't receive any inappropriate ellipses or modules.\n            typeArgs.forEach((typeArg, index) => {\n                if (isEllipsisType(typeArg.type)) {\n                    if (!isTuple) {\n                        addError(Localizer.Diagnostic.ellipsisContext(), typeArg.node);\n                    } else if (typeArgs!.length !== 2 || index !== 1) {\n                        addError(Localizer.Diagnostic.ellipsisSecondArg(), typeArg.node);\n                    }\n                } else if (isModule(typeArg.type)) {\n                    addError(Localizer.Diagnostic.moduleContext(), typeArg.node);\n                } else if (!allowParamSpec && isParamSpecType(typeArg.type)) {\n                    addError(Localizer.Diagnostic.paramSpecContext(), typeArg.node);\n                }\n            });\n\n            // Handle Tuple[()] as a special case, as defined in PEP 483.\n            if (isTuple) {\n                if (\n                    typeArgs.length === 1 &&\n                    isObject(typeArgs[0].type) &&\n                    isTupleClass(typeArgs[0].type.classType) &&\n                    typeArgs[0].type.classType.typeArguments &&\n                    typeArgs[0].type.classType.typeArguments.length === 0\n                ) {\n                    typeArgs = [];\n                }\n            }\n        }\n\n        let typeArgTypes = typeArgs ? typeArgs.map((t) => convertToInstance(t.type)) : [];\n\n        // Make sure the argument list count is correct.\n        if (paramLimit !== undefined) {\n            if (typeArgs && typeArgTypes.length > paramLimit) {\n                addError(\n                    Localizer.Diagnostic.typeArgsTooMany().format({\n                        name: classType.details.name,\n                        expected: paramLimit,\n                        received: typeArgTypes.length,\n                    }),\n                    typeArgs[paramLimit].node\n                );\n                typeArgTypes = typeArgTypes.slice(0, paramLimit);\n            } else if (typeArgTypes.length < paramLimit) {\n                // Fill up the remainder of the slots with unknown types.\n                while (typeArgTypes.length < paramLimit) {\n                    typeArgTypes.push(UnknownType.create());\n                }\n            }\n        }\n\n        // Handle tuple as a special case.\n        if (isTuple) {\n            // If no type args are provided and it's a tuple, default to [Any, ...].\n            if (!typeArgs) {\n                typeArgTypes.push(AnyType.create(false));\n                typeArgTypes.push(AnyType.create(true));\n            }\n\n            return cloneTupleForSpecialization(classType, typeArgTypes, typeArgs !== undefined);\n        }\n\n        return ClassType.cloneForSpecialization(classType, typeArgTypes, typeArgs !== undefined);\n    }\n\n    // Unpacks the index expression for a \"Union[X, Y, Z]\" type annotation.\n    function createUnionType(typeArgs?: TypeResult[]): Type {\n        const types: Type[] = [];\n\n        if (typeArgs) {\n            for (const typeArg of typeArgs) {\n                types.push(typeArg.type);\n\n                // Verify that we didn't receive any inappropriate ellipses.\n                if (isEllipsisType(typeArg.type)) {\n                    addError(Localizer.Diagnostic.ellipsisContext(), typeArg.node);\n                } else if (isModule(typeArg.type)) {\n                    addError(Localizer.Diagnostic.moduleContext(), typeArg.node);\n                } else if (isParamSpecType(typeArg.type)) {\n                    addError(Localizer.Diagnostic.paramSpecContext(), typeArg.node);\n                } else if (!TypeBase.isInstantiable(typeArg.type)) {\n                    addExpectedClassDiagnostic(typeArg.type, typeArg.node);\n                }\n            }\n        }\n\n        if (types.length > 0) {\n            return combineTypes(types);\n        }\n\n        return NeverType.create();\n    }\n\n    // Creates a type that represents \"Generic[T1, T2, ...]\", used in the\n    // definition of a generic class.\n    function createGenericType(errorNode: ParseNode, classType: ClassType, typeArgs?: TypeResult[]): Type {\n        // Make sure there's at least one type arg.\n        if (!typeArgs || typeArgs.length === 0) {\n            addError(Localizer.Diagnostic.genericTypeArgMissing(), errorNode);\n        }\n\n        // Make sure that all of the type args are typeVars and are unique.\n        const uniqueTypeVars: TypeVarType[] = [];\n        if (typeArgs) {\n            typeArgs.forEach((typeArg) => {\n                if (!isTypeVar(typeArg.type)) {\n                    addError(Localizer.Diagnostic.genericTypeArgTypeVar(), typeArg.node);\n                } else {\n                    for (const typeVar of uniqueTypeVars) {\n                        if (typeVar === typeArg.type) {\n                            addError(Localizer.Diagnostic.genericTypeArgUnique(), typeArg.node);\n                            break;\n                        }\n                    }\n\n                    uniqueTypeVars.push(typeArg.type);\n                }\n            });\n        }\n\n        return createSpecialType(classType, typeArgs, /* paramLimit */ undefined, /* allowParamSpec */ true);\n    }\n\n    function transformTypeForPossibleEnumClass(node: NameNode, typeOfExpr: Type): Type {\n        // If the node is within a class that derives from the metaclass\n        // \"EnumMeta\", we need to treat assignments differently.\n        const enclosingClassNode = ParseTreeUtils.getEnclosingClass(node, true);\n        if (enclosingClassNode) {\n            const enumClassInfo = getTypeOfClass(enclosingClassNode);\n\n            if (enumClassInfo && ClassType.isEnumClass(enumClassInfo.classType)) {\n                if (ClassType.isBuiltIn(enumClassInfo.classType)) {\n                    // Handle several built-in classes specially. We don't\n                    // want to interpret their class variables as enumerations.\n                    const className = enumClassInfo.classType.details.name;\n                    const builtInEnumClasses = ['Enum', 'IntEnum', 'Flag', 'IntFlag'];\n                    if (builtInEnumClasses.find((c) => c === className)) {\n                        return typeOfExpr;\n                    }\n                }\n\n                return ObjectType.create(\n                    ClassType.cloneWithLiteral(\n                        enumClassInfo.classType,\n                        new EnumLiteral(enumClassInfo.classType.details.name, node.value)\n                    )\n                );\n            }\n        }\n\n        return typeOfExpr;\n    }\n\n    function transformTypeForTypeAlias(type: Type, name: NameNode): Type {\n        if (!TypeBase.isInstantiable(type)) {\n            return type;\n        }\n\n        // If this is a recursive type alias that hasn't yet been fully resolved\n        // (i.e. there is no boundType associated with it), don't apply the transform.\n        if (isTypeVar(type) && type.details.recursiveTypeAliasName && !type.details.boundType) {\n            return type;\n        }\n\n        // Determine if there are any generic type parameters associated\n        // with this type alias.\n        let typeParameters: TypeVarType[] = [];\n\n        // Skip this for a simple TypeVar (one that's not part of a union).\n        if (!isTypeVar(type)) {\n            doForSubtypes(type, (subtype) => {\n                addTypeVarsToListIfUnique(typeParameters, getTypeVarArgumentsRecursive(subtype));\n                return undefined;\n            });\n        }\n\n        // Don't include any synthesized type variables.\n        typeParameters = typeParameters.filter((typeVar) => !typeVar.details.isSynthesized);\n\n        return TypeBase.cloneForTypeAlias(type, name.value, typeParameters.length > 0 ? typeParameters : undefined);\n    }\n\n    function createSpecialBuiltInClass(node: ParseNode, assignedName: string, aliasMapEntry: AliasMapEntry): ClassType {\n        const fileInfo = getFileInfo(node);\n        const specialClassType = ClassType.create(\n            assignedName,\n            getClassFullName(node, fileInfo.moduleName, assignedName),\n            fileInfo.moduleName,\n            ClassTypeFlags.BuiltInClass | ClassTypeFlags.SpecialBuiltIn,\n            node.id,\n            /* declaredMetaclass */ undefined,\n            /* effectiveMetaclass */ undefined\n        );\n\n        if (fileInfo.isTypingExtensionsStubFile) {\n            specialClassType.details.flags |= ClassTypeFlags.TypingExtensionClass;\n        }\n\n        const baseClassName = aliasMapEntry.alias ? aliasMapEntry.alias : 'object';\n\n        let aliasClass: Type | undefined;\n        if (aliasMapEntry.module === 'builtins') {\n            aliasClass = getBuiltInType(node, baseClassName);\n        } else if (aliasMapEntry.module === 'collections') {\n            // The typing.pyi file imports collections.\n            if (fileInfo.collectionsModulePath) {\n                const lookupResult = importLookup(fileInfo.collectionsModulePath);\n                if (lookupResult) {\n                    const symbol = lookupResult.symbolTable.get(baseClassName);\n                    if (symbol) {\n                        aliasClass = getEffectiveTypeOfSymbol(symbol);\n                    }\n                }\n            }\n        } else if (aliasMapEntry.module === 'self') {\n            const symbolWithScope = lookUpSymbolRecursive(node, baseClassName, /* honorCodeFlow */ false);\n            if (symbolWithScope) {\n                aliasClass = getEffectiveTypeOfSymbol(symbolWithScope.symbol);\n            }\n        }\n\n        if (aliasClass && isClass(aliasClass)) {\n            specialClassType.details.baseClasses.push(aliasClass);\n\n            if (aliasMapEntry.alias) {\n                specialClassType.details.aliasClass = aliasClass;\n            }\n            specialClassType.details.effectiveMetaclass = aliasClass.details.effectiveMetaclass;\n        } else {\n            specialClassType.details.baseClasses.push(UnknownType.create());\n            specialClassType.details.effectiveMetaclass = UnknownType.create();\n        }\n\n        computeMroLinearization(specialClassType);\n\n        return specialClassType;\n    }\n\n    // Handles some special-case type annotations that are found\n    // within the typings.pyi file.\n    function handleTypingStubTypeAnnotation(node: ExpressionNode): ClassType | undefined {\n        if (!node.parent || node.parent.nodeType !== ParseNodeType.TypeAnnotation) {\n            return undefined;\n        }\n\n        if (node.parent.valueExpression.nodeType !== ParseNodeType.Name) {\n            return undefined;\n        }\n\n        const nameNode = node.parent.valueExpression;\n        const assignedName = nameNode.value;\n\n        const specialTypes: { [name: string]: AliasMapEntry } = {\n            Tuple: { alias: 'tuple', module: 'builtins' },\n            Generic: { alias: '', module: 'builtins' },\n            Protocol: { alias: '', module: 'builtins' },\n            Callable: { alias: '', module: 'builtins' },\n            Type: { alias: 'type', module: 'builtins' },\n            ClassVar: { alias: '', module: 'builtins' },\n            Final: { alias: '', module: 'builtins' },\n            Literal: { alias: '', module: 'builtins' },\n            TypedDict: { alias: '_TypedDict', module: 'self' },\n            Union: { alias: '', module: 'builtins' },\n            Optional: { alias: '', module: 'builtins' },\n            Annotated: { alias: '', module: 'builtins' },\n            TypeAlias: { alias: '', module: 'builtins' },\n            Concatenate: { alias: '', module: 'builtins' },\n        };\n\n        const aliasMapEntry = specialTypes[assignedName];\n        if (aliasMapEntry) {\n            return createSpecialBuiltInClass(node, assignedName, aliasMapEntry);\n        }\n\n        return undefined;\n    }\n\n    // Handles some special-case assignment statements that are found\n    // within the typings.pyi file.\n    function handleTypingStubAssignment(node: AssignmentNode): Type | undefined {\n        if (node.leftExpression.nodeType !== ParseNodeType.Name) {\n            return undefined;\n        }\n\n        const nameNode = node.leftExpression;\n        const assignedName = nameNode.value;\n\n        if (assignedName === 'Any') {\n            return AnyType.create();\n        }\n\n        const specialTypes: { [name: string]: AliasMapEntry } = {\n            overload: { alias: '', module: 'builtins' },\n            TypeVar: { alias: '', module: 'builtins' },\n            _promote: { alias: '', module: 'builtins' },\n            no_type_check: { alias: '', module: 'builtins' },\n            NoReturn: { alias: '', module: 'builtins' },\n            Counter: { alias: 'Counter', module: 'collections' },\n            List: { alias: 'list', module: 'builtins' },\n            Dict: { alias: 'dict', module: 'builtins' },\n            DefaultDict: { alias: 'defaultdict', module: 'collections' },\n            Set: { alias: 'set', module: 'builtins' },\n            FrozenSet: { alias: 'frozenset', module: 'builtins' },\n            Deque: { alias: 'deque', module: 'collections' },\n            ChainMap: { alias: 'ChainMap', module: 'collections' },\n            OrderedDict: { alias: 'OrderedDict', module: 'collections' },\n        };\n\n        const aliasMapEntry = specialTypes[assignedName];\n        if (aliasMapEntry) {\n            return createSpecialBuiltInClass(node, assignedName, aliasMapEntry);\n        }\n\n        return undefined;\n    }\n\n    function evaluateTypesForAssignmentStatement(node: AssignmentNode): void {\n        const fileInfo = getFileInfo(node);\n\n        // If the entire statement has already been evaluated, don't\n        // re-evaluate it.\n        if (readTypeCache(node)) {\n            return;\n        }\n\n        // Is this type already cached?\n        let rightHandType = readTypeCache(node.rightExpression);\n        let isResolutionCycle = false;\n        let expectedTypeDiagAddendum: DiagnosticAddendum | undefined;\n\n        if (!rightHandType) {\n            // Special-case the typing.pyi file, which contains some special\n            // types that the type analyzer needs to interpret differently.\n            if (fileInfo.isTypingStubFile || fileInfo.isTypingExtensionsStubFile) {\n                rightHandType = handleTypingStubAssignment(node);\n                if (rightHandType) {\n                    writeTypeCache(node.rightExpression, rightHandType);\n                }\n            }\n\n            if (!rightHandType) {\n                // Determine whether there is a declared type.\n                const declaredType = getDeclaredTypeForExpression(node.leftExpression);\n\n                let flags: EvaluatorFlags = EvaluatorFlags.DoNotSpecialize;\n                if (fileInfo.isStubFile) {\n                    // An assignment of ellipsis means \"Any\" within a type stub file.\n                    flags |= EvaluatorFlags.ConvertEllipsisToUnknown;\n                }\n\n                let typeAliasNameNode: NameNode | undefined;\n                if (isDeclaredTypeAlias(node.leftExpression)) {\n                    flags |=\n                        EvaluatorFlags.ExpectingType |\n                        EvaluatorFlags.EvaluateStringLiteralAsType |\n                        EvaluatorFlags.ParamSpecDisallowed;\n\n                    typeAliasNameNode = (node.leftExpression as TypeAnnotationNode).valueExpression as NameNode;\n                } else if (isPossibleImplicitTypeAlias(node.leftExpression)) {\n                    if (node.leftExpression.nodeType === ParseNodeType.Name) {\n                        typeAliasNameNode = node.leftExpression;\n                    }\n                }\n\n                // Synthesize a type variable that represents the type alias while we're\n                // evaluating it. This allows us to handle recursive definitions.\n                let typeAliasTypeVar: TypeVarType | undefined;\n                if (typeAliasNameNode) {\n                    typeAliasTypeVar = TypeVarType.createInstantiable(\n                        `__type_alias_${typeAliasNameNode.value}`,\n                        /* isParamSpec */ false,\n                        /* isSynthesized */ true\n                    );\n                    typeAliasTypeVar.details.recursiveTypeAliasName = typeAliasNameNode.value;\n\n                    // Write the type back to the type cache. It will be replaced below.\n                    writeTypeCache(node, typeAliasTypeVar);\n                    writeTypeCache(node.leftExpression, typeAliasTypeVar);\n                }\n\n                const srcTypeResult = getTypeOfExpression(node.rightExpression, declaredType, flags);\n                let srcType = srcTypeResult.type;\n                expectedTypeDiagAddendum = srcTypeResult.expectedTypeDiagAddendum;\n                if (srcTypeResult.isResolutionCyclical) {\n                    isResolutionCycle = true;\n                }\n\n                // If the RHS is a constant boolean expression, assign it a literal type.\n                const constExprValue = evaluateStaticBoolExpression(\n                    node.rightExpression,\n                    fileInfo.executionEnvironment\n                );\n\n                if (constExprValue !== undefined) {\n                    const boolType = getBuiltInObject(node, 'bool');\n                    if (isObject(boolType)) {\n                        srcType = ObjectType.create(ClassType.cloneWithLiteral(boolType.classType, constExprValue));\n                    }\n                }\n\n                // If there was a declared type, make sure the RHS value is compatible.\n                if (declaredType) {\n                    const diagAddendum = new DiagnosticAddendum();\n                    const typeVarMap = new TypeVarMap();\n                    if (canAssignType(declaredType, srcType, diagAddendum, typeVarMap)) {\n                        // Narrow the resulting type to match the declared type.\n                        srcType = narrowTypeBasedOnAssignment(declaredType, srcType);\n                    }\n                }\n\n                // If this is an enum, transform the type as required.\n                rightHandType = srcType;\n                if (node.leftExpression.nodeType === ParseNodeType.Name && !node.typeAnnotationComment) {\n                    rightHandType = transformTypeForPossibleEnumClass(node.leftExpression, rightHandType);\n                }\n\n                if (typeAliasNameNode) {\n                    // If this is a type alias, record its name based on the assignment target.\n                    rightHandType = transformTypeForTypeAlias(rightHandType, typeAliasNameNode);\n\n                    if (isTypeAliasRecursive(typeAliasTypeVar!, rightHandType)) {\n                        addDiagnostic(\n                            fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                            DiagnosticRule.reportGeneralTypeIssues,\n                            Localizer.Diagnostic.typeAliasIsRecursive().format({ name: typeAliasNameNode.value }),\n                            node.rightExpression\n                        );\n                    }\n\n                    // Set the resulting type to the boundType of the original type alias\n                    // to support recursive type aliases.\n                    typeAliasTypeVar!.details.boundType = rightHandType;\n                }\n            }\n        }\n\n        // Don't write back an unbound type that results from a resolution cycle. We'll\n        // write back the type when the stack unwinds and the type is fully evaluated.\n        if (!isResolutionCycle) {\n            assignTypeToExpression(node.leftExpression, rightHandType, node.rightExpression, expectedTypeDiagAddendum);\n\n            writeTypeCache(node, rightHandType);\n        }\n    }\n\n    function evaluateTypesForAugmentedAssignment(node: AugmentedAssignmentNode): void {\n        if (readTypeCache(node)) {\n            return;\n        }\n\n        const destType = getTypeFromAugmentedAssignment(node, /* expectedType */ undefined);\n        assignTypeToExpression(node.destExpression, destType, node.rightExpression);\n\n        writeTypeCache(node, destType);\n    }\n\n    function getTypeOfClass(node: ClassNode): ClassTypeResult | undefined {\n        // Is this type already cached?\n        const cachedClassType = readTypeCache(node.name);\n\n        if (cachedClassType) {\n            if (!isClass(cachedClassType)) {\n                // This can happen in rare circumstances where the class declaration\n                // is located in an unreachable code block.\n                return undefined;\n            }\n            return { classType: cachedClassType, decoratedType: readTypeCache(node) || UnknownType.create() };\n        }\n\n        // The type wasn't cached, so we need to create a new one.\n        const scope = ScopeUtils.getScopeForNode(node);\n\n        const fileInfo = getFileInfo(node);\n        let classFlags = ClassTypeFlags.None;\n        if (\n            scope?.type === ScopeType.Builtin ||\n            fileInfo.isTypingStubFile ||\n            fileInfo.isTypingExtensionsStubFile ||\n            fileInfo.isBuiltInStubFile\n        ) {\n            classFlags |= ClassTypeFlags.BuiltInClass;\n\n            if (fileInfo.isTypingExtensionsStubFile) {\n                classFlags |= ClassTypeFlags.TypingExtensionClass;\n            }\n\n            if (node.name.value === 'property') {\n                classFlags |= ClassTypeFlags.PropertyClass;\n            }\n        }\n\n        const classType = ClassType.create(\n            node.name.value,\n            getClassFullName(node, fileInfo.moduleName, node.name.value),\n            fileInfo.moduleName,\n            classFlags,\n            node.id,\n            /* declaredMetaclass */ undefined,\n            /* effectiveMetaclass */ undefined,\n            ParseTreeUtils.getDocString(node.suite.statements)\n        );\n\n        // Some classes refer to themselves within type arguments used within\n        // base classes. We'll register the partially-constructed class type\n        // to allow these to be resolved.\n        const classSymbol = scope?.lookUpSymbol(node.name.value);\n        let classDecl: ClassDeclaration | undefined;\n        const decl = AnalyzerNodeInfo.getDeclaration(node);\n        if (decl) {\n            classDecl = decl as ClassDeclaration;\n        }\n        if (classDecl) {\n            setSymbolResolutionPartialType(classSymbol!, classDecl, classType);\n        }\n        classType.details.flags |= ClassTypeFlags.PartiallyConstructed;\n        writeTypeCache(node, classType);\n        writeTypeCache(node.name, classType);\n\n        // Keep a list of unique type parameters that are used in the\n        // base class arguments.\n        const typeParameters: TypeVarType[] = [];\n\n        // If the class derives from \"Generic\" directly, it will provide\n        // all of the type parameters in the specified order.\n        let genericTypeParameters: TypeVarType[] | undefined;\n\n        let sawMetaclass = false;\n        let nonMetaclassBaseClassCount = 0;\n        const initSubclassArgs: FunctionArgument[] = [];\n\n        node.arguments.forEach((arg) => {\n            // Ignore keyword parameters other than metaclass or total.\n            if (!arg.name || arg.name.value === 'metaclass') {\n                let exprFlags =\n                    EvaluatorFlags.ExpectingType |\n                    EvaluatorFlags.GenericClassTypeAllowed |\n                    EvaluatorFlags.DisallowTypeVarsWithScopeId |\n                    EvaluatorFlags.AssociateTypeVarsWithCurrentScope;\n                if (fileInfo.isStubFile) {\n                    exprFlags |= EvaluatorFlags.AllowForwardReferences;\n                }\n\n                let argType = getTypeOfExpression(arg.valueExpression, undefined, exprFlags).type;\n                const isMetaclass = !!arg.name;\n\n                if (isMetaclass) {\n                    if (sawMetaclass) {\n                        addError(Localizer.Diagnostic.metaclassDuplicate(), arg);\n                    }\n                    sawMetaclass = true;\n                }\n\n                // In some stub files, classes are conditionally defined (e.g. based\n                // on platform type). We'll assume that the conditional logic is correct\n                // and strip off the \"unbound\" union.\n                if (argType.category === TypeCategory.Union) {\n                    argType = removeUnboundFromUnion(argType);\n                }\n\n                if (!isAnyOrUnknown(argType) && !isUnbound(argType)) {\n                    // Handle \"Type[X]\" object.\n                    argType = transformTypeObjectToClass(argType);\n                    if (!isClass(argType)) {\n                        addDiagnostic(\n                            fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                            DiagnosticRule.reportGeneralTypeIssues,\n                            Localizer.Diagnostic.baseClassInvalid(),\n                            arg\n                        );\n                        argType = UnknownType.create();\n                    } else {\n                        if (ClassType.isBuiltIn(argType, 'Protocol')) {\n                            if (\n                                !fileInfo.isStubFile &&\n                                !ClassType.isTypingExtensionClass(argType) &&\n                                fileInfo.executionEnvironment.pythonVersion < PythonVersion.V3_7\n                            ) {\n                                addError(Localizer.Diagnostic.protocolIllegal(), arg.valueExpression);\n                            }\n                            classType.details.flags |= ClassTypeFlags.ProtocolClass;\n                        }\n\n                        if (ClassType.isBuiltIn(argType, 'property')) {\n                            classType.details.flags |= ClassTypeFlags.PropertyClass;\n                        }\n\n                        // If the class directly derives from NamedTuple (in Python 3.6 or\n                        // newer), it's considered a dataclass.\n                        if (fileInfo.executionEnvironment.pythonVersion >= PythonVersion.V3_6) {\n                            if (ClassType.isBuiltIn(argType, 'NamedTuple')) {\n                                classType.details.flags |= ClassTypeFlags.DataClass;\n                            }\n                        }\n\n                        // If the class directly derives from TypedDict or from a class that is\n                        // a TypedDict, it is considered a TypedDict.\n                        if (ClassType.isBuiltIn(argType, 'TypedDict') || ClassType.isTypedDictClass(argType)) {\n                            classType.details.flags |= ClassTypeFlags.TypedDictClass;\n                        } else if (ClassType.isTypedDictClass(classType) && !ClassType.isTypedDictClass(argType)) {\n                            // TypedDict classes must derive only from other\n                            // TypedDict classes.\n                            addError(Localizer.Diagnostic.typedDictBaseClass(), arg);\n                        }\n\n                        // Validate that the class isn't deriving from itself, creating a\n                        // circular dependency.\n                        if (derivesFromClassRecursive(argType, classType, /* ignoreUnknown */ true)) {\n                            addError(Localizer.Diagnostic.baseClassCircular(), arg);\n                            argType = UnknownType.create();\n                        }\n                    }\n                }\n\n                if (isUnknown(argType)) {\n                    addDiagnostic(\n                        fileInfo.diagnosticRuleSet.reportUntypedBaseClass,\n                        DiagnosticRule.reportUntypedBaseClass,\n                        Localizer.Diagnostic.baseClassUnknown(),\n                        arg\n                    );\n                }\n\n                if (isMetaclass) {\n                    if (isClass(argType) || isUnknown(argType)) {\n                        classType.details.declaredMetaclass = argType;\n                        if (isClass(argType)) {\n                            if (ClassType.isBuiltIn(argType, 'EnumMeta')) {\n                                classType.details.flags |= ClassTypeFlags.EnumClass;\n                            } else if (ClassType.isBuiltIn(argType, 'ABCMeta')) {\n                                classType.details.flags |= ClassTypeFlags.SupportsAbstractMethods;\n                            }\n                        }\n                    }\n                } else {\n                    // Check for a duplicate class.\n                    if (\n                        classType.details.baseClasses.some((prevBaseClass) => {\n                            return (\n                                isClass(prevBaseClass) &&\n                                isClass(argType) &&\n                                ClassType.isSameGenericClass(argType, prevBaseClass)\n                            );\n                        })\n                    ) {\n                        addDiagnostic(\n                            fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                            DiagnosticRule.reportGeneralTypeIssues,\n                            Localizer.Diagnostic.duplicateBaseClass(),\n                            arg.name || arg\n                        );\n                    }\n\n                    classType.details.baseClasses.push(argType);\n                    if (isClass(argType)) {\n                        if (ClassType.isEnumClass(argType)) {\n                            classType.details.flags |= ClassTypeFlags.EnumClass;\n                        }\n\n                        if (ClassType.supportsAbstractMethods(argType)) {\n                            classType.details.flags |= ClassTypeFlags.SupportsAbstractMethods;\n                        }\n\n                        if (ClassType.isPropertyClass(argType)) {\n                            classType.details.flags |= ClassTypeFlags.PropertyClass;\n                        }\n\n                        if (ClassType.isFinal(argType)) {\n                            const className = printObjectTypeForClass(argType);\n                            addError(\n                                Localizer.Diagnostic.baseClassFinal().format({ type: className }),\n                                arg.valueExpression\n                            );\n                        }\n                    }\n                }\n\n                addTypeVarsToListIfUnique(typeParameters, getTypeVarArgumentsRecursive(argType));\n                if (isClass(argType) && ClassType.isBuiltIn(argType, 'Generic')) {\n                    if (!genericTypeParameters) {\n                        genericTypeParameters = [];\n                        addTypeVarsToListIfUnique(genericTypeParameters, getTypeVarArgumentsRecursive(argType));\n                    }\n                }\n\n                if (!isMetaclass) {\n                    nonMetaclassBaseClassCount++;\n                }\n            } else if (arg.name.value === 'total' && ClassType.isTypedDictClass(classType)) {\n                // The \"total\" parameter name applies only for TypedDict classes.\n                // PEP 589 specifies that the parameter must be either True or False.\n                const constArgValue = evaluateStaticBoolExpression(arg.valueExpression, fileInfo.executionEnvironment);\n                if (constArgValue === undefined) {\n                    addError(Localizer.Diagnostic.typedDictTotalParam(), arg.valueExpression);\n                } else if (!constArgValue) {\n                    classType.details.flags |= ClassTypeFlags.CanOmitDictValues;\n                }\n            } else {\n                // Collect arguments that will be passed to the `__init_subclass__`\n                // method described in PEP 487.\n                initSubclassArgs.push({\n                    argumentCategory: ArgumentCategory.Simple,\n                    node: arg,\n                    name: arg.name,\n                    valueExpression: arg.valueExpression,\n                });\n            }\n        });\n\n        // Make sure we don't have 'object' derive from itself. Infinite\n        // recursion will result.\n        if (!ClassType.isBuiltIn(classType, 'object')) {\n            classType.details.baseClasses.push(getBuiltInType(node, 'object'));\n        }\n\n        // TODO - if genericTypeParameters are provided, make sure that\n        // typeParameters is a proper subset.\n        classType.details.typeParameters = genericTypeParameters || typeParameters;\n\n        if (!computeMroLinearization(classType)) {\n            addError(Localizer.Diagnostic.methodOrdering(), node.name);\n        }\n\n        // Determine the effective metaclass and detect metaclass conflicts.\n        let effectiveMetaclass = classType.details.declaredMetaclass;\n        let reportedMetaclassConflict = false;\n\n        if (!effectiveMetaclass || isClass(effectiveMetaclass)) {\n            for (const baseClass of classType.details.baseClasses) {\n                if (isClass(baseClass)) {\n                    const baseClassMeta = baseClass.details.effectiveMetaclass;\n                    if (baseClassMeta && isClass(baseClassMeta)) {\n                        // Make sure there is no metaclass conflict.\n                        if (!effectiveMetaclass) {\n                            effectiveMetaclass = baseClassMeta;\n                        } else if (\n                            derivesFromClassRecursive(baseClassMeta, effectiveMetaclass, /* ignoreUnknown */ true)\n                        ) {\n                            effectiveMetaclass = baseClassMeta;\n                        } else if (\n                            !derivesFromClassRecursive(effectiveMetaclass, baseClassMeta, /* ignoreUnknown */ true)\n                        ) {\n                            if (!reportedMetaclassConflict) {\n                                addDiagnostic(\n                                    fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                                    DiagnosticRule.reportGeneralTypeIssues,\n                                    Localizer.Diagnostic.metaclassConflict(),\n                                    node.name\n                                );\n                                // Don't report more than once.\n                                reportedMetaclassConflict = true;\n                            }\n                        }\n                    } else {\n                        effectiveMetaclass = UnknownType.create();\n                        break;\n                    }\n                } else {\n                    // If one of the base classes is unknown, then the effective\n                    // metaclass is also unknowable.\n                    effectiveMetaclass = UnknownType.create();\n                    break;\n                }\n            }\n        }\n\n        // If we haven't found an effective metaclass, assume \"type\", which\n        // is the metaclass for \"object\".\n        if (!effectiveMetaclass) {\n            const typeMetaclass = getBuiltInType(node, 'type');\n            effectiveMetaclass = typeMetaclass && isClass(typeMetaclass) ? typeMetaclass : UnknownType.create();\n        }\n\n        classType.details.effectiveMetaclass = effectiveMetaclass;\n\n        // The scope for this class becomes the \"fields\" for the corresponding type.\n        const innerScope = ScopeUtils.getScopeForNode(node.suite);\n        classType.details.fields = innerScope?.symbolTable || new Map<string, Symbol>();\n\n        if (ClassType.isTypedDictClass(classType)) {\n            synthesizeTypedDictClassMethods(node, classType);\n        }\n\n        // Determine if the class should be a \"pseudo-generic\" class, characterized\n        // by having an __init__ method with parameters that lack type annotations.\n        // For such classes, we'll treat them as generic, with the type arguments provided\n        // by the callers of the constructor.\n        if (!fileInfo.isStubFile && classType.details.typeParameters.length === 0) {\n            const initMethod = classType.details.fields.get('__init__');\n            if (initMethod) {\n                const initDecls = initMethod.getTypedDeclarations();\n                if (initDecls.length === 1 && initDecls[0].type === DeclarationType.Function) {\n                    const initDeclNode = initDecls[0].node;\n                    const initParams = initDeclNode.parameters;\n\n                    if (\n                        initParams.length > 1 &&\n                        !initParams.some((param, index) => !!getTypeAnnotationForParameter(initDeclNode, index))\n                    ) {\n                        const genericParams = initParams.filter(\n                            (param, index) => index > 0 && param.name && param.category === ParameterCategory.Simple\n                        );\n\n                        if (genericParams.length > 0) {\n                            classType.details.flags |= ClassTypeFlags.PseudoGenericClass;\n\n                            // Create a type parameter for each simple, named parameter\n                            // in the __init__ method.\n                            classType.details.typeParameters = genericParams.map((param) => {\n                                const typeVar = TypeVarType.createInstance(\n                                    `__type_of_${param.name!.value}`,\n                                    /* isParamSpec */ false,\n                                    /* isSynthesized */ true\n                                );\n                                return TypeVarType.cloneForScopeId(typeVar, node.id);\n                            });\n                        }\n                    }\n                }\n            }\n        }\n\n        // Determine if the class is abstract.\n        if (ClassType.supportsAbstractMethods(classType)) {\n            if (getAbstractMethods(classType).length > 0) {\n                classType.details.flags |= ClassTypeFlags.HasAbstractMethods;\n            }\n        }\n\n        // Now determine the decorated type of the class.\n        let decoratedType: Type = classType;\n        let foundUnknown = false;\n\n        for (let i = node.decorators.length - 1; i >= 0; i--) {\n            const decorator = node.decorators[i];\n\n            const newDecoratedType = applyClassDecorator(decoratedType, classType, decorator);\n            if (isUnknown(newDecoratedType)) {\n                // Report this error only on the first unknown type.\n                if (!foundUnknown) {\n                    addDiagnostic(\n                        fileInfo.diagnosticRuleSet.reportUntypedClassDecorator,\n                        DiagnosticRule.reportUntypedClassDecorator,\n                        Localizer.Diagnostic.classDecoratorTypeUnknown(),\n                        node.decorators[i].leftExpression\n                    );\n\n                    foundUnknown = true;\n                }\n            } else {\n                // Apply the decorator only if the type is known.\n                decoratedType = newDecoratedType;\n            }\n        }\n\n        if (ClassType.isDataClass(classType)) {\n            let skipSynthesizedInit = ClassType.isSkipSynthesizedInit(classType);\n            if (!skipSynthesizedInit) {\n                // See if there's already a non-synthesized __init__ method.\n                // We shouldn't override it.\n                const initSymbol = lookUpClassMember(classType, '__init__', ClassMemberLookupFlags.SkipBaseClasses);\n                if (initSymbol) {\n                    const initSymbolType = getTypeOfMember(initSymbol);\n                    if (initSymbolType.category === TypeCategory.Function) {\n                        if (!FunctionType.isSynthesizedMethod(initSymbolType)) {\n                            skipSynthesizedInit = true;\n                        }\n                    } else {\n                        skipSynthesizedInit = true;\n                    }\n                }\n            }\n\n            synthesizeDataClassMethods(node, classType, skipSynthesizedInit);\n        }\n\n        // Clear the \"partially constructed\" flag.\n        classType.details.flags &= ~ClassTypeFlags.PartiallyConstructed;\n\n        // Update the undecorated class type.\n        writeTypeCache(node.name, classType);\n\n        // Update the decorated class type.\n        writeTypeCache(node, decoratedType);\n\n        // Validate __init_subclass__ call.\n        if (initSubclassArgs.length > 0) {\n            validateInitSubclassArgs(node, classType, initSubclassArgs);\n        }\n\n        return { classType, decoratedType };\n    }\n\n    function applyClassDecorator(\n        inputClassType: Type,\n        originalClassType: ClassType,\n        decoratorNode: DecoratorNode\n    ): Type {\n        const decoratorType = getTypeOfExpression(decoratorNode.leftExpression).type;\n\n        // Is this a @dataclass?\n        if (decoratorType.category === TypeCategory.OverloadedFunction) {\n            const overloads = decoratorType.overloads;\n            if (overloads.length > 0 && overloads[0].details.builtInName === 'dataclass') {\n                // Determine whether we should skip synthesizing the init method.\n                let skipSynthesizeInit = false;\n\n                if (decoratorNode.arguments) {\n                    decoratorNode.arguments.forEach((arg) => {\n                        if (arg.name && arg.name.value === 'init') {\n                            if (arg.valueExpression) {\n                                const fileInfo = getFileInfo(decoratorNode);\n                                const value = evaluateStaticBoolExpression(\n                                    arg.valueExpression,\n                                    fileInfo.executionEnvironment\n                                );\n                                if (!value) {\n                                    skipSynthesizeInit = true;\n                                }\n                            }\n                        }\n                    });\n                }\n\n                originalClassType.details.flags |= ClassTypeFlags.DataClass;\n                if (skipSynthesizeInit) {\n                    originalClassType.details.flags |= ClassTypeFlags.SkipSynthesizedInit;\n                }\n                return inputClassType;\n            }\n        } else if (decoratorType.category === TypeCategory.Function) {\n            if (decoratorType.details.builtInName === 'final') {\n                originalClassType.details.flags |= ClassTypeFlags.Final;\n            } else if (decoratorType.details.builtInName === 'runtime_checkable') {\n                originalClassType.details.flags |= ClassTypeFlags.RuntimeCheckable;\n            }\n        }\n\n        return getTypeFromDecorator(decoratorNode, inputClassType);\n    }\n\n    function validateInitSubclassArgs(node: ClassNode, classType: ClassType, argList: FunctionArgument[]) {\n        const errorNode = argList[0].node!.name!;\n        const initSubclassMethodInfo = getTypeFromClassMemberName(\n            errorNode,\n            classType,\n            '__init_subclass__',\n            { method: 'get' },\n            new DiagnosticAddendum(),\n            MemberAccessFlags.SkipForMethodLookup | MemberAccessFlags.SkipObjectBaseClass\n        );\n\n        if (initSubclassMethodInfo) {\n            const initSubclassMethodType = bindFunctionToClassOrObject(\n                classType,\n                initSubclassMethodInfo.type,\n                /* treatAsClassMember */ true,\n                errorNode\n            );\n            const typeVarMap = new TypeVarMap();\n\n            if (initSubclassMethodType)\n                validateCallArguments(\n                    errorNode,\n                    argList,\n                    initSubclassMethodType,\n                    typeVarMap,\n                    /* skipUnknownArgCheck */ false,\n                    /* inferReturnTypeIfNeeded */ true,\n                    NoneType.createInstance()\n                );\n        }\n    }\n\n    function getTypeOfFunction(node: FunctionNode): FunctionTypeResult | undefined {\n        const fileInfo = getFileInfo(node);\n\n        // Is this type already cached?\n        const cachedFunctionType = readTypeCache(node.name) as FunctionType;\n\n        if (cachedFunctionType) {\n            if (!isFunction(cachedFunctionType)) {\n                // This can happen in certain rare circumstances where the\n                // function declaration falls within an unreachable code block.\n                return undefined;\n            }\n            return { functionType: cachedFunctionType, decoratedType: readTypeCache(node) || UnknownType.create() };\n        }\n\n        let functionDecl: FunctionDeclaration | undefined;\n        const decl = AnalyzerNodeInfo.getDeclaration(node);\n        if (decl) {\n            functionDecl = decl as FunctionDeclaration;\n        }\n\n        // There was no cached type, so create a new one.\n        // Retrieve the containing class node if the function is a method.\n        const containingClassNode = ParseTreeUtils.getEnclosingClass(node, true);\n        let containingClassType: ClassType | undefined;\n        if (containingClassNode) {\n            const classInfo = getTypeOfClass(containingClassNode);\n            if (!classInfo) {\n                return undefined;\n            }\n            containingClassType = classInfo.classType;\n        }\n\n        let functionFlags = getFunctionFlagsFromDecorators(node, !!containingClassNode);\n        if (functionDecl?.isGenerator) {\n            functionFlags |= FunctionTypeFlags.Generator;\n        }\n\n        if (fileInfo.isStubFile) {\n            functionFlags |= FunctionTypeFlags.StubDefinition;\n        } else if (fileInfo.isInPyTypedPackage && evaluatorOptions.disableInferenceForPyTypedSources) {\n            functionFlags |= FunctionTypeFlags.PyTypedDefinition;\n        }\n\n        if (node.isAsync) {\n            functionFlags |= FunctionTypeFlags.Async;\n        }\n\n        const functionType = FunctionType.createInstance(\n            node.name.value,\n            fileInfo.moduleName,\n            functionFlags,\n            ParseTreeUtils.getDocString(node.suite.statements)\n        );\n\n        if (fileInfo.isBuiltInStubFile || fileInfo.isTypingStubFile || fileInfo.isTypingExtensionsStubFile) {\n            // Stash away the name of the function since we need to handle\n            // 'namedtuple', 'abstractmethod', 'dataclass' and 'NewType'\n            // specially.\n            functionType.details.builtInName = node.name.value;\n        }\n\n        functionType.details.declaration = functionDecl;\n\n        // Allow recursion by registering the partially-constructed\n        // function type.\n        const scope = ScopeUtils.getScopeForNode(node);\n        const functionSymbol = scope?.lookUpSymbol(node.name.value);\n        if (functionDecl) {\n            setSymbolResolutionPartialType(functionSymbol!, functionDecl, functionType);\n        }\n        writeTypeCache(node, functionType);\n        writeTypeCache(node.name, functionType);\n\n        // Is this an \"__init__\" method within a pseudo-generic class? If so,\n        // we'll add generic types to the constructor's parameters.\n        const addGenericParamTypes =\n            containingClassType &&\n            ClassType.isPseudoGenericClass(containingClassType) &&\n            node.name.value === '__init__';\n\n        const paramTypes: Type[] = [];\n        let typeParamIndex = 0;\n\n        // Determine if the first parameter should be skipped for comment-based\n        // function annotations.\n        let firstCommentAnnotationIndex = 0;\n        if (containingClassType && (functionType.details.flags & FunctionTypeFlags.StaticMethod) === 0) {\n            firstCommentAnnotationIndex = 1;\n        }\n\n        // If there is a function annotation comment, validate that it has the correct\n        // number of parameter annotations.\n        if (node.functionAnnotationComment && !node.functionAnnotationComment.isParamListEllipsis) {\n            const expected = node.parameters.length - firstCommentAnnotationIndex;\n            const received = node.functionAnnotationComment.paramTypeAnnotations.length;\n\n            // For methods with \"self\" or \"cls\" parameters, the annotation list\n            // can either include or exclude the annotation for the first parameter.\n            if (firstCommentAnnotationIndex > 0 && received === node.parameters.length) {\n                firstCommentAnnotationIndex = 0;\n            } else if (received !== expected) {\n                addError(\n                    Localizer.Diagnostic.annotatedParamCountMismatch().format({\n                        expected,\n                        received,\n                    }),\n                    node.functionAnnotationComment\n                );\n            }\n        }\n\n        const typeParameters: TypeVarType[] = [];\n\n        node.parameters.forEach((param, index) => {\n            let paramType: Type | undefined;\n            let annotatedType: Type | undefined;\n            let concreteAnnotatedType: Type | undefined;\n            let isNoneWithoutOptional = false;\n            let paramTypeNode: ExpressionNode | undefined;\n\n            if (param.typeAnnotation) {\n                paramTypeNode = param.typeAnnotation;\n            } else if (param.typeAnnotationComment) {\n                paramTypeNode = param.typeAnnotationComment;\n            } else if (node.functionAnnotationComment && !node.functionAnnotationComment.isParamListEllipsis) {\n                const adjustedIndex = index - firstCommentAnnotationIndex;\n                if (adjustedIndex >= 0 && adjustedIndex < node.functionAnnotationComment.paramTypeAnnotations.length) {\n                    paramTypeNode = node.functionAnnotationComment.paramTypeAnnotations[adjustedIndex];\n                }\n            }\n\n            if (paramTypeNode) {\n                annotatedType = getTypeOfAnnotation(\n                    paramTypeNode,\n                    /* allowFinal */ false,\n                    /* associateTypeVarsWithScope */ true\n                );\n            }\n\n            if (!annotatedType && addGenericParamTypes) {\n                if (index > 0 && param.category === ParameterCategory.Simple && param.name) {\n                    annotatedType = containingClassType!.details.typeParameters[typeParamIndex];\n                    typeParamIndex++;\n                }\n            }\n\n            if (annotatedType) {\n                // PEP 484 indicates that if a parameter has a default value of 'None'\n                // the type checker should assume that the type is optional (i.e. a union\n                // of the specified type and 'None').\n                if (param.defaultValue && param.defaultValue.nodeType === ParseNodeType.Constant) {\n                    if (param.defaultValue.constType === KeywordType.None) {\n                        isNoneWithoutOptional = true;\n\n                        if (!fileInfo.diagnosticRuleSet.strictParameterNoneValue) {\n                            annotatedType = combineTypes([annotatedType, NoneType.createInstance()]);\n                        }\n                    }\n                }\n\n                concreteAnnotatedType = specializeType(annotatedType, /* typeVarMap */ undefined);\n            }\n\n            let defaultValueType: Type | undefined;\n            if (param.defaultValue) {\n                defaultValueType = getTypeOfExpression(\n                    param.defaultValue,\n                    annotatedType,\n                    EvaluatorFlags.ConvertEllipsisToAny\n                ).type;\n            }\n\n            if (annotatedType) {\n                // If there was both a type annotation and a default value, verify\n                // that the default value matches the annotation.\n                if (param.defaultValue && defaultValueType && concreteAnnotatedType) {\n                    const diagAddendum = new DiagnosticAddendum();\n\n                    if (!canAssignType(concreteAnnotatedType, defaultValueType, diagAddendum)) {\n                        const diag = addDiagnostic(\n                            fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                            DiagnosticRule.reportGeneralTypeIssues,\n                            Localizer.Diagnostic.paramAssignmentMismatch().format({\n                                sourceType: printType(defaultValueType),\n                                paramType: printType(annotatedType),\n                            }) + diagAddendum.getString(),\n                            param.defaultValue\n                        );\n\n                        if (isNoneWithoutOptional && paramTypeNode) {\n                            const addOptionalAction: AddMissingOptionalToParamAction = {\n                                action: Commands.addMissingOptionalToParam,\n                                offsetOfTypeNode: paramTypeNode.start + 1,\n                            };\n                            if (diag) {\n                                diag.addAction(addOptionalAction);\n                            }\n                        }\n                    }\n                }\n\n                paramType = annotatedType;\n            }\n\n            const functionParam: FunctionParameter = {\n                category: param.category,\n                name: param.name ? param.name.value : undefined,\n                hasDefault: !!param.defaultValue,\n                defaultType: defaultValueType,\n                hasDeclaredType: !!paramTypeNode,\n                type: paramType || UnknownType.create(),\n            };\n\n            FunctionType.addParameter(functionType, functionParam);\n\n            if (param.name) {\n                const variadicParamType = transformVariadicParamType(node, param.category, functionParam.type);\n                paramTypes.push(variadicParamType);\n            } else {\n                paramTypes.push(functionParam.type);\n            }\n        });\n\n        if (containingClassNode && containingClassType) {\n            // If the first parameter doesn't have an explicit type annotation,\n            // provide a type if it's an instance, class or constructor method.\n            if (functionType.details.parameters.length > 0) {\n                const typeAnnotation = getTypeAnnotationForParameter(node, 0);\n                if (!typeAnnotation) {\n                    const inferredParamType = inferFirstParamType(\n                        functionType.details.flags,\n                        containingClassType,\n                        containingClassNode\n                    );\n                    if (inferredParamType) {\n                        functionType.details.parameters[0].type = inferredParamType;\n                        if (!isAnyOrUnknown(inferredParamType)) {\n                            functionType.details.parameters[0].isTypeInferred = true;\n                        }\n\n                        paramTypes[0] = inferredParamType;\n                    }\n                }\n            }\n        }\n\n        // Update the types for the nodes associated with the parameters.\n        paramTypes.forEach((paramType, index) => {\n            const paramNameNode = node.parameters[index].name;\n            if (paramNameNode) {\n                if (isUnknown(paramType)) {\n                    functionType.details.flags |= FunctionTypeFlags.UnannotatedParams;\n                }\n                writeTypeCache(paramNameNode, paramType);\n            }\n        });\n\n        // If there was a defined return type, analyze that first so when we\n        // walk the contents of the function, return statements can be\n        // validated against this type.\n        if (node.returnTypeAnnotation) {\n            // Temporarily set the return type to unknown in case of recursion.\n            functionType.details.declaredReturnType = UnknownType.create();\n\n            const returnType = getTypeOfAnnotation(\n                node.returnTypeAnnotation,\n                /* allowFinal */ false,\n                /* associateTypeVarsWithScope */ true\n            );\n            functionType.details.declaredReturnType = returnType;\n        } else if (node.functionAnnotationComment) {\n            // Temporarily set the return type to unknown in case of recursion.\n            functionType.details.declaredReturnType = UnknownType.create();\n\n            const returnType = getTypeOfAnnotation(\n                node.functionAnnotationComment.returnTypeAnnotation,\n                /* allowFinal */ false,\n                /* associateTypeVarsWithScope */ true\n            );\n            functionType.details.declaredReturnType = returnType;\n        } else {\n            // If there was no return type annotation and this is a type stub,\n            // we have no opportunity to infer the return type, so we'll indicate\n            // that it's unknown.\n            if (fileInfo.isStubFile) {\n                // Special-case the __init__ method, which is commonly left without\n                // an annotated return type, but we can assume it returns None.\n                if (node.name.value === '__init__') {\n                    functionType.details.declaredReturnType = NoneType.createInstance();\n                } else {\n                    functionType.details.declaredReturnType = UnknownType.create();\n                }\n            }\n        }\n\n        // If it's an async function, wrap the return type in an Awaitable or Generator.\n        const preDecoratedType = node.isAsync ? createAsyncFunction(node, functionType) : functionType;\n\n        // Apply all of the decorators in reverse order.\n        let decoratedType: Type = preDecoratedType;\n        let foundUnknown = false;\n        for (let i = node.decorators.length - 1; i >= 0; i--) {\n            const decorator = node.decorators[i];\n\n            const newDecoratedType = applyFunctionDecorator(decoratedType, functionType, decorator, node);\n            if (isUnknown(newDecoratedType)) {\n                // Report this error only on the first unknown type.\n                if (!foundUnknown) {\n                    addDiagnostic(\n                        fileInfo.diagnosticRuleSet.reportUntypedFunctionDecorator,\n                        DiagnosticRule.reportUntypedFunctionDecorator,\n                        Localizer.Diagnostic.functionDecoratorTypeUnknown(),\n                        node.decorators[i].leftExpression\n                    );\n\n                    foundUnknown = true;\n                }\n            } else {\n                // Apply the decorator only if the type is known.\n                decoratedType = newDecoratedType;\n            }\n        }\n\n        // See if there are any overloads provided by previous function declarations.\n        if (decoratedType.category === TypeCategory.Function) {\n            decoratedType = addOverloadsToFunctionType(node, decoratedType);\n        }\n\n        writeTypeCache(node.name, functionType);\n        writeTypeCache(node, decoratedType);\n\n        return { functionType, decoratedType };\n    }\n\n    function inferFirstParamType(\n        flags: FunctionTypeFlags,\n        containingClassType: ClassType,\n        containingClassNode: ClassNode\n    ): Type | undefined {\n        if ((flags & FunctionTypeFlags.StaticMethod) === 0) {\n            if (containingClassType) {\n                if (ClassType.isProtocolClass(containingClassType)) {\n                    // Don't specialize the \"self\" for protocol classes because type\n                    // comparisons will fail during structural typing analysis. We'll\n                    // use an \"Any\" type here to avoid triggering errors about Unknown\n                    // types.\n                    return AnyType.create();\n                }\n\n                if (flags & (FunctionTypeFlags.ClassMethod | FunctionTypeFlags.ConstructorMethod)) {\n                    // For class methods, the cls parameter is allowed to skip the\n                    // abstract class test because the caller is possibly passing\n                    // in a non-abstract subclass.\n                    const clsType = TypeVarType.createInstance(\n                        `__type_of_cls_${containingClassType.details.name}`,\n                        /* isParamSpec */ false,\n                        /* isSynthesized */ true\n                    );\n                    clsType.scopeId = TypeVarType.makeScopeId(clsType.details.name, containingClassNode.id);\n                    clsType.details.boundType = selfSpecializeClassType(\n                        containingClassType,\n                        /* setSkipAbstractClassTest */ true\n                    );\n                    return clsType;\n                } else if ((flags & FunctionTypeFlags.StaticMethod) === 0) {\n                    const selfType = TypeVarType.createInstance(\n                        `__type_of_self_${containingClassType.details.name}`,\n                        /* isParamSpec */ false,\n                        /* isSynthesized */ true\n                    );\n                    selfType.scopeId = TypeVarType.makeScopeId(selfType.details.name, containingClassNode.id);\n                    selfType.details.boundType = ObjectType.create(\n                        selfSpecializeClassType(containingClassType, /* setSkipAbstractClassTest */ true)\n                    );\n                    return selfType;\n                }\n            }\n        }\n\n        return undefined;\n    }\n\n    // Transforms the parameter type based on its category. If it's a simple parameter,\n    // no transform is applied. If it's a var-arg or keyword-arg parameter, the type\n    // is wrapped in a List or Dict.\n    function transformVariadicParamType(node: ParseNode, paramCategory: ParameterCategory, type: Type): Type {\n        switch (paramCategory) {\n            case ParameterCategory.Simple: {\n                return type;\n            }\n\n            case ParameterCategory.VarArgList: {\n                // Create a Tuple[X, ...] type.\n                const tupleType = getTypingType(node, 'Tuple');\n                if (tupleType && isClass(tupleType)) {\n                    return ObjectType.create(\n                        ClassType.cloneForSpecialization(\n                            tupleType,\n                            [type, AnyType.create(true)],\n                            /* isTypeArgumentExplicit */ false\n                        )\n                    );\n                }\n\n                return UnknownType.create();\n            }\n\n            case ParameterCategory.VarArgDictionary: {\n                const dictType = getBuiltInType(node, 'Dict');\n                const strType = getBuiltInObject(node, 'str');\n\n                if (isClass(dictType) && isObject(strType)) {\n                    return ObjectType.create(\n                        ClassType.cloneForSpecialization(dictType, [strType, type], /* isTypeArgumentExplicit */ false)\n                    );\n                }\n\n                return UnknownType.create();\n            }\n        }\n    }\n\n    // Scans through the decorators to find a few built-in decorators\n    // that affect the function flags.\n    function getFunctionFlagsFromDecorators(node: FunctionNode, isInClass: boolean) {\n        const fileInfo = getFileInfo(node);\n        let flags = FunctionTypeFlags.None;\n\n        // The \"__new__\" magic method is not an instance method.\n        // It acts as a static method instead.\n        if (node.name.value === '__new__' && isInClass) {\n            flags |= FunctionTypeFlags.ConstructorMethod;\n        }\n\n        // The \"__init_subclass__\" magic method is not an instance method.\n        // It acts an an implicit class method instead.\n        if (node.name.value === '__init_subclass__' && isInClass) {\n            flags |= FunctionTypeFlags.ClassMethod;\n        }\n\n        for (const decoratorNode of node.decorators) {\n            let evaluatorFlags = EvaluatorFlags.DoNotSpecialize;\n            if (fileInfo.isStubFile) {\n                // Some stub files (e.g. builtins.pyi) rely on forward\n                // declarations of decorators.\n                evaluatorFlags |= EvaluatorFlags.AllowForwardReferences;\n            }\n\n            const decoratorType = getTypeOfExpression(decoratorNode.leftExpression, undefined, evaluatorFlags).type;\n            if (decoratorType.category === TypeCategory.Function) {\n                if (decoratorType.details.builtInName === 'abstractmethod') {\n                    if (isInClass) {\n                        flags |= FunctionTypeFlags.AbstractMethod;\n                    }\n                } else if (decoratorType.details.builtInName === 'final') {\n                    flags |= FunctionTypeFlags.Final;\n                }\n            } else if (isClass(decoratorType)) {\n                if (ClassType.isBuiltIn(decoratorType, 'staticmethod')) {\n                    if (isInClass) {\n                        flags |= FunctionTypeFlags.StaticMethod;\n                    }\n                } else if (ClassType.isBuiltIn(decoratorType, 'classmethod')) {\n                    if (isInClass) {\n                        flags |= FunctionTypeFlags.ClassMethod;\n                    }\n                }\n            }\n        }\n\n        return flags;\n    }\n\n    // Transforms the input function type into an output type based on the\n    // decorator function described by the decoratorNode.\n    function applyFunctionDecorator(\n        inputFunctionType: Type,\n        originalFunctionType: FunctionType,\n        decoratorNode: DecoratorNode,\n        functionNode: FunctionNode\n    ): Type {\n        const fileInfo = getFileInfo(decoratorNode);\n\n        let evaluatorFlags = EvaluatorFlags.DoNotSpecialize;\n        if (fileInfo.isStubFile) {\n            // Some stub files (e.g. builtins.pyi) rely on forward\n            // declarations of decorators.\n            evaluatorFlags |= EvaluatorFlags.AllowForwardReferences;\n        }\n\n        const decoratorType = getTypeOfExpression(decoratorNode.leftExpression, undefined, evaluatorFlags).type;\n\n        // Special-case the \"overload\" because it has no definition.\n        if (isClass(decoratorType) && ClassType.isSpecialBuiltIn(decoratorType, 'overload')) {\n            if (inputFunctionType.category === TypeCategory.Function) {\n                inputFunctionType.details.flags |= FunctionTypeFlags.Overloaded;\n                return inputFunctionType;\n            }\n        }\n\n        const returnType = getTypeFromDecorator(decoratorNode, inputFunctionType);\n\n        // Check for some built-in decorator types with known semantics.\n        if (decoratorType.category === TypeCategory.Function) {\n            if (decoratorType.details.builtInName === 'abstractmethod') {\n                return inputFunctionType;\n            }\n\n            // Handle property setters and deleters.\n            if (decoratorNode.leftExpression.nodeType === ParseNodeType.MemberAccess) {\n                const baseType = getTypeOfExpression(decoratorNode.leftExpression.leftExpression).type;\n                if (isProperty(baseType)) {\n                    const memberName = decoratorNode.leftExpression.memberName.value;\n                    if (memberName === 'setter') {\n                        return clonePropertyWithSetter(baseType, originalFunctionType, functionNode);\n                    } else if (memberName === 'deleter') {\n                        return clonePropertyWithDeleter(baseType, originalFunctionType);\n                    }\n                }\n            }\n        } else if (isClass(decoratorType)) {\n            if (ClassType.isBuiltIn(decoratorType)) {\n                switch (decoratorType.details.name) {\n                    case 'classmethod':\n                    case 'staticmethod': {\n                        return inputFunctionType;\n                    }\n                }\n            }\n\n            // Handle properties and subclasses of properties specially.\n            if (ClassType.isPropertyClass(decoratorType)) {\n                if (inputFunctionType.category === TypeCategory.Function) {\n                    return createProperty(\n                        decoratorNode,\n                        decoratorType.details.name,\n                        inputFunctionType,\n                        decoratorNode.id\n                    );\n                }\n            }\n        }\n\n        // Copy the overload flag from the input function type.\n        if (inputFunctionType.category === TypeCategory.Function && returnType.category === TypeCategory.Function) {\n            if (FunctionType.isOverloaded(inputFunctionType)) {\n                returnType.details.flags |= FunctionTypeFlags.Overloaded;\n            }\n        }\n\n        return returnType;\n    }\n\n    function createProperty(\n        decoratorNode: DecoratorNode,\n        className: string,\n        fget: FunctionType,\n        typeSourceId: TypeSourceId\n    ): ObjectType {\n        const fileInfo = getFileInfo(decoratorNode);\n        const typeMetaclass = getBuiltInType(decoratorNode, 'type');\n        const propertyClass = ClassType.create(\n            className,\n            getClassFullName(decoratorNode, fileInfo.moduleName, className),\n            fileInfo.moduleName,\n            ClassTypeFlags.PropertyClass,\n            typeSourceId,\n            /* declaredMetaclass */ undefined,\n            isClass(typeMetaclass) ? typeMetaclass : UnknownType.create()\n        );\n        computeMroLinearization(propertyClass);\n\n        const propertyObject = ObjectType.create(propertyClass);\n\n        // Fill in the fget method.\n        const fields = propertyClass.details.fields;\n        const fgetSymbol = Symbol.createWithType(SymbolFlags.ClassMember, fget);\n        fields.set('fget', fgetSymbol);\n\n        // Fill in the __get__ method with an overload.\n        const getFunction1 = FunctionType.createInstance(\n            '__get__',\n            '',\n            FunctionTypeFlags.SynthesizedMethod | FunctionTypeFlags.Overloaded\n        );\n        getFunction1.details.parameters.push({\n            category: ParameterCategory.Simple,\n            name: 'self',\n            type: propertyObject,\n        });\n        getFunction1.details.parameters.push({\n            category: ParameterCategory.Simple,\n            name: 'obj',\n            type: NoneType.createInstance(),\n        });\n        getFunction1.details.parameters.push({\n            category: ParameterCategory.Simple,\n            name: 'type',\n            type: AnyType.create(),\n            hasDefault: true,\n            defaultType: AnyType.create(),\n        });\n        getFunction1.details.declaredReturnType = propertyObject;\n        getFunction1.details.declaration = fget.details.declaration;\n\n        const getFunction2 = FunctionType.createInstance(\n            '__get__',\n            '',\n            FunctionTypeFlags.SynthesizedMethod | FunctionTypeFlags.Overloaded\n        );\n        getFunction2.details.parameters.push({\n            category: ParameterCategory.Simple,\n            name: 'self',\n            type: propertyObject,\n        });\n        getFunction2.details.parameters.push({\n            category: ParameterCategory.Simple,\n            name: 'obj',\n            type: fget.details.parameters.length > 0 ? fget.details.parameters[0].type : AnyType.create(),\n        });\n        getFunction2.details.parameters.push({\n            category: ParameterCategory.Simple,\n            name: 'type',\n            type: AnyType.create(),\n            hasDefault: true,\n            defaultType: AnyType.create(),\n        });\n        getFunction2.details.declaredReturnType = fget.details.declaredReturnType;\n        getFunction2.details.declaration = fget.details.declaration;\n\n        const getFunctionOverload = OverloadedFunctionType.create([getFunction1, getFunction2]);\n        const getSymbol = Symbol.createWithType(SymbolFlags.ClassMember, getFunctionOverload);\n        fields.set('__get__', getSymbol);\n\n        // Fill in the getter, setter and deleter methods.\n        ['getter', 'setter', 'deleter'].forEach((accessorName) => {\n            const accessorFunction = FunctionType.createInstance(accessorName, '', FunctionTypeFlags.SynthesizedMethod);\n            accessorFunction.details.parameters.push({\n                category: ParameterCategory.Simple,\n                name: 'self',\n                type: propertyObject,\n            });\n            accessorFunction.details.parameters.push({\n                category: ParameterCategory.Simple,\n                name: 'accessor',\n                type: AnyType.create(),\n            });\n            accessorFunction.details.declaredReturnType = propertyObject;\n            const accessorSymbol = Symbol.createWithType(SymbolFlags.ClassMember, accessorFunction);\n            fields.set(accessorName, accessorSymbol);\n        });\n\n        return propertyObject;\n    }\n\n    function clonePropertyWithSetter(prop: Type, fset: FunctionType, errorNode: FunctionNode): Type {\n        if (!isProperty(prop)) {\n            return prop;\n        }\n\n        const classType = (prop as ObjectType).classType;\n        const propertyClass = ClassType.create(\n            classType.details.name,\n            classType.details.fullName,\n            classType.details.moduleName,\n            classType.details.flags,\n            classType.details.typeSourceId,\n            classType.details.declaredMetaclass,\n            classType.details.effectiveMetaclass\n        );\n        computeMroLinearization(propertyClass);\n\n        const propertyObject = ObjectType.create(propertyClass);\n\n        // Clone the symbol table of the old class type.\n        const fields = propertyClass.details.fields;\n        classType.details.fields.forEach((symbol, name) => {\n            if (!symbol.isIgnoredForProtocolMatch()) {\n                fields.set(name, symbol);\n            }\n        });\n\n        // Verify parameters for fset.\n        if (errorNode.parameters.length >= 2) {\n            const typeAnnotation = getTypeAnnotationForParameter(errorNode, 1);\n            if (typeAnnotation) {\n                // Verify consistency of the type.\n                const fgetType = getGetterTypeFromProperty(classType, /* inferTypeIfNeeded */ false);\n                if (fgetType && !isAnyOrUnknown(fgetType)) {\n                    const fsetType = getTypeOfAnnotation(typeAnnotation);\n\n                    // The setter type should be assignable to the getter type.\n                    const diag = new DiagnosticAddendum();\n                    if (\n                        !canAssignType(\n                            fgetType,\n                            fsetType,\n                            diag,\n                            /* typeVarMap */ undefined,\n                            CanAssignFlags.DoNotSpecializeTypeVars\n                        )\n                    ) {\n                        addDiagnostic(\n                            getFileInfo(errorNode).diagnosticRuleSet.reportPropertyTypeMismatch,\n                            DiagnosticRule.reportPropertyTypeMismatch,\n                            Localizer.Diagnostic.setterGetterTypeMismatch() + diag.getString(),\n                            typeAnnotation\n                        );\n                    }\n                }\n            }\n        }\n\n        // Fill in the fset method.\n        const fsetSymbol = Symbol.createWithType(SymbolFlags.ClassMember, fset);\n        fields.set('fset', fsetSymbol);\n\n        // Fill in the __set__ method.\n        const setFunction = FunctionType.createInstance('__set__', '', FunctionTypeFlags.SynthesizedMethod);\n        setFunction.details.parameters.push({\n            category: ParameterCategory.Simple,\n            name: 'self',\n            type: fset.details.parameters.length > 0 ? fset.details.parameters[0].type : AnyType.create(),\n        });\n        setFunction.details.parameters.push({\n            category: ParameterCategory.Simple,\n            name: 'obj',\n            type: propertyObject,\n        });\n        setFunction.details.declaredReturnType = NoneType.createInstance();\n        let setParamType: Type = UnknownType.create();\n        if (\n            fset.details.parameters.length >= 2 &&\n            fset.details.parameters[1].category === ParameterCategory.Simple &&\n            fset.details.parameters[1].name\n        ) {\n            setParamType = fset.details.parameters[1].type;\n        }\n        setFunction.details.parameters.push({\n            category: ParameterCategory.Simple,\n            name: 'value',\n            type: setParamType,\n        });\n        const setSymbol = Symbol.createWithType(SymbolFlags.ClassMember, setFunction);\n        fields.set('__set__', setSymbol);\n\n        return propertyObject;\n    }\n\n    function clonePropertyWithDeleter(prop: Type, fdel: FunctionType): Type {\n        if (!isProperty(prop)) {\n            return prop;\n        }\n\n        const classType = (prop as ObjectType).classType;\n        const propertyClass = ClassType.create(\n            classType.details.name,\n            classType.details.fullName,\n            classType.details.moduleName,\n            classType.details.flags,\n            classType.details.typeSourceId,\n            classType.details.declaredMetaclass,\n            classType.details.effectiveMetaclass\n        );\n        computeMroLinearization(propertyClass);\n\n        const propertyObject = ObjectType.create(propertyClass);\n\n        // Clone the symbol table of the old class type.\n        const fields = propertyClass.details.fields;\n        classType.details.fields.forEach((symbol, name) => {\n            if (!symbol.isIgnoredForProtocolMatch()) {\n                fields.set(name, symbol);\n            }\n        });\n\n        // Fill in the fdel method.\n        const fdelSymbol = Symbol.createWithType(SymbolFlags.ClassMember, fdel);\n        fields.set('fdel', fdelSymbol);\n\n        // Fill in the __delete__ method.\n        const delFunction = FunctionType.createInstance('__delete__', '', FunctionTypeFlags.SynthesizedMethod);\n        delFunction.details.parameters.push({\n            category: ParameterCategory.Simple,\n            name: 'self',\n            type: fdel.details.parameters.length > 0 ? fdel.details.parameters[0].type : AnyType.create(),\n        });\n        delFunction.details.parameters.push({\n            category: ParameterCategory.Simple,\n            name: 'obj',\n            type: propertyObject,\n        });\n        delFunction.details.declaredReturnType = NoneType.createInstance();\n        const delSymbol = Symbol.createWithType(SymbolFlags.ClassMember, delFunction);\n        fields.set('__delete__', delSymbol);\n\n        return propertyObject;\n    }\n\n    // Given a function node and the function type associated with it, this\n    // method search for prior function nodes that are marked as @overload\n    // and creates an OverloadedFunctionType that includes this function and\n    // all previous ones.\n    function addOverloadsToFunctionType(node: FunctionNode, type: FunctionType): Type {\n        let functionDecl: FunctionDeclaration | undefined;\n        const decl = AnalyzerNodeInfo.getDeclaration(node);\n        if (decl) {\n            functionDecl = decl as FunctionDeclaration;\n        }\n        const symbolWithScope = lookUpSymbolRecursive(node, node.name.value, /* honorCodeFlow */ false);\n        if (symbolWithScope) {\n            const decls = symbolWithScope.symbol.getDeclarations();\n\n            // Find this function's declaration.\n            let declIndex = decls.findIndex((decl) => decl === functionDecl);\n            if (declIndex > 0) {\n                const overloadedTypes: FunctionType[] = [type];\n                while (declIndex > 0) {\n                    const decl = decls[declIndex - 1];\n                    if (decl.type !== DeclarationType.Function) {\n                        break;\n                    }\n\n                    const declTypeInfo = getTypeOfFunction(decl.node);\n                    if (!declTypeInfo) {\n                        break;\n                    }\n\n                    if (declTypeInfo.decoratedType.category === TypeCategory.Function) {\n                        if (FunctionType.isOverloaded(declTypeInfo.decoratedType)) {\n                            overloadedTypes.unshift(declTypeInfo.decoratedType);\n                        } else {\n                            break;\n                        }\n                    } else if (declTypeInfo.decoratedType.category === TypeCategory.OverloadedFunction) {\n                        // If the previous declaration was itself an overloaded function,\n                        // copy the last entry out of it.\n                        const lastOverload =\n                            declTypeInfo.decoratedType.overloads[declTypeInfo.decoratedType.overloads.length - 1];\n                        if (FunctionType.isOverloaded(lastOverload)) {\n                            overloadedTypes.unshift(lastOverload);\n                        } else {\n                            break;\n                        }\n                    } else {\n                        break;\n                    }\n\n                    declIndex--;\n                }\n\n                if (overloadedTypes.length > 1) {\n                    // Create a new overloaded type that copies the contents of the previous\n                    // one and adds a new function.\n                    const newOverload = OverloadedFunctionType.create();\n                    newOverload.overloads = overloadedTypes;\n\n                    const prevOverload = overloadedTypes[overloadedTypes.length - 2];\n                    const isPrevOverloadAbstract = FunctionType.isAbstractMethod(prevOverload);\n                    const isCurrentOverloadAbstract = FunctionType.isAbstractMethod(type);\n\n                    if (isPrevOverloadAbstract !== isCurrentOverloadAbstract) {\n                        addDiagnostic(\n                            getFileInfo(node).diagnosticRuleSet.reportGeneralTypeIssues,\n                            DiagnosticRule.reportGeneralTypeIssues,\n                            Localizer.Diagnostic.overloadAbstractMismatch().format({ name: node.name.value }),\n                            node.name\n                        );\n                    }\n\n                    return newOverload;\n                }\n            }\n        }\n\n        return type;\n    }\n\n    function createAsyncFunction(node: FunctionNode, functionType: FunctionType): FunctionType {\n        // Clone the original function and replace its return type with an\n        // Awaitable[<returnType>].\n        const awaitableFunctionType = FunctionType.clone(functionType);\n\n        if (functionType.details.declaredReturnType) {\n            awaitableFunctionType.details.declaredReturnType = createAwaitableReturnType(\n                node,\n                functionType.details.declaredReturnType\n            );\n        }\n\n        // Note that the inferred type, once lazily computed, needs to wrap the\n        // resulting type in an awaitable.\n        awaitableFunctionType.details.flags |= FunctionTypeFlags.WrapReturnTypeInAwait;\n\n        return awaitableFunctionType;\n    }\n\n    function createAwaitableReturnType(node: ParseNode, returnType: Type): Type {\n        let awaitableReturnType: Type | undefined;\n\n        if (isObject(returnType)) {\n            const classType = returnType.classType;\n            if (ClassType.isBuiltIn(classType)) {\n                if (classType.details.name === 'Generator') {\n                    // If the return type is a Generator, change it to an AsyncGenerator.\n                    const asyncGeneratorType = getTypingType(node, 'AsyncGenerator');\n                    if (asyncGeneratorType && isClass(asyncGeneratorType)) {\n                        const typeArgs: Type[] = [];\n                        const generatorTypeArgs = classType.typeArguments;\n                        if (generatorTypeArgs && generatorTypeArgs.length > 0) {\n                            typeArgs.push(generatorTypeArgs[0]);\n                        }\n                        if (generatorTypeArgs && generatorTypeArgs.length > 1) {\n                            typeArgs.push(generatorTypeArgs[1]);\n                        }\n                        awaitableReturnType = ObjectType.create(\n                            ClassType.cloneForSpecialization(\n                                asyncGeneratorType,\n                                typeArgs,\n                                /* isTypeArgumentExplicit */ false\n                            )\n                        );\n                    }\n                } else if (\n                    ['AsyncGenerator', 'AsyncIterator', 'AsyncIterable'].some((name) => name === classType.details.name)\n                ) {\n                    // If it's already an AsyncGenerator, AsyncIterator or AsyncIterable,\n                    // leave it as is.\n                    awaitableReturnType = returnType;\n                }\n            }\n        }\n\n        if (!awaitableReturnType) {\n            // Wrap in a Coroutine, which is a subclass of Awaitable.\n            const coroutineType = getTypingType(node, 'Coroutine');\n            if (coroutineType && isClass(coroutineType)) {\n                // Don't wrap a NoReturn in a Coroutine. Treat it as an Any.\n                if (isNoReturnType(returnType)) {\n                    returnType = AnyType.create();\n                }\n\n                awaitableReturnType = ObjectType.create(\n                    ClassType.cloneForSpecialization(\n                        coroutineType,\n                        [AnyType.create(), AnyType.create(), returnType],\n                        /* isTypeArgumentExplicit */ true\n                    )\n                );\n            } else {\n                awaitableReturnType = UnknownType.create();\n            }\n        }\n\n        return awaitableReturnType;\n    }\n\n    function inferFunctionReturnType(node: FunctionNode, isAbstract: boolean): Type | undefined {\n        // This shouldn't be called if there is a declared return type.\n        const returnAnnotation = node.returnTypeAnnotation || node.functionAnnotationComment?.returnTypeAnnotation;\n        assert(!returnAnnotation);\n\n        // Is this type already cached?\n        let inferredReturnType = readTypeCache(node.suite);\n        if (inferredReturnType) {\n            return inferredReturnType;\n        }\n\n        if (!functionRecursionMap.has(node.id)) {\n            functionRecursionMap.set(node.id, true);\n\n            try {\n                let functionDecl: FunctionDeclaration | undefined;\n                const decl = AnalyzerNodeInfo.getDeclaration(node);\n                if (decl) {\n                    functionDecl = decl as FunctionDeclaration;\n                }\n\n                // Is it a generator?\n                if (functionDecl?.yieldStatements) {\n                    const inferredYieldTypes: Type[] = [];\n                    functionDecl.yieldStatements.forEach((yieldNode) => {\n                        if (isNodeReachable(yieldNode)) {\n                            if (yieldNode.nodeType === ParseNodeType.YieldFrom) {\n                                const iteratorType = getTypeOfExpression(yieldNode.expression).type;\n                                const yieldType = getTypeFromIterable(\n                                    iteratorType,\n                                    /* isAsync */ false,\n                                    yieldNode,\n                                    /* supportGetItem */ false\n                                );\n                                inferredYieldTypes.push(yieldType || UnknownType.create());\n                            } else {\n                                if (yieldNode.expression) {\n                                    const yieldType = getTypeOfExpression(yieldNode.expression).type;\n                                    inferredYieldTypes.push(yieldType || UnknownType.create());\n                                } else {\n                                    inferredYieldTypes.push(NoneType.createInstance());\n                                }\n                            }\n                        }\n                    });\n\n                    if (inferredYieldTypes.length === 0) {\n                        inferredYieldTypes.push(NoneType.createInstance());\n                    }\n                    inferredReturnType = combineTypes(inferredYieldTypes);\n\n                    // Inferred yield types need to be wrapped in a Generator to\n                    // produce the final result.\n                    const generatorType = getTypingType(node, 'Generator');\n                    if (generatorType && isClass(generatorType)) {\n                        inferredReturnType = ObjectType.create(\n                            ClassType.cloneForSpecialization(\n                                generatorType,\n                                [inferredReturnType],\n                                /* isTypeArgumentExplicit */ false\n                            )\n                        );\n                    } else {\n                        inferredReturnType = UnknownType.create();\n                    }\n                } else {\n                    const functionNeverReturns = !isAfterNodeReachable(node);\n                    const implicitlyReturnsNone = isAfterNodeReachable(node.suite);\n\n                    // Infer the return type based on all of the return statements in the function's body.\n                    if (getFileInfo(node).isStubFile) {\n                        // If a return type annotation is missing in a stub file, assume\n                        // it's an \"unknown\" type. In normal source files, we can infer the\n                        // type from the implementation.\n                        inferredReturnType = UnknownType.create();\n                    } else if (functionNeverReturns) {\n                        // If the function always raises and never returns, assume a \"NoReturn\" type.\n                        // Skip this for abstract methods which often are implemented with \"raise\n                        // NotImplementedError()\".\n                        if (isAbstract || methodAlwaysRaisesNotImplemented(functionDecl)) {\n                            inferredReturnType = UnknownType.create();\n                        } else {\n                            const noReturnClass = getTypingType(node, 'NoReturn');\n                            if (noReturnClass && isClass(noReturnClass)) {\n                                inferredReturnType = ObjectType.create(noReturnClass);\n                            } else {\n                                inferredReturnType = UnknownType.create();\n                            }\n                        }\n                    } else {\n                        const inferredReturnTypes: Type[] = [];\n                        if (functionDecl?.returnStatements) {\n                            functionDecl.returnStatements.forEach((returnNode) => {\n                                if (isNodeReachable(returnNode)) {\n                                    if (returnNode.returnExpression) {\n                                        const returnType = getTypeOfExpression(returnNode.returnExpression).type;\n                                        inferredReturnTypes.push(returnType || UnknownType.create());\n                                    } else {\n                                        inferredReturnTypes.push(NoneType.createInstance());\n                                    }\n                                }\n                            });\n                        }\n\n                        if (!functionNeverReturns && implicitlyReturnsNone) {\n                            inferredReturnTypes.push(NoneType.createInstance());\n                        }\n\n                        inferredReturnType = combineTypes(inferredReturnTypes);\n                    }\n                }\n\n                // Remove any unbound values since those would generate an exception\n                // before being returned.\n                inferredReturnType = removeUnboundFromUnion(inferredReturnType);\n\n                writeTypeCache(node.suite, inferredReturnType);\n            } finally {\n                functionRecursionMap.delete(node.id);\n            }\n        }\n\n        return inferredReturnType;\n    }\n\n    // Determines whether the function consists only of a \"raise\" statement\n    // and the exception type raised is a NotImplementedError. This is commonly\n    // used for abstract methods that\n    function methodAlwaysRaisesNotImplemented(functionDecl?: FunctionDeclaration): boolean {\n        if (\n            !functionDecl ||\n            !functionDecl.isMethod ||\n            functionDecl.returnStatements ||\n            functionDecl.yieldStatements ||\n            !functionDecl.raiseStatements\n        ) {\n            return false;\n        }\n\n        for (const raiseStatement of functionDecl.raiseStatements) {\n            if (!raiseStatement.typeExpression || raiseStatement.valueExpression) {\n                return false;\n            }\n            const raiseType = getTypeOfExpression(raiseStatement.typeExpression).type;\n            const classType = isClass(raiseType) ? raiseType : isObject(raiseType) ? raiseType.classType : undefined;\n            if (!classType || !ClassType.isBuiltIn(classType, 'NotImplementedError')) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function evaluateTypesForForStatement(node: ForNode): void {\n        if (readTypeCache(node)) {\n            return;\n        }\n\n        const iteratorType = getTypeOfExpression(node.iterableExpression).type;\n        const iteratedType = getTypeFromIterable(iteratorType, !!node.isAsync, node.iterableExpression, !node.isAsync);\n\n        assignTypeToExpression(node.targetExpression, iteratedType, node.targetExpression);\n\n        writeTypeCache(node, iteratedType);\n    }\n\n    function evaluateTypesForExceptStatement(node: ExceptNode): void {\n        // This should be called only if the except node has a target exception.\n        assert(node.typeExpression !== undefined);\n\n        if (readTypeCache(node)) {\n            return;\n        }\n\n        const exceptionTypes = getTypeOfExpression(node.typeExpression!).type;\n\n        function getExceptionType(exceptionType: Type, errorNode: ParseNode) {\n            if (isAnyOrUnknown(exceptionType)) {\n                return exceptionType;\n            }\n\n            if (isObject(exceptionType)) {\n                exceptionType = transformTypeObjectToClass(exceptionType);\n            }\n\n            if (isClass(exceptionType)) {\n                return ObjectType.create(exceptionType);\n            }\n\n            if (isObject(exceptionType)) {\n                const iterableType = getTypeFromIterable(\n                    exceptionType,\n                    /* isAsync */ false,\n                    errorNode,\n                    /* supportGetItem */ false\n                );\n\n                return doForSubtypes(iterableType, (subtype) => {\n                    if (isAnyOrUnknown(subtype)) {\n                        return subtype;\n                    }\n\n                    const transformedSubtype = transformTypeObjectToClass(subtype);\n                    if (isClass(transformedSubtype)) {\n                        return ObjectType.create(transformedSubtype);\n                    }\n\n                    return UnknownType.create();\n                });\n            }\n\n            return UnknownType.create();\n        }\n\n        const targetType = doForSubtypes(exceptionTypes, (subType) => {\n            // If more than one type was specified for the exception, we'll receive\n            // a specialized tuple object here.\n            const tupleType = getSpecializedTupleType(subType);\n            if (tupleType && tupleType.typeArguments) {\n                const entryTypes = tupleType.typeArguments.map((t) => {\n                    return getExceptionType(t, node.typeExpression!);\n                });\n                return combineTypes(entryTypes);\n            }\n\n            return getExceptionType(subType, node.typeExpression!);\n        });\n\n        if (node.name) {\n            assignTypeToExpression(node.name, targetType);\n        }\n\n        writeTypeCache(node, targetType);\n    }\n\n    function evaluateTypesForWithStatement(node: WithItemNode): void {\n        if (readTypeCache(node)) {\n            return;\n        }\n\n        let exprType = getTypeOfExpression(node.expression).type;\n        const isAsync = node.parent && node.parent.nodeType === ParseNodeType.With && !!node.parent.isAsync;\n\n        if (isOptionalType(exprType)) {\n            const fileInfo = getFileInfo(node);\n            addDiagnostic(\n                fileInfo.diagnosticRuleSet.reportOptionalContextManager,\n                DiagnosticRule.reportOptionalContextManager,\n                Localizer.Diagnostic.noneNotUsableWith(),\n                node.expression\n            );\n            exprType = removeNoneFromUnion(exprType);\n        }\n\n        // Verify that the target has an __enter__ or __aenter__ method defined.\n        const enterMethodName = isAsync ? '__aenter__' : '__enter__';\n        const scopedType = doForSubtypes(exprType, (subtype) => {\n            subtype = makeTypeVarsConcrete(subtype);\n\n            if (isAnyOrUnknown(subtype)) {\n                return subtype;\n            }\n\n            const diag = new DiagnosticAddendum();\n            const additionalHelp = new DiagnosticAddendum();\n\n            if (isObject(subtype)) {\n                const enterType = getTypeFromObjectMember(\n                    node.expression,\n                    subtype,\n                    enterMethodName,\n                    { method: 'get' },\n                    diag,\n                    MemberAccessFlags.None\n                );\n\n                if (enterType) {\n                    let memberReturnType: Type;\n                    if (enterType.category === TypeCategory.Function) {\n                        memberReturnType = getFunctionEffectiveReturnType(enterType);\n                    } else {\n                        memberReturnType = UnknownType.create();\n                    }\n\n                    // For \"async while\", an implicit \"await\" is performed.\n                    if (isAsync) {\n                        memberReturnType = getTypeFromAwaitable(memberReturnType, node);\n                    }\n\n                    return memberReturnType;\n                }\n\n                if (!isAsync) {\n                    const memberType = getTypeFromObjectMember(\n                        node.expression,\n                        subtype,\n                        '__aenter__',\n                        { method: 'get' },\n                        diag,\n                        MemberAccessFlags.None\n                    );\n                    if (memberType) {\n                        additionalHelp.addMessage(Localizer.DiagnosticAddendum.asyncHelp());\n                    }\n                }\n            }\n\n            const fileInfo = getFileInfo(node);\n            addDiagnostic(\n                fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                DiagnosticRule.reportGeneralTypeIssues,\n                Localizer.Diagnostic.typeNotUsableWith().format({ type: printType(subtype), method: enterMethodName }) +\n                    additionalHelp.getString(),\n                node.expression\n            );\n            return UnknownType.create();\n        });\n\n        // Verify that the target has an __exit__ or __aexit__ method defined.\n        const exitMethodName = isAsync ? '__aexit__' : '__exit__';\n        doForSubtypes(exprType, (subtype) => {\n            subtype = makeTypeVarsConcrete(subtype);\n\n            if (isAnyOrUnknown(subtype)) {\n                return undefined;\n            }\n\n            const diag = new DiagnosticAddendum();\n\n            if (isObject(subtype)) {\n                const exitType = getTypeFromObjectMember(\n                    node.expression,\n                    subtype,\n                    exitMethodName,\n                    { method: 'get' },\n                    diag,\n                    MemberAccessFlags.None\n                );\n\n                if (exitType) {\n                    return undefined;\n                }\n            }\n\n            const fileInfo = getFileInfo(node);\n            addDiagnostic(\n                fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                DiagnosticRule.reportGeneralTypeIssues,\n                Localizer.Diagnostic.typeNotUsableWith().format({ type: printType(subtype), method: exitMethodName }),\n                node.expression\n            );\n            return undefined;\n        });\n\n        if (node.target) {\n            assignTypeToExpression(node.target, scopedType, node.target);\n        }\n\n        writeTypeCache(node, scopedType);\n    }\n\n    function evaluateTypesForImportAs(node: ImportAsNode): void {\n        if (readTypeCache(node)) {\n            return;\n        }\n\n        let symbolNameNode: NameNode;\n        if (node.alias) {\n            // The symbol name is defined by the alias.\n            symbolNameNode = node.alias;\n        } else {\n            // There was no alias, so we need to use the first element of\n            // the name parts as the symbol.\n            symbolNameNode = node.module.nameParts[0];\n        }\n\n        if (!symbolNameNode) {\n            // This can happen in certain cases where there are parse errors.\n            return;\n        }\n\n        // Look up the symbol to find the alias declaration.\n        let symbolType = getAliasedSymbolTypeForName(node, symbolNameNode.value) || UnknownType.create();\n\n        // Is there a cached module type associated with this node? If so, use\n        // it instead of the type we just created.\n        const cachedModuleType = readTypeCache(node) as ModuleType;\n        if (cachedModuleType && isModule(cachedModuleType) && symbolType) {\n            if (isTypeSame(symbolType, cachedModuleType)) {\n                symbolType = cachedModuleType;\n            }\n        }\n\n        assignTypeToNameNode(symbolNameNode, symbolType);\n\n        writeTypeCache(node, symbolType);\n    }\n\n    function evaluateTypesForImportFromAs(node: ImportFromAsNode): void {\n        if (readTypeCache(node)) {\n            return;\n        }\n\n        const aliasNode = node.alias || node.name;\n\n        let symbolType = getAliasedSymbolTypeForName(node, aliasNode.value);\n        if (!symbolType) {\n            const parentNode = node.parent as ImportFromNode;\n            assert(parentNode && parentNode.nodeType === ParseNodeType.ImportFrom);\n            assert(!parentNode.isWildcardImport);\n\n            const importInfo = AnalyzerNodeInfo.getImportInfo(parentNode.module);\n            if (importInfo && importInfo.isImportFound && !importInfo.isNativeLib) {\n                const resolvedPath = importInfo.resolvedPaths[importInfo.resolvedPaths.length - 1];\n\n                const importLookupInfo = importLookup(resolvedPath);\n                const fileInfo = getFileInfo(node);\n                let reportError = false;\n\n                // If we were able to resolve the import, report the error as\n                // an unresolved symbol.\n                if (importLookupInfo) {\n                    // Handle PEP 562 support for module-level __getattr__ function,\n                    // introduced in Python 3.7.\n                    if (\n                        fileInfo.executionEnvironment.pythonVersion < PythonVersion.V3_7 ||\n                        !importLookupInfo.symbolTable.get('__getattr__')\n                    ) {\n                        reportError = true;\n                    }\n                } else if (!resolvedPath) {\n                    // This corresponds to the \"from . import a\" form.\n                    reportError = true;\n                }\n\n                if (reportError) {\n                    addDiagnostic(\n                        fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                        DiagnosticRule.reportGeneralTypeIssues,\n                        Localizer.Diagnostic.importSymbolUnknown().format({ name: node.name.value }),\n                        node.name\n                    );\n                }\n            }\n\n            symbolType = UnknownType.create();\n        }\n\n        assignTypeToNameNode(aliasNode, symbolType);\n        writeTypeCache(node, symbolType);\n    }\n\n    function evaluateTypesForImportFrom(node: ImportFromNode): void {\n        if (readTypeCache(node)) {\n            return;\n        }\n\n        // Use the first element of the name parts as the symbol.\n        const symbolNameNode = node.module.nameParts[0];\n\n        // Look up the symbol to find the alias declaration.\n        let symbolType = getAliasedSymbolTypeForName(node, symbolNameNode.value) || UnknownType.create();\n\n        // Is there a cached module type associated with this node? If so, use\n        // it instead of the type we just created.\n        const cachedModuleType = readTypeCache(node) as ModuleType;\n        if (cachedModuleType && isModule(cachedModuleType) && symbolType) {\n            if (isTypeSame(symbolType, cachedModuleType)) {\n                symbolType = cachedModuleType;\n            }\n        }\n\n        assignTypeToNameNode(symbolNameNode, symbolType);\n\n        writeTypeCache(node, symbolType);\n    }\n\n    function getAliasedSymbolTypeForName(\n        node: ImportAsNode | ImportFromAsNode | ImportFromNode,\n        name: string\n    ): Type | undefined {\n        const symbolWithScope = lookUpSymbolRecursive(node, name, /* honorCodeFlow */ true);\n        if (!symbolWithScope) {\n            return undefined;\n        }\n\n        let aliasDecl = symbolWithScope.symbol.getDeclarations().find((decl) => decl.node === node);\n\n        // If we didn't find an exact match, look for any alias associated with\n        // this symbol. In cases where we have multiple ImportAs nodes that share\n        // the same first-part name (e.g. \"import asyncio\" and \"import asyncio.tasks\"),\n        // we may not find the declaration associated with this node.\n        if (!aliasDecl) {\n            aliasDecl = symbolWithScope.symbol.getDeclarations().find((decl) => decl.type === DeclarationType.Alias);\n        }\n\n        if (!aliasDecl) {\n            return undefined;\n        }\n\n        assert(aliasDecl.type === DeclarationType.Alias);\n\n        const resolvedDecl = resolveAliasDeclaration(aliasDecl, /* resolveLocalNames */ true);\n        if (!resolvedDecl) {\n            return resolvedDecl;\n        }\n\n        return getInferredTypeOfDeclaration(aliasDecl);\n    }\n\n    // In some cases, an expression must be evaluated in the context of another\n    // expression or statement that contains it. This contextual evaluation\n    // allows for bidirectional type evaluation.\n    function evaluateTypesForExpressionInContext(node: ExpressionNode): void {\n        let lastContextualExpression = node;\n        let curNode: ParseNode | undefined = node;\n\n        function isContextual(node: ParseNode) {\n            // Parameters are contextual only for lambdas.\n            if (\n                node.nodeType === ParseNodeType.Parameter &&\n                node.parent &&\n                node.parent.nodeType === ParseNodeType.Lambda\n            ) {\n                return true;\n            }\n\n            // Arguments are contextual only for call nodes.\n            if (\n                node.nodeType === ParseNodeType.Argument &&\n                node.parent &&\n                node.parent.nodeType === ParseNodeType.Call\n            ) {\n                return true;\n            }\n\n            return (\n                node.nodeType === ParseNodeType.Call ||\n                node.nodeType === ParseNodeType.Dictionary ||\n                node.nodeType === ParseNodeType.FormatString ||\n                node.nodeType === ParseNodeType.List ||\n                node.nodeType === ParseNodeType.Lambda ||\n                node.nodeType === ParseNodeType.MemberAccess ||\n                node.nodeType === ParseNodeType.Set ||\n                node.nodeType === ParseNodeType.String ||\n                node.nodeType === ParseNodeType.Tuple ||\n                node.nodeType === ParseNodeType.Unpack ||\n                node.nodeType === ParseNodeType.DictionaryKeyEntry ||\n                node.nodeType === ParseNodeType.DictionaryExpandEntry ||\n                node.nodeType === ParseNodeType.ListComprehension\n            );\n        }\n\n        // Scan up the parse tree until we find a non-expression (while\n        // looking for contextual expressions in the process).\n        while (curNode) {\n            const isNodeContextual = isContextual(curNode);\n            if (!isNodeContextual && !isExpressionNode(curNode)) {\n                break;\n            }\n            if (isNodeContextual) {\n                lastContextualExpression = curNode as ExpressionNode;\n            }\n\n            curNode = curNode.parent;\n        }\n\n        const parent = lastContextualExpression.parent!;\n        if (parent.nodeType === ParseNodeType.Assignment) {\n            if (lastContextualExpression === parent.typeAnnotationComment) {\n                getTypeOfAnnotation(\n                    lastContextualExpression,\n                    ParseTreeUtils.isFinalAllowedForAssignmentTarget(parent.leftExpression)\n                );\n            } else {\n                evaluateTypesForAssignmentStatement(parent);\n            }\n            return;\n        }\n\n        if (parent.nodeType === ParseNodeType.AugmentedAssignment) {\n            evaluateTypesForAugmentedAssignment(parent);\n            return;\n        }\n\n        const evaluateTypeAnnotationExpression = (node: TypeAnnotationNode) => {\n            const annotationParent = node.parent;\n            if (annotationParent?.nodeType === ParseNodeType.Assignment && annotationParent.leftExpression === parent) {\n                evaluateTypesForAssignmentStatement(annotationParent);\n            } else {\n                const annotationType = getTypeOfAnnotation(\n                    node.typeAnnotation,\n                    ParseTreeUtils.isFinalAllowedForAssignmentTarget(node.valueExpression)\n                );\n                if (annotationType) {\n                    writeTypeCache(node.valueExpression, annotationType);\n                }\n            }\n        };\n\n        if (parent.nodeType === ParseNodeType.TypeAnnotation) {\n            evaluateTypeAnnotationExpression(parent);\n            return;\n        }\n\n        if (parent.nodeType === ParseNodeType.ModuleName) {\n            // A name within a module name isn't an expression,\n            // so there's nothing we can evaluate here.\n            return;\n        }\n\n        if (parent.nodeType === ParseNodeType.Argument && lastContextualExpression === parent.name) {\n            // A name used to specify a named parameter in an argument isn't an\n            // expression, so there's nothing we can evaluate here.\n            return;\n        }\n\n        if (parent.nodeType === ParseNodeType.Return && parent.returnExpression) {\n            const enclosingFunctionNode = ParseTreeUtils.getEnclosingFunction(node);\n            const declaredReturnType = enclosingFunctionNode\n                ? getFunctionDeclaredReturnType(enclosingFunctionNode)\n                : undefined;\n            getTypeOfExpression(parent.returnExpression, declaredReturnType, EvaluatorFlags.None);\n            return;\n        }\n\n        // If the parent is an expression, we'll evaluate it to provide\n        // the context for its child. If it's not, we'll evaluate the\n        // child directly without any context.\n        const nodeToEvaluate =\n            isExpressionNode(parent) && parent.nodeType !== ParseNodeType.Error\n                ? (parent as ExpressionNode)\n                : lastContextualExpression;\n\n        if (nodeToEvaluate.nodeType === ParseNodeType.TypeAnnotation) {\n            evaluateTypeAnnotationExpression(nodeToEvaluate);\n        } else {\n            getTypeOfExpression(nodeToEvaluate);\n        }\n    }\n\n    function evaluateTypeOfParameter(node: ParameterNode): void {\n        assert(node.name !== undefined);\n\n        // We need to handle lambdas differently from functions because\n        // the former never have parameter type annotations but can\n        // be inferred, whereas the latter sometimes have type annotations\n        // but cannot be inferred.\n        const parent = node.parent!;\n        if (parent.nodeType === ParseNodeType.Lambda) {\n            evaluateTypesForExpressionInContext(parent);\n            return;\n        }\n\n        assert(parent.nodeType === ParseNodeType.Function);\n        const functionNode = parent as FunctionNode;\n\n        const paramIndex = functionNode.parameters.findIndex((param) => param === node);\n        const typeAnnotation = getTypeAnnotationForParameter(functionNode, paramIndex);\n\n        if (typeAnnotation) {\n            writeTypeCache(\n                node.name!,\n                transformVariadicParamType(\n                    node,\n                    node.category,\n                    getTypeOfAnnotation(typeAnnotation, /* allowFinal */ false, /* associateTypeVarsWithScope */ true)\n                )\n            );\n            return;\n        }\n\n        // We may be able to infer the type of the first parameter.\n        if (paramIndex === 0) {\n            const containingClassNode = ParseTreeUtils.getEnclosingClass(functionNode, true);\n            if (containingClassNode) {\n                const classInfo = getTypeOfClass(containingClassNode);\n                if (classInfo) {\n                    const functionFlags = getFunctionFlagsFromDecorators(functionNode, true);\n                    // If the first parameter doesn't have an explicit type annotation,\n                    // provide a type if it's an instance, class or constructor method.\n                    const inferredParamType = inferFirstParamType(\n                        functionFlags,\n                        classInfo.classType,\n                        containingClassNode\n                    );\n                    writeTypeCache(node.name!, inferredParamType || UnknownType.create());\n                    return;\n                }\n            }\n        }\n\n        // We weren't able to infer the input parameter type. Set its\n        // type to unknown.\n        writeTypeCache(node.name!, transformVariadicParamType(node, node.category, UnknownType.create()));\n    }\n\n    // Evaluates the types that are assigned within the statement that contains\n    // the specified parse node. In some cases, a broader statement may need to\n    // be evaluated to provide sufficient context for the type. Evaluated types\n    // are written back to the type cache for later retrieval.\n    function evaluateTypesForStatement(node: ParseNode): void {\n        let curNode: ParseNode | undefined = node;\n\n        while (curNode) {\n            switch (curNode.nodeType) {\n                case ParseNodeType.Assignment: {\n                    // See if the assignment is part of a chain of assignments. If so,\n                    // evaluate the entire chain.\n                    const isInAssignmentChain =\n                        curNode.parent &&\n                        (curNode.parent.nodeType === ParseNodeType.Assignment ||\n                            curNode.parent.nodeType === ParseNodeType.AssignmentExpression ||\n                            curNode.parent.nodeType === ParseNodeType.AugmentedAssignment) &&\n                        curNode.parent.rightExpression === curNode;\n                    if (!isInAssignmentChain) {\n                        evaluateTypesForAssignmentStatement(curNode);\n                        return;\n                    }\n                    break;\n                }\n\n                case ParseNodeType.AssignmentExpression: {\n                    getTypeOfExpression(curNode);\n                    return;\n                }\n\n                case ParseNodeType.AugmentedAssignment: {\n                    evaluateTypesForAugmentedAssignment(curNode);\n                    return;\n                }\n\n                case ParseNodeType.Class: {\n                    getTypeOfClass(curNode);\n                    return;\n                }\n\n                case ParseNodeType.Parameter: {\n                    evaluateTypeOfParameter(curNode);\n                    return;\n                }\n\n                case ParseNodeType.Lambda: {\n                    evaluateTypesForExpressionInContext(curNode);\n                    return;\n                }\n\n                case ParseNodeType.Function: {\n                    getTypeOfFunction(curNode);\n                    return;\n                }\n\n                case ParseNodeType.For: {\n                    evaluateTypesForForStatement(curNode);\n                    return;\n                }\n\n                case ParseNodeType.Except: {\n                    evaluateTypesForExceptStatement(curNode);\n                    return;\n                }\n\n                case ParseNodeType.WithItem: {\n                    evaluateTypesForWithStatement(curNode);\n                    return;\n                }\n\n                case ParseNodeType.ListComprehensionFor: {\n                    const listComprehension = curNode.parent as ListComprehensionNode;\n                    assert(listComprehension.nodeType === ParseNodeType.ListComprehension);\n                    evaluateTypesForExpressionInContext(listComprehension);\n                    return;\n                }\n\n                case ParseNodeType.ImportAs: {\n                    evaluateTypesForImportAs(curNode);\n                    return;\n                }\n\n                case ParseNodeType.ImportFromAs: {\n                    evaluateTypesForImportFromAs(curNode);\n                    return;\n                }\n\n                case ParseNodeType.ImportFrom: {\n                    evaluateTypesForImportFrom(curNode);\n                    return;\n                }\n            }\n\n            curNode = curNode.parent;\n        }\n\n        fail('Unexpected assignment target');\n        return undefined;\n    }\n\n    function getTypeFromWildcardImport(flowNode: FlowWildcardImport, name: string): Type {\n        const importInfo = AnalyzerNodeInfo.getImportInfo(flowNode.node.module);\n        assert(importInfo !== undefined && importInfo.isImportFound);\n        assert(flowNode.node.isWildcardImport);\n\n        const symbolWithScope = lookUpSymbolRecursive(flowNode.node, name, /* honorCodeFlow */ false);\n        assert(symbolWithScope !== undefined);\n        const decls = symbolWithScope!.symbol.getDeclarations();\n        const wildcardDecl = decls.find((decl) => decl.node === flowNode.node);\n\n        if (!wildcardDecl) {\n            return UnknownType.create();\n        }\n\n        return getInferredTypeOfDeclaration(wildcardDecl) || UnknownType.create();\n    }\n\n    // When we're evaluating a call to determine whether it returns NoReturn,\n    // we don't want to do a full type evaluation, which would be expensive\n    // and create circular dependencies in type evaluation. Instead, we do\n    // a best-effort evaluation using only declared types (functions, parameters,\n    // etc.).\n    function getDeclaredCallBaseType(node: ExpressionNode): Type | undefined {\n        if (node.nodeType === ParseNodeType.Name) {\n            const symbolWithScope = lookUpSymbolRecursive(node, node.value, /* honorCodeFlow */ false);\n\n            if (!symbolWithScope) {\n                return undefined;\n            }\n\n            const symbol = symbolWithScope.symbol;\n            const type = getDeclaredTypeOfSymbol(symbol);\n            if (type) {\n                return type;\n            }\n\n            // There was no declared type. Before we give up, see if the\n            // symbol is a function parameter whose value can be inferred\n            // or an imported symbol.\n            const declarations = symbol.getDeclarations();\n            if (declarations.length === 0) {\n                return undefined;\n            }\n\n            const decl = declarations[declarations.length - 1];\n            if (decl.type === DeclarationType.Parameter) {\n                evaluateTypeOfParameter(decl.node);\n                return readTypeCache(decl.node.name!);\n            }\n\n            if (decl.type === DeclarationType.Alias) {\n                return getInferredTypeOfDeclaration(decl);\n            }\n\n            return undefined;\n        }\n\n        if (node.nodeType === ParseNodeType.MemberAccess) {\n            const memberName = node.memberName.value;\n            let baseType = getDeclaredCallBaseType(node.leftExpression);\n            if (!baseType) {\n                return undefined;\n            }\n\n            baseType = makeTypeVarsConcrete(baseType);\n\n            let symbol: Symbol | undefined;\n            if (isModule(baseType)) {\n                symbol = ModuleType.getField(baseType, memberName);\n            } else if (isClass(baseType)) {\n                const classMemberInfo = lookUpClassMember(baseType, memberName);\n                symbol = classMemberInfo ? classMemberInfo.symbol : undefined;\n            } else if (isObject(baseType)) {\n                const classMemberInfo = lookUpClassMember(baseType.classType, memberName);\n                symbol = classMemberInfo ? classMemberInfo.symbol : undefined;\n            }\n\n            if (!symbol) {\n                return undefined;\n            }\n\n            return getDeclaredTypeOfSymbol(symbol);\n        }\n\n        return undefined;\n    }\n\n    // Determines whether a call never returns without fully evaluating its type.\n    function isCallNoReturn(node: CallNode) {\n        // See if this information is cached already.\n        if (callIsNoReturnCache.has(node.id)) {\n            return callIsNoReturnCache.get(node.id);\n        }\n\n        // Initially set to false to avoid infinite recursion.\n        callIsNoReturnCache.set(node.id, false);\n\n        let callIsNoReturn = false;\n\n        // Evaluate the call base type.\n        const callType = getDeclaredCallBaseType(node.leftExpression);\n        if (callType) {\n            // We assume here that no constructors or __call__ methods\n            // will be inferred \"no return\" types, so we can restrict\n            // our check to functions.\n            let functionType: FunctionType | undefined;\n            if (callType.category === TypeCategory.Function) {\n                functionType = callType;\n            } else if (callType.category === TypeCategory.OverloadedFunction) {\n                // Use the last overload, which should be the most general.\n                const overloadedFunction = callType;\n                functionType = overloadedFunction.overloads[overloadedFunction.overloads.length - 1];\n            }\n\n            if (functionType && !FunctionType.isAsync(functionType)) {\n                if (functionType.details.declaredReturnType) {\n                    callIsNoReturn = isNoReturnType(functionType.details.declaredReturnType);\n                } else if (functionType.inferredReturnType) {\n                    // If the inferred return type has already been lazily\n                    // evaluated, use it.\n                    callIsNoReturn = isNoReturnType(functionType.inferredReturnType);\n                } else if (functionType.details.declaration) {\n                    // If the function has yield expressions, it's a generator, and\n                    // we'll assume the yield statements are reachable. Also, don't\n                    // infer a \"no return\" type for abstract methods.\n                    if (\n                        !functionType.details.declaration.yieldStatements &&\n                        !FunctionType.isAbstractMethod(functionType) &&\n                        !FunctionType.isStubDefinition(functionType) &&\n                        !FunctionType.isPyTypedDefinition(functionType)\n                    ) {\n                        callIsNoReturn = !isAfterNodeReachable(functionType.details.declaration.node);\n                    }\n                }\n            }\n        }\n\n        // Cache the value for next time.\n        callIsNoReturnCache.set(node.id, callIsNoReturn);\n\n        return callIsNoReturn;\n    }\n\n    // Attempts to determine the type of the reference expression at the\n    // point in the code. If the code flow analysis has nothing to say\n    // about that expression, it return undefined.\n    function getFlowTypeOfReference(\n        reference: NameNode | MemberAccessNode,\n        targetSymbolId: number,\n        initialType: Type | undefined\n    ): Type | undefined {\n        // See if this execution scope requires code flow for this reference expression.\n        const referenceKey = createKeyForReference(reference);\n        const executionScope = ParseTreeUtils.getExecutionScopeNode(reference);\n        const codeFlowExpressions = AnalyzerNodeInfo.getCodeFlowExpressions(executionScope);\n\n        assert(codeFlowExpressions !== undefined);\n        if (!codeFlowExpressions!.has(referenceKey)) {\n            return undefined;\n        }\n\n        // Is there an code flow analyzer cached for this execution scope?\n        const executionNode = ParseTreeUtils.getExecutionScopeNode(reference);\n        let analyzer: CodeFlowAnalyzer | undefined;\n\n        if (isNodeInReturnTypeInferenceContext(executionNode)) {\n            // If we're performing the analysis within a temporary\n            // context of a function for purposes of inferring its\n            // return type for a specified set of arguments, use\n            // a temporary analyzer that we'll use only for this context.\n            analyzer = getCodeFlowAnalyzerForReturnTypeInferenceContext();\n        } else {\n            analyzer = codeFlowAnalyzerCache.get(executionNode.id);\n\n            if (!analyzer) {\n                // Allocate a new code flow analyzer.\n                analyzer = createCodeFlowAnalyzer();\n                codeFlowAnalyzerCache.set(executionNode.id, analyzer);\n            }\n        }\n\n        const wasIncompleteTypeMode = incompleteTypeTracker.isIncompleteTypeMode();\n        const codeFlowResult = analyzer.getTypeFromCodeFlow(reference, targetSymbolId, initialType);\n\n        if (codeFlowResult.isIncomplete) {\n            incompleteTypeTracker.enterIncompleteTypeMode();\n        } else if (!wasIncompleteTypeMode) {\n            incompleteTypeTracker.leaveIncompleteTypeMode();\n        }\n\n        return codeFlowResult.type;\n    }\n\n    // Creates a new code flow analyzer that can be used to narrow the types\n    // of the expressions within an execution context. Each code flow analyzer\n    // instance maintains a cache of types it has already determined.\n    function createCodeFlowAnalyzer(): CodeFlowAnalyzer {\n        const flowNodeTypeCacheSet = new Map<string, TypeCache>();\n\n        function getTypeFromCodeFlow(\n            reference: NameNode | MemberAccessNode,\n            targetSymbolId: number,\n            initialType: Type | undefined\n        ): FlowNodeTypeResult {\n            const flowNode = AnalyzerNodeInfo.getFlowNode(reference);\n            const referenceKey = createKeyForReference(reference) + `.${targetSymbolId.toString()}`;\n            let flowNodeTypeCache = flowNodeTypeCacheSet.get(referenceKey);\n            if (!flowNodeTypeCache) {\n                flowNodeTypeCache = new Map<number, CachedType | undefined>();\n                flowNodeTypeCacheSet.set(referenceKey, flowNodeTypeCache);\n            }\n\n            // Caches the type of the flow node in our local cache, keyed by the flow node ID.\n            function setCacheEntry(\n                flowNode: FlowNode,\n                type: Type | undefined,\n                isIncomplete: boolean\n            ): FlowNodeTypeResult {\n                if (!isIncomplete) {\n                    flowIncompleteGeneration++;\n                } else {\n                    const prevEntry = flowNodeTypeCache!.get(flowNode.id);\n                    if (prevEntry === undefined) {\n                        flowIncompleteGeneration++;\n                    } else if (type && (prevEntry as IncompleteType).isIncompleteType) {\n                        const prevIncompleteType = prevEntry as IncompleteType;\n                        if (prevIncompleteType.type && !isTypeSame(prevIncompleteType.type, type)) {\n                            flowIncompleteGeneration++;\n                        }\n                    }\n                }\n\n                // For speculative or incomplete types, we'll create a separate\n                // object. For non-speculative and complete types, we'll store\n                // the type directly.\n                const entry: CachedType | undefined = isIncomplete\n                    ? {\n                          isIncompleteType: true,\n                          type,\n                          incompleteSubtypes: [],\n                          generationCount: flowIncompleteGeneration,\n                      }\n                    : type;\n\n                flowNodeTypeCache!.set(flowNode.id, entry);\n                speculativeTypeTracker.trackEntry(flowNodeTypeCache!, flowNode.id);\n\n                return {\n                    type,\n                    isIncomplete,\n                    generationCount: flowIncompleteGeneration,\n                    incompleteSubtypes: isIncomplete ? [] : undefined,\n                };\n            }\n\n            function setIncompleteSubtype(flowNode: FlowNode, index: number, type: Type | undefined) {\n                const cachedEntry = flowNodeTypeCache!.get(flowNode.id);\n                if (cachedEntry === undefined || !isIncompleteType(cachedEntry)) {\n                    fail('setIncompleteSubtype can be called only on a valid incomplete cache entry');\n                }\n\n                const incompleteEntries = cachedEntry.incompleteSubtypes;\n                if (index < incompleteEntries.length) {\n                    incompleteEntries[index] = type;\n                } else {\n                    assert(incompleteEntries.length === index);\n                    incompleteEntries.push(type);\n                }\n\n                flowIncompleteGeneration++;\n\n                return getCacheEntry(flowNode);\n            }\n\n            function deleteCacheEntry(flowNode: FlowNode) {\n                flowNodeTypeCache!.delete(flowNode.id);\n            }\n\n            function getCacheEntry(flowNode: FlowNode): FlowNodeTypeResult | undefined {\n                if (!flowNodeTypeCache!.has(flowNode.id)) {\n                    return undefined;\n                }\n\n                const cachedEntry = flowNodeTypeCache!.get(flowNode.id);\n                if (cachedEntry === undefined) {\n                    return {\n                        type: cachedEntry,\n                        isIncomplete: false,\n                    };\n                }\n\n                if (!isIncompleteType(cachedEntry)) {\n                    return {\n                        type: cachedEntry,\n                        isIncomplete: false,\n                    };\n                }\n\n                let type = cachedEntry.type;\n\n                if (cachedEntry.incompleteSubtypes.length > 0) {\n                    // Recompute the effective type based on all of the incomplete\n                    // types we've accumulated so far.\n                    const typesToCombine: Type[] = [];\n                    cachedEntry.incompleteSubtypes.forEach((t) => {\n                        if (t) {\n                            typesToCombine.push(t);\n                        }\n                    });\n                    type = typesToCombine.length > 0 ? combineTypes(typesToCombine) : undefined;\n                }\n\n                return {\n                    type,\n                    isIncomplete: true,\n                    incompleteSubtypes: cachedEntry.incompleteSubtypes,\n                    generationCount: cachedEntry.generationCount,\n                };\n            }\n\n            function evaluateAssignmentFlowNode(flowNode: FlowAssignment): Type | undefined {\n                // For function and class nodes, the reference node is the name\n                // node, but we need to use the parent node (the FunctionNode or ClassNode)\n                // to access the decorated type in the type cache.\n                let nodeForCacheLookup: ParseNode = flowNode.node;\n                const parentNode = flowNode.node.parent;\n                if (parentNode) {\n                    if (parentNode.nodeType === ParseNodeType.Function || parentNode.nodeType === ParseNodeType.Class) {\n                        nodeForCacheLookup = parentNode;\n                    }\n                }\n\n                let cachedType = readTypeCache(nodeForCacheLookup);\n                if (!cachedType) {\n                    // There is no cached type for this expression, so we need to\n                    // evaluate it.\n                    evaluateTypesForStatement(flowNode.node);\n                    cachedType = readTypeCache(nodeForCacheLookup);\n                }\n\n                return cachedType;\n            }\n\n            // If this flow has no knowledge of the target expression, it returns undefined.\n            // If the start flow node for this scope is reachable, the typeAtStart value is\n            // returned.\n            function getTypeFromFlowNode(\n                flowNode: FlowNode,\n                reference: NameNode | MemberAccessNode,\n                targetSymbolId: number,\n                initialType: Type | undefined\n            ): FlowNodeTypeResult {\n                let curFlowNode = flowNode;\n\n                // This is a frequently-called routine, so it's a good place to call\n                // the cancellation check. If the operation is canceled, an exception\n                // will be thrown at this point.\n                checkForCancellation();\n\n                while (true) {\n                    // Have we already been here? If so, use the cached value.\n                    const cachedEntry = getCacheEntry(curFlowNode);\n                    if (cachedEntry) {\n                        // If the cached entry is incomplete, we can use it only if nothing\n                        // has changed that may cause the previously-reported incomplete type to change.\n                        if (!cachedEntry.isIncomplete || cachedEntry.generationCount === flowIncompleteGeneration) {\n                            return cachedEntry;\n                        }\n                    }\n\n                    if (curFlowNode.flags & FlowFlags.Unreachable) {\n                        // We can get here if there are nodes in a compound logical expression\n                        // (e.g. \"False and x\") that are never executed but are evaluated.\n                        // The type doesn't matter in this case.\n                        return setCacheEntry(curFlowNode, undefined, /* isIncomplete */ false);\n                    }\n\n                    if (curFlowNode.flags & FlowFlags.Call) {\n                        const callFlowNode = curFlowNode as FlowCall;\n\n                        // If this function returns a \"NoReturn\" type, that means\n                        // it always raises an exception or otherwise doesn't return,\n                        // so we can assume that the code before this is unreachable.\n                        if (isCallNoReturn(callFlowNode.node)) {\n                            return setCacheEntry(curFlowNode, undefined, /* isIncomplete */ false);\n                        }\n\n                        curFlowNode = callFlowNode.antecedent;\n                        continue;\n                    }\n\n                    if (curFlowNode.flags & FlowFlags.Assignment) {\n                        const assignmentFlowNode = curFlowNode as FlowAssignment;\n                        // Are we targeting the same symbol? We need to do this extra check because the same\n                        // symbol name might refer to different symbols in different scopes (e.g. a list\n                        // comprehension introduces a new scope).\n                        if (\n                            targetSymbolId === assignmentFlowNode.targetSymbolId &&\n                            ParseTreeUtils.isMatchingExpression(reference, assignmentFlowNode.node)\n                        ) {\n                            // Is this a special \"unbind\" assignment? If so,\n                            // we can handle it immediately without any further evaluation.\n                            if (curFlowNode.flags & FlowFlags.Unbind) {\n                                return setCacheEntry(curFlowNode, UnboundType.create(), /* isIncomplete */ false);\n                            }\n\n                            // If there was a cache entry already, that means we hit a recursive\n                            // case (something like \"int: int = 4\"). Avoid infinite recursion\n                            // by returning an undefined type.\n                            if (cachedEntry) {\n                                return { type: undefined, isIncomplete: true };\n                            }\n\n                            // Set the cache entry to undefined before evaluating the\n                            // expression in case it depends on itself.\n                            setCacheEntry(curFlowNode, undefined, /* isIncomplete */ true);\n                            const flowType = evaluateAssignmentFlowNode(assignmentFlowNode);\n                            return setCacheEntry(curFlowNode, flowType, /* isIncomplete */ false);\n                        }\n\n                        curFlowNode = assignmentFlowNode.antecedent;\n                        continue;\n                    }\n\n                    if (curFlowNode.flags & FlowFlags.AssignmentAlias) {\n                        const aliasFlowNode = curFlowNode as FlowAssignmentAlias;\n\n                        // If the target symbol ID matches, replace with its alias\n                        // and continue to traverse the code flow graph.\n                        if (targetSymbolId === aliasFlowNode.targetSymbolId) {\n                            targetSymbolId = aliasFlowNode.aliasSymbolId;\n                        }\n                        curFlowNode = aliasFlowNode.antecedent;\n                        continue;\n                    }\n\n                    if (curFlowNode.flags & FlowFlags.BranchLabel) {\n                        const labelNode = curFlowNode as FlowLabel;\n                        const typesToCombine: Type[] = [];\n\n                        let sawIncomplete = false;\n\n                        labelNode.antecedents.forEach((antecedent) => {\n                            const flowTypeResult = getTypeFromFlowNode(\n                                antecedent,\n                                reference,\n                                targetSymbolId,\n                                initialType\n                            );\n\n                            if (flowTypeResult.isIncomplete) {\n                                sawIncomplete = true;\n                            }\n\n                            if (flowTypeResult.type) {\n                                typesToCombine.push(flowTypeResult.type);\n                            }\n                        });\n\n                        const effectiveType = combineTypes(typesToCombine);\n                        return setCacheEntry(curFlowNode, effectiveType, sawIncomplete);\n                    }\n\n                    if (curFlowNode.flags & FlowFlags.LoopLabel) {\n                        const labelNode = curFlowNode as FlowLabel;\n\n                        let firstWasIncomplete = false;\n                        let isFirstTimeInLoop = false;\n\n                        // See if we've been here before. If so, there will be an incomplete cache entry.\n                        let cacheEntry = getCacheEntry(curFlowNode);\n                        if (cacheEntry === undefined) {\n                            // We haven't been here before, so create a new incomplete cache entry.\n                            isFirstTimeInLoop = true;\n                            cacheEntry = setCacheEntry(curFlowNode, undefined, /* isIncomplete */ true);\n                        }\n\n                        labelNode.antecedents.forEach((antecedent, index) => {\n                            // Have we already been here? If so, there will be an entry\n                            // for this index, and we can use the type that was already\n                            // computed.\n                            if (index >= cacheEntry!.incompleteSubtypes!.length) {\n                                // Set the incomplete type for this index to undefined to prevent\n                                // infinite recursion. We'll set it to the computed value below.\n                                cacheEntry = setIncompleteSubtype(curFlowNode, index, undefined);\n                                const flowTypeResult = getTypeFromFlowNode(\n                                    antecedent,\n                                    reference,\n                                    targetSymbolId,\n                                    initialType\n                                );\n\n                                if (flowTypeResult.isIncomplete && index === 0) {\n                                    firstWasIncomplete = true;\n                                }\n\n                                cacheEntry = setIncompleteSubtype(curFlowNode, index, flowTypeResult.type);\n                            }\n                        });\n\n                        if (!isFirstTimeInLoop) {\n                            // This was not the first time through the loop, so we are recursively trying\n                            // to resolve other parts of the incomplete type. It will be marked complete\n                            // once the stack pops back up to the first caller.\n                            return cacheEntry;\n                        }\n\n                        // The result is incomplete only if the first antecedent (the edge\n                        // that feeds the loop) is incomplete.\n                        if (firstWasIncomplete) {\n                            deleteCacheEntry(curFlowNode);\n                            return { type: cacheEntry!.type, isIncomplete: true };\n                        }\n\n                        // We have made it all the way through all the antecedents, and we can\n                        // mark the type as complete.\n                        return setCacheEntry(curFlowNode, cacheEntry!.type, /* isIncomplete */ false);\n                    }\n\n                    if (curFlowNode.flags & (FlowFlags.TrueCondition | FlowFlags.FalseCondition)) {\n                        const conditionalFlowNode = curFlowNode as FlowCondition;\n                        const typeNarrowingCallback = getTypeNarrowingCallback(reference, conditionalFlowNode);\n                        if (typeNarrowingCallback) {\n                            const flowTypeResult = getTypeFromFlowNode(\n                                conditionalFlowNode.antecedent,\n                                reference,\n                                targetSymbolId,\n                                initialType\n                            );\n                            let flowType = flowTypeResult.type;\n                            if (flowType) {\n                                flowType = typeNarrowingCallback(flowType);\n                            }\n\n                            return setCacheEntry(curFlowNode, flowType, flowTypeResult.isIncomplete);\n                        }\n\n                        curFlowNode = conditionalFlowNode.antecedent;\n                        continue;\n                    }\n\n                    if (curFlowNode.flags & FlowFlags.PreFinallyGate) {\n                        const preFinallyFlowNode = curFlowNode as FlowPreFinallyGate;\n                        if (preFinallyFlowNode.isGateClosed) {\n                            return { type: undefined, isIncomplete: false };\n                        }\n                        curFlowNode = preFinallyFlowNode.antecedent;\n                        continue;\n                    }\n\n                    if (curFlowNode.flags & FlowFlags.PostFinally) {\n                        const postFinallyFlowNode = curFlowNode as FlowPostFinally;\n                        const wasGateClosed = postFinallyFlowNode.preFinallyGate.isGateClosed;\n                        try {\n                            postFinallyFlowNode.preFinallyGate.isGateClosed = true;\n                            const flowTypeResult = getTypeFromFlowNode(\n                                postFinallyFlowNode.antecedent,\n                                reference,\n                                targetSymbolId,\n                                initialType\n                            );\n\n                            // If the type is incomplete, don't write back to the cache.\n                            return flowTypeResult.isIncomplete\n                                ? flowTypeResult\n                                : setCacheEntry(curFlowNode, flowTypeResult.type, /* isIncomplete */ false);\n                        } finally {\n                            postFinallyFlowNode.preFinallyGate.isGateClosed = wasGateClosed;\n                        }\n                    }\n\n                    if (curFlowNode.flags & FlowFlags.Start) {\n                        return setCacheEntry(curFlowNode, initialType, /* isIncomplete */ false);\n                    }\n\n                    if (curFlowNode.flags & FlowFlags.WildcardImport) {\n                        const wildcardImportFlowNode = curFlowNode as FlowWildcardImport;\n                        if (reference.nodeType === ParseNodeType.Name) {\n                            const nameValue = reference.value;\n                            if (wildcardImportFlowNode.names.some((name) => name === nameValue)) {\n                                const type = getTypeFromWildcardImport(wildcardImportFlowNode, nameValue);\n                                return setCacheEntry(curFlowNode, type, /* isIncomplete */ false);\n                            }\n                        }\n\n                        curFlowNode = wildcardImportFlowNode.antecedent;\n                        continue;\n                    }\n\n                    // We shouldn't get here.\n                    fail('Unexpected flow node flags');\n                    return setCacheEntry(curFlowNode, undefined, /* isIncomplete */ false);\n                }\n            }\n\n            if (!flowNode) {\n                // This should happen only in cases where we're evaluating\n                // parse nodes that are created after the initial parse\n                // (namely, string literals that are used for forward\n                // referenced types).\n                return {\n                    type: initialType,\n                    isIncomplete: false,\n                };\n            }\n\n            return getTypeFromFlowNode(flowNode, reference, targetSymbolId, initialType);\n        }\n\n        return {\n            getTypeFromCodeFlow,\n        };\n    }\n\n    // Determines whether the specified flowNode can be reached by any\n    // control flow path within the execution context. If sourceFlowNode\n    // is specified, it returns true only if at least one control flow\n    // path passes through sourceFlowNode.\n    function isFlowNodeReachable(flowNode: FlowNode, sourceFlowNode?: FlowNode): boolean {\n        const visitedFlowNodeMap = new Map<number, true>();\n\n        function isFlowNodeReachableRecursive(flowNode: FlowNode, sourceFlowNode: FlowNode | undefined): boolean {\n            let curFlowNode = flowNode;\n\n            while (true) {\n                // If we've already visited this node, we can assume\n                // it wasn't reachable.\n                if (visitedFlowNodeMap.has(curFlowNode.id)) {\n                    return false;\n                }\n\n                // Note that we've been here before.\n                visitedFlowNodeMap.set(curFlowNode.id, true);\n\n                if (curFlowNode.flags & FlowFlags.Unreachable) {\n                    return false;\n                }\n\n                if (curFlowNode === sourceFlowNode) {\n                    return true;\n                }\n\n                if (curFlowNode.flags & FlowFlags.Call) {\n                    const callFlowNode = curFlowNode as FlowCall;\n\n                    // If we're determining whether a specified source flow node is\n                    // reachable, don't take into consideration possible \"no return\"\n                    // calls.\n                    if (sourceFlowNode === undefined) {\n                        // If this function returns a \"NoReturn\" type, that means\n                        // it always raises an exception or otherwise doesn't return,\n                        // so we can assume that the code before this is unreachable.\n                        if (isCallNoReturn(callFlowNode.node)) {\n                            return false;\n                        }\n                    }\n\n                    curFlowNode = callFlowNode.antecedent;\n                    continue;\n                }\n\n                if (curFlowNode.flags & FlowFlags.Assignment) {\n                    const assignmentFlowNode = curFlowNode as FlowAssignment;\n                    curFlowNode = assignmentFlowNode.antecedent;\n                    continue;\n                }\n\n                if (curFlowNode.flags & FlowFlags.AssignmentAlias) {\n                    const aliasFlowNode = curFlowNode as FlowAssignmentAlias;\n                    curFlowNode = aliasFlowNode.antecedent;\n                    continue;\n                }\n\n                if (curFlowNode.flags & (FlowFlags.BranchLabel | FlowFlags.LoopLabel)) {\n                    const labelNode = curFlowNode as FlowLabel;\n                    for (const antecedent of labelNode.antecedents) {\n                        if (isFlowNodeReachableRecursive(antecedent, sourceFlowNode)) {\n                            return true;\n                        }\n                    }\n                    return false;\n                }\n\n                if (curFlowNode.flags & (FlowFlags.TrueCondition | FlowFlags.FalseCondition)) {\n                    const conditionalFlowNode = curFlowNode as FlowCondition;\n                    curFlowNode = conditionalFlowNode.antecedent;\n                    continue;\n                }\n\n                if (curFlowNode.flags & FlowFlags.PreFinallyGate) {\n                    const preFinallyFlowNode = curFlowNode as FlowPreFinallyGate;\n                    if (preFinallyFlowNode.isGateClosed) {\n                        return false;\n                    }\n                    curFlowNode = preFinallyFlowNode.antecedent;\n                    continue;\n                }\n\n                if (curFlowNode.flags & FlowFlags.PostFinally) {\n                    const postFinallyFlowNode = curFlowNode as FlowPostFinally;\n                    const wasGateClosed = postFinallyFlowNode.preFinallyGate.isGateClosed;\n\n                    try {\n                        postFinallyFlowNode.preFinallyGate.isGateClosed = true;\n                        return isFlowNodeReachableRecursive(postFinallyFlowNode.antecedent, sourceFlowNode);\n                    } finally {\n                        postFinallyFlowNode.preFinallyGate.isGateClosed = wasGateClosed;\n                    }\n                }\n\n                if (curFlowNode.flags & FlowFlags.Start) {\n                    // If we hit the start but were looking for a particular source flow\n                    // node, return false. Otherwise, the start is what we're looking for.\n                    return sourceFlowNode ? false : true;\n                }\n\n                if (curFlowNode.flags & FlowFlags.WildcardImport) {\n                    const wildcardImportFlowNode = curFlowNode as FlowWildcardImport;\n                    curFlowNode = wildcardImportFlowNode.antecedent;\n                    continue;\n                }\n\n                // We shouldn't get here.\n                fail('Unexpected flow node flags');\n                return false;\n            }\n        }\n\n        // Protect against infinite recursion.\n        if (isReachableRecursionMap.has(flowNode.id)) {\n            return true;\n        }\n        isReachableRecursionMap.set(flowNode.id, true);\n\n        try {\n            return isFlowNodeReachableRecursive(flowNode, sourceFlowNode);\n        } finally {\n            isReachableRecursionMap.delete(flowNode.id);\n        }\n    }\n\n    // Given a reference expression and a flow node, returns a callback that\n    // can be used to narrow the type described by the target expression.\n    // If the specified flow node is not associated with the target expression,\n    // it returns undefined.\n    function getTypeNarrowingCallback(\n        reference: ExpressionNode,\n        flowNode: FlowCondition\n    ): TypeNarrowingCallback | undefined {\n        let testExpression = flowNode.expression;\n        const isPositiveTest = !!(flowNode.flags & FlowFlags.TrueCondition);\n\n        if (testExpression.nodeType === ParseNodeType.AssignmentExpression) {\n            if (ParseTreeUtils.isMatchingExpression(reference, testExpression.rightExpression)) {\n                testExpression = testExpression.rightExpression;\n            } else if (ParseTreeUtils.isMatchingExpression(reference, testExpression.name)) {\n                testExpression = testExpression.name;\n            }\n        }\n\n        if (testExpression.nodeType === ParseNodeType.BinaryOperation) {\n            const isOrIsNotOperator =\n                testExpression.operator === OperatorType.Is || testExpression.operator === OperatorType.IsNot;\n            const equalsOrNotEqualsOperator =\n                testExpression.operator === OperatorType.Equals || testExpression.operator === OperatorType.NotEquals;\n\n            if (isOrIsNotOperator || equalsOrNotEqualsOperator) {\n                // Invert the \"isPositiveTest\" value if this is an \"is not\" operation.\n                const adjIsPositiveTest =\n                    testExpression.operator === OperatorType.Is || testExpression.operator === OperatorType.Equals\n                        ? isPositiveTest\n                        : !isPositiveTest;\n\n                // Look for \"X is None\", \"X is not None\", \"X == None\", and \"X != None\".\n                // These are commonly-used patterns used in control flow.\n                if (\n                    testExpression.rightExpression.nodeType === ParseNodeType.Constant &&\n                    testExpression.rightExpression.constType === KeywordType.None\n                ) {\n                    // Allow the LHS to be either a simple expression or an assignment\n                    // expression that assigns to a simple name.\n                    let leftExpression = testExpression.leftExpression;\n                    if (leftExpression.nodeType === ParseNodeType.AssignmentExpression) {\n                        leftExpression = leftExpression.name;\n                    }\n\n                    if (ParseTreeUtils.isMatchingExpression(reference, leftExpression)) {\n                        // Narrow the type by filtering on \"None\".\n                        return (type: Type) => {\n                            if (type.category === TypeCategory.Union) {\n                                const remainingTypes = type.subtypes.filter((t) => {\n                                    if (isAnyOrUnknown(t)) {\n                                        // We need to assume that \"Any\" is always both None and not None,\n                                        // so it matches regardless of whether the test is positive or negative.\n                                        return true;\n                                    }\n\n                                    // See if it's a match for None.\n                                    return isNone(t) === adjIsPositiveTest;\n                                });\n\n                                return combineTypes(remainingTypes);\n                            } else if (isNone(type)) {\n                                if (!adjIsPositiveTest) {\n                                    // Use a \"Never\" type (which is a special form\n                                    // of None) to indicate that the condition will\n                                    // always evaluate to false.\n                                    return NeverType.create();\n                                }\n                            }\n\n                            return type;\n                        };\n                    }\n                }\n\n                // Look for \"type(X) is Y\" or \"type(X) is not Y\".\n                if (isOrIsNotOperator && testExpression.leftExpression.nodeType === ParseNodeType.Call) {\n                    const callType = getTypeOfExpression(testExpression.leftExpression.leftExpression).type;\n                    if (\n                        isClass(callType) &&\n                        ClassType.isBuiltIn(callType, 'type') &&\n                        testExpression.leftExpression.arguments.length === 1 &&\n                        testExpression.leftExpression.arguments[0].argumentCategory === ArgumentCategory.Simple\n                    ) {\n                        const arg0Expr = testExpression.leftExpression.arguments[0].valueExpression;\n                        if (ParseTreeUtils.isMatchingExpression(reference, arg0Expr)) {\n                            const classType = getTypeOfExpression(testExpression.rightExpression).type;\n                            if (isClass(classType)) {\n                                return (type: Type) => {\n                                    // Narrow the type based on whether the type matches the specified type.\n                                    return doForSubtypes(type, (subtype) => {\n                                        if (isObject(subtype)) {\n                                            const matches = ClassType.isSameGenericClass(subtype.classType, classType);\n                                            if (adjIsPositiveTest) {\n                                                return matches ? subtype : undefined;\n                                            } else {\n                                                return matches ? undefined : subtype;\n                                            }\n                                        } else if (isNone(subtype)) {\n                                            return adjIsPositiveTest ? undefined : subtype;\n                                        }\n\n                                        return subtype;\n                                    });\n                                };\n                            }\n                        }\n                    }\n                }\n\n                // Look for \"X is Y\" or \"X is not Y\" where Y is a an enum.\n                if (isOrIsNotOperator) {\n                    if (ParseTreeUtils.isMatchingExpression(reference, testExpression.leftExpression)) {\n                        const rightType = getTypeOfExpression(testExpression.rightExpression).type;\n                        if (\n                            isObject(rightType) &&\n                            ClassType.isEnumClass(rightType.classType) &&\n                            rightType.classType.literalValue !== undefined\n                        ) {\n                            return (type: Type) => {\n                                return narrowTypeForLiteralComparison(type, rightType, adjIsPositiveTest);\n                            };\n                        }\n                    }\n                }\n\n                if (equalsOrNotEqualsOperator) {\n                    // Look for X == <literal> or X != <literal>\n                    const adjIsPositiveTest =\n                        testExpression.operator === OperatorType.Equals ? isPositiveTest : !isPositiveTest;\n\n                    if (ParseTreeUtils.isMatchingExpression(reference, testExpression.leftExpression)) {\n                        const rightType = getTypeOfExpression(testExpression.rightExpression).type;\n                        if (isObject(rightType) && rightType.classType.literalValue !== undefined) {\n                            return (type: Type) => {\n                                return narrowTypeForLiteralComparison(type, rightType, adjIsPositiveTest);\n                            };\n                        }\n                    }\n\n                    if (ParseTreeUtils.isMatchingExpression(reference, testExpression.rightExpression)) {\n                        const leftType = getTypeOfExpression(testExpression.leftExpression).type;\n                        if (isObject(leftType) && leftType.classType.literalValue !== undefined) {\n                            return (type: Type) => {\n                                return narrowTypeForLiteralComparison(type, leftType, adjIsPositiveTest);\n                            };\n                        }\n                    }\n\n                    // Look for X.Y == <literal> or X.Y != <literal>\n                    if (\n                        testExpression.leftExpression.nodeType === ParseNodeType.MemberAccess &&\n                        ParseTreeUtils.isMatchingExpression(reference, testExpression.leftExpression.leftExpression)\n                    ) {\n                        const rightType = getTypeOfExpression(testExpression.rightExpression).type;\n                        const memberName = testExpression.leftExpression.memberName;\n                        if (isObject(rightType) && rightType.classType.literalValue !== undefined) {\n                            return (type: Type) => {\n                                return narrowTypeForDiscriminatedFieldComparison(\n                                    type,\n                                    memberName.value,\n                                    rightType,\n                                    adjIsPositiveTest\n                                );\n                            };\n                        }\n                    }\n                }\n            }\n\n            if (testExpression.operator === OperatorType.In && isPositiveTest) {\n                if (ParseTreeUtils.isMatchingExpression(reference, testExpression.leftExpression)) {\n                    const rightType = getTypeOfExpression(testExpression.rightExpression).type;\n                    return (type: Type) => {\n                        return narrowTypeForContains(type, rightType);\n                    };\n                }\n            }\n        }\n\n        if (testExpression.nodeType === ParseNodeType.Call) {\n            if (testExpression.leftExpression.nodeType === ParseNodeType.Name) {\n                // Look for \"isinstance(X, Y)\" or \"issubclass(X, Y)\".\n                if (\n                    (testExpression.leftExpression.value === 'isinstance' ||\n                        testExpression.leftExpression.value === 'issubclass') &&\n                    testExpression.arguments.length === 2\n                ) {\n                    // Make sure the first parameter is a supported expression type\n                    // and the second parameter is a valid class type or a tuple\n                    // of valid class types.\n                    const isInstanceCheck = testExpression.leftExpression.value === 'isinstance';\n                    const arg0Expr = testExpression.arguments[0].valueExpression;\n                    const arg1Expr = testExpression.arguments[1].valueExpression;\n                    if (ParseTreeUtils.isMatchingExpression(reference, arg0Expr)) {\n                        const arg1Type = getTypeOfExpression(\n                            arg1Expr,\n                            undefined,\n                            EvaluatorFlags.EvaluateStringLiteralAsType | EvaluatorFlags.ParamSpecDisallowed\n                        ).type;\n                        const classTypeList = getIsInstanceClassTypes(arg1Type);\n                        if (classTypeList) {\n                            return (type: Type) => {\n                                return narrowTypeForIsInstance(type, classTypeList, isInstanceCheck, isPositiveTest);\n                            };\n                        }\n                    }\n                } else if (\n                    testExpression.leftExpression.value === 'callable' &&\n                    testExpression.arguments.length === 1\n                ) {\n                    const arg0Expr = testExpression.arguments[0].valueExpression;\n                    if (ParseTreeUtils.isMatchingExpression(reference, arg0Expr)) {\n                        return (type: Type) => {\n                            return narrowTypeForCallable(type, isPositiveTest, testExpression);\n                        };\n                    }\n                }\n            }\n        }\n\n        if (ParseTreeUtils.isMatchingExpression(reference, testExpression)) {\n            return (type: Type) => {\n                // Narrow the type based on whether the subtype can be true or false.\n                return doForSubtypes(type, (subtype) => {\n                    if (isPositiveTest) {\n                        if (canBeTruthy(subtype)) {\n                            return removeFalsinessFromType(subtype);\n                        }\n                    } else {\n                        if (canBeFalsy(subtype)) {\n                            return removeTruthinessFromType(subtype);\n                        }\n                    }\n                    return undefined;\n                });\n            };\n        }\n\n        return undefined;\n    }\n\n    // The \"isinstance\" and \"issubclass\" calls support two forms - a simple form\n    // that accepts a single class, and a more complex form that accepts a tuple\n    // of classes. This method determines which form and returns a list of classes\n    // or undefined.\n    function getIsInstanceClassTypes(argType: Type): ClassType[] | undefined {\n        if (isClass(argType)) {\n            return [argType];\n        }\n\n        if (isObject(argType)) {\n            const objClass = argType.classType;\n            if (isTupleClass(objClass) && objClass.typeArguments) {\n                let foundNonClassType = false;\n                const classTypeList: ClassType[] = [];\n                objClass.typeArguments.forEach((typeArg) => {\n                    if (isClass(typeArg)) {\n                        classTypeList.push(typeArg);\n                    } else {\n                        foundNonClassType = true;\n                    }\n                });\n\n                if (!foundNonClassType) {\n                    return classTypeList;\n                }\n            }\n        }\n\n        return undefined;\n    }\n\n    // Attempts to narrow a type (make it more constrained) based on a\n    // call to isinstance or issubclass. For example, if the original\n    // type of expression \"x\" is \"Mammal\" and the test expression is\n    // \"isinstance(x, Cow)\", (assuming \"Cow\" is a subclass of \"Mammal\"),\n    // we can conclude that x must be constrained to \"Cow\".\n    function narrowTypeForIsInstance(\n        type: Type,\n        classTypeList: ClassType[],\n        isInstanceCheck: boolean,\n        isPositiveTest: boolean\n    ): Type {\n        let effectiveType = doForSubtypes(type, (subtype) => {\n            return transformTypeObjectToClass(subtype);\n        });\n\n        // Handle bound TypeVar.\n        effectiveType = makeTypeVarsConcrete(effectiveType);\n\n        // Filters the varType by the parameters of the isinstance\n        // and returns the list of types the varType could be after\n        // applying the filter.\n        const filterType = (varType: ClassType): ObjectType[] | ClassType[] => {\n            const filteredTypes: ClassType[] = [];\n\n            let foundSuperclass = false;\n            let isClassRelationshipIndeterminate = false;\n\n            for (const filterType of classTypeList) {\n                const filterIsSuperclass = ClassType.isDerivedFrom(varType, filterType);\n                const filterIsSubclass = ClassType.isDerivedFrom(filterType, varType);\n\n                if (filterIsSuperclass) {\n                    foundSuperclass = true;\n                }\n\n                // Normally, a type should never be both a subclass or a superclass.\n                // This can happen if either of the class types derives from a\n                // class whose type is unknown (e.g. an import failed). We'll\n                // note this case specially so we don't do any narrowing, which\n                // will generate false positives.\n                if (filterIsSubclass && filterIsSuperclass && !ClassType.isSameGenericClass(varType, filterType)) {\n                    isClassRelationshipIndeterminate = true;\n                }\n\n                if (isPositiveTest) {\n                    if (filterIsSuperclass) {\n                        // If the variable type is a subclass of the isinstance\n                        // filter, we haven't learned anything new about the\n                        // variable type.\n                        filteredTypes.push(varType);\n                    } else if (filterIsSubclass) {\n                        // If the variable type is a superclass of the isinstance\n                        // filter, we can narrow the type to the subclass.\n                        filteredTypes.push(filterType);\n                    }\n                }\n            }\n\n            // In the negative case, if one or more of the filters\n            // always match the type (i.e. they are an exact match or\n            // a superclass of the type), then there's nothing left after\n            // the filter is applied. If we didn't find any superclass\n            // match, then the original variable type survives the filter.\n            if (!isPositiveTest) {\n                if (!foundSuperclass || isClassRelationshipIndeterminate) {\n                    filteredTypes.push(varType);\n                }\n            }\n\n            if (!isInstanceCheck) {\n                return filteredTypes;\n            }\n\n            return filteredTypes.map((t) => ObjectType.create(t));\n        };\n\n        if (isInstanceCheck && isObject(effectiveType)) {\n            const filteredType = filterType(effectiveType.classType);\n            return combineTypes(filteredType);\n        } else if (!isInstanceCheck && isClass(effectiveType)) {\n            const filteredType = filterType(effectiveType);\n            return combineTypes(filteredType);\n        } else if (effectiveType.category === TypeCategory.Union) {\n            let remainingTypes: Type[] = [];\n\n            effectiveType.subtypes.forEach((t) => {\n                if (isAnyOrUnknown(t)) {\n                    // Any types always remain for both positive and negative\n                    // checks because we can't say anything about them.\n                    remainingTypes.push(t);\n                } else if (isInstanceCheck && isObject(t)) {\n                    remainingTypes = remainingTypes.concat(filterType(t.classType));\n                } else if (!isInstanceCheck && isClass(t)) {\n                    remainingTypes = remainingTypes.concat(filterType(t));\n                } else {\n                    // All other types are never instances of a class.\n                    if (!isPositiveTest) {\n                        remainingTypes.push(t);\n                    }\n                }\n            });\n\n            return combineTypes(remainingTypes);\n        } else if (isInstanceCheck && isPositiveTest && isAnyOrUnknown(effectiveType)) {\n            // If this is a positive test for isinstance and the effective\n            // type is Any or Unknown, we can assume that the type matches\n            // one of the specified types.\n            type = combineTypes(classTypeList.map((classType) => ObjectType.create(classType)));\n        }\n\n        // Return the original type.\n        return type;\n    }\n\n    // Attempts to narrow a type (make it more constrained) based on an \"in\" or\n    // \"not in\" binary expression.\n    function narrowTypeForContains(referenceType: Type, containerType: Type) {\n        // We support contains narrowing only for certain built-in types that have been specialized.\n        if (!isObject(containerType) || !ClassType.isBuiltIn(containerType.classType)) {\n            return referenceType;\n        }\n        const classType = containerType.classType;\n        const builtInName = classType.details.aliasClass\n            ? classType.details.aliasClass.details.name\n            : classType.details.name;\n\n        if (!['list', 'set', 'frozenset', 'deque'].some((name) => name === builtInName)) {\n            return referenceType;\n        }\n\n        if (!classType.typeArguments || classType.typeArguments.length !== 1) {\n            return referenceType;\n        }\n\n        const typeArg = classType.typeArguments[0];\n        let canNarrow = true;\n\n        const narrowedType = doForSubtypes(referenceType, (subtype) => {\n            if (isAnyOrUnknown(subtype)) {\n                canNarrow = false;\n                return subtype;\n            }\n\n            if (!canAssignType(typeArg, subtype, new DiagnosticAddendum())) {\n                // If the reference type isn't assignable to the element type, we will\n                // assume that the __contains__ method will return false.\n                return undefined;\n            }\n\n            return subtype;\n        });\n\n        return canNarrow ? narrowedType : referenceType;\n    }\n\n    // Attempts to narrow a type (make it more constrained) based on a comparison\n    // (equal or not equal) between a discriminating node that has a declared\n    // literal type to a literal value.\n    function narrowTypeForDiscriminatedFieldComparison(\n        referenceType: Type,\n        memberName: string,\n        literalType: ObjectType,\n        isPositiveTest: boolean\n    ): Type {\n        let canNarrow = true;\n\n        const narrowedType = doForSubtypes(referenceType, (subtype) => {\n            subtype = transformTypeObjectToClass(subtype);\n\n            let memberInfo: ClassMember | undefined;\n            if (isObject(subtype)) {\n                memberInfo = lookUpObjectMember(subtype, memberName);\n            } else if (isClass(subtype)) {\n                memberInfo = lookUpClassMember(subtype, memberName);\n            }\n\n            if (memberInfo && memberInfo.isTypeDeclared) {\n                const memberType = getTypeOfMember(memberInfo);\n\n                if (isLiteralType(memberType, /* allowLiteralUnions */ false)) {\n                    const isAssignable = canAssignType(memberType, literalType, new DiagnosticAddendum());\n                    return isAssignable === isPositiveTest ? subtype : undefined;\n                }\n            }\n\n            canNarrow = false;\n            return subtype;\n        });\n\n        return canNarrow ? narrowedType : referenceType;\n    }\n\n    // Attempts to narrow a type (make it more constrained) based on a comparison\n    // (equal or not equal) to a literal value.\n    function narrowTypeForLiteralComparison(\n        referenceType: Type,\n        literalType: ObjectType,\n        isPositiveTest: boolean\n    ): Type {\n        let canNarrow = true;\n        const narrowedType = doForSubtypes(referenceType, (subtype) => {\n            if (isObject(subtype) && ClassType.isSameGenericClass(literalType.classType, subtype.classType)) {\n                if (subtype.classType.literalValue !== undefined) {\n                    const literalValueMatches = ClassType.isLiteralValueSame(subtype.classType, literalType.classType);\n                    if ((literalValueMatches && !isPositiveTest) || (!literalValueMatches && isPositiveTest)) {\n                        return undefined;\n                    }\n                    return subtype;\n                } else if (isPositiveTest) {\n                    return literalType;\n                } else {\n                    // If we're able to enumerate all possible literal values\n                    // (for bool or enum), we can eliminate all others in a negative test.\n                    const allLiteralTypes = enumerateLiteralsForType(subtype);\n                    if (allLiteralTypes) {\n                        return combineTypes(\n                            allLiteralTypes.filter(\n                                (type) => !ClassType.isLiteralValueSame(type.classType, literalType.classType)\n                            )\n                        );\n                    }\n                }\n            }\n            canNarrow = false;\n            return subtype;\n        });\n\n        return canNarrow ? narrowedType : referenceType;\n    }\n\n    // Attempts to narrow a type (make it more constrained) based on a\n    // call to \"callable\". For example, if the original type of expression \"x\" is\n    // Union[Callable[..., Any], Type[int], int], it would remove the \"int\" because\n    // it's not callable.\n    function narrowTypeForCallable(type: Type, isPositiveTest: boolean, errorNode: ExpressionNode): Type {\n        return doForSubtypes(type, (subtype) => {\n            switch (subtype.category) {\n                case TypeCategory.Function:\n                case TypeCategory.OverloadedFunction:\n                case TypeCategory.Class: {\n                    return isPositiveTest ? subtype : undefined;\n                }\n\n                case TypeCategory.Module: {\n                    return isPositiveTest ? undefined : subtype;\n                }\n\n                case TypeCategory.Object: {\n                    const classFromTypeObject = getClassFromPotentialTypeObject(subtype);\n                    if (classFromTypeObject && isClass(classFromTypeObject)) {\n                        // It's a Type object, which is a class.\n                        return isPositiveTest ? subtype : undefined;\n                    }\n\n                    // See if the object is callable.\n                    const callMemberType = getTypeFromObjectMember(\n                        errorNode,\n                        subtype,\n                        '__call__',\n                        { method: 'get' },\n                        new DiagnosticAddendum(),\n                        MemberAccessFlags.SkipForMethodLookup\n                    );\n                    if (!callMemberType) {\n                        return isPositiveTest ? undefined : subtype;\n                    } else {\n                        return isPositiveTest ? subtype : undefined;\n                    }\n                }\n\n                default: {\n                    // For all other types, we can't determine whether it's\n                    // callable or not, so we can't eliminate them.\n                    return subtype;\n                }\n            }\n        });\n    }\n\n    // Specializes the specified (potentially generic) class type using\n    // the specified type arguments, reporting errors as appropriate.\n    // Returns the specialized type and a boolean indicating whether\n    // the type indicates a class type (true) or an object type (false).\n    function createSpecializedClassType(\n        classType: ClassType,\n        typeArgs: TypeResult[] | undefined,\n        flags: EvaluatorFlags,\n        errorNode: ParseNode\n    ): Type {\n        // Handle the special-case classes that are not defined\n        // in the type stubs.\n        if (ClassType.isSpecialBuiltIn(classType)) {\n            switch (classType.details.name) {\n                case 'Callable': {\n                    return createCallableType(typeArgs);\n                }\n\n                case 'Optional': {\n                    return createOptionalType(errorNode, typeArgs);\n                }\n\n                case 'Type': {\n                    return createSpecialType(classType, typeArgs, 1);\n                }\n\n                case 'ClassVar': {\n                    return createClassVarType(errorNode, typeArgs);\n                }\n\n                case 'Deque':\n                case 'List':\n                case 'FrozenSet':\n                case 'Set': {\n                    return createSpecialType(classType, typeArgs, 1);\n                }\n\n                case 'ChainMap':\n                case 'Dict':\n                case 'DefaultDict': {\n                    return createSpecialType(classType, typeArgs, 2);\n                }\n\n                case 'Protocol': {\n                    return createSpecialType(classType, typeArgs, undefined);\n                }\n\n                case 'Tuple': {\n                    return createSpecialType(classType, typeArgs, undefined);\n                }\n\n                case 'Union': {\n                    return createUnionType(typeArgs);\n                }\n\n                case 'Generic': {\n                    return createGenericType(errorNode, classType, typeArgs);\n                }\n\n                case 'Final': {\n                    return createFinalType(errorNode, typeArgs, flags);\n                }\n\n                case 'Annotated': {\n                    return createAnnotatedType(errorNode, typeArgs);\n                }\n\n                case 'Concatenate': {\n                    return createConcatenateType(errorNode, classType, typeArgs);\n                }\n            }\n        }\n\n        // Handle \"tuple\" specially, since it needs to act like \"Tuple\"\n        // in Python 3.9 and newer.\n        if (ClassType.isBuiltIn(classType, 'tuple')) {\n            return createSpecialType(classType, typeArgs, undefined);\n        }\n\n        let typeArgCount = typeArgs ? typeArgs.length : 0;\n\n        // Make sure the argument list count is correct.\n        const typeParameters = ClassType.getTypeParameters(classType);\n\n        // If there are no type parameters or args, the class is already specialized.\n        // No need to do any more work.\n        if (typeParameters.length === 0 && typeArgCount === 0) {\n            return classType;\n        }\n\n        if (typeArgs && typeArgCount > typeParameters.length) {\n            if (!ClassType.isPartiallyConstructed(classType)) {\n                const fileInfo = getFileInfo(errorNode);\n                if (typeParameters.length === 0) {\n                    addDiagnostic(\n                        fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                        DiagnosticRule.reportGeneralTypeIssues,\n                        Localizer.Diagnostic.typeArgsExpectingNone(),\n                        typeArgs[typeParameters.length].node\n                    );\n                } else {\n                    addDiagnostic(\n                        fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                        DiagnosticRule.reportGeneralTypeIssues,\n                        Localizer.Diagnostic.typeArgsTooMany().format({\n                            name: classType.details.name,\n                            expected: typeParameters.length,\n                            received: typeArgCount,\n                        }),\n                        typeArgs[typeParameters.length].node\n                    );\n                }\n            }\n            typeArgCount = typeParameters.length;\n        } else if (typeArgs && typeArgCount < typeParameters.length) {\n            const fileInfo = getFileInfo(errorNode);\n            addDiagnostic(\n                fileInfo.diagnosticRuleSet.reportMissingTypeArgument,\n                DiagnosticRule.reportMissingTypeArgument,\n                Localizer.Diagnostic.typeArgsTooFew().format({\n                    name: classType.details.name,\n                    expected: typeParameters.length,\n                    received: typeArgCount,\n                }),\n                typeArgs[0].node.parent!\n            );\n        }\n\n        if (typeArgs) {\n            typeArgs.forEach((typeArg) => {\n                // Verify that we didn't receive any inappropriate ellipses or modules.\n                if (isEllipsisType(typeArg.type)) {\n                    addError(Localizer.Diagnostic.ellipsisContext(), typeArg.node);\n                } else if (isModule(typeArg.type)) {\n                    addError(Localizer.Diagnostic.moduleContext(), typeArg.node);\n                }\n            });\n        }\n\n        // Fill in any missing type arguments with Any.\n        const typeArgTypes = typeArgs ? typeArgs.map((t) => convertToInstance(t.type)) : [];\n        const typeParams = ClassType.getTypeParameters(classType);\n        for (let i = typeArgTypes.length; i < typeParams.length; i++) {\n            typeArgTypes.push(getConcreteTypeFromTypeVar(typeParams[i]));\n        }\n\n        typeArgTypes.forEach((typeArgType, index) => {\n            if (index < typeArgCount) {\n                const diag = new DiagnosticAddendum();\n                if (!canAssignToTypeVar(typeParameters[index], typeArgType, diag)) {\n                    const fileInfo = getFileInfo(typeArgs![index].node);\n                    addDiagnostic(\n                        fileInfo.diagnosticRuleSet.reportGeneralTypeIssues,\n                        DiagnosticRule.reportGeneralTypeIssues,\n                        Localizer.Diagnostic.typeVarAssignmentMismatch().format({\n                            type: printType(typeArgType),\n                            name: typeParameters[index].details.name,\n                        }) + diag.getString(),\n                        typeArgs![index].node\n                    );\n                }\n            }\n        });\n\n        const specializedClass = ClassType.cloneForSpecialization(classType, typeArgTypes, typeArgs !== undefined);\n\n        return specializedClass;\n    }\n\n    function getTypeForArgument(arg: FunctionArgument): Type {\n        if (arg.type) {\n            return arg.type;\n        }\n\n        // If there was no defined type provided, there should always\n        // be a value expression from which we can retrieve the type.\n        return getTypeOfExpression(arg.valueExpression!).type;\n    }\n\n    // This function is like getTypeForArgument except that it is\n    // used in cases where the argument is expected to be a type\n    // and therefore follows the normal rules of types (e.g. they\n    // can be forward-declared in stubs, etc.).\n    function getTypeForArgumentExpectingType(\n        arg: FunctionArgument,\n        fileInfo: AnalyzerFileInfo,\n        allowMissingTypeArgs = false\n    ): Type {\n        if (arg.type) {\n            return arg.type;\n        }\n\n        let flags =\n            EvaluatorFlags.ExpectingType |\n            EvaluatorFlags.EvaluateStringLiteralAsType |\n            EvaluatorFlags.ParamSpecDisallowed;\n\n        if (fileInfo.isStubFile) {\n            flags |= EvaluatorFlags.AllowForwardReferences;\n        }\n\n        if (allowMissingTypeArgs) {\n            flags |= EvaluatorFlags.AllowMissingTypeArgs;\n        }\n\n        // If there was no defined type provided, there should always\n        // be a value expression from which we can retrieve the type.\n        return getTypeOfExpression(arg.valueExpression!, undefined, flags).type;\n    }\n\n    function getBuiltInType(node: ParseNode, name: string): Type {\n        const scope = ScopeUtils.getScopeForNode(node);\n        if (scope) {\n            const builtInScope = ScopeUtils.getBuiltInScope(scope);\n            const nameType = builtInScope.lookUpSymbol(name);\n            if (nameType) {\n                return getEffectiveTypeOfSymbol(nameType);\n            }\n        }\n\n        return UnknownType.create();\n    }\n\n    function getBuiltInObject(node: ParseNode, name: string, typeArguments?: Type[]) {\n        const nameType = getBuiltInType(node, name);\n        if (isClass(nameType)) {\n            let classType = nameType;\n            if (typeArguments) {\n                classType = ClassType.cloneForSpecialization(\n                    classType,\n                    typeArguments,\n                    /* isTypeArgumentExplicit */ false\n                );\n            }\n\n            return ObjectType.create(classType);\n        }\n\n        return nameType;\n    }\n\n    function lookUpSymbolRecursive(node: ParseNode, name: string, honorCodeFlow: boolean) {\n        const scope = ScopeUtils.getScopeForNode(node);\n        let symbolWithScope = scope?.lookUpSymbolRecursive(name);\n\n        if (symbolWithScope && honorCodeFlow) {\n            // Filter the declarations based on flow reachability.\n            const decls = symbolWithScope.symbol.getDeclarations().filter((decl) => {\n                if (decl.type !== DeclarationType.Alias) {\n                    // Is the declaration in the same execution scope as the \"usageNode\" node?\n                    const usageScope = ParseTreeUtils.getExecutionScopeNode(node);\n                    const declNode =\n                        decl.type === DeclarationType.Class || decl.type === DeclarationType.Function\n                            ? decl.node.name\n                            : decl.node;\n                    const declScope = ParseTreeUtils.getExecutionScopeNode(declNode);\n                    if (usageScope === declScope) {\n                        if (!isFlowPathBetweenNodes(declNode, node)) {\n                            return false;\n                        }\n                    }\n                }\n\n                return true;\n            });\n\n            // If none of the declarations are reachable from the current node,\n            // search for the symbol in outer scopes.\n            if (decls.length === 0) {\n                if (symbolWithScope.scope.parent) {\n                    symbolWithScope = symbolWithScope.scope.parent.lookUpSymbolRecursive(name);\n                } else {\n                    symbolWithScope = undefined;\n                }\n            }\n        }\n\n        return symbolWithScope;\n    }\n\n    // Disables recording of errors and warnings.\n    function suppressDiagnostics(callback: () => void) {\n        const wasSuppressed = isDiagnosticSuppressed;\n        isDiagnosticSuppressed = true;\n        try {\n            callback();\n        } finally {\n            isDiagnosticSuppressed = wasSuppressed;\n        }\n    }\n\n    // Disables recording of errors and warnings and disables\n    // any caching of types, under the assumption that we're\n    // performing speculative evaluations.\n    function useSpeculativeMode(speculativeNode: ParseNode, callback: () => void) {\n        speculativeTypeTracker.enterSpeculativeContext(speculativeNode);\n\n        try {\n            callback();\n        } finally {\n            speculativeTypeTracker.leaveSpeculativeContext();\n        }\n    }\n\n    // Determines whether the specified node is within a part of the parse tree that\n    // is being \"speculatively\" evaluated. If so, it should not be written to the type\n    // cache, and diagnostics should not be reported for it.\n    function isSpeculativeMode(node: ParseNode | undefined) {\n        const speculativeRootNode = speculativeTypeTracker.getSpeculativeRootNode();\n        if (!speculativeRootNode) {\n            return false;\n        }\n        return node === undefined || ParseTreeUtils.isNodeContainedWithin(node, speculativeRootNode);\n    }\n\n    function disableSpeculativeMode(callback: () => void) {\n        const stack = speculativeTypeTracker.disableSpeculativeMode();\n        try {\n            callback();\n        } finally {\n            speculativeTypeTracker.enableSpeculativeMode(stack);\n        }\n    }\n\n    function getFileInfo(node: ParseNode): AnalyzerFileInfo {\n        while (node.nodeType !== ParseNodeType.Module) {\n            node = node.parent!;\n        }\n        return AnalyzerNodeInfo.getFileInfo(node)!;\n    }\n\n    function getDeclarationFromFunctionNamedParameter(type: FunctionType, paramName: string): Declaration | undefined {\n        if (type.category === TypeCategory.Function) {\n            if (type.details.declaration) {\n                const functionDecl = type.details.declaration;\n                if (functionDecl.type === DeclarationType.Function) {\n                    const functionNode = functionDecl.node;\n                    const functionScope = AnalyzerNodeInfo.getScope(functionNode);\n                    if (functionScope) {\n                        const paramSymbol = functionScope.lookUpSymbol(paramName)!;\n                        if (paramSymbol) {\n                            return paramSymbol\n                                .getDeclarations()\n                                .find((decl) => decl.type === DeclarationType.Parameter);\n                        }\n                    }\n                }\n            }\n        }\n\n        return undefined;\n    }\n\n    function getDeclarationsForNameNode(node: NameNode): Declaration[] | undefined {\n        if (AnalyzerNodeInfo.isCodeUnreachable(node)) {\n            return undefined;\n        }\n\n        const declarations: Declaration[] = [];\n\n        // If the node is part of a \"from X import Y as Z\" statement and the node\n        // is the \"Y\" (non-aliased) name, we need to look up the alias symbol\n        // since the non-aliased name is not in the symbol table.\n        if (\n            node.parent &&\n            node.parent.nodeType === ParseNodeType.ImportFromAs &&\n            node.parent.alias &&\n            node === node.parent.name\n        ) {\n            const scope = ScopeUtils.getScopeForNode(node);\n            if (scope) {\n                // Look up the alias symbol.\n                const symbolInScope = scope.lookUpSymbolRecursive(node.parent.alias.value);\n                if (symbolInScope) {\n                    // The alias could have more decls that don't refer to this import. Filter\n                    // out the one(s) that specifically associated with this import statement.\n                    const declsForThisImport = symbolInScope.symbol.getDeclarations().filter((decl) => {\n                        return decl.type === DeclarationType.Alias && decl.node === node.parent;\n                    });\n\n                    // Make a shallow copy and clear the \"usesLocalName\" field.\n                    const nonLocalDecls = declsForThisImport.map((localDecl) => {\n                        if (localDecl.type === DeclarationType.Alias) {\n                            const nonLocalDecl: AliasDeclaration = { ...localDecl };\n                            nonLocalDecl.usesLocalName = false;\n                            return nonLocalDecl;\n                        }\n                        return localDecl;\n                    });\n\n                    declarations.push(...nonLocalDecls);\n                }\n            }\n        } else if (\n            node.parent &&\n            node.parent.nodeType === ParseNodeType.MemberAccess &&\n            node === node.parent.memberName\n        ) {\n            let baseType = getType(node.parent.leftExpression);\n            if (baseType) {\n                baseType = specializeType(baseType, /* typeVarMap */ undefined);\n                const memberName = node.parent.memberName.value;\n                doForSubtypes(baseType, (subtype) => {\n                    let symbol: Symbol | undefined;\n\n                    if (isClass(subtype)) {\n                        // Try to find a member that has a declared type. If so, that\n                        // overrides any inferred types.\n                        let member = lookUpClassMember(subtype, memberName, ClassMemberLookupFlags.DeclaredTypesOnly);\n                        if (!member) {\n                            member = lookUpClassMember(subtype, memberName);\n                        }\n                        if (member) {\n                            symbol = member.symbol;\n                        }\n                    } else if (isObject(subtype)) {\n                        // Try to find a member that has a declared type. If so, that\n                        // overrides any inferred types.\n                        let member = lookUpObjectMember(subtype, memberName, ClassMemberLookupFlags.DeclaredTypesOnly);\n                        if (!member) {\n                            member = lookUpObjectMember(subtype, memberName);\n                        }\n                        if (member) {\n                            symbol = member.symbol;\n                        }\n                    } else if (isModule(subtype)) {\n                        symbol = ModuleType.getField(subtype, memberName);\n                    }\n\n                    if (symbol) {\n                        // By default, report only the declarations that have type annotations.\n                        // If there are none, then report all of the unannotated declarations,\n                        // which includes every assignment of that symbol.\n                        const typedDecls = symbol.getTypedDeclarations();\n                        if (typedDecls.length > 0) {\n                            declarations.push(...typedDecls);\n                        } else {\n                            declarations.push(...symbol.getDeclarations());\n                        }\n                    }\n\n                    return subtype;\n                });\n            }\n        } else if (node.parent && node.parent.nodeType === ParseNodeType.ModuleName) {\n            const namePartIndex = node.parent.nameParts.findIndex((part) => part === node);\n            const importInfo = AnalyzerNodeInfo.getImportInfo(node.parent);\n            if (\n                namePartIndex >= 0 &&\n                importInfo &&\n                !importInfo.isNativeLib &&\n                namePartIndex < importInfo.resolvedPaths.length\n            ) {\n                if (importInfo.resolvedPaths[namePartIndex]) {\n                    evaluateTypesForStatement(node);\n\n                    // Synthesize an alias declaration for this name part. The only\n                    // time this case is used is for the hover provider.\n                    const aliasDeclaration: AliasDeclaration = {\n                        type: DeclarationType.Alias,\n                        node: undefined!,\n                        path: importInfo.resolvedPaths[namePartIndex],\n                        range: getEmptyRange(),\n                        implicitImports: new Map<string, ModuleLoaderActions>(),\n                        usesLocalName: false,\n                        moduleName: '',\n                    };\n                    declarations.push(aliasDeclaration);\n                }\n            }\n        } else if (node.parent && node.parent.nodeType === ParseNodeType.Argument && node === node.parent.name) {\n            // The target node is the name in a named argument. We need to determine whether\n            // the corresponding named parameter can be determined from the context.\n            const argNode = node.parent;\n            const paramName = node.value;\n            if (argNode.parent && argNode.parent.nodeType === ParseNodeType.Call) {\n                const baseType = getType(argNode.parent.leftExpression);\n\n                if (baseType) {\n                    if (baseType.category === TypeCategory.Function && baseType.details.declaration) {\n                        const paramDecl = getDeclarationFromFunctionNamedParameter(baseType, paramName);\n                        if (paramDecl) {\n                            declarations.push(paramDecl);\n                        }\n                    } else if (isClass(baseType)) {\n                        const initMethodType = getTypeFromObjectMember(\n                            argNode.parent.leftExpression,\n                            ObjectType.create(baseType),\n                            '__init__',\n                            { method: 'get' },\n                            new DiagnosticAddendum(),\n                            MemberAccessFlags.SkipForMethodLookup | MemberAccessFlags.SkipObjectBaseClass\n                        );\n\n                        if (initMethodType && initMethodType.category === TypeCategory.Function) {\n                            const paramDecl = getDeclarationFromFunctionNamedParameter(initMethodType, paramName);\n                            if (paramDecl) {\n                                declarations.push(paramDecl);\n                            } else if (ClassType.isDataClass(baseType)) {\n                                const lookupResults = lookUpClassMember(baseType, paramName);\n                                if (lookupResults) {\n                                    declarations.push(...lookupResults.symbol.getDeclarations());\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        } else {\n            let allowForwardReferences = false;\n\n            // Determine if this node is within a quoted type annotation.\n            if (ParseTreeUtils.isWithinTypeAnnotation(node, !isAnnotationEvaluationPostponed(getFileInfo(node)))) {\n                allowForwardReferences = true;\n            }\n\n            const symbolWithScope = lookUpSymbolRecursive(node, node.value, !allowForwardReferences);\n            if (symbolWithScope) {\n                declarations.push(...symbolWithScope.symbol.getDeclarations());\n            }\n        }\n\n        return declarations;\n    }\n\n    function getTypeForDeclaration(declaration: Declaration): Type | undefined {\n        switch (declaration.type) {\n            case DeclarationType.Intrinsic: {\n                if (declaration.intrinsicType === 'Any') {\n                    return AnyType.create();\n                }\n\n                if (declaration.intrinsicType === 'class') {\n                    const classNode = ParseTreeUtils.getEnclosingClass(declaration.node) as ClassNode;\n                    const classTypeInfo = getTypeOfClass(classNode);\n                    return classTypeInfo ? classTypeInfo.classType : undefined;\n                }\n\n                const strType = getBuiltInObject(declaration.node, 'str');\n                const intType = getBuiltInObject(declaration.node, 'int');\n                if (isObject(intType) && isObject(strType)) {\n                    if (declaration.intrinsicType === 'str') {\n                        return strType;\n                    }\n\n                    if (declaration.intrinsicType === 'int') {\n                        return intType;\n                    }\n\n                    if (declaration.intrinsicType === 'List[str]') {\n                        const listType = getBuiltInType(declaration.node, 'List');\n                        if (isClass(listType)) {\n                            return ObjectType.create(\n                                ClassType.cloneForSpecialization(\n                                    listType,\n                                    [strType],\n                                    /* isTypeArgumentExplicit */ false\n                                )\n                            );\n                        }\n                    }\n\n                    if (declaration.intrinsicType === 'Dict[str, Any]') {\n                        const dictType = getBuiltInType(declaration.node, 'Dict');\n                        if (isClass(dictType)) {\n                            return ObjectType.create(\n                                ClassType.cloneForSpecialization(\n                                    dictType,\n                                    [strType, AnyType.create()],\n                                    /* isTypeArgumentExplicit */ false\n                                )\n                            );\n                        }\n                    }\n                }\n\n                return UnknownType.create();\n            }\n\n            case DeclarationType.Class: {\n                const classTypeInfo = getTypeOfClass(declaration.node);\n                return classTypeInfo ? classTypeInfo.decoratedType : undefined;\n            }\n\n            case DeclarationType.SpecialBuiltInClass: {\n                return getTypeOfAnnotation(declaration.node.typeAnnotation);\n            }\n\n            case DeclarationType.Function: {\n                const functionTypeInfo = getTypeOfFunction(declaration.node);\n                return functionTypeInfo ? functionTypeInfo.decoratedType : undefined;\n            }\n\n            case DeclarationType.Parameter: {\n                let typeAnnotationNode = declaration.node.typeAnnotation || declaration.node.typeAnnotationComment;\n\n                // If there wasn't an annotation, see if the parent function\n                // has a function-level annotation comment that provides\n                // this parameter's annotation type.\n                if (!typeAnnotationNode) {\n                    if (declaration.node.parent?.nodeType === ParseNodeType.Function) {\n                        const functionNode = declaration.node.parent;\n                        if (\n                            functionNode.functionAnnotationComment &&\n                            !functionNode.functionAnnotationComment.isParamListEllipsis\n                        ) {\n                            const paramIndex = functionNode.parameters.findIndex((param) => param === declaration.node);\n                            typeAnnotationNode = getTypeAnnotationForParameter(functionNode, paramIndex);\n                        }\n                    }\n                }\n\n                if (typeAnnotationNode) {\n                    const declaredType = getTypeOfAnnotation(\n                        typeAnnotationNode,\n                        /* allowFinal */ false,\n                        /* associateTypeVarsWithScope */ true\n                    );\n                    return transformVariadicParamType(declaration.node, declaration.node.category, declaredType);\n                }\n\n                return undefined;\n            }\n\n            case DeclarationType.Variable: {\n                const typeAnnotationNode = declaration.typeAnnotationNode;\n\n                if (typeAnnotationNode) {\n                    const typeAliasNode = isDeclaredTypeAlias(typeAnnotationNode)\n                        ? ParseTreeUtils.getTypeAnnotationNode(typeAnnotationNode)\n                        : undefined;\n                    let declaredType = getTypeOfAnnotation(typeAnnotationNode);\n                    if (declaredType) {\n                        // Apply enum transform if appropriate.\n                        if (declaration.node.nodeType === ParseNodeType.Name) {\n                            declaredType = transformTypeForPossibleEnumClass(declaration.node, declaredType);\n                        }\n\n                        if (typeAliasNode && typeAliasNode.valueExpression.nodeType === ParseNodeType.Name) {\n                            declaredType = transformTypeForTypeAlias(declaredType, typeAliasNode.valueExpression);\n                        }\n\n                        return declaredType;\n                    }\n                }\n\n                return undefined;\n            }\n\n            case DeclarationType.Alias: {\n                return undefined;\n            }\n        }\n    }\n\n    function getInferredTypeOfDeclaration(decl: Declaration): Type | undefined {\n        const resolvedDecl = resolveAliasDeclaration(decl, /* resolveLocalNames */ true);\n\n        // We couldn't resolve the alias. Substitute an unknown\n        // type in this case.\n        if (!resolvedDecl) {\n            return UnknownType.create();\n        }\n\n        function applyLoaderActionsToModuleType(\n            moduleType: ModuleType,\n            loaderActions: ModuleLoaderActions,\n            importLookup: ImportLookup\n        ): Type {\n            if (loaderActions.path) {\n                const lookupResults = importLookup(loaderActions.path);\n                if (lookupResults) {\n                    moduleType.fields = lookupResults.symbolTable;\n                    moduleType.docString = lookupResults.docString;\n                } else {\n                    return UnknownType.create();\n                }\n            }\n\n            if (loaderActions.implicitImports) {\n                loaderActions.implicitImports.forEach((implicitImport, name) => {\n                    // Recursively apply loader actions.\n                    const moduleName = moduleType.moduleName ? moduleType.moduleName + '.' + name : '';\n                    const importedModuleType = ModuleType.create(moduleName);\n                    const symbolType = applyLoaderActionsToModuleType(importedModuleType, implicitImport, importLookup);\n\n                    const importedModuleSymbol = Symbol.createWithType(SymbolFlags.None, symbolType);\n                    moduleType.loaderFields.set(name, importedModuleSymbol);\n                });\n            }\n\n            return moduleType;\n        }\n\n        // If the resolved declaration is still an alias, the alias\n        // is pointing at a module, and we need to synthesize a\n        // module type.\n        if (resolvedDecl.type === DeclarationType.Alias) {\n            // Build a module type that corresponds to the declaration and\n            // its associated loader actions.\n            const moduleType = ModuleType.create(resolvedDecl.moduleName);\n            if (resolvedDecl.symbolName) {\n                if (resolvedDecl.submoduleFallback) {\n                    return applyLoaderActionsToModuleType(\n                        moduleType,\n                        resolvedDecl.symbolName && resolvedDecl.submoduleFallback\n                            ? resolvedDecl.submoduleFallback\n                            : resolvedDecl,\n                        importLookup\n                    );\n                }\n            } else {\n                return applyLoaderActionsToModuleType(moduleType, resolvedDecl, importLookup);\n            }\n        }\n\n        const declaredType = getTypeForDeclaration(resolvedDecl);\n        if (declaredType) {\n            return declaredType;\n        }\n\n        // If this is part of a \"py.typed\" package, don't fall back on type inference\n        // unless it's marked Final, is a constant, or is a declared type alias.\n        const fileInfo = getFileInfo(resolvedDecl.node);\n        let isSpeculativeTypeAliasFromPyTypedFile = false;\n        if (fileInfo.isInPyTypedPackage && !fileInfo.isStubFile && evaluatorOptions.disableInferenceForPyTypedSources) {\n            if (resolvedDecl.type !== DeclarationType.Variable) {\n                return UnknownType.create();\n            }\n\n            if (!resolvedDecl.isFinal && !resolvedDecl.isConstant && !resolvedDecl.typeAliasName) {\n                return UnknownType.create();\n            }\n\n            if (resolvedDecl.typeAliasName && !resolvedDecl.typeAliasAnnotation) {\n                isSpeculativeTypeAliasFromPyTypedFile = true;\n            }\n        }\n\n        // If the resolved declaration had no defined type, use the\n        // inferred type for this node.\n        if (resolvedDecl.type === DeclarationType.Parameter) {\n            const cachedValue = readTypeCache(resolvedDecl.node.name!);\n            if (cachedValue) {\n                return cachedValue;\n            }\n            evaluateTypeOfParameter(resolvedDecl.node);\n            return readTypeCache(resolvedDecl.node.name!);\n        }\n\n        if (resolvedDecl.type === DeclarationType.Variable && resolvedDecl.inferredTypeSource) {\n            let inferredType = readTypeCache(resolvedDecl.node);\n\n            if (!inferredType) {\n                // If this is a type alias, evaluate types for the entire assignment\n                // statement rather than just the RHS of the assignment.\n                const typeSource =\n                    resolvedDecl.typeAliasName && resolvedDecl.inferredTypeSource.parent\n                        ? resolvedDecl.inferredTypeSource.parent\n                        : resolvedDecl.inferredTypeSource;\n                evaluateTypesForStatement(typeSource);\n                inferredType = readTypeCache(resolvedDecl.node);\n            }\n\n            if (inferredType && resolvedDecl.node.nodeType === ParseNodeType.Name) {\n                inferredType = transformTypeForPossibleEnumClass(resolvedDecl.node, inferredType);\n            }\n\n            if (inferredType && resolvedDecl.typeAliasName) {\n                inferredType = transformTypeForTypeAlias(inferredType, resolvedDecl.typeAliasName);\n\n                // If this was a speculative type alias (i.e. not declared as a TypeAlias) that\n                // came from a py.typed package and it turned out not to be a real type alias,\n                // return Unknown.\n                if (isSpeculativeTypeAliasFromPyTypedFile && !inferredType.typeAliasInfo) {\n                    return UnknownType.create();\n                }\n            }\n\n            return inferredType;\n        }\n\n        return undefined;\n    }\n\n    // If the specified declaration is an alias declaration that points to a symbol,\n    // it resolves the alias and looks up the symbol, then returns the first declaration\n    // associated with that symbol. It does this recursively if necessary. If a symbol\n    // lookup fails, undefined is returned. If resolveLocalNames is true, the method\n    // resolves aliases through local renames (\"as\" clauses found in import statements).\n    function resolveAliasDeclaration(declaration: Declaration, resolveLocalNames: boolean): Declaration | undefined {\n        return DeclarationUtils.resolveAliasDeclaration(importLookup, declaration, resolveLocalNames);\n    }\n\n    // Returns the type of the symbol. If the type is explicitly declared, that type\n    // is returned. If not, the type is inferred from assignments to the symbol. All\n    // assigned types are evaluated and combined into a union. If a \"usageNode\"\n    // node is specified, only declarations that are outside of the current execution\n    // scope or that are reachable (as determined by code flow analysis) are considered.\n    // This helps in cases where there are cyclical dependencies between symbols.\n    function getEffectiveTypeOfSymbol(symbol: Symbol): Type {\n        return getEffectiveTypeOfSymbolForUsage(symbol).type;\n    }\n\n    function getEffectiveTypeOfSymbolForUsage(symbol: Symbol, usageNode?: NameNode): EffectiveTypeResult {\n        // If there's a declared type, it takes precedence over inferred types.\n        if (symbol.hasTypedDeclarations()) {\n            return {\n                type: getDeclaredTypeOfSymbol(symbol) || UnknownType.create(),\n                isResolutionCyclical: false,\n            };\n        }\n\n        // Infer the type.\n        const typesToCombine: Type[] = [];\n        const isPrivate = symbol.isPrivateMember();\n        const decls = symbol.getDeclarations();\n        const isFinalVar = isFinalVariable(symbol);\n        let isResolutionCyclical = false;\n\n        decls.forEach((decl) => {\n            let considerDecl = true;\n            if (usageNode !== undefined) {\n                if (decl.type !== DeclarationType.Alias) {\n                    // Is the declaration in the same execution scope as the \"usageNode\" node?\n                    const usageScope = ParseTreeUtils.getExecutionScopeNode(usageNode);\n                    const declScope = ParseTreeUtils.getExecutionScopeNode(decl.node);\n                    if (usageScope === declScope) {\n                        if (!isFlowPathBetweenNodes(decl.node, usageNode)) {\n                            considerDecl = false;\n                        }\n                    }\n                }\n            }\n\n            if (considerDecl) {\n                const isTypeAlias = isExplicitTypeAliasDeclaration(decl) || isPossibleTypeAliasDeclaration(decl);\n\n                // If this is a type alias, evaluate it outside of the recursive symbol\n                // resolution check so we can evaluate the full assignment statement.\n                if (\n                    isTypeAlias &&\n                    decl.type === DeclarationType.Variable &&\n                    decl.inferredTypeSource?.parent?.nodeType === ParseNodeType.Assignment\n                ) {\n                    evaluateTypesForAssignmentStatement(decl.inferredTypeSource.parent);\n\n                    if (decl.typeAliasAnnotation) {\n                        // Mark \"TypeAlias\" declaration as accessed.\n                        getTypeOfExpression(decl.typeAliasAnnotation);\n                    }\n                }\n\n                if (pushSymbolResolution(symbol, decl)) {\n                    try {\n                        let type = getInferredTypeOfDeclaration(decl);\n\n                        if (popSymbolResolution(symbol)) {\n                            isResolutionCyclical = true;\n                        }\n\n                        if (type) {\n                            const isConstant = decl.type === DeclarationType.Variable && !!decl.isConstant;\n                            type = stripLiteralTypeArgsValue(type);\n\n                            if (decl.type === DeclarationType.Variable) {\n                                const isEnum = isObject(type) && ClassType.isEnumClass(type.classType);\n\n                                // If the symbol is private or constant, we can retain the literal\n                                // value. Otherwise, strip them off to make the type less specific,\n                                // allowing other values to be assigned to it in subclasses.\n                                if (\n                                    TypeBase.isInstance(type) &&\n                                    !isTypeAlias &&\n                                    !isPrivate &&\n                                    !isConstant &&\n                                    !isEnum &&\n                                    !isFinalVar\n                                ) {\n                                    type = stripLiteralValue(type);\n                                }\n                            }\n                            typesToCombine.push(type);\n                        }\n                    } catch (e) {\n                        // Clean up the stack before rethrowing.\n                        popSymbolResolution(symbol);\n                        throw e;\n                    }\n                } else {\n                    isResolutionCyclical = true;\n                }\n            }\n        });\n\n        if (typesToCombine.length > 0) {\n            return {\n                type: combineTypes(typesToCombine),\n                isResolutionCyclical: false,\n            };\n        }\n\n        return {\n            type: UnboundType.create(),\n            isResolutionCyclical,\n        };\n    }\n\n    function getDeclaredTypeOfSymbol(symbol: Symbol): Type | undefined {\n        const synthesizedType = symbol.getSynthesizedType();\n        if (synthesizedType) {\n            return synthesizedType;\n        }\n\n        const typedDecls = symbol.getTypedDeclarations();\n\n        if (typedDecls.length === 0) {\n            // There was no declaration with a defined type.\n            return undefined;\n        }\n\n        // Start with the last decl. If that's already being resolved,\n        // use the next-to-last decl, etc. This can happen when resolving\n        // property methods. Often the setter method is defined in reference to\n        // the initial property, which defines the getter method with the same\n        // symbol name.\n        let declIndex = typedDecls.length - 1;\n        while (declIndex >= 0) {\n            const decl = typedDecls[declIndex];\n\n            // If there's a partially-constructed type that is allowed\n            // for recursive symbol resolution, return it as the resolved type.\n            const partialType = getSymbolResolutionPartialType(symbol, decl);\n            if (partialType) {\n                return partialType;\n            }\n\n            if (getIndexOfSymbolResolution(symbol, decl) < 0) {\n                if (pushSymbolResolution(symbol, decl)) {\n                    try {\n                        const type = getTypeForDeclaration(decl);\n\n                        if (!popSymbolResolution(symbol)) {\n                            return undefined;\n                        }\n\n                        return type;\n                    } catch (e) {\n                        // Clean up the stack before rethrowing.\n                        popSymbolResolution(symbol);\n                        throw e;\n                    }\n                }\n\n                break;\n            }\n\n            declIndex--;\n        }\n\n        return undefined;\n    }\n\n    // Returns the return type of the function. If the type is explicitly provided in\n    // a type annotation, that type is returned. If not, an attempt is made to infer\n    // the return type. If a list of args is provided, the inference logic may take\n    // into account argument types to infer the return type.\n    function getFunctionEffectiveReturnType(\n        type: FunctionType,\n        args?: ValidateArgTypeParams[],\n        inferTypeIfNeeded = true\n    ) {\n        const specializedReturnType = FunctionType.getSpecializedReturnType(type);\n        if (specializedReturnType) {\n            return specializedReturnType;\n        }\n\n        if (inferTypeIfNeeded) {\n            return getFunctionInferredReturnType(type, args);\n        }\n\n        return UnknownType.create();\n    }\n\n    function getFunctionInferredReturnType(type: FunctionType, args?: ValidateArgTypeParams[]) {\n        let returnType: Type | undefined;\n\n        // Don't attempt to infer the return type for a stub file or a py.typed module.\n        if (FunctionType.isStubDefinition(type) || FunctionType.isPyTypedDefinition(type)) {\n            return UnknownType.create();\n        }\n\n        // If the return type has already been lazily evaluated,\n        // don't bother computing it again.\n        if (type.inferredReturnType) {\n            returnType = type.inferredReturnType;\n        } else {\n            if (type.details.declaration) {\n                const functionNode = type.details.declaration.node;\n\n                // Temporarily disable speculative mode while we\n                // lazily evaluate the return type.\n                disableSpeculativeMode(() => {\n                    returnType = inferFunctionReturnType(functionNode, FunctionType.isAbstractMethod(type));\n                });\n\n                // Do we need to wrap this in an awaitable?\n                if (returnType && FunctionType.isWrapReturnTypeInAwait(type)) {\n                    returnType = createAwaitableReturnType(functionNode, returnType);\n                }\n            }\n\n            if (!returnType) {\n                returnType = UnknownType.create();\n            }\n\n            // Cache the type for next time.\n            type.inferredReturnType = returnType;\n        }\n\n        // If the type is partially unknown and the function has one or more unannotated\n        // params, try to analyze the function with the provided argument types and\n        // attempt to do a better job at inference.\n        if (\n            isPartlyUnknown(returnType) &&\n            FunctionType.hasUnannotatedParams(type) &&\n            !FunctionType.isStubDefinition(type) &&\n            !FunctionType.isPyTypedDefinition(type) &&\n            args\n        ) {\n            const contextualReturnType = getFunctionInferredReturnTypeUsingArguments(type, args);\n            if (contextualReturnType) {\n                returnType = contextualReturnType;\n            }\n        }\n\n        return returnType;\n    }\n\n    function getFunctionInferredReturnTypeUsingArguments(\n        type: FunctionType,\n        args: ValidateArgTypeParams[]\n    ): Type | undefined {\n        let contextualReturnType: Type | undefined;\n\n        if (!type.details.declaration) {\n            return undefined;\n        }\n        const functionNode = type.details.declaration.node;\n\n        // If an arg hasn't been matched to a specific named parameter,\n        // it's an unpacked value that corresponds to multiple parameters.\n        // That's an edge case that we don't handle here.\n        if (args.some((arg) => !arg.paramName)) {\n            return undefined;\n        }\n\n        // Detect recurrence. If a function invokes itself either directly\n        // or indirectly, we won't attempt to infer contextual return\n        // types any further.\n        if (returnTypeInferenceContextStack.some((context) => context.functionNode === functionNode)) {\n            return undefined;\n        }\n\n        const functionType = getTypeOfFunction(functionNode);\n        if (!functionType) {\n            return undefined;\n        }\n\n        // Don't explore arbitrarily deep in the call graph.\n        if (returnTypeInferenceContextStack.length >= maxReturnTypeInferenceStackSize) {\n            return undefined;\n        }\n\n        // Suppress diagnostics because we don't want to generate errors.\n        suppressDiagnostics(() => {\n            // Allocate a new temporary type cache for the context of just\n            // this function so we can analyze it separately without polluting\n            // the main type cache.\n            const prevTypeCache = returnTypeInferenceTypeCache;\n            returnTypeInferenceContextStack.push({\n                functionNode,\n                codeFlowAnalyzer: createCodeFlowAnalyzer(),\n            });\n\n            try {\n                returnTypeInferenceTypeCache = new Map<number, CachedType>();\n\n                let allArgTypesAreUnknown = true;\n                functionNode.parameters.forEach((param, index) => {\n                    if (param.name) {\n                        let paramType: Type | undefined;\n                        const arg = args.find((arg) => param.name!.value === arg.paramName);\n                        if (arg && arg.argument.valueExpression) {\n                            paramType = getTypeOfExpression(arg.argument.valueExpression).type;\n                            allArgTypesAreUnknown = false;\n                        } else if (param.defaultValue) {\n                            paramType = getTypeOfExpression(param.defaultValue).type;\n                            allArgTypesAreUnknown = false;\n                        } else if (index === 0) {\n                            // If this is an instance or class method, use the implied\n                            // parameter type for the \"self\" or \"cls\" parameter.\n                            if (\n                                FunctionType.isInstanceMethod(functionType.functionType) ||\n                                FunctionType.isClassMethod(functionType.functionType)\n                            ) {\n                                if (functionType.functionType.details.parameters.length > 0) {\n                                    if (functionNode.parameters[0].name) {\n                                        paramType = functionType.functionType.details.parameters[0].type;\n                                    }\n                                }\n                            }\n                        }\n\n                        if (!paramType) {\n                            paramType = UnknownType.create();\n                        }\n\n                        writeTypeCache(param.name, paramType);\n                    }\n                });\n\n                // Don't bother trying to determine the contextual return\n                // type if none of the argument types are known.\n                if (!allArgTypesAreUnknown) {\n                    contextualReturnType = inferFunctionReturnType(functionNode, FunctionType.isAbstractMethod(type));\n                }\n            } finally {\n                returnTypeInferenceContextStack.pop();\n                returnTypeInferenceTypeCache = prevTypeCache;\n            }\n        });\n\n        if (contextualReturnType) {\n            // Do we need to wrap this in an awaitable?\n            if (FunctionType.isWrapReturnTypeInAwait(type) && !isNoReturnType(contextualReturnType)) {\n                contextualReturnType = createAwaitableReturnType(functionNode, contextualReturnType);\n            }\n\n            return contextualReturnType;\n        }\n\n        return undefined;\n    }\n\n    function getFunctionDeclaredReturnType(node: FunctionNode): Type | undefined {\n        const functionTypeInfo = getTypeOfFunction(node)!;\n        if (!functionTypeInfo) {\n            // We hit a recursive dependency.\n            return AnyType.create();\n        }\n\n        // Ignore this check for abstract methods, which often\n        // don't actually return any value.\n        if (FunctionType.isAbstractMethod(functionTypeInfo.functionType)) {\n            return AnyType.create();\n        }\n\n        if (FunctionType.isGenerator(functionTypeInfo.functionType)) {\n            return getDeclaredGeneratorReturnType(functionTypeInfo.functionType);\n        }\n\n        return functionTypeInfo.functionType.details.declaredReturnType;\n    }\n\n    function getTypeOfMember(member: ClassMember): Type {\n        if (isClass(member.classType)) {\n            return partiallySpecializeType(getEffectiveTypeOfSymbol(member.symbol), member.classType);\n        }\n        return UnknownType.create();\n    }\n\n    function canAssignClassToProtocol(\n        destType: ClassType,\n        srcType: ClassType,\n        diag: DiagnosticAddendum,\n        typeVarMap: TypeVarMap | undefined,\n        flags: CanAssignFlags,\n        recursionCount: number\n    ): boolean {\n        const destClassFields = destType.details.fields;\n\n        // Some protocol definitions include recursive references to themselves.\n        // We need to protect against infinite recursion, so we'll check for that here.\n        if (isTypeSame(srcType, destType)) {\n            return true;\n        }\n\n        // Strip the type arguments off the dest protocol if they are provided.\n        const genericDestType = ClassType.cloneForSpecialization(\n            destType,\n            undefined,\n            /* isTypeArgumentExplicit */ false\n        );\n        const genericDestTypeVarMap = new TypeVarMap();\n\n        let typesAreConsistent = true;\n        const srcClassTypeVarMap = buildTypeVarMapFromSpecializedClass(srcType);\n\n        destClassFields.forEach((symbol, name) => {\n            if (symbol.isClassMember() && !symbol.isIgnoredForProtocolMatch()) {\n                const memberInfo = lookUpClassMember(srcType, name);\n                if (!memberInfo) {\n                    diag.addMessage(Localizer.DiagnosticAddendum.protocolMemberMissing().format({ name }));\n                    typesAreConsistent = false;\n                } else {\n                    const declaredType = getDeclaredTypeOfSymbol(symbol);\n                    if (declaredType) {\n                        const srcMemberType = specializeType(\n                            getTypeOfMember(memberInfo),\n                            srcClassTypeVarMap,\n                            /* makeConcrete */ false\n                        );\n\n                        if (\n                            !canAssignType(\n                                declaredType,\n                                srcMemberType,\n                                diag.createAddendum(),\n                                genericDestTypeVarMap,\n                                CanAssignFlags.Default,\n                                recursionCount + 1\n                            )\n                        ) {\n                            diag.addMessage(Localizer.DiagnosticAddendum.memberTypeMismatch().format({ name }));\n                            typesAreConsistent = false;\n                        }\n                    }\n\n                    if (symbol.isClassVar() && !memberInfo.symbol.isClassMember()) {\n                        diag.addMessage(Localizer.DiagnosticAddendum.protocolMemberClassVar().format({ name }));\n                        typesAreConsistent = false;\n                    }\n                }\n            }\n        });\n\n        // Now handle base classes of the dest protocol.\n        destType.details.baseClasses.forEach((baseClass) => {\n            if (\n                isClass(baseClass) &&\n                !ClassType.isBuiltIn(baseClass, 'object') &&\n                !ClassType.isBuiltIn(baseClass, 'Protocol')\n            ) {\n                const specializedBaseClass = specializeForBaseClass(destType, baseClass, recursionCount + 1);\n                if (\n                    !canAssignClassToProtocol(\n                        specializedBaseClass,\n                        srcType,\n                        diag,\n                        typeVarMap,\n                        flags,\n                        recursionCount + 1\n                    )\n                ) {\n                    typesAreConsistent = false;\n                }\n            }\n        });\n\n        // If the dest protocol has type parameters, make sure the source type arguments match.\n        if (typesAreConsistent && destType.details.typeParameters.length > 0 && destType.typeArguments !== undefined) {\n            // Create a specialized version of the protocol defined by the dest and\n            // make sure the resulting type args can be assigned.\n            const specializedSrcProtocol = specializeType(\n                genericDestType,\n                genericDestTypeVarMap,\n                /* makeConcrete */ false\n            ) as ClassType;\n\n            if (\n                !verifyTypeArgumentsAssignable(\n                    destType,\n                    specializedSrcProtocol,\n                    diag,\n                    typeVarMap,\n                    flags,\n                    recursionCount\n                )\n            ) {\n                typesAreConsistent = false;\n            }\n        }\n\n        return typesAreConsistent;\n    }\n\n    function canAssignTypedDict(\n        destType: ClassType,\n        srcType: ClassType,\n        diag: DiagnosticAddendum,\n        recursionCount: number\n    ) {\n        let typesAreConsistent = true;\n        const destEntries = getTypedDictMembersForClass(destType);\n        const srcEntries = getTypedDictMembersForClass(srcType);\n\n        destEntries.forEach((destEntry, name) => {\n            const srcEntry = srcEntries.get(name);\n            if (!srcEntry) {\n                diag.addMessage(\n                    Localizer.DiagnosticAddendum.typedDictFieldMissing().format({ name, type: printType(srcType) })\n                );\n                typesAreConsistent = false;\n            } else {\n                if (destEntry.isRequired && !srcEntry.isRequired) {\n                    diag.addMessage(\n                        Localizer.DiagnosticAddendum.typedDictFieldRequired().format({\n                            name,\n                            type: printType(destType),\n                        })\n                    );\n                    typesAreConsistent = false;\n                } else if (!destEntry.isRequired && srcEntry.isRequired) {\n                    diag.addMessage(\n                        Localizer.DiagnosticAddendum.typedDictFieldNotRequired().format({\n                            name,\n                            type: printType(destType),\n                        })\n                    );\n                    typesAreConsistent = false;\n                }\n\n                if (!isTypeSame(destEntry.valueType, srcEntry.valueType, recursionCount + 1)) {\n                    diag.addMessage(Localizer.DiagnosticAddendum.memberTypeMismatch().format({ name }));\n                    typesAreConsistent = false;\n                }\n            }\n        });\n\n        return typesAreConsistent;\n    }\n\n    function canAssignClass(\n        destType: ClassType,\n        srcType: ClassType,\n        diag: DiagnosticAddendum,\n        typeVarMap: TypeVarMap | undefined,\n        flags: CanAssignFlags,\n        recursionCount: number,\n        reportErrorsUsingObjType: boolean\n    ): boolean {\n        // Is it a structural type (i.e. a protocol)? If so, we need to\n        // perform a member-by-member check.\n        if (ClassType.isProtocolClass(destType)) {\n            return canAssignClassToProtocol(destType, srcType, diag, typeVarMap, flags, recursionCount);\n        }\n\n        // Handle typed dicts. They also use a form of structural typing for type\n        // checking, as defined in PEP 589.\n        if (ClassType.isTypedDictClass(destType) && ClassType.isTypedDictClass(srcType)) {\n            return canAssignTypedDict(destType, srcType, diag, recursionCount);\n        }\n\n        // Handle property classes. They are special because each property\n        // class has a different source ID, so they wouldn't otherwise match.\n        // We need to see if the return types of the properties match.\n        if (ClassType.isPropertyClass(destType) && ClassType.isPropertyClass(srcType)) {\n            let typesAreConsistent = true;\n\n            const fgetDestReturnType = getGetterTypeFromProperty(destType, /* inferTypeIfNeeded */ true);\n            const fgetSrcReturnType = getGetterTypeFromProperty(srcType, /* inferTypeIfNeeded */ true);\n            if (fgetDestReturnType && fgetSrcReturnType) {\n                if (\n                    !canAssignType(\n                        fgetDestReturnType,\n                        fgetSrcReturnType,\n                        diag,\n                        /* typeVarMap */ undefined,\n                        CanAssignFlags.Default,\n                        recursionCount + 1\n                    )\n                ) {\n                    typesAreConsistent = false;\n                }\n            }\n\n            return typesAreConsistent;\n        }\n\n        // Special-case conversion for the \"numeric tower\".\n        if (ClassType.isBuiltIn(destType, 'float')) {\n            if (ClassType.isBuiltIn(srcType, 'int')) {\n                if ((flags & CanAssignFlags.EnforceInvariance) === 0) {\n                    return true;\n                }\n            }\n        }\n\n        if (ClassType.isBuiltIn(destType, 'complex')) {\n            if (ClassType.isBuiltIn(srcType, 'int') || ClassType.isBuiltIn(srcType, 'float')) {\n                if ((flags & CanAssignFlags.EnforceInvariance) === 0) {\n                    return true;\n                }\n            }\n        }\n\n        if ((flags & CanAssignFlags.EnforceInvariance) === 0 || ClassType.isSameGenericClass(srcType, destType)) {\n            const inheritanceChain: InheritanceChain = [];\n            if (ClassType.isDerivedFrom(srcType, destType, inheritanceChain)) {\n                assert(inheritanceChain.length > 0);\n\n                return canAssignClassWithTypeArgs(\n                    destType,\n                    srcType,\n                    inheritanceChain,\n                    diag,\n                    typeVarMap,\n                    flags,\n                    recursionCount + 1\n                );\n            }\n        }\n\n        // Everything is assignable to an object.\n        if (ClassType.isBuiltIn(destType, 'object')) {\n            return true;\n        }\n\n        const destErrorType = reportErrorsUsingObjType ? ObjectType.create(destType) : destType;\n        const srcErrorType = reportErrorsUsingObjType ? ObjectType.create(srcType) : srcType;\n        diag.addMessage(\n            Localizer.DiagnosticAddendum.typeIncompatible().format({\n                sourceType: printType(srcErrorType),\n                destType: printType(destErrorType),\n            })\n        );\n        return false;\n    }\n\n    // Determines the specialized base class type that srcType derives from.\n    function specializeForBaseClass(srcType: ClassType, baseClass: ClassType, recursionCount: number): ClassType {\n        const typeParams = ClassType.getTypeParameters(baseClass);\n\n        // If there are no type parameters for the specified base class,\n        // no specialization is required.\n        if (typeParams.length === 0) {\n            return baseClass;\n        }\n\n        const typeVarMap = buildTypeVarMapFromSpecializedClass(srcType);\n        const specializedType = specializeType(baseClass, typeVarMap, /* makeConcrete */ false, recursionCount + 1);\n        assert(isClass(specializedType));\n        return specializedType as ClassType;\n    }\n\n    // Determines whether the specified type can be assigned to the\n    // specified inheritance chain, taking into account its type arguments.\n    function canAssignClassWithTypeArgs(\n        destType: ClassType,\n        srcType: ClassType,\n        inheritanceChain: InheritanceChain,\n        diag: DiagnosticAddendum,\n        typeVarMap: TypeVarMap | undefined,\n        flags: CanAssignFlags,\n        recursionCount: number\n    ): boolean {\n        let curSrcType = srcType;\n        let curTypeVarMap = typeVarMap;\n\n        for (let ancestorIndex = inheritanceChain.length - 1; ancestorIndex >= 0; ancestorIndex--) {\n            const ancestorType = inheritanceChain[ancestorIndex];\n\n            // If we've hit an \"unknown\", all bets are off, and we need to assume\n            // that the type is assignable.\n            if (isUnknown(ancestorType)) {\n                return true;\n            }\n\n            // If we've hit an 'object', it's assignable.\n            if (ClassType.isBuiltIn(ancestorType, 'object')) {\n                return true;\n            }\n\n            // If this isn't the first time through the loop, specialize\n            // for the next ancestor in the chain.\n            if (ancestorIndex < inheritanceChain.length - 1) {\n                curSrcType = specializeForBaseClass(curSrcType, ancestorType, recursionCount + 1);\n            }\n\n            // Do we need to do special-case processing for various built-in classes?\n            if (ancestorIndex === 0 && ClassType.isBuiltIn(destType)) {\n                // Handle built-in types that support arbitrary numbers\n                // of type parameters like Tuple.\n                if (isTupleClass(destType)) {\n                    if (destType.typeArguments && curSrcType.typeArguments) {\n                        const destTypeArgs = destType.typeArguments;\n                        let destArgCount = destTypeArgs.length;\n                        const isDestHomogenousTuple = destArgCount === 2 && isEllipsisType(destTypeArgs[1]);\n                        if (isDestHomogenousTuple) {\n                            destArgCount = 1;\n                        }\n\n                        const srcTypeArgs = curSrcType.typeArguments;\n                        let srcArgCount = srcTypeArgs.length;\n                        const isSrcHomogeneousType = srcArgCount === 2 && isEllipsisType(srcTypeArgs[1]);\n                        if (isSrcHomogeneousType) {\n                            srcArgCount = 1;\n                        }\n\n                        if ((srcTypeArgs.length === destArgCount && !isSrcHomogeneousType) || isDestHomogenousTuple) {\n                            for (let i = 0; i < Math.max(destArgCount, srcArgCount); i++) {\n                                const expectedDestType =\n                                    (isDestHomogenousTuple ? destTypeArgs[0] : destTypeArgs[i]) || AnyType.create();\n                                const expectedSrcType =\n                                    (isSrcHomogeneousType ? srcTypeArgs[0] : srcTypeArgs[i]) || AnyType.create();\n                                const entryDiag = diag.createAddendum();\n\n                                if (\n                                    !canAssignType(\n                                        expectedDestType,\n                                        expectedSrcType,\n                                        entryDiag.createAddendum(),\n                                        curTypeVarMap,\n                                        flags,\n                                        recursionCount + 1\n                                    )\n                                ) {\n                                    entryDiag.addMessage(\n                                        Localizer.DiagnosticAddendum.tupleEntryTypeMismatch().format({ entry: i + 1 })\n                                    );\n                                    return false;\n                                }\n                            }\n                        } else {\n                            diag.addMessage(\n                                Localizer.DiagnosticAddendum.tupleSizeMismatch().format({\n                                    expected: destArgCount,\n                                    received: srcTypeArgs.length,\n                                })\n                            );\n                            return false;\n                        }\n                    }\n\n                    return true;\n                }\n            }\n\n            // If there are no type parameters on this class, we're done.\n            const ancestorTypeParams = ClassType.getTypeParameters(ancestorType);\n            if (ancestorTypeParams.length === 0) {\n                continue;\n            }\n\n            // If the dest type isn't specialized, there are no type args to validate.\n            if (!ancestorType.typeArguments) {\n                return true;\n            }\n\n            // Validate that the type arguments match.\n            if (!verifyTypeArgumentsAssignable(ancestorType, curSrcType, diag, curTypeVarMap, flags, recursionCount)) {\n                return false;\n            }\n\n            // Allocate a new type var map for the next time through the loop.\n            curTypeVarMap = new TypeVarMap();\n        }\n\n        if (destType.typeArguments) {\n            // If the dest type is specialized, make sure the specialized source\n            // type arguments are assignable to the dest type arguments.\n            if (!verifyTypeArgumentsAssignable(destType, curSrcType, diag, typeVarMap, flags, recursionCount)) {\n                return false;\n            }\n        } else if (\n            typeVarMap &&\n            destType.details.typeParameters.length > 0 &&\n            curSrcType.typeArguments &&\n            !typeVarMap.isLocked()\n        ) {\n            // Populate the typeVar map with type arguments of the source.\n            const srcTypeArgs = curSrcType.effectiveTypeArguments || curSrcType.typeArguments;\n            for (let i = 0; i < destType.details.typeParameters.length; i++) {\n                const typeArgType = i < srcTypeArgs.length ? srcTypeArgs[i] : UnknownType.create();\n                typeVarMap.setTypeVar(destType.details.typeParameters[i], typeArgType, /* isNarrowable */ true);\n            }\n        }\n\n        return true;\n    }\n\n    function getGetterTypeFromProperty(propertyClass: ClassType, inferTypeIfNeeded: boolean): Type | undefined {\n        if (!ClassType.isPropertyClass(propertyClass)) {\n            return undefined;\n        }\n\n        const fgetSymbol = propertyClass.details.fields.get('fget');\n\n        if (fgetSymbol) {\n            const fgetType = getDeclaredTypeOfSymbol(fgetSymbol);\n            if (fgetType && fgetType.category === TypeCategory.Function) {\n                return getFunctionEffectiveReturnType(fgetType, /* args */ undefined, inferTypeIfNeeded);\n            }\n        }\n\n        return undefined;\n    }\n\n    function verifyTypeArgumentsAssignable(\n        destType: ClassType,\n        srcType: ClassType,\n        diag: DiagnosticAddendum,\n        typeVarMap: TypeVarMap | undefined,\n        flags: CanAssignFlags,\n        recursionCount: number\n    ) {\n        assert(ClassType.isSameGenericClass(destType, srcType));\n\n        const destTypeParams = ClassType.getTypeParameters(destType);\n        const destTypeArgs = destType.effectiveTypeArguments || destType.typeArguments!;\n        assert(destTypeArgs !== undefined);\n        const srcTypeArgs = srcType.effectiveTypeArguments || srcType.typeArguments;\n\n        if (srcTypeArgs) {\n            if (ClassType.isSpecialBuiltIn(srcType) || srcTypeArgs.length === destTypeParams.length) {\n                for (let srcArgIndex = 0; srcArgIndex < srcTypeArgs.length; srcArgIndex++) {\n                    const srcTypeArg = srcTypeArgs[srcArgIndex];\n\n                    // In most cases, the number of type args should match the number\n                    // of type arguments, but there are a few special cases where this\n                    // isn't true (e.g. assigning a Tuple[X, Y, Z] to a tuple[W]).\n                    const destArgIndex = srcArgIndex >= destTypeArgs.length ? destTypeArgs.length - 1 : srcArgIndex;\n                    const destTypeArg = destArgIndex >= 0 ? destTypeArgs[destArgIndex] : UnknownType.create();\n                    const destTypeParam =\n                        destArgIndex < destTypeParams.length ? destTypeParams[destArgIndex] : undefined;\n                    const assignmentDiag = new DiagnosticAddendum();\n\n                    if (!destTypeParam || destTypeParam.details.isCovariant) {\n                        if (\n                            !canAssignType(\n                                destTypeArg,\n                                srcTypeArg,\n                                assignmentDiag,\n                                typeVarMap,\n                                flags,\n                                recursionCount + 1\n                            )\n                        ) {\n                            if (destTypeParam) {\n                                const childDiag = diag.createAddendum();\n                                childDiag.addMessage(\n                                    Localizer.DiagnosticAddendum.typeVarIsCovariant().format({\n                                        name: destTypeParam.details.name,\n                                    })\n                                );\n                                childDiag.addAddendum(assignmentDiag);\n                            }\n                            return false;\n                        }\n                    } else if (destTypeParam.details.isContravariant) {\n                        if (\n                            !canAssignType(\n                                srcTypeArg,\n                                destTypeArg,\n                                assignmentDiag,\n                                typeVarMap,\n                                flags | CanAssignFlags.ReverseTypeVarMatching,\n                                recursionCount + 1\n                            )\n                        ) {\n                            const childDiag = diag.createAddendum();\n                            childDiag.addMessage(\n                                Localizer.DiagnosticAddendum.typeVarIsContravariant().format({\n                                    name: destTypeParam.details.name,\n                                })\n                            );\n                            childDiag.addAddendum(assignmentDiag);\n                            return false;\n                        }\n                    } else {\n                        if (\n                            !canAssignType(\n                                destTypeArg,\n                                srcTypeArg,\n                                assignmentDiag,\n                                typeVarMap,\n                                flags | CanAssignFlags.EnforceInvariance,\n                                recursionCount + 1\n                            )\n                        ) {\n                            const childDiag = diag.createAddendum();\n                            childDiag.addMessage(\n                                Localizer.DiagnosticAddendum.typeVarIsInvariant().format({\n                                    name: destTypeParam.details.name,\n                                })\n                            );\n                            childDiag.addAddendum(assignmentDiag);\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n\n        return true;\n    }\n\n    // Assigns the source type to the dest type var in the type map. If an existing type is\n    // already associated with that type var name, it attempts to either widen or narrow\n    // the type (depending on the value of the canNarrowType parameter). The goal is to\n    // produce the narrowest type that meets all of the requirements. If the type var map\n    // has been \"locked\", it simply validates that the srcType is compatible (with no attempt\n    // to widen or narrow).\n    function assignTypeToTypeVar(\n        destType: TypeVarType,\n        srcType: Type,\n        canNarrowType: boolean,\n        diag: DiagnosticAddendum,\n        typeVarMap: TypeVarMap,\n        flags = CanAssignFlags.Default,\n        recursionCount = 0\n    ): boolean {\n        const curTypeVarMapping = typeVarMap.getTypeVar(destType);\n\n        if (destType.details.isParamSpec) {\n            diag.addMessage(\n                Localizer.DiagnosticAddendum.typeParamSpec().format({\n                    type: printType(srcType),\n                    name: destType.details.name,\n                })\n            );\n            return false;\n        }\n\n        // Handle the constrained case.\n        if (destType.details.constraints.length > 0) {\n            // Find the first constrained type that is compatible.\n            const constrainedType = destType.details.constraints.find((constraintType) => {\n                return canAssignType(constraintType, srcType, new DiagnosticAddendum());\n            });\n\n            if (!constrainedType) {\n                diag.addMessage(\n                    Localizer.DiagnosticAddendum.typeConstraint().format({\n                        type: printType(srcType),\n                        name: destType.details.name,\n                    })\n                );\n                return false;\n            }\n\n            const isSrcTypeVar = isTypeVar(srcType) && !srcType.details.isSynthesized;\n            if (curTypeVarMapping && !isAnyOrUnknown(curTypeVarMapping) && !isSrcTypeVar) {\n                if (!isTypeSame(curTypeVarMapping, constrainedType)) {\n                    diag.addMessage(\n                        Localizer.DiagnosticAddendum.typeConstraint().format({\n                            type: printType(constrainedType),\n                            name: printType(curTypeVarMapping),\n                        })\n                    );\n                    return false;\n                }\n            } else {\n                // Assign the type to the type var. If the source is a TypeVar, don't\n                // specialize it to one of the constrained types. Leave it generic.\n                if (!typeVarMap.isLocked()) {\n                    typeVarMap.setTypeVar(destType, isSrcTypeVar ? srcType : constrainedType, false);\n                }\n            }\n\n            return true;\n        }\n\n        // Handle the unconstrained (but possibly bound) case.\n        let updatedType = srcType;\n        const curTypeIsNarrowable = typeVarMap.isNarrowable(destType) && !typeVarMap.isLocked();\n        const updatedTypeIsNarrowable = canNarrowType && curTypeIsNarrowable;\n\n        if (curTypeVarMapping) {\n            const diagAddendum = new DiagnosticAddendum();\n            if (canNarrowType) {\n                // Handle the narrowing case (used for contravariant type matching).\n                if (\n                    curTypeIsNarrowable &&\n                    canAssignType(srcType, curTypeVarMapping, diagAddendum, typeVarMap, flags, recursionCount + 1)\n                ) {\n                    // No need to narrow. Stick with the existing type unless it's an Unknown,\n                    // in which case we'll try to replace it with a known type.\n                    if (!isAnyOrUnknown(curTypeVarMapping) && !isUnknown(srcType)) {\n                        updatedType = curTypeVarMapping;\n                    }\n                } else if (\n                    !canAssignType(\n                        curTypeVarMapping,\n                        srcType,\n                        new DiagnosticAddendum(),\n                        typeVarMap,\n                        flags,\n                        recursionCount + 1\n                    )\n                ) {\n                    diag.addMessage(\n                        Localizer.DiagnosticAddendum.typeAssignmentMismatch().format({\n                            sourceType: printType(srcType),\n                            destType: printType(curTypeVarMapping),\n                        })\n                    );\n                    return false;\n                }\n            } else {\n                // Handle the widen case.\n                if (canAssignType(curTypeVarMapping, srcType, diagAddendum, typeVarMap, flags, recursionCount + 1)) {\n                    if (curTypeIsNarrowable) {\n                        // The new srcType is narrower than the current type, but the current\n                        // type is allowed to be narrowed, so replace the current type with\n                        // the srcType.\n                    } else {\n                        // No need to widen. Stick with the existing type unless it's an Unknown,\n                        // in which case we'll replace it with a known type.\n                        if (!isUnknown(curTypeVarMapping)) {\n                            updatedType = curTypeVarMapping;\n                        }\n                    }\n                } else {\n                    if (typeVarMap.isLocked()) {\n                        diag.addMessage(\n                            Localizer.DiagnosticAddendum.typeAssignmentMismatch().format({\n                                sourceType: printType(curTypeVarMapping),\n                                destType: printType(srcType),\n                            })\n                        );\n                        return false;\n                    }\n\n                    if (\n                        !canAssignType(\n                            srcType,\n                            curTypeVarMapping,\n                            new DiagnosticAddendum(),\n                            typeVarMap,\n                            flags,\n                            recursionCount + 1\n                        )\n                    ) {\n                        // Create a union, widening the type.\n                        updatedType = combineTypes([curTypeVarMapping, srcType]);\n                    }\n                }\n            }\n        }\n\n        // If there's a bound type, make sure the source is derived from it.\n        if (destType.details.boundType) {\n            if (\n                !canAssignType(\n                    destType.details.boundType,\n                    updatedType,\n                    diag.createAddendum(),\n                    undefined,\n                    CanAssignFlags.Default,\n                    recursionCount + 1\n                )\n            ) {\n                // Avoid adding a message that will confuse users if the TypeVar was\n                // synthesized for internal purposes.\n                if (!destType.details.isSynthesized) {\n                    diag.addMessage(\n                        Localizer.DiagnosticAddendum.typeBound().format({\n                            sourceType: printType(updatedType),\n                            destType: printType(destType.details.boundType),\n                            name: destType.details.name,\n                        })\n                    );\n                }\n                return false;\n            }\n        }\n\n        if (!typeVarMap.isLocked()) {\n            typeVarMap.setTypeVar(destType, updatedType, updatedTypeIsNarrowable);\n        }\n\n        return true;\n    }\n\n    // Determines if the source type can be assigned to the dest type.\n    // If typeVarMap is provided, type variables within the destType are\n    // matched against existing type variables in the map. If a type variable\n    // in the dest type is not in the type map already, it is assigned a type\n    // and added to the map.\n    function canAssignType(\n        destType: Type,\n        srcType: Type,\n        diag: DiagnosticAddendum,\n        typeVarMap?: TypeVarMap,\n        flags = CanAssignFlags.Default,\n        recursionCount = 0\n    ): boolean {\n        destType = transformPossibleRecursiveTypeAlias(destType);\n        srcType = transformPossibleRecursiveTypeAlias(srcType);\n\n        if (recursionCount > maxTypeRecursionCount) {\n            return true;\n        }\n\n        if (destType === srcType) {\n            return true;\n        }\n\n        // If the source or dest is unbound, allow the assignment. The\n        // error will be reported elsewhere.\n        if (isUnbound(destType) || isUnbound(srcType)) {\n            return true;\n        }\n\n        // Strip the ReverseTypeVarMatching from the incoming flags.\n        // We don't want to propagate this flag to any nested calls to\n        // canAssignType.\n        const reverseTypeVarMatching = (flags & CanAssignFlags.ReverseTypeVarMatching) !== 0;\n        flags &= ~CanAssignFlags.ReverseTypeVarMatching;\n\n        // Before performing any other checks, see if the dest type is a\n        // TypeVar that we are attempting to match.\n        if (isTypeVar(destType)) {\n            if (flags & CanAssignFlags.MatchTypeVarsExactly) {\n                if (isTypeVar(srcType) && destType.details.name === srcType.details.name) {\n                    return true;\n                }\n            } else if (!reverseTypeVarMatching) {\n                if (\n                    assignTypeToTypeVar(\n                        destType,\n                        srcType,\n                        /* canNarrowType */ false,\n                        diag,\n                        typeVarMap || new TypeVarMap(),\n                        flags,\n                        recursionCount + 1\n                    )\n                ) {\n                    return true;\n                }\n\n                diag.addMessage(\n                    Localizer.DiagnosticAddendum.typeAssignmentMismatch().format({\n                        sourceType: printType(srcType),\n                        destType: printType(destType),\n                    })\n                );\n                return false;\n            }\n        }\n\n        if (isTypeVar(srcType)) {\n            if (flags & CanAssignFlags.MatchTypeVarsExactly) {\n                if (isTypeVar(destType) && destType.details.name === srcType.details.name) {\n                    return true;\n                }\n\n                diag.addMessage(\n                    Localizer.DiagnosticAddendum.typeAssignmentMismatch().format({\n                        sourceType: printType(srcType),\n                        destType: printType(destType),\n                    })\n                );\n                return false;\n            }\n        }\n\n        if (isAnyOrUnknown(destType)) {\n            return true;\n        }\n\n        if (isAnyOrUnknown(srcType)) {\n            if (typeVarMap) {\n                // If it's an ellipsis type, convert it to a regular \"Any\"\n                // type. These are functionally equivalent, but \"Any\" looks\n                // better in the text representation.\n                const typeVarSubstitution = isEllipsisType(srcType) ? AnyType.create() : srcType;\n                setTypeArgumentsRecursive(destType, typeVarSubstitution, typeVarMap);\n            }\n            if ((flags & CanAssignFlags.DisallowAssignFromAny) === 0) {\n                return true;\n            }\n        }\n\n        if (isNever(srcType)) {\n            if (typeVarMap) {\n                setTypeArgumentsRecursive(destType, UnknownType.create(), typeVarMap);\n            }\n            return true;\n        }\n\n        if (isTypeVar(srcType)) {\n            // In most cases, the source type will be specialized before\n            // canAssignType is called, so we won't get here. However, there\n            // are cases where this can occur (e.g. when we swap the src and dest\n            // types because they are contravariant).\n            if (reverseTypeVarMatching) {\n                return assignTypeToTypeVar(\n                    srcType,\n                    destType,\n                    /* canNarrowType */ true,\n                    diag,\n                    typeVarMap || new TypeVarMap(),\n                    flags,\n                    recursionCount + 1\n                );\n            }\n\n            if (flags & CanAssignFlags.DoNotSpecializeTypeVars) {\n                if (destType !== srcType) {\n                    diag.addMessage(\n                        Localizer.DiagnosticAddendum.typeAssignmentMismatch().format({\n                            sourceType: printType(srcType),\n                            destType: printType(destType),\n                        })\n                    );\n                    return false;\n                }\n                return true;\n            }\n\n            const specializedSrcType = getConcreteTypeFromTypeVar(srcType);\n            return canAssignType(destType, specializedSrcType, diag, undefined, flags, recursionCount + 1);\n        }\n\n        if (recursionCount > maxTypeRecursionCount) {\n            return true;\n        }\n\n        // If we need to enforce invariance, union types must match exactly.\n        if (flags & CanAssignFlags.EnforceInvariance) {\n            if (srcType.category === TypeCategory.Union || destType.category === TypeCategory.Union) {\n                if (!isTypeSame(srcType, destType)) {\n                    diag.addMessage(\n                        Localizer.DiagnosticAddendum.typeAssignmentMismatch().format({\n                            sourceType: printType(srcType),\n                            destType: printType(destType),\n                        })\n                    );\n                    return false;\n                }\n\n                return true;\n            }\n        }\n\n        if (srcType.category === TypeCategory.Union) {\n            let isIncompatible = false;\n\n            // For union sources, all of the types need to be assignable to the dest.\n            srcType.subtypes.forEach((t) => {\n                if (!canAssignType(destType, t, diag.createAddendum(), typeVarMap, flags, recursionCount + 1)) {\n                    isIncompatible = true;\n                }\n            });\n\n            if (isIncompatible) {\n                diag.addMessage(\n                    Localizer.DiagnosticAddendum.typeAssignmentMismatch().format({\n                        sourceType: printType(srcType),\n                        destType: printType(destType),\n                    })\n                );\n                return false;\n            }\n\n            return true;\n        }\n\n        if (destType.category === TypeCategory.Union) {\n            // For union destinations, we just need to match one of the types.\n            const diagAddendum = new DiagnosticAddendum();\n\n            let foundMatch = false;\n            // Run through all subtypes in the union. Don't stop at the first\n            // match we find because we may need to match TypeVars in other\n            // subtypes. We special-case \"None\" so we can handle Optional[T]\n            // without matching the None to the type var.\n            if (\n                srcType.category === TypeCategory.None &&\n                destType.subtypes.some((subtype) => subtype.category === TypeCategory.None)\n            ) {\n                foundMatch = true;\n            } else {\n                let bestTypeVarMap: TypeVarMap | undefined;\n                let bestTypeVarMapScore: number | undefined;\n\n                destType.subtypes.forEach((subtype) => {\n                    // Make a temporary clone of the typeVarMap. We don't want to modify\n                    // the original typeVarMap until we find the \"optimal\" typeVar mapping.\n                    const typeVarMapClone = typeVarMap?.clone();\n                    if (canAssignType(subtype, srcType, diagAddendum, typeVarMapClone, flags, recursionCount + 1)) {\n                        foundMatch = true;\n\n                        if (typeVarMapClone) {\n                            // Ask the typeVarMap to compute a \"score\" for the current\n                            // contents of the table.\n                            const typeVarMapScore = typeVarMapClone.getScore();\n                            if (bestTypeVarMapScore === undefined || bestTypeVarMapScore <= typeVarMapScore) {\n                                // We found a typeVar mapping with a higher score than before.\n                                bestTypeVarMapScore = typeVarMapScore;\n                                bestTypeVarMap = typeVarMapClone;\n                            }\n                        }\n                    }\n                });\n\n                // If we found a winning type var mapping, copy it back to typeVarMap.\n                if (typeVarMap && bestTypeVarMap) {\n                    typeVarMap.copyFromClone(bestTypeVarMap);\n                }\n            }\n\n            if (!foundMatch) {\n                diag.addMessage(\n                    Localizer.DiagnosticAddendum.typeAssignmentMismatch().format({\n                        sourceType: printType(srcType),\n                        destType: printType(destType),\n                    })\n                );\n                diag.addAddendum(diagAddendum);\n                return false;\n            }\n            return true;\n        }\n\n        if (destType.category === TypeCategory.None && srcType.category === TypeCategory.None) {\n            return true;\n        }\n\n        // Is the src a specialized \"Type\" object?\n        if (isObject(srcType) && ClassType.isBuiltIn(srcType.classType, 'Type')) {\n            const srcTypeArgs = srcType.classType.typeArguments;\n            if (srcTypeArgs && srcTypeArgs.length >= 1) {\n                if (isAnyOrUnknown(srcTypeArgs[0])) {\n                    return true;\n                } else if (isObject(srcTypeArgs[0])) {\n                    if (\n                        canAssignType(\n                            destType,\n                            srcTypeArgs[0].classType,\n                            diag.createAddendum(),\n                            typeVarMap,\n                            flags,\n                            recursionCount + 1\n                        )\n                    ) {\n                        return true;\n                    }\n\n                    diag.addMessage(\n                        Localizer.DiagnosticAddendum.typeAssignmentMismatch().format({\n                            sourceType: printType(srcType),\n                            destType: printType(destType),\n                        })\n                    );\n                    return false;\n                }\n            }\n        }\n\n        if (isClass(destType)) {\n            if (isClass(srcType)) {\n                if (\n                    canAssignClass(\n                        destType,\n                        srcType,\n                        diag,\n                        typeVarMap,\n                        flags,\n                        recursionCount + 1,\n                        /* reportErrorsUsingObjType */ false\n                    )\n                ) {\n                    return true;\n                }\n\n                diag.addMessage(\n                    Localizer.DiagnosticAddendum.typeAssignmentMismatch().format({\n                        sourceType: printType(srcType),\n                        destType: printType(destType),\n                    })\n                );\n                return false;\n            }\n        }\n\n        if (isObject(destType)) {\n            const destClassType = destType.classType;\n\n            // Is the dest a generic \"type\" object?\n            if (ClassType.isBuiltIn(destClassType, 'type')) {\n                if (\n                    isClass(srcType) ||\n                    srcType.category === TypeCategory.Function ||\n                    srcType.category === TypeCategory.OverloadedFunction\n                ) {\n                    return true;\n                }\n            }\n\n            // Is the dest a specialized \"Type\" object?\n            if (ClassType.isBuiltIn(destClassType, 'Type')) {\n                const destTypeArgs = destClassType.typeArguments;\n                if (destTypeArgs && destTypeArgs.length >= 1) {\n                    if (isAnyOrUnknown(destTypeArgs[0])) {\n                        return true;\n                    } else if (isObject(destTypeArgs[0])) {\n                        return canAssignType(\n                            destTypeArgs[0].classType,\n                            srcType,\n                            diag,\n                            typeVarMap,\n                            flags,\n                            recursionCount + 1\n                        );\n                    } else if (isTypeVar(destTypeArgs[0])) {\n                        if (isClass(srcType) || (isNone(srcType) && TypeBase.isInstantiable(srcType))) {\n                            return canAssignType(\n                                destTypeArgs[0],\n                                convertToInstance(srcType),\n                                diag,\n                                typeVarMap,\n                                flags,\n                                recursionCount + 1\n                            );\n                        } else if (\n                            srcType.category === TypeCategory.Function ||\n                            srcType.category === TypeCategory.OverloadedFunction\n                        ) {\n                            return canAssignType(destTypeArgs[0], srcType, diag, typeVarMap, flags, recursionCount + 1);\n                        }\n                    }\n                }\n            }\n\n            if (isObject(srcType)) {\n                if (destType.classType.literalValue !== undefined) {\n                    const srcLiteral = srcType.classType.literalValue;\n                    if (\n                        srcLiteral === undefined ||\n                        !ClassType.isLiteralValueSame(srcType.classType, destType.classType)\n                    ) {\n                        diag.addMessage(\n                            Localizer.DiagnosticAddendum.literalAssignmentMismatch().format({\n                                sourceType: srcLiteral !== undefined ? printLiteralType(srcType) : printType(srcType),\n                                destType: printLiteralType(destType),\n                            })\n                        );\n\n                        return false;\n                    }\n                }\n\n                if (\n                    !canAssignClass(\n                        destClassType,\n                        srcType.classType,\n                        diag,\n                        typeVarMap,\n                        flags,\n                        recursionCount + 1,\n                        /* reportErrorsUsingObjType */ true\n                    )\n                ) {\n                    return false;\n                }\n\n                return true;\n            } else if (srcType.category === TypeCategory.Function) {\n                // Is the destination a callback protocol (defined in PEP 544)?\n                const callbackType = getCallbackProtocolType(destType);\n                if (callbackType) {\n                    return canAssignFunction(callbackType, srcType, diag, typeVarMap, flags, recursionCount + 1);\n                }\n\n                // All functions are assignable to \"object\".\n                if (ClassType.isBuiltIn(destType.classType) && destType.classType.details.name === 'object') {\n                    return true;\n                }\n            } else if (isModule(srcType)) {\n                // Is the destination the built-in \"ModuleType\"?\n                if (ClassType.isBuiltIn(destClassType, 'ModuleType')) {\n                    return true;\n                }\n            } else if (isClass(srcType)) {\n                // All classes are assignable to \"object\".\n                if (ClassType.isBuiltIn(destType.classType, 'object')) {\n                    return true;\n                }\n\n                // Determine if the metaclass can be assigned to the object.\n                const metaclass = srcType.details.effectiveMetaclass;\n                if (metaclass) {\n                    if (isAnyOrUnknown(metaclass)) {\n                        return true;\n                    } else if (isClass(metaclass) && !ClassType.isBuiltIn(metaclass, 'type')) {\n                        return canAssignClass(\n                            destClassType,\n                            metaclass,\n                            diag,\n                            typeVarMap,\n                            flags,\n                            recursionCount + 1,\n                            /* reportErrorsUsingObjType */ false\n                        );\n                    }\n                }\n            }\n\n            // See if the destType is an instantiation of a Protocol\n            // class that is effectively a function.\n            const callbackType = getCallbackProtocolType(destType);\n            if (callbackType) {\n                destType = callbackType;\n            }\n        }\n\n        if (destType.category === TypeCategory.Function) {\n            let srcFunction: FunctionType | undefined;\n\n            if (srcType.category === TypeCategory.OverloadedFunction) {\n                // Find first overloaded function that matches the parameters.\n                // We don't want to pollute the current typeVarMap, so we'll\n                // make a copy of the existing one if it's specified.\n                const overloads = srcType.overloads;\n                const overloadIndex = overloads.findIndex((overload) => {\n                    const typeVarMapClone = typeVarMap ? typeVarMap.clone() : undefined;\n                    return canAssignType(\n                        destType,\n                        overload,\n                        diag.createAddendum(),\n                        typeVarMapClone,\n                        flags,\n                        recursionCount + 1\n                    );\n                });\n                if (overloadIndex < 0) {\n                    diag.addMessage(\n                        Localizer.DiagnosticAddendum.noOverloadAssignable().format({ type: printType(destType) })\n                    );\n                    return false;\n                }\n                srcFunction = overloads[overloadIndex];\n            } else if (srcType.category === TypeCategory.Function) {\n                srcFunction = srcType;\n            } else if (isObject(srcType)) {\n                const callMember = lookUpObjectMember(srcType, '__call__');\n                if (callMember) {\n                    const memberType = getTypeOfMember(callMember);\n                    if (memberType.category === TypeCategory.Function) {\n                        srcFunction = stripFirstParameter(memberType);\n                    }\n                }\n            } else if (isClass(srcType)) {\n                // Synthesize a function that represents the constructor for this class.\n                const constructorFunction = FunctionType.createInstance(\n                    '__init__',\n                    '',\n                    FunctionTypeFlags.StaticMethod |\n                        FunctionTypeFlags.ConstructorMethod |\n                        FunctionTypeFlags.SynthesizedMethod\n                );\n                constructorFunction.details.declaredReturnType = ObjectType.create(srcType);\n\n                let constructorInfo = lookUpClassMember(\n                    srcType,\n                    '__init__',\n                    ClassMemberLookupFlags.SkipInstanceVariables | ClassMemberLookupFlags.SkipObjectBaseClass\n                );\n\n                if (!constructorInfo) {\n                    constructorInfo = lookUpClassMember(\n                        srcType,\n                        '__new__',\n                        ClassMemberLookupFlags.SkipInstanceVariables | ClassMemberLookupFlags.SkipObjectBaseClass\n                    );\n                }\n\n                const constructorType = constructorInfo ? getTypeOfMember(constructorInfo) : undefined;\n                if (constructorType && constructorType.category === TypeCategory.Function) {\n                    constructorType.details.parameters.forEach((param, index) => {\n                        // Skip the 'cls' or 'self' parameter.\n                        if (index > 0) {\n                            FunctionType.addParameter(constructorFunction, param);\n                        }\n                    });\n                } else {\n                    FunctionType.addDefaultParameters(constructorFunction);\n                }\n\n                srcFunction = constructorFunction;\n            }\n\n            if (srcFunction) {\n                if (\n                    canAssignFunction(\n                        destType,\n                        srcFunction,\n                        diag.createAddendum(),\n                        typeVarMap,\n                        flags,\n                        recursionCount + 1\n                    )\n                ) {\n                    return true;\n                }\n            }\n        }\n\n        if (destType.category === TypeCategory.OverloadedFunction) {\n            const overloadDiag = diag.createAddendum();\n\n            // All overloads in the dest must be assignable.\n            const isAssignable = !destType.overloads.some((destOverload) => {\n                return !canAssignType(\n                    destOverload,\n                    srcType,\n                    overloadDiag.createAddendum(),\n                    new TypeVarMap(),\n                    flags,\n                    recursionCount + 1\n                );\n            });\n\n            if (!isAssignable) {\n                overloadDiag.addMessage(\n                    Localizer.DiagnosticAddendum.overloadNotAssignable().format({\n                        name: destType.overloads[0].details.name,\n                    })\n                );\n                return false;\n            }\n\n            return true;\n        }\n\n        // NoneType and ModuleType derive from object.\n        if (isNone(srcType) || isModule(srcType)) {\n            if (isObject(destType)) {\n                const destClassType = destType.classType;\n                if (ClassType.isBuiltIn(destClassType, 'object')) {\n                    return true;\n                }\n            }\n        }\n\n        if (isNone(destType)) {\n            diag.addMessage(Localizer.DiagnosticAddendum.assignToNone());\n            return false;\n        }\n\n        diag.addMessage(\n            Localizer.DiagnosticAddendum.typeAssignmentMismatch().format({\n                sourceType: printType(srcType),\n                destType: printType(destType),\n            })\n        );\n\n        return false;\n    }\n\n    function getCallbackProtocolType(objType: ObjectType): FunctionType | undefined {\n        if (!ClassType.isProtocolClass(objType.classType)) {\n            return undefined;\n        }\n\n        const callMember = lookUpObjectMember(objType, '__call__');\n        if (!callMember) {\n            return undefined;\n        }\n\n        const memberType = getTypeOfMember(callMember);\n        if (memberType.category === TypeCategory.Function) {\n            const boundMethod = bindFunctionToClassOrObject(\n                objType,\n                memberType,\n                /* treatAsClassMember */ false,\n                /* errorNode */ undefined\n            );\n\n            if (boundMethod) {\n                return boundMethod as FunctionType;\n            }\n        }\n\n        return undefined;\n    }\n\n    function canAssignFunctionParameter(\n        destType: Type,\n        srcType: Type,\n        paramIndex: number,\n        diag: DiagnosticAddendum,\n        typeVarMap: TypeVarMap | undefined,\n        flags: CanAssignFlags,\n        recursionCount: number\n    ) {\n        // Call canAssignType once to perform any typeVarMap population.\n        canAssignType(\n            srcType,\n            destType,\n            new DiagnosticAddendum(),\n            typeVarMap,\n            flags | CanAssignFlags.ReverseTypeVarMatching,\n            recursionCount + 1\n        );\n\n        // Make sure we can assign the specialized dest type to the source type.\n        const specializedDestType = specializeType(destType, typeVarMap, /* makeConcrete */ false, recursionCount + 1);\n\n        if (!canAssignType(srcType, specializedDestType, diag.createAddendum(), undefined, flags, recursionCount + 1)) {\n            diag.addMessage(\n                Localizer.DiagnosticAddendum.paramAssignment().format({\n                    index: paramIndex + 1,\n                    sourceType: printType(specializedDestType),\n                    destType: printType(srcType),\n                })\n            );\n            return false;\n        }\n\n        return true;\n    }\n\n    function canAssignFunction(\n        destType: FunctionType,\n        srcType: FunctionType,\n        diag: DiagnosticAddendum,\n        typeVarMap: TypeVarMap | undefined,\n        flags: CanAssignFlags,\n        recursionCount: number\n    ): boolean {\n        let canAssign = true;\n        const checkReturnType = (flags & CanAssignFlags.SkipFunctionReturnTypeCheck) === 0;\n        flags &= ~CanAssignFlags.SkipFunctionReturnTypeCheck;\n\n        const srcParams = srcType.details.parameters;\n        const destParams = destType.details.parameters;\n\n        const srcStartOfNamed = srcParams.findIndex(\n            (p, index) =>\n                p.category === ParameterCategory.VarArgDictionary ||\n                (p.category === ParameterCategory.VarArgList && !p.name) ||\n                (index > 0 && srcParams[index - 1].category === ParameterCategory.VarArgList)\n        );\n        let srcPositionals = srcStartOfNamed < 0 ? srcParams : srcParams.slice(0, srcStartOfNamed);\n        const srcArgsIndex = srcPositionals.findIndex((p) => p.category === ParameterCategory.VarArgList && p.name);\n        srcPositionals = srcPositionals.filter((p) => p.category === ParameterCategory.Simple && p.name);\n\n        const destStartOfNamed = destParams.findIndex(\n            (p, index) =>\n                p.category === ParameterCategory.VarArgDictionary ||\n                (p.category === ParameterCategory.VarArgList && !p.name) ||\n                (index > 0 && destParams[index - 1].category === ParameterCategory.VarArgList)\n        );\n        let destPositionals = destStartOfNamed < 0 ? destParams : destParams.slice(0, destStartOfNamed);\n        const destArgsIndex = destPositionals.findIndex((p) => p.category === ParameterCategory.VarArgList && p.name);\n        destPositionals = destPositionals.filter((p) => p.category === ParameterCategory.Simple && p.name);\n\n        const positionalsToMatch = Math.min(srcPositionals.length, destPositionals.length);\n\n        if (!FunctionType.shouldSkipParamCompatibilityCheck(destType)) {\n            // Match positional parameters.\n            for (let paramIndex = 0; paramIndex < positionalsToMatch; paramIndex++) {\n                const srcParamType = FunctionType.getEffectiveParameterType(\n                    srcType,\n                    srcParams.findIndex((p) => p === srcPositionals[paramIndex])\n                );\n                const destParamType = FunctionType.getEffectiveParameterType(\n                    destType,\n                    destParams.findIndex((p) => p === destPositionals[paramIndex])\n                );\n\n                if (\n                    !canAssignFunctionParameter(\n                        destParamType,\n                        srcParamType,\n                        paramIndex + 1,\n                        diag.createAddendum(),\n                        typeVarMap,\n                        flags,\n                        recursionCount\n                    )\n                ) {\n                    canAssign = false;\n                }\n            }\n\n            if (destPositionals.length < srcPositionals.length) {\n                // If the dest type includes a ParamSpec, the additional parameters\n                // can be assigned to it, so no need to report an error here.\n                if (!destType.details.paramSpec) {\n                    const nonDefaultSrcParamCount = srcParams.filter((p) => !!p.name && !p.hasDefault).length;\n                    if (destArgsIndex < 0) {\n                        if (destPositionals.length < nonDefaultSrcParamCount) {\n                            diag.createAddendum().addMessage(\n                                Localizer.DiagnosticAddendum.functionTooFewParams().format({\n                                    expected: nonDefaultSrcParamCount,\n                                    received: destPositionals.length,\n                                })\n                            );\n                            canAssign = false;\n                        }\n                    } else {\n                        // Make sure the remaining positional arguments are of the\n                        // correct type for the *args parameter.\n                        const destArgsType = FunctionType.getEffectiveParameterType(destType, destArgsIndex);\n                        if (!isAnyOrUnknown(destArgsType)) {\n                            for (\n                                let paramIndex = destPositionals.length;\n                                paramIndex < srcPositionals.length;\n                                paramIndex++\n                            ) {\n                                const srcParamType = FunctionType.getEffectiveParameterType(\n                                    srcType,\n                                    srcParams.findIndex((p) => p === srcPositionals[paramIndex])\n                                );\n                                if (\n                                    !canAssignFunctionParameter(\n                                        destArgsType,\n                                        srcParamType,\n                                        paramIndex + 1,\n                                        diag.createAddendum(),\n                                        typeVarMap,\n                                        flags,\n                                        recursionCount\n                                    )\n                                ) {\n                                    canAssign = false;\n                                }\n                            }\n                        }\n                    }\n                }\n            } else if (srcPositionals.length < destPositionals.length) {\n                if (srcArgsIndex >= 0) {\n                    // Make sure the remaining dest parameters can be assigned to the source\n                    // *args parameter type.\n                    const srcArgsType = FunctionType.getEffectiveParameterType(srcType, srcArgsIndex);\n                    if (!isAnyOrUnknown(srcArgsType)) {\n                        for (\n                            let paramIndex = srcPositionals.length;\n                            paramIndex < destPositionals.length;\n                            paramIndex++\n                        ) {\n                            const destParamType = FunctionType.getEffectiveParameterType(\n                                destType,\n                                destParams.findIndex((p) => p === destPositionals[paramIndex])\n                            );\n                            if (\n                                !canAssignFunctionParameter(\n                                    destParamType,\n                                    srcArgsType,\n                                    paramIndex + 1,\n                                    diag.createAddendum(),\n                                    typeVarMap,\n                                    flags,\n                                    recursionCount\n                                )\n                            ) {\n                                canAssign = false;\n                            }\n                        }\n                    }\n                } else {\n                    diag.addMessage(\n                        Localizer.DiagnosticAddendum.functionTooManyParams().format({\n                            expected: srcPositionals.length,\n                            received: destPositionals.length,\n                        })\n                    );\n                    canAssign = false;\n                }\n            }\n\n            // If both src and dest have an \"*args\" parameter, make sure\n            // their types are compatible.\n            if (srcArgsIndex >= 0 && destArgsIndex >= 0) {\n                const srcArgsType = FunctionType.getEffectiveParameterType(srcType, srcArgsIndex);\n                const destArgsType = FunctionType.getEffectiveParameterType(destType, destArgsIndex);\n                if (\n                    !canAssignFunctionParameter(\n                        destArgsType,\n                        srcArgsType,\n                        destArgsIndex + 1,\n                        diag.createAddendum(),\n                        typeVarMap,\n                        flags,\n                        recursionCount\n                    )\n                ) {\n                    canAssign = false;\n                }\n            }\n\n            // If the dest has an \"*args\" but the source doesn't, report the incompatibility.\n            // The converse situation is OK.\n            if (srcArgsIndex < 0 && destArgsIndex >= 0) {\n                diag.createAddendum().addMessage(\n                    Localizer.DiagnosticAddendum.argsParamMissing().format({\n                        paramName: destParams[destArgsIndex].name!,\n                    })\n                );\n                canAssign = false;\n            }\n\n            // Handle matching of named (keyword) parameters.\n            // Build a dictionary of named parameters in the dest.\n            const destParamMap = new Map<string, FunctionParameter>();\n            let destHasKwargsParam = false;\n            if (destStartOfNamed >= 0) {\n                destParams.forEach((param, index) => {\n                    if (index >= destStartOfNamed) {\n                        if (param.category === ParameterCategory.VarArgDictionary) {\n                            destHasKwargsParam = true;\n                        } else if (param.name && param.category === ParameterCategory.Simple) {\n                            destParamMap.set(param.name, param);\n                        }\n                    }\n                });\n            }\n\n            if (srcStartOfNamed >= 0) {\n                srcParams.forEach((param, index) => {\n                    if (index >= srcStartOfNamed) {\n                        if (param.name && param.category === ParameterCategory.Simple) {\n                            const destParam = destParamMap.get(param.name);\n                            const paramDiag = diag.createAddendum();\n                            if (!destParam) {\n                                if (!destHasKwargsParam && !param.hasDefault) {\n                                    paramDiag.addMessage(\n                                        Localizer.DiagnosticAddendum.namedParamMissingInDest().format({\n                                            name: param.name,\n                                        })\n                                    );\n                                    canAssign = false;\n                                }\n                            } else {\n                                const specializedDestParamType = specializeType(\n                                    destParam.type,\n                                    typeVarMap,\n                                    /* makeConcrete */ false,\n                                    recursionCount + 1\n                                );\n                                if (\n                                    !canAssignType(\n                                        param.type,\n                                        specializedDestParamType,\n                                        paramDiag.createAddendum(),\n                                        undefined,\n                                        flags,\n                                        recursionCount + 1\n                                    )\n                                ) {\n                                    paramDiag.addMessage(\n                                        Localizer.DiagnosticAddendum.namedParamTypeMismatch().format({\n                                            name: param.name,\n                                            sourceType: printType(specializedDestParamType),\n                                            destType: printType(param.type),\n                                        })\n                                    );\n                                    canAssign = false;\n                                }\n                                destParamMap.delete(param.name);\n                            }\n                        }\n                    }\n                });\n            }\n\n            // See if there are any unmatched named parameters.\n            destParamMap.forEach((_, paramName) => {\n                const paramDiag = diag.createAddendum();\n                paramDiag.addMessage(\n                    Localizer.DiagnosticAddendum.namedParamMissingInSource().format({ name: paramName })\n                );\n                canAssign = false;\n            });\n        }\n\n        // Perform partial specialization of type variables to allow for\n        // \"higher-order\" type variables.\n        if (typeVarMap && !typeVarMap.isLocked()) {\n            typeVarMap.getTypeVars().forEach((entry) => {\n                const specializedType = specializeType(entry.type, typeVarMap, /* makeConcrete */ false);\n                if (specializedType !== entry.type) {\n                    typeVarMap.setTypeVar(entry.typeVar, specializedType, typeVarMap.isNarrowable(entry.typeVar));\n                }\n            });\n        }\n\n        // Match the return parameter.\n        if (checkReturnType) {\n            const destReturnType = getFunctionEffectiveReturnType(destType);\n            if (!isAnyOrUnknown(destReturnType)) {\n                let srcReturnType = getFunctionEffectiveReturnType(srcType);\n                if (typeVarMap) {\n                    srcReturnType = specializeType(srcReturnType, typeVarMap, /* makeConcrete */ false);\n                }\n                const returnDiag = diag.createAddendum();\n\n                if (\n                    !canAssignType(\n                        destReturnType,\n                        srcReturnType,\n                        returnDiag.createAddendum(),\n                        typeVarMap,\n                        flags,\n                        recursionCount + 1\n                    )\n                ) {\n                    returnDiag.addMessage(\n                        Localizer.DiagnosticAddendum.functionReturnTypeMismatch().format({\n                            sourceType: printType(srcReturnType),\n                            destType: printType(destReturnType),\n                        })\n                    );\n                    canAssign = false;\n                }\n            }\n\n            // Are we assigning to a function with a ParamSpec?\n            if (destType.details.paramSpec && typeVarMap && !typeVarMap.isLocked()) {\n                typeVarMap.setParamSpec(\n                    destType.details.paramSpec,\n                    srcType.details.parameters\n                        .map((p, index) => {\n                            const paramSpecEntry: ParamSpecEntry = {\n                                name: p.name || `__p${index}`,\n                                type: p.type,\n                            };\n                            return paramSpecEntry;\n                        })\n                        .slice(destType.details.parameters.length, srcType.details.parameters.length)\n                );\n            }\n        }\n\n        return canAssign;\n    }\n\n    // When a value is assigned to a variable with a declared type,\n    // we may be able to narrow the type based on the assignment.\n    function narrowTypeBasedOnAssignment(declaredType: Type, assignedType: Type): Type {\n        const diagAddendum = new DiagnosticAddendum();\n\n        if (declaredType.category === TypeCategory.Union) {\n            return doForSubtypes(declaredType, (subtype) => {\n                if (assignedType.category === TypeCategory.Union) {\n                    if (!assignedType.subtypes.some((t) => canAssignType(subtype, t, diagAddendum))) {\n                        return undefined;\n                    } else {\n                        return subtype;\n                    }\n                }\n\n                if (!canAssignType(subtype, assignedType, diagAddendum)) {\n                    return undefined;\n                }\n\n                // We assume that assignedType is a narrower type than subtype,\n                // so return it rather than subtype.\n                if (!isAnyOrUnknown(assignedType)) {\n                    return assignedType;\n                }\n\n                return subtype;\n            });\n        }\n\n        if (!canAssignType(declaredType, assignedType, diagAddendum)) {\n            return NeverType.create();\n        }\n\n        return transformTypeObjectToClass(declaredType);\n    }\n\n    function canOverrideMethod(baseMethod: Type, overrideMethod: FunctionType, diag: DiagnosticAddendum): boolean {\n        // If we're overriding an overloaded method, uses the last overload.\n        if (baseMethod.category === TypeCategory.OverloadedFunction) {\n            baseMethod = baseMethod.overloads[baseMethod.overloads.length - 1];\n        }\n\n        // If we're overriding a non-method with a method, report it as an error.\n        // This occurs when a non-property overrides a property.\n        if (baseMethod.category !== TypeCategory.Function) {\n            diag.addMessage(Localizer.DiagnosticAddendum.overrideType().format({ type: printType(baseMethod) }));\n            return false;\n        }\n\n        let canOverride = true;\n        const baseParams = baseMethod.details.parameters;\n        const overrideParams = overrideMethod.details.parameters;\n\n        // Verify that the param count matches exactly or that the override\n        // adds only params that preserve the original signature.\n        let foundParamCountMismatch = false;\n        if (overrideParams.length < baseParams.length) {\n            foundParamCountMismatch = true;\n        } else if (overrideParams.length > baseParams.length) {\n            // Verify that all of the override parameters that extend the\n            // signature are either *vars, **kwargs or parameters with\n            // default values.\n\n            for (let i = baseParams.length; i < overrideParams.length; i++) {\n                const overrideParam = overrideParams[i];\n\n                if (\n                    overrideParam.category === ParameterCategory.Simple &&\n                    overrideParam.name &&\n                    !overrideParam.hasDefault\n                ) {\n                    foundParamCountMismatch = true;\n                }\n            }\n        }\n\n        if (foundParamCountMismatch) {\n            diag.addMessage(\n                Localizer.DiagnosticAddendum.overrideParamCount().format({\n                    baseCount: baseParams.length,\n                    overrideCount: overrideParams.length,\n                })\n            );\n            canOverride = false;\n        }\n\n        const paramCount = Math.min(baseParams.length, overrideParams.length);\n        const positionOnlyIndex = baseParams.findIndex(\n            (param) => !param.name && param.category === ParameterCategory.Simple\n        );\n\n        for (let i = 0; i < paramCount; i++) {\n            const baseParam = baseParams[i];\n            const overrideParam = overrideParams[i];\n\n            if (\n                i > positionOnlyIndex &&\n                !isPrivateOrProtectedName(baseParam.name || '') &&\n                baseParam.category === ParameterCategory.Simple &&\n                baseParam.name !== overrideParam.name\n            ) {\n                diag.addMessage(\n                    Localizer.DiagnosticAddendum.overrideParamName().format({\n                        index: i + 1,\n                        baseName: baseParam.name || '*',\n                        overrideName: overrideParam.name || '*',\n                    })\n                );\n                canOverride = false;\n            } else {\n                const baseParamType = FunctionType.getEffectiveParameterType(baseMethod, i);\n                const overrideParamType = FunctionType.getEffectiveParameterType(overrideMethod, i);\n\n                const baseIsSynthesizedTypeVar = isTypeVar(baseParamType) && baseParamType.details.isSynthesized;\n                const overrideIsSynthesizedTypeVar =\n                    isTypeVar(overrideParamType) && overrideParamType.details.isSynthesized;\n                if (!baseIsSynthesizedTypeVar && !overrideIsSynthesizedTypeVar) {\n                    if (\n                        baseParam.category !== overrideParam.category ||\n                        !canAssignType(overrideParamType, baseParamType, diag.createAddendum())\n                    ) {\n                        diag.addMessage(\n                            Localizer.DiagnosticAddendum.overrideParamType().format({\n                                index: i + 1,\n                                baseType: printType(baseParamType),\n                                overrideType: printType(overrideParamType),\n                            })\n                        );\n                        canOverride = false;\n                    }\n                }\n            }\n        }\n\n        const baseReturnType = getFunctionEffectiveReturnType(baseMethod);\n        const overrideReturnType = getFunctionEffectiveReturnType(overrideMethod);\n        if (!canAssignType(baseReturnType, overrideReturnType, diag.createAddendum())) {\n            diag.addMessage(\n                Localizer.DiagnosticAddendum.overrideReturnType().format({\n                    baseType: printType(baseReturnType),\n                    overrideType: printType(overrideReturnType),\n                })\n            );\n\n            canOverride = false;\n        }\n\n        return canOverride;\n    }\n\n    // Validates that the specified source type matches the constraints\n    // of the type variable.\n    function canAssignToTypeVar(\n        destType: TypeVarType,\n        srcType: Type,\n        diag: DiagnosticAddendum,\n        flags = CanAssignFlags.Default,\n        recursionCount = 0\n    ): boolean {\n        if (recursionCount > maxTypeRecursionCount) {\n            return true;\n        }\n\n        if (isAnyOrUnknown(srcType)) {\n            return true;\n        }\n\n        let effectiveSrcType: Type = srcType;\n\n        if (isTypeVar(srcType)) {\n            if (isTypeSame(srcType, destType)) {\n                return true;\n            }\n\n            if (srcType.details.boundType) {\n                // If the source type is a type var itself and has a bound type,\n                // convert it to that bound type.\n                effectiveSrcType = getConcreteTypeFromTypeVar(srcType, recursionCount + 1);\n            } else if (srcType.details.constraints) {\n                effectiveSrcType = combineTypes(srcType.details.constraints);\n            } else {\n                effectiveSrcType = AnyType.create();\n            }\n        }\n\n        // If there's a bound type, make sure the source is derived from it.\n        const boundType = destType.details.boundType;\n        if (boundType) {\n            if (\n                !canAssignType(boundType, effectiveSrcType, diag.createAddendum(), undefined, flags, recursionCount + 1)\n            ) {\n                // Avoid adding a message that will confuse users if the TypeVar was\n                // synthesized for internal purposes.\n                if (!destType.details.isSynthesized) {\n                    diag.addMessage(\n                        Localizer.DiagnosticAddendum.typeBound().format({\n                            sourceType: printType(effectiveSrcType),\n                            destType: printType(boundType),\n                            name: destType.details.name,\n                        })\n                    );\n                }\n                return false;\n            }\n        }\n\n        // If there are no constraints, we're done.\n        const constraints = destType.details.constraints;\n        if (constraints.length === 0) {\n            return true;\n        }\n\n        // Try to find a match among the constraints.\n        for (const constraint of constraints) {\n            if (isAnyOrUnknown(constraint)) {\n                return true;\n            } else if (effectiveSrcType.category === TypeCategory.Union) {\n                // Does it match at least one of the constraints?\n                if (effectiveSrcType.subtypes.find((t) => isSameWithoutLiteralValue(constraint, t))) {\n                    return true;\n                }\n            } else if (isSameWithoutLiteralValue(constraint, effectiveSrcType)) {\n                return true;\n            }\n        }\n\n        diag.addMessage(\n            Localizer.DiagnosticAddendum.typeConstrainedTypeVar().format({\n                type: printType(effectiveSrcType),\n                name: destType.details.name,\n            })\n        );\n\n        return false;\n    }\n\n    function getAbstractMethods(classType: ClassType): AbstractMethod[] {\n        const symbolTable = new Map<string, AbstractMethod>();\n\n        classType.details.mro.forEach((mroClass) => {\n            if (isClass(mroClass)) {\n                // See if this class is introducing a new abstract method that has not been\n                // introduced previously or if it is overriding an abstract method with\n                // a non-abstract one.\n                mroClass.details.fields.forEach((symbol, symbolName) => {\n                    // We do a quick-and-dirty evaluation of methods based on\n                    // decorators to determine which ones are abstract. This allows\n                    // us to avoid evaluating the full function types.\n                    if (symbol.isClassMember()) {\n                        let isAbstract: boolean;\n\n                        const decl = getLastTypedDeclaredForSymbol(symbol);\n                        if (decl && decl.type === DeclarationType.Function) {\n                            const functionFlags = getFunctionFlagsFromDecorators(decl.node, true);\n                            isAbstract = !!(functionFlags & FunctionTypeFlags.AbstractMethod);\n                        } else {\n                            // If a symbol is overridden by a non-function, it is no longer\n                            // considered abstract. This can happen in some code, for example,\n                            // when a base class declares an abstract property and a subclass\n                            // \"overrides\" it with an instance variable.\n                            isAbstract = false;\n                        }\n\n                        if (!symbolTable.has(symbolName)) {\n                            symbolTable.set(symbolName, {\n                                symbol,\n                                symbolName,\n                                isAbstract,\n                                classType: mroClass,\n                            });\n                        }\n                    }\n                });\n            }\n        });\n\n        // Create a final list of methods that are abstract.\n        const methodList: AbstractMethod[] = [];\n        symbolTable.forEach((method) => {\n            if (method.isAbstract) {\n                methodList.push(method);\n            }\n        });\n\n        return methodList;\n    }\n\n    // Determines whether the specified keys and values can be assigned to\n    // a typed dictionary class. The caller should have already validated\n    // that the class is indeed a typed dict.\n    function canAssignToTypedDict(\n        classType: ClassType,\n        keyTypes: Type[],\n        valueTypes: Type[],\n        diagAddendum: DiagnosticAddendum\n    ): boolean {\n        assert(ClassType.isTypedDictClass(classType));\n        assert(keyTypes.length === valueTypes.length);\n\n        let isMatch = true;\n\n        const symbolMap = getTypedDictMembersForClass(classType);\n\n        keyTypes.forEach((keyType, index) => {\n            if (\n                !isObject(keyType) ||\n                !ClassType.isBuiltIn(keyType.classType, 'str') ||\n                keyType.classType.literalValue === undefined\n            ) {\n                isMatch = false;\n            } else {\n                const keyValue = keyType.classType.literalValue as string;\n                const symbolEntry = symbolMap.get(keyValue);\n\n                if (!symbolEntry) {\n                    // The provided key name doesn't exist.\n                    isMatch = false;\n                    diagAddendum.addMessage(\n                        Localizer.DiagnosticAddendum.typedDictFieldUndefined().format({\n                            name: keyType.classType.literalValue as string,\n                            type: printType(ObjectType.create(classType)),\n                        })\n                    );\n                } else {\n                    // Can we assign the value to the declared type?\n                    const assignDiag = new DiagnosticAddendum();\n                    if (!canAssignType(symbolEntry.valueType, valueTypes[index], assignDiag)) {\n                        diagAddendum.addMessage(\n                            Localizer.DiagnosticAddendum.typedDictFieldTypeMismatch().format({\n                                name: keyType.classType.literalValue as string,\n                                type: printType(valueTypes[index]),\n                            })\n                        );\n                        isMatch = false;\n                    }\n                    symbolEntry.isProvided = true;\n                }\n            }\n        });\n\n        if (!isMatch) {\n            return false;\n        }\n\n        // See if any required keys are missing.\n        symbolMap.forEach((entry, name) => {\n            if (entry.isRequired && !entry.isProvided) {\n                diagAddendum.addMessage(\n                    Localizer.DiagnosticAddendum.typedDictFieldRequired().format({\n                        name,\n                        type: printType(ObjectType.create(classType)),\n                    })\n                );\n                isMatch = false;\n            }\n        });\n\n        return isMatch;\n    }\n\n    function getTypedDictMembersForClass(classType: ClassType) {\n        // Were the entries already calculated and cached?\n        if (!classType.details.typedDictEntries) {\n            const entries = new Map<string, TypedDictEntry>();\n            getTypedDictMembersForClassRecursive(classType, entries);\n\n            // Cache the entries for next time.\n            classType.details.typedDictEntries = entries;\n        }\n\n        // Create a copy of the entries so the caller can mutate them.\n        const entries = new Map<string, TypedDictEntry>();\n        classType.details.typedDictEntries!.forEach((value, key) => {\n            entries.set(key, { ...value });\n        });\n\n        return entries;\n    }\n\n    function getTypedDictMembersForClassRecursive(\n        classType: ClassType,\n        keyMap: Map<string, TypedDictEntry>,\n        recursionCount = 0\n    ) {\n        assert(ClassType.isTypedDictClass(classType));\n        if (recursionCount > maxTypeRecursionCount) {\n            return;\n        }\n\n        classType.details.baseClasses.forEach((baseClassType) => {\n            if (isClass(baseClassType) && ClassType.isTypedDictClass(baseClassType)) {\n                getTypedDictMembersForClassRecursive(baseClassType, keyMap, recursionCount + 1);\n            }\n        });\n\n        // Add any new typed dict entries from this class.\n        classType.details.fields.forEach((symbol, name) => {\n            if (!symbol.isIgnoredForProtocolMatch()) {\n                // Only variables (not functions, classes, etc.) are considered.\n                const lastDecl = getLastTypedDeclaredForSymbol(symbol);\n                if (lastDecl && lastDecl.type === DeclarationType.Variable) {\n                    keyMap.set(name, {\n                        valueType: getDeclaredTypeOfSymbol(symbol) || UnknownType.create(),\n                        isRequired: !ClassType.isCanOmitDictValues(classType),\n                        isProvided: false,\n                    });\n                }\n            }\n        });\n    }\n\n    // If the memberType is an instance or class method, creates a new\n    // version of the function that has the \"self\" or \"cls\" parameter bound\n    // to it. If treatAsClassMember is true, the function is treated like a\n    // class member even if it's not marked as such. That's needed to\n    // special-case the __new__ magic method when it's invoked as a\n    // constructor (as opposed to by name).\n    function bindFunctionToClassOrObject(\n        baseType: ClassType | ObjectType | undefined,\n        memberType: Type,\n        treatAsClassMember: boolean,\n        errorNode: ParseNode | undefined = undefined\n    ): Type | undefined {\n        if (memberType.category === TypeCategory.Function) {\n            // If the caller specified no base type, always strip the\n            // first parameter. This is used in cases like constructors.\n            if (!baseType) {\n                return stripFirstParameter(memberType);\n            } else if (FunctionType.isInstanceMethod(memberType) && !treatAsClassMember) {\n                if (isObject(baseType)) {\n                    return partiallySpecializeFunctionForBoundClassOrObject(baseType, memberType, errorNode);\n                }\n            } else if (FunctionType.isClassMethod(memberType) || treatAsClassMember) {\n                return partiallySpecializeFunctionForBoundClassOrObject(\n                    isClass(baseType) ? baseType : baseType.classType,\n                    memberType,\n                    errorNode\n                );\n            }\n        } else if (memberType.category === TypeCategory.OverloadedFunction) {\n            const newOverloadType = OverloadedFunctionType.create();\n            memberType.overloads.forEach((overload) => {\n                const boundMethod = bindFunctionToClassOrObject(\n                    baseType,\n                    overload,\n                    treatAsClassMember,\n                    /* errorNode */ undefined\n                );\n                if (boundMethod) {\n                    OverloadedFunctionType.addOverload(newOverloadType, boundMethod as FunctionType);\n                }\n            });\n\n            if (newOverloadType.overloads.length === 1) {\n                return newOverloadType.overloads[0];\n            } else if (newOverloadType.overloads.length === 0) {\n                // No overloads matched, so rebind with the errorNode\n                // to report the error(s) to the user.\n                memberType.overloads.forEach((overload) => {\n                    bindFunctionToClassOrObject(baseType, overload, treatAsClassMember, errorNode);\n                });\n                return undefined;\n            }\n\n            return newOverloadType;\n        }\n\n        return memberType;\n    }\n\n    function partiallySpecializeFunctionForBoundClassOrObject(\n        baseType: ClassType | ObjectType,\n        memberType: FunctionType,\n        errorNode: ParseNode | undefined\n    ): Type | undefined {\n        const classType = isClass(baseType) ? baseType : baseType.classType;\n\n        // If the class has already been specialized (fully or partially), use its\n        // existing type arg mappings. If it hasn't, use a fresh type arg map.\n        const typeVarMap = classType.typeArguments ? buildTypeVarMapFromSpecializedClass(classType) : new TypeVarMap();\n\n        if (memberType.details.parameters.length > 0) {\n            const firstParam = memberType.details.parameters[0];\n\n            // Fill out the typeVarMap.\n            canAssignType(firstParam.type, baseType, new DiagnosticAddendum(), typeVarMap);\n        }\n\n        // Get the effective return type, which will have the side effect of lazily\n        // evaluating (and caching) the inferred return type if there is no defined return type.\n        getFunctionEffectiveReturnType(memberType);\n\n        const specializedFunction = specializeType(memberType, typeVarMap, /* makeConcrete */ false) as FunctionType;\n\n        // If the method has an annotated cls or self parameter, make sure the\n        // base type is compatible with it.\n        if (memberType.details.parameters.length > 0) {\n            const firstParam = memberType.details.parameters[0];\n\n            if (firstParam.name && !firstParam.isNameSynthesized && firstParam.hasDeclaredType) {\n                const paramType = makeTypeVarsConcrete(FunctionType.getEffectiveParameterType(memberType, 0));\n                const diag = new DiagnosticAddendum();\n                if (!canAssignType(paramType, baseType, diag)) {\n                    if (errorNode) {\n                        addDiagnostic(\n                            getFileInfo(errorNode).diagnosticRuleSet.reportGeneralTypeIssues,\n                            DiagnosticRule.reportGeneralTypeIssues,\n                            Localizer.Diagnostic.bindTypeMismatch().format({\n                                type: printType(baseType),\n                                methodName: memberType.details.name,\n                                paramName: firstParam.name,\n                            }) + diag.getString(),\n                            errorNode\n                        );\n                    } else {\n                        // If there was no errorNode, we couldn't report the error,\n                        // so we will instead return undefined and let the caller\n                        // deal with the error.\n                        return undefined;\n                    }\n                }\n            }\n        }\n\n        return stripFirstParameter(specializedFunction);\n    }\n\n    function printObjectTypeForClass(type: ClassType, recursionCount = 0): string {\n        let objName = type.details.name;\n\n        // If this is a pseudo-generic class, don't display the type arguments\n        // or type parameters because it will confuse users.\n        if (!ClassType.isPseudoGenericClass(type)) {\n            // If there is a type arguments array, it's a specialized class.\n            if (type.typeArguments) {\n                // Handle Tuple[()] as a special case.\n                if (type.typeArguments.length > 0) {\n                    if (\n                        (evaluatorOptions.printTypeFlags & PrintTypeFlags.OmitTypeArgumentsIfAny) === 0 ||\n                        type.typeArguments.some((typeArg) => !isAnyOrUnknown(typeArg))\n                    ) {\n                        objName +=\n                            '[' +\n                            type.typeArguments\n                                .map((typeArg) => {\n                                    return printType(typeArg, /* expandTypeAlias */ false, recursionCount + 1);\n                                })\n                                .join(', ') +\n                            ']';\n                    }\n                } else {\n                    if (isTupleClass(type)) {\n                        objName += '[()]';\n                    }\n                }\n            } else {\n                const typeParams = ClassType.getTypeParameters(type);\n\n                if (typeParams.length > 0) {\n                    if (\n                        (evaluatorOptions.printTypeFlags & PrintTypeFlags.OmitTypeArgumentsIfAny) === 0 ||\n                        typeParams.some((typeParam) => !isAnyOrUnknown(typeParam))\n                    ) {\n                        objName +=\n                            '[' +\n                            typeParams\n                                .map((typeParam) => {\n                                    return printType(typeParam, /* expandTypeAlias */ false, recursionCount + 1);\n                                })\n                                .join(', ') +\n                            ']';\n                    }\n                }\n            }\n        }\n\n        return objName;\n    }\n\n    function printFunctionParts(type: FunctionType, recursionCount = 0): [string[], string] {\n        const paramTypeStrings = type.details.parameters.map((param, index) => {\n            let paramString = '';\n            if (param.category === ParameterCategory.VarArgList) {\n                paramString += '*';\n            } else if (param.category === ParameterCategory.VarArgDictionary) {\n                paramString += '**';\n            }\n\n            if (param.name) {\n                paramString += param.name;\n            }\n\n            let defaultValueAssignment = '=';\n            if (param.name) {\n                // Avoid printing type types if parameter have unknown type.\n                if (param.hasDeclaredType || param.isTypeInferred) {\n                    const paramType = FunctionType.getEffectiveParameterType(type, index);\n                    const paramTypeString =\n                        recursionCount < maxTypeRecursionCount\n                            ? printType(paramType, /* expandTypeAlias */ false, recursionCount + 1)\n                            : '';\n                    paramString += ': ' + paramTypeString;\n\n                    // PEP8 indicates that the \"=\" for the default value should have surrounding\n                    // spaces when used with a type annotation.\n                    defaultValueAssignment = ' = ';\n                } else if ((evaluatorOptions.printTypeFlags & PrintTypeFlags.OmitTypeArgumentsIfAny) === 0) {\n                    paramString += ': Unknown';\n                    defaultValueAssignment = ' = ';\n                }\n            } else {\n                paramString += '/';\n            }\n\n            if (type.details.declaration) {\n                const adjustedIndex = type.ignoreFirstParamOfDeclaration ? index + 1 : index;\n                const paramNode = type.details.declaration.node.parameters[adjustedIndex];\n                if (paramNode.defaultValue) {\n                    paramString += defaultValueAssignment + ParseTreeUtils.printExpression(paramNode.defaultValue);\n                }\n            }\n\n            return paramString;\n        });\n\n        const returnType = getFunctionEffectiveReturnType(type);\n        let returnTypeString =\n            recursionCount < maxTypeRecursionCount\n                ? printType(returnType, /* expandTypeAlias */ false, recursionCount + 1)\n                : '';\n\n        if (\n            evaluatorOptions.printTypeFlags & PrintTypeFlags.PEP604 &&\n            returnType.category === TypeCategory.Union &&\n            recursionCount > 0\n        ) {\n            returnTypeString = `(${returnTypeString})`;\n        }\n\n        return [paramTypeStrings, returnTypeString];\n    }\n\n    function printType(type: Type, expandTypeAlias = false, recursionCount = 0): string {\n        if (recursionCount >= maxTypeRecursionCount) {\n            return '...';\n        }\n\n        // If this is a type alias, use its name rather than the type\n        // it represents.\n        if (type.typeAliasInfo && !expandTypeAlias) {\n            let aliasName = type.typeAliasInfo.aliasName;\n\n            // If there is a type arguments array, it's a specialized type alias.\n            if (type.typeAliasInfo.typeArguments) {\n                if (\n                    (evaluatorOptions.printTypeFlags & PrintTypeFlags.OmitTypeArgumentsIfAny) === 0 ||\n                    type.typeAliasInfo.typeArguments.some((typeArg) => !isAnyOrUnknown(typeArg))\n                ) {\n                    aliasName +=\n                        '[' +\n                        type.typeAliasInfo.typeArguments\n                            .map((typeArg) => {\n                                return printType(typeArg, /* expandTypeAlias */ false, recursionCount + 1);\n                            })\n                            .join(', ') +\n                        ']';\n                }\n            } else {\n                if (type.typeAliasInfo.typeParameters) {\n                    if (\n                        (evaluatorOptions.printTypeFlags & PrintTypeFlags.OmitTypeArgumentsIfAny) === 0 ||\n                        type.typeAliasInfo.typeParameters.some((typeParam) => !isAnyOrUnknown(typeParam))\n                    ) {\n                        aliasName +=\n                            '[' +\n                            type.typeAliasInfo.typeParameters\n                                .map((typeParam) => {\n                                    return printType(typeParam, /* expandTypeAlias */ false, recursionCount + 1);\n                                })\n                                .join(', ') +\n                            ']';\n                    }\n                }\n            }\n\n            return aliasName;\n        }\n\n        switch (type.category) {\n            case TypeCategory.Unbound: {\n                return 'Unbound';\n            }\n\n            case TypeCategory.Unknown: {\n                return (evaluatorOptions.printTypeFlags & PrintTypeFlags.PrintUnknownWithAny) !== 0 ? 'Any' : 'Unknown';\n            }\n\n            case TypeCategory.Module: {\n                return 'Module';\n            }\n\n            case TypeCategory.Class: {\n                return 'Type[' + printObjectTypeForClass(type, recursionCount + 1) + ']';\n            }\n\n            case TypeCategory.Object: {\n                const objType = type;\n                if (objType.classType.literalValue !== undefined) {\n                    return printLiteralType(objType);\n                }\n\n                return printObjectTypeForClass(objType.classType, recursionCount + 1);\n            }\n\n            case TypeCategory.Function: {\n                // If it's a Callable with a ParamSpec, use the\n                // Callable notation.\n                const parts = printFunctionParts(type, recursionCount);\n                if (type.details.paramSpec) {\n                    if (type.details.parameters.length > 0) {\n                        // Remove the args and kwargs parameters from the end.\n                        const paramTypes = type.details.parameters.map((param) => printType(param.type));\n                        return `Callable[Concatenate[${paramTypes.join(', ')}, ${\n                            type.details.paramSpec.details.name\n                        }], ${parts[1]}]`;\n                    }\n                    return `Callable[${type.details.paramSpec.details.name}, ${parts[1]}]`;\n                }\n                return `(${parts[0].join(', ')}) -> ${parts[1]}`;\n            }\n\n            case TypeCategory.OverloadedFunction: {\n                const overloadedType = type;\n                const overloads = overloadedType.overloads.map((overload) =>\n                    printType(overload, /* expandTypeAlias */ false, recursionCount + 1)\n                );\n                return `Overload[${overloads.join(', ')}]`;\n            }\n\n            case TypeCategory.Union: {\n                const unionType = type;\n                let subtypes: Type[] = unionType.subtypes;\n\n                if (subtypes.find((t) => t.category === TypeCategory.None) !== undefined) {\n                    const optionalType = printType(\n                        removeNoneFromUnion(unionType),\n                        /* expandTypeAlias */ false,\n                        recursionCount + 1\n                    );\n\n                    if (evaluatorOptions.printTypeFlags & PrintTypeFlags.PEP604) {\n                        return optionalType + ' | None';\n                    }\n\n                    return 'Optional[' + optionalType + ']';\n                }\n\n                // Make a shallow copy of the array so we can manipulate it.\n                subtypes = [];\n                subtypes = subtypes.concat(...unionType.subtypes);\n\n                // If we're printing \"Unknown\" as \"Any\", remove redundant\n                // unknowns so we don't see two Any's appear in the union.\n                if ((evaluatorOptions.printTypeFlags & PrintTypeFlags.PrintUnknownWithAny) !== 0) {\n                    if (subtypes.some((t) => t.category === TypeCategory.Any)) {\n                        subtypes = subtypes.filter((t) => !isUnknown(t));\n                    }\n                }\n\n                // If one or more subtypes are pseudo-generic, remove any other pseudo-generics\n                // of the same type because we don't print type arguments for pseudo-generic\n                // types, and we'll end up displaying seemingly-duplicated types.\n                const isPseudoGeneric = (type: Type) =>\n                    (isClass(type) && ClassType.isPseudoGenericClass(type)) ||\n                    (isObject(type) && ClassType.isPseudoGenericClass(type.classType));\n                if (subtypes.some((t) => isPseudoGeneric(t))) {\n                    const filteredSubtypes: Type[] = [];\n                    subtypes.forEach((type) => {\n                        if (!isPseudoGeneric(type)) {\n                            filteredSubtypes.push(type);\n                        } else if (isClass(type)) {\n                            if (!filteredSubtypes.some((t) => isClass(t) && ClassType.isSameGenericClass(t, type))) {\n                                filteredSubtypes.push(type);\n                            }\n                        } else if (isObject(type)) {\n                            if (\n                                !filteredSubtypes.some(\n                                    (t) => isObject(t) && ClassType.isSameGenericClass(t.classType, type.classType)\n                                )\n                            ) {\n                                filteredSubtypes.push(type);\n                            }\n                        }\n                    });\n                    subtypes = filteredSubtypes;\n                }\n\n                const isLiteralObject = (type: Type) => isObject(type) && type.classType.literalValue !== undefined;\n                const isLiteralClass = (type: Type) => isClass(type) && type.literalValue !== undefined;\n\n                const subtypeStrings: string[] = [];\n                while (subtypes.length > 0) {\n                    const subtype = subtypes.shift()!;\n                    if (isLiteralObject(subtype)) {\n                        // Combine all literal objects. Rather than printing Union[Literal[1],\n                        // Literal[2]], print Literal[1, 2].\n                        const literals = subtypes.filter((t) => isLiteralObject(t));\n                        literals.unshift(subtype);\n                        const literalValues = literals.map((t) => printLiteralValue((t as ObjectType).classType));\n                        subtypeStrings.push(`Literal[${literalValues.join(', ')}]`);\n\n                        // Remove the items we've handled.\n                        if (literals.length > 1) {\n                            subtypes = subtypes.filter((t) => !isLiteralObject(t));\n                        }\n                    } else if (isLiteralClass(subtype)) {\n                        // Combine all literal classes.\n                        const literals = subtypes.filter((t) => isLiteralClass(t));\n                        literals.unshift(subtype);\n                        const literalValues = literals.map((t) => printLiteralValue(t as ClassType));\n                        subtypeStrings.push(`Type[Literal[${literalValues.join(', ')}]]`);\n\n                        // Remove the items we've handled.\n                        if (literals.length > 1) {\n                            subtypes = subtypes.filter((t) => !isLiteralClass(t));\n                        }\n                    } else {\n                        subtypeStrings.push(printType(subtype, /* expandTypeAlias */ false, recursionCount + 1));\n                    }\n                }\n\n                if (subtypeStrings.length === 1) {\n                    return subtypeStrings[0];\n                }\n\n                if (evaluatorOptions.printTypeFlags & PrintTypeFlags.PEP604) {\n                    return subtypeStrings.join(' | ');\n                }\n\n                return `Union[${subtypeStrings.join(', ')}]`;\n            }\n\n            case TypeCategory.TypeVar: {\n                // If it's synthesized, don't expose the internal name we generated.\n                // This will confuse users. The exception is if it's a bound synthesized\n                // type, in which case we'll print the bound type. This is used for\n                // \"self\" and \"cls\" parameters.\n                if (type.details.isSynthesized) {\n                    // If it's a synthesized type var used to implement recursive type\n                    // aliases, return the type alias name.\n                    if (type.details.recursiveTypeAliasName) {\n                        return type.details.recursiveTypeAliasName;\n                    }\n\n                    if (type.details.boundType) {\n                        return printType(type.details.boundType, /* expandTypeAlias */ false, recursionCount + 1);\n                    }\n\n                    return (evaluatorOptions.printTypeFlags & PrintTypeFlags.PrintUnknownWithAny) !== 0\n                        ? 'Any'\n                        : 'Unknown';\n                }\n\n                if (type.details.isParamSpec) {\n                    return `ParamSpec('${type.details.name}')`;\n                }\n\n                return `TypeVar('${type.details.name}')`;\n            }\n\n            case TypeCategory.None: {\n                return TypeBase.isInstantiable(type) ? 'NoneType' : 'None';\n            }\n\n            case TypeCategory.Never: {\n                return 'Never';\n            }\n\n            case TypeCategory.Any: {\n                const anyType = type;\n                return anyType.isEllipsis ? '...' : 'Any';\n            }\n        }\n\n        return '';\n    }\n\n    // Calls back into the parser to parse the contents of a string literal.\n    // This is unfortunately needed in some cases — specifically where the\n    // parser couldn't determine that the string literal would be used in\n    // a context where it should be treated as a forward-declared type. This\n    // call produces an expression tree that is not attached to the main parse\n    // expression tree because we don't want to mutate the latter; the\n    // expression tree created by this function is therefore used only temporarily.\n    function parseStringAsTypeAnnotation(node: StringListNode): ExpressionNode | undefined {\n        const fileInfo = getFileInfo(node);\n        const parser = new Parser();\n        const textValue = node.strings[0].value;\n\n        // Determine the offset within the file where the string\n        // literal's contents begin.\n        const valueOffset =\n            node.strings[0].start + node.strings[0].token.prefixLength + node.strings[0].token.quoteMarkLength;\n\n        const parseOptions = new ParseOptions();\n        parseOptions.isStubFile = fileInfo.isStubFile;\n        parseOptions.pythonVersion = fileInfo.executionEnvironment.pythonVersion;\n\n        const parseResults = parser.parseTextExpression(\n            fileInfo.fileContents,\n            valueOffset,\n            textValue.length,\n            parseOptions\n        );\n\n        if (parseResults.parseTree) {\n            parseResults.diagnostics.forEach((diag) => {\n                addError(diag.message, node);\n            });\n\n            parseResults.parseTree.parent = node;\n            return parseResults.parseTree;\n        }\n\n        return undefined;\n    }\n\n    return {\n        runWithCancellationToken,\n        getType,\n        getTypeOfClass,\n        getTypeOfFunction,\n        evaluateTypesForStatement,\n        getDeclaredTypeForExpression,\n        verifyRaiseExceptionType,\n        verifyDeleteExpression,\n        isAfterNodeReachable,\n        isNodeReachable,\n        suppressDiagnostics,\n        getDeclarationsForNameNode,\n        getTypeForDeclaration,\n        resolveAliasDeclaration,\n        getTypeFromIterable,\n        getTypedDictMembersForClass,\n        getGetterTypeFromProperty,\n        getEffectiveTypeOfSymbol,\n        getFunctionDeclaredReturnType,\n        getFunctionInferredReturnType,\n        getBuiltInType,\n        getTypeOfMember,\n        bindFunctionToClassOrObject,\n        getBoundMethod,\n        getCallSignatureInfo,\n        getTypeAnnotationForParameter,\n        canAssignType,\n        canOverrideMethod,\n        addError,\n        addWarning,\n        addInformation,\n        addUnusedCode,\n        addDiagnostic,\n        addDiagnosticForTextRange,\n        printType,\n        printFunctionParts,\n        getTypeCacheSize,\n    };\n}\n","/*\n * typeStubWriter.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Logic to emit a type stub file for a corresponding parsed\n * and analyzed python source file.\n */\n\nimport {\n    ArgumentCategory,\n    ArgumentNode,\n    AssignmentNode,\n    AugmentedAssignmentNode,\n    ClassNode,\n    DecoratorNode,\n    ExpressionNode,\n    ForNode,\n    FunctionNode,\n    IfNode,\n    ImportFromNode,\n    ImportNode,\n    ModuleNameNode,\n    NameNode,\n    ParameterCategory,\n    ParameterNode,\n    ParseNode,\n    ParseNodeType,\n    StatementListNode,\n    StringNode,\n    TryNode,\n    TypeAnnotationNode,\n    WhileNode,\n    WithNode,\n} from '../parser/parseNodes';\nimport * as AnalyzerNodeInfo from './analyzerNodeInfo';\nimport * as ParseTreeUtils from './parseTreeUtils';\nimport { ParseTreeWalker } from './parseTreeWalker';\nimport { getScopeForNode } from './scopeUtils';\nimport { SourceFile } from './sourceFile';\nimport { Symbol } from './symbol';\nimport * as SymbolNameUtils from './symbolNameUtils';\nimport { TypeEvaluator } from './typeEvaluator';\n\nclass TrackedImport {\n    constructor(public importName: string) {}\n\n    isAccessed = false;\n}\n\nclass TrackedImportAs extends TrackedImport {\n    constructor(importName: string, public alias: string | undefined, public symbol: Symbol) {\n        super(importName);\n    }\n}\n\ninterface TrackedImportSymbol {\n    symbol?: Symbol;\n    name: string;\n    alias?: string;\n    isAccessed: boolean;\n}\n\nclass TrackedImportFrom extends TrackedImport {\n    symbols: TrackedImportSymbol[] = [];\n\n    constructor(importName: string, public isWildcardImport: boolean, public node?: ImportFromNode) {\n        super(importName);\n    }\n\n    addSymbol(symbol: Symbol | undefined, name: string, alias: string | undefined, isAccessed = false) {\n        if (!this.symbols.find((s) => s.name === name)) {\n            this.symbols.push({\n                symbol,\n                name,\n                alias,\n                isAccessed,\n            });\n        }\n    }\n}\n\nclass ImportSymbolWalker extends ParseTreeWalker {\n    constructor(private _accessedImportedSymbols: Map<string, boolean>, private _treatStringsAsSymbols: boolean) {\n        super();\n    }\n\n    analyze(node: ExpressionNode) {\n        this.walk(node);\n    }\n\n    walk(node: ParseNode) {\n        if (!AnalyzerNodeInfo.isCodeUnreachable(node)) {\n            super.walk(node);\n        }\n    }\n\n    visitName(node: NameNode) {\n        this._accessedImportedSymbols.set(node.value, true);\n        return true;\n    }\n\n    visitString(node: StringNode) {\n        if (this._treatStringsAsSymbols) {\n            this._accessedImportedSymbols.set(node.value, true);\n        }\n\n        return true;\n    }\n}\n\nexport class TypeStubWriter extends ParseTreeWalker {\n    private _indentAmount = 0;\n    private _includeAllImports = false;\n    private _typeStubText = '';\n    private _lineEnd = '\\n';\n    private _tab = '    ';\n    private _classNestCount = 0;\n    private _functionNestCount = 0;\n    private _ifNestCount = 0;\n    private _emittedSuite = false;\n    private _emitDocString = true;\n    private _trackedImportAs = new Map<string, TrackedImportAs>();\n    private _trackedImportFrom = new Map<string, TrackedImportFrom>();\n    private _accessedImportedSymbols = new Map<string, boolean>();\n\n    constructor(private _stubPath: string, private _sourceFile: SourceFile, private _evaluator: TypeEvaluator) {\n        super();\n\n        // As a heuristic, we'll include all of the import statements\n        // in \"__init__.pyi\" files even if they're not locally referenced\n        // because these are often used as ways to re-export symbols.\n        if (this._stubPath.endsWith('__init__.pyi')) {\n            this._includeAllImports = true;\n        }\n    }\n\n    write() {\n        const parseResults = this._sourceFile.getParseResults()!;\n        this._lineEnd = parseResults.tokenizerOutput.predominantEndOfLineSequence;\n        this._tab = parseResults.tokenizerOutput.predominantTabSequence;\n\n        this.walk(parseResults.parseTree);\n\n        this._writeFile();\n    }\n\n    walk(node: ParseNode) {\n        if (!AnalyzerNodeInfo.isCodeUnreachable(node)) {\n            super.walk(node);\n        }\n    }\n\n    visitClass(node: ClassNode) {\n        const className = node.name.value;\n\n        this._emittedSuite = true;\n        this._emitDocString = true;\n        this._emitDecorators(node.decorators);\n        let line = `class ${className}`;\n        if (node.arguments.length > 0) {\n            line += `(${node.arguments\n                .map((arg) => {\n                    let argString = '';\n                    if (arg.name) {\n                        argString = arg.name.value + '=';\n                    }\n                    argString += this._printExpression(arg.valueExpression);\n                    return argString;\n                })\n                .join(', ')})`;\n        }\n        line += ':';\n        this._emitLine(line);\n\n        this._emitSuite(() => {\n            this._classNestCount++;\n            this.walk(node.suite);\n            this._classNestCount--;\n        });\n\n        this._emitLine('');\n        this._emitLine('');\n\n        return false;\n    }\n\n    visitFunction(node: FunctionNode) {\n        const functionName = node.name.value;\n\n        // Skip if we're already within a function or if the name is private/protected.\n        if (this._functionNestCount === 0 && !SymbolNameUtils.isPrivateOrProtectedName(functionName)) {\n            this._emittedSuite = true;\n            this._emitDocString = true;\n            this._emitDecorators(node.decorators);\n            let line = node.isAsync ? 'async ' : '';\n            line += `def ${functionName}`;\n            line += `(${node.parameters.map((param, index) => this._printParameter(param, node, index)).join(', ')})`;\n\n            let returnAnnotation: string | undefined;\n            if (node.returnTypeAnnotation) {\n                returnAnnotation = this._printExpression(node.returnTypeAnnotation, true);\n            } else if (node.functionAnnotationComment) {\n                returnAnnotation = this._printExpression(node.functionAnnotationComment.returnTypeAnnotation, true);\n            } else {\n                // Handle a few common cases where we always know the answer.\n                if (node.name.value === '__init__') {\n                    returnAnnotation = 'None';\n                } else if (node.name.value === '__str__') {\n                    returnAnnotation = 'str';\n                } else if (['__int__', '__hash__'].some((name) => name === node.name.value)) {\n                    returnAnnotation = 'int';\n                } else if (\n                    ['__eq__', '__ne__', '__gt__', '__lt__', '__ge__', '__le__'].some(\n                        (name) => name === node.name.value\n                    )\n                ) {\n                    returnAnnotation = 'bool';\n                }\n            }\n\n            if (returnAnnotation) {\n                line += ' -> ' + returnAnnotation;\n            }\n\n            line += ':';\n            this._emitLine(line);\n\n            this._emitSuite(() => {\n                // Don't emit any nested functions.\n                this._functionNestCount++;\n                this.walk(node.suite);\n                this._functionNestCount--;\n            });\n\n            this._emitLine('');\n        }\n\n        return false;\n    }\n\n    visitWhile(node: WhileNode) {\n        // Don't emit a doc string after the first statement.\n        this._emitDocString = false;\n        return false;\n    }\n\n    visitFor(node: ForNode) {\n        // Don't emit a doc string after the first statement.\n        this._emitDocString = false;\n        return false;\n    }\n\n    visitTry(node: TryNode) {\n        // Don't emit a doc string after the first statement.\n        this._emitDocString = false;\n        return false;\n    }\n\n    visitWith(node: WithNode) {\n        // Don't emit a doc string after the first statement.\n        this._emitDocString = false;\n        return false;\n    }\n\n    visitIf(node: IfNode) {\n        // Don't emit a doc string after the first statement.\n        this._emitDocString = false;\n\n        // Include if statements if they are located\n        // at the global scope.\n        if (this._functionNestCount === 0 && this._ifNestCount === 0) {\n            this._ifNestCount++;\n            this._emittedSuite = true;\n            this._emitLine('if ' + this._printExpression(node.testExpression) + ':');\n            this._emitSuite(() => {\n                this.walkMultiple(node.ifSuite.statements);\n            });\n\n            const elseSuite = node.elseSuite;\n            if (elseSuite) {\n                this._emitLine('else:');\n                this._emitSuite(() => {\n                    if (elseSuite.nodeType === ParseNodeType.If) {\n                        this.walkMultiple([elseSuite.testExpression, elseSuite.ifSuite, elseSuite.elseSuite]);\n                    } else {\n                        this.walkMultiple(elseSuite.statements);\n                    }\n                });\n            }\n            this._ifNestCount--;\n        }\n\n        return false;\n    }\n\n    visitAssignment(node: AssignmentNode) {\n        let line = '';\n\n        if (node.leftExpression.nodeType === ParseNodeType.Name) {\n            // Strip out \"__all__\" assignments.\n            if (node.leftExpression.value === '__all__') {\n                return false;\n            }\n\n            if (this._functionNestCount === 0) {\n                line = this._printExpression(node.leftExpression);\n            }\n        }\n\n        if (line) {\n            const emitValue = this._functionNestCount === 0 && this._classNestCount === 0;\n            this._emittedSuite = true;\n\n            // Add the inferred type if it's known.\n            // TODO - need to implement\n            // line += ': ' + type.asString();\n\n            line += ' = ';\n\n            if (emitValue) {\n                line += this._printExpression(node.rightExpression);\n            } else {\n                line += '...';\n            }\n            this._emitLine(line);\n        }\n\n        return false;\n    }\n\n    visitAugmentedAssignment(node: AugmentedAssignmentNode) {\n        return false;\n    }\n\n    visitTypeAnnotation(node: TypeAnnotationNode) {\n        if (this._functionNestCount === 0) {\n            let line = '';\n            if (node.valueExpression.nodeType === ParseNodeType.Name) {\n                line = this._printExpression(node.valueExpression);\n            } else if (node.valueExpression.nodeType === ParseNodeType.MemberAccess) {\n                const baseExpression = node.valueExpression.leftExpression;\n                if (baseExpression.nodeType === ParseNodeType.Name) {\n                    if (baseExpression.value === 'self') {\n                        const memberName = node.valueExpression.memberName.value;\n                        if (!SymbolNameUtils.isPrivateOrProtectedName(memberName)) {\n                            line = this._printExpression(node.valueExpression);\n                        }\n                    }\n                }\n            }\n\n            if (line) {\n                line += ': ' + this._printExpression(node.typeAnnotation, true);\n                this._emitLine(line);\n            }\n        }\n\n        return false;\n    }\n\n    visitImport(node: ImportNode) {\n        if (this._functionNestCount > 0 || this._classNestCount > 0) {\n            return false;\n        }\n\n        const currentScope = getScopeForNode(node);\n        if (currentScope) {\n            // Record the input for later.\n            node.list.forEach((imp) => {\n                const moduleName = this._printModuleName(imp.module);\n                if (!this._trackedImportAs.has(moduleName)) {\n                    const symbolName = imp.alias\n                        ? imp.alias.value\n                        : imp.module.nameParts.length > 0\n                        ? imp.module.nameParts[0].value\n                        : '';\n                    const symbolInfo = currentScope.lookUpSymbolRecursive(symbolName);\n                    if (symbolInfo) {\n                        const trackedImportAs = new TrackedImportAs(\n                            moduleName,\n                            imp.alias ? imp.alias.value : undefined,\n                            symbolInfo.symbol\n                        );\n                        this._trackedImportAs.set(moduleName, trackedImportAs);\n                    }\n                }\n            });\n        }\n\n        return false;\n    }\n\n    visitImportFrom(node: ImportFromNode) {\n        if (this._functionNestCount > 0 || this._classNestCount > 0) {\n            return false;\n        }\n\n        const currentScope = getScopeForNode(node);\n        if (currentScope) {\n            // Record the input for later.\n            const moduleName = this._printModuleName(node.module);\n            let trackedImportFrom = this._trackedImportFrom.get(moduleName);\n            if (!trackedImportFrom) {\n                trackedImportFrom = new TrackedImportFrom(moduleName, node.isWildcardImport, node);\n                this._trackedImportFrom.set(moduleName, trackedImportFrom);\n            }\n\n            node.imports.forEach((imp) => {\n                const symbolName = imp.alias ? imp.alias.value : imp.name.value;\n                const symbolInfo = currentScope.lookUpSymbolRecursive(symbolName);\n                if (symbolInfo) {\n                    trackedImportFrom!.addSymbol(\n                        symbolInfo.symbol,\n                        imp.name.value,\n                        imp.alias ? imp.alias.value : undefined,\n                        false\n                    );\n                }\n            });\n        }\n\n        return false;\n    }\n\n    visitStatementList(node: StatementListNode) {\n        if (node.statements.length > 0 && node.statements[0].nodeType === ParseNodeType.StringList) {\n            // Is this the first statement in a suite? If it's a string\n            // literal, assume it's a doc string and emit it.\n            if (!this._emittedSuite && this._emitDocString) {\n                this._emitLine(this._printExpression(node.statements[0]));\n            }\n        }\n\n        // Don't emit a doc string after the first statement.\n        this._emitDocString = false;\n\n        this.walkMultiple(node.statements);\n        return false;\n    }\n\n    private _emitSuite(callback: () => void) {\n        this._increaseIndent(() => {\n            const prevEmittedSuite = this._emittedSuite;\n            this._emittedSuite = false;\n\n            callback();\n\n            if (!this._emittedSuite) {\n                this._emitLine('...');\n            }\n\n            this._emittedSuite = prevEmittedSuite;\n        });\n    }\n\n    private _increaseIndent(callback: () => void) {\n        this._indentAmount++;\n        callback();\n        this._indentAmount--;\n    }\n\n    private _emitDecorators(decorators: DecoratorNode[]) {\n        decorators.forEach((decorator) => {\n            let line = '@' + this._printExpression(decorator.leftExpression);\n            if (decorator.arguments) {\n                line += `(${decorator.arguments.map((arg) => this._printArgument(arg)).join(', ')})`;\n            }\n            this._emitLine(line);\n        });\n    }\n\n    private _printHeaderDocString() {\n        return (\n            '\"\"\"' +\n            this._lineEnd +\n            'This type stub file was generated by pyright.' +\n            this._lineEnd +\n            '\"\"\"' +\n            this._lineEnd +\n            this._lineEnd\n        );\n    }\n\n    private _emitLine(line: string) {\n        for (let i = 0; i < this._indentAmount; i++) {\n            this._typeStubText += this._tab;\n        }\n\n        this._typeStubText += line + this._lineEnd;\n    }\n\n    private _printModuleName(node: ModuleNameNode): string {\n        let line = '';\n        for (let i = 0; i < node.leadingDots; i++) {\n            line += '.';\n        }\n        line += node.nameParts.map((part) => part.value).join('.');\n        return line;\n    }\n\n    private _printParameter(paramNode: ParameterNode, functionNode: FunctionNode, paramIndex: number): string {\n        let line = '';\n        if (paramNode.category === ParameterCategory.VarArgList) {\n            line += '*';\n        } else if (paramNode.category === ParameterCategory.VarArgDictionary) {\n            line += '**';\n        }\n\n        if (paramNode.name) {\n            line += paramNode.name.value;\n        }\n\n        const paramTypeAnnotation = this._evaluator.getTypeAnnotationForParameter(functionNode, paramIndex);\n        let paramType = '';\n        if (paramTypeAnnotation) {\n            paramType = this._printExpression(paramTypeAnnotation, true);\n        }\n\n        if (paramType) {\n            line += ': ' + paramType;\n        }\n\n        if (paramNode.defaultValue) {\n            // Follow PEP8 spacing rules. Include spaces if type\n            // annotation is present, no space otherwise.\n            if (paramType) {\n                line += ' = ...';\n            } else {\n                line += '=...';\n            }\n        }\n\n        return line;\n    }\n\n    private _printArgument(node: ArgumentNode): string {\n        let line = '';\n        if (node.argumentCategory === ArgumentCategory.UnpackedList) {\n            line += '*';\n        } else if (node.argumentCategory === ArgumentCategory.UnpackedDictionary) {\n            line += '**';\n        }\n\n        if (node.name) {\n            line += node.name.value + '=';\n        }\n\n        return line + this._printExpression(node.valueExpression);\n    }\n\n    private _printExpression(node: ExpressionNode, isType = false, treatStringsAsSymbols = false): string {\n        const importSymbolWalker = new ImportSymbolWalker(this._accessedImportedSymbols, treatStringsAsSymbols);\n        importSymbolWalker.analyze(node);\n\n        return ParseTreeUtils.printExpression(\n            node,\n            isType ? ParseTreeUtils.PrintExpressionFlags.ForwardDeclarations : ParseTreeUtils.PrintExpressionFlags.None\n        );\n    }\n\n    private _printTrackedImports() {\n        let importStr = '';\n        let lineEmitted = false;\n\n        // Emit the \"import\" statements.\n        this._trackedImportAs.forEach((imp) => {\n            if (this._accessedImportedSymbols.get(imp.alias || imp.importName)) {\n                imp.isAccessed = true;\n            }\n\n            if (imp.isAccessed || this._includeAllImports) {\n                importStr += `import ${imp.importName}`;\n                if (imp.alias) {\n                    importStr += ` as ${imp.alias}`;\n                }\n                importStr += this._lineEnd;\n                lineEmitted = true;\n            }\n        });\n\n        // Emit the \"import from\" statements.\n        this._trackedImportFrom.forEach((imp) => {\n            imp.symbols.forEach((s) => {\n                if (this._accessedImportedSymbols.get(s.alias || s.name)) {\n                    s.isAccessed = true;\n                }\n            });\n\n            if (imp.isWildcardImport) {\n                importStr += `from ${imp.importName} import *` + this._lineEnd;\n                lineEmitted = true;\n            }\n\n            const sortedSymbols = imp.symbols\n                .filter((s) => s.isAccessed || this._includeAllImports)\n                .sort((a, b) => {\n                    if (a.name < b.name) {\n                        return -1;\n                    } else if (a.name > b.name) {\n                        return 1;\n                    }\n                    return 0;\n                });\n\n            if (sortedSymbols.length > 0) {\n                importStr += `from ${imp.importName} import `;\n\n                importStr += sortedSymbols\n                    .map((symbol) => {\n                        let symStr = symbol.name;\n                        if (symbol.alias) {\n                            symStr += ' as ' + symbol.alias;\n                        }\n                        return symStr;\n                    })\n                    .join(', ');\n\n                importStr += this._lineEnd;\n                lineEmitted = true;\n            }\n        });\n\n        if (lineEmitted) {\n            importStr += this._lineEnd;\n        }\n\n        return importStr;\n    }\n\n    private _writeFile() {\n        let finalText = this._printHeaderDocString();\n        finalText += this._printTrackedImports();\n        finalText += this._typeStubText;\n\n        this._sourceFile.fileSystem.writeFileSync(this._stubPath, finalText, 'utf8');\n    }\n}\n","/*\n * typeUtils.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Collection of functions that operate on Type objects.\n */\n\nimport { isClassOrTypeElement } from 'typescript';\n\nimport { PythonVersion } from '../common/pythonVersion';\nimport { ParameterCategory } from '../parser/parseNodes';\nimport { DeclarationType } from './declaration';\nimport { Symbol, SymbolFlags, SymbolTable } from './symbol';\nimport { isTypedDictMemberAccessedThroughIndex } from './symbolUtils';\nimport {\n    AnyType,\n    ClassType,\n    combineTypes,\n    EnumLiteral,\n    FunctionType,\n    isAnyOrUnknown,\n    isClass,\n    isNone,\n    isObject,\n    isTypeSame,\n    isTypeVar,\n    isUnknown,\n    maxTypeRecursionCount,\n    ModuleType,\n    NeverType,\n    NoneType,\n    ObjectType,\n    OverloadedFunctionType,\n    SpecializedFunctionTypes,\n    Type,\n    TypeBase,\n    TypeCategory,\n    TypeVarType,\n    UnknownType,\n} from './types';\nimport { TypeVarMap } from './typeVarMap';\n\nexport interface ClassMember {\n    // Symbol\n    symbol: Symbol;\n\n    // Partially-specialized class that contains the class member\n    classType: Type;\n\n    // True if instance member, false if class member\n    isInstanceMember: boolean;\n\n    // True if member has declared type, false if inferred\n    isTypeDeclared: boolean;\n}\n\nexport const enum ClassMemberLookupFlags {\n    Default = 0,\n\n    // By default, the original (derived) class is searched along\n    // with its base classes. If this flag is set, the original\n    // class is skipped and only the base classes are searched.\n    SkipOriginalClass = 1 << 0,\n\n    // By default, base classes are searched as well as the\n    // original (derived) class. If this flag is set, no recursion\n    // is performed.\n    SkipBaseClasses = 1 << 1,\n\n    // Skip the 'object' base class in particular.\n    SkipObjectBaseClass = 1 << 2,\n\n    // By default, both class and instance variables are searched.\n    // If this flag is set, the instance variables are skipped.\n    SkipInstanceVariables = 1 << 3,\n\n    // By default, the first symbol is returned even if it has only\n    // an inferred type associated with it. If this flag is set,\n    // the search looks only for symbols with declared types.\n    DeclaredTypesOnly = 1 << 4,\n}\n\nexport const enum CanAssignFlags {\n    Default = 0,\n\n    // Require invariance with respect to class matching? Normally\n    // subclasses are allowed.\n    EnforceInvariance = 1 << 0,\n\n    // The caller has swapped the source and dest types because\n    // the types are contravariant. Perform type var matching\n    // on dest type vars rather than source type var.\n    ReverseTypeVarMatching = 1 << 1,\n\n    // Normally type vars are treated as variables that need to\n    // be \"solved\". If this flag is set, they are treated as types\n    // that must match exactly.\n    MatchTypeVarsExactly = 1 << 2,\n\n    // If the dest is not Any but the src is Any, treat it\n    // as incompatible.\n    DisallowAssignFromAny = 1 << 3,\n\n    // For function types, skip the return type check.\n    SkipFunctionReturnTypeCheck = 1 << 4,\n\n    // Normally type vars are specialized during type comparisons.\n    // With this flag, a type var must match a type var exactly.\n    DoNotSpecializeTypeVars = 1 << 5,\n}\n\nconst singleTickRegEx = /'/g;\nconst tripleTickRegEx = /'''/g;\n\nexport function isOptionalType(type: Type): boolean {\n    if (type.category === TypeCategory.Union) {\n        return type.subtypes.some((t) => isNone(t));\n    }\n\n    return false;\n}\n\n// Calls a callback for each subtype and combines the results\n// into a final type.\nexport function doForSubtypes(type: Type, callback: (type: Type) => Type | undefined): Type {\n    if (type.category === TypeCategory.Union) {\n        const newTypes: Type[] = [];\n\n        type.subtypes.forEach((typeEntry) => {\n            const transformedType = callback(typeEntry);\n            if (transformedType) {\n                newTypes.push(transformedType);\n            }\n        });\n\n        return combineTypes(newTypes);\n    }\n\n    return callback(type) || NeverType.create();\n}\n\n// Determines if all of the types in the array are the same.\nexport function areTypesSame(types: Type[]): boolean {\n    if (types.length < 2) {\n        return true;\n    }\n\n    for (let i = 1; i < types.length; i++) {\n        if (!isTypeSame(types[0], types[i])) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nexport function derivesFromAnyOrUnknown(type: Type): boolean {\n    let anyOrUnknown = false;\n\n    doForSubtypes(type, (subtype) => {\n        if (isAnyOrUnknown(type)) {\n            anyOrUnknown = true;\n        } else if (isClass(subtype)) {\n            if (ClassType.hasUnknownBaseClass(subtype)) {\n                anyOrUnknown = true;\n            }\n        } else if (isObject(subtype)) {\n            if (ClassType.hasUnknownBaseClass(subtype.classType)) {\n                anyOrUnknown = true;\n            }\n        }\n\n        return undefined;\n    });\n\n    return anyOrUnknown;\n}\n\nexport function stripLiteralValue(type: Type): Type {\n    if (isObject(type)) {\n        if (type.classType.literalValue !== undefined) {\n            type = ObjectType.create(ClassType.cloneWithLiteral(type.classType, undefined));\n        }\n\n        return type;\n    }\n\n    if (isClass(type)) {\n        if (type.literalValue !== undefined) {\n            type = ClassType.cloneWithLiteral(type, undefined);\n        }\n\n        return type;\n    }\n\n    if (type.category === TypeCategory.Union) {\n        return doForSubtypes(type, (subtype) => {\n            return stripLiteralValue(subtype);\n        });\n    }\n\n    return type;\n}\n\nexport function enumerateLiteralsForType(type: ObjectType): ObjectType[] | undefined {\n    if (ClassType.isBuiltIn(type.classType, 'bool')) {\n        // Booleans have only two types: True and False.\n        return [\n            ObjectType.create(ClassType.cloneWithLiteral(type.classType, true)),\n            ObjectType.create(ClassType.cloneWithLiteral(type.classType, false)),\n        ];\n    }\n\n    if (ClassType.isEnumClass(type.classType)) {\n        // Enumerate all of the values in this enumeration.\n        const enumList: ObjectType[] = [];\n        const fields = type.classType.details.fields;\n        fields.forEach((symbol, name) => {\n            if (!symbol.isIgnoredForProtocolMatch() && !symbol.isInstanceMember()) {\n                enumList.push(\n                    ObjectType.create(\n                        ClassType.cloneWithLiteral(type.classType, new EnumLiteral(type.classType.details.name, name))\n                    )\n                );\n            }\n        });\n\n        return enumList;\n    }\n\n    return undefined;\n}\n\nexport function stripLiteralTypeArgsValue(type: Type, recursionCount = 0): Type {\n    if (recursionCount > maxTypeRecursionCount) {\n        return type;\n    }\n\n    if (isClass(type)) {\n        if (type.typeArguments) {\n            const strippedTypeArgs = type.typeArguments.map((t) =>\n                stripLiteralTypeArgsValue(stripLiteralValue(t), recursionCount + 1)\n            );\n            return ClassType.cloneForSpecialization(\n                type,\n                strippedTypeArgs,\n                !!type.isTypeArgumentExplicit,\n                type.skipAbstractClassTest\n            );\n        }\n\n        return type;\n    }\n\n    if (isObject(type)) {\n        if (type.classType.typeArguments) {\n            type = ObjectType.create(stripLiteralTypeArgsValue(type.classType, recursionCount + 1) as ClassType);\n        }\n\n        return type;\n    }\n\n    if (type.category === TypeCategory.Union) {\n        let typeChanged = false;\n        const transformedUnion = doForSubtypes(type, (subtype) => {\n            const transformedType = stripLiteralTypeArgsValue(subtype, recursionCount + 1);\n            if (transformedType !== subtype) {\n                typeChanged = true;\n            }\n            return transformedType;\n        });\n\n        return typeChanged ? transformedUnion : type;\n    }\n\n    if (type.category === TypeCategory.Function) {\n        if (type.specializedTypes) {\n            const strippedSpecializedTypes: SpecializedFunctionTypes = {\n                parameterTypes: type.specializedTypes.parameterTypes.map((t) =>\n                    stripLiteralTypeArgsValue(stripLiteralValue(t), recursionCount + 1)\n                ),\n                returnType: type.specializedTypes.returnType\n                    ? stripLiteralTypeArgsValue(stripLiteralValue(type.specializedTypes.returnType), recursionCount + 1)\n                    : undefined,\n            };\n            type = FunctionType.cloneForSpecialization(type, strippedSpecializedTypes, type.inferredReturnType);\n        }\n\n        return type;\n    }\n\n    if (type.category === TypeCategory.OverloadedFunction) {\n        const strippedOverload = OverloadedFunctionType.create();\n        let typeChanged = false;\n        strippedOverload.overloads = type.overloads.map((t) => {\n            const transformedOverload = stripLiteralTypeArgsValue(t, recursionCount + 1) as FunctionType;\n            if (transformedOverload !== t) {\n                typeChanged = true;\n            }\n            return transformedOverload;\n        });\n        return typeChanged ? strippedOverload : type;\n    }\n\n    return type;\n}\n\n// If the type is a concrete class X described by the object Type[X],\n// returns X. Otherwise returns the original type.\nexport function transformTypeObjectToClass(type: Type): Type {\n    if (!isObject(type)) {\n        return type;\n    }\n\n    const classType = type.classType;\n    if (!ClassType.isBuiltIn(classType, 'Type')) {\n        return type;\n    }\n\n    // If it's a generic Type, we can't get the class.\n    if (!classType.typeArguments || classType.typeArguments.length < 1) {\n        return type;\n    }\n\n    const typeArg = classType.typeArguments[0];\n    if (!isObject(typeArg)) {\n        return type;\n    }\n\n    return typeArg.classType;\n}\n\n// Determines whether the type alias placeholder is used directly\n// within the specified type. It's OK if it's used indirectly as\n// a type argument.\nexport function isTypeAliasRecursive(typeAliasPlaceholder: TypeVarType, type: Type) {\n    if (type.category !== TypeCategory.Union) {\n        // Handle the specific case where the type alias directly refers to itself.\n        // In this case, the type will be unbound because it could not be resolved.\n        return (\n            type.category === TypeCategory.Unbound &&\n            type.typeAliasInfo &&\n            type.typeAliasInfo.aliasName === typeAliasPlaceholder.details.recursiveTypeAliasName\n        );\n    }\n\n    for (const subtype of type.subtypes) {\n        if (isTypeSame(typeAliasPlaceholder, subtype)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nexport function transformPossibleRecursiveTypeAlias(type: Type): Type;\nexport function transformPossibleRecursiveTypeAlias(type: Type | undefined): Type | undefined;\nexport function transformPossibleRecursiveTypeAlias(type: Type | undefined): Type | undefined {\n    if (type) {\n        if (type.category === TypeCategory.TypeVar && type.details.recursiveTypeAliasName && type.details.boundType) {\n            if (TypeBase.isInstance(type)) {\n                return convertToInstance(type.details.boundType);\n            }\n            return type.details.boundType;\n        }\n    }\n\n    return type;\n}\n\n// None is always falsy. All other types are generally truthy\n// unless they are objects that support the __bool__ or __len__\n// methods.\nexport function canBeFalsy(type: Type, recursionLevel = 0): boolean {\n    if (recursionLevel > maxTypeRecursionCount) {\n        return true;\n    }\n\n    switch (type.category) {\n        case TypeCategory.Unbound:\n        case TypeCategory.Unknown:\n        case TypeCategory.Any:\n        case TypeCategory.Never:\n        case TypeCategory.None: {\n            return true;\n        }\n\n        case TypeCategory.Union: {\n            return type.subtypes.some((t) => canBeFalsy(t, recursionLevel + 1));\n        }\n\n        case TypeCategory.Function:\n        case TypeCategory.OverloadedFunction:\n        case TypeCategory.Class:\n        case TypeCategory.Module:\n        case TypeCategory.TypeVar: {\n            return false;\n        }\n\n        case TypeCategory.Object: {\n            // Handle tuples specially.\n            if (isTupleClass(type.classType) && type.classType.typeArguments) {\n                if (type.classType.typeArguments.length === 0) {\n                    return true;\n                }\n\n                const lastTypeArg = type.classType.typeArguments[type.classType.typeArguments.length - 1];\n                if (isEllipsisType(lastTypeArg)) {\n                    return true;\n                }\n\n                return false;\n            }\n\n            const lenMethod = lookUpObjectMember(type, '__len__');\n            if (lenMethod) {\n                return true;\n            }\n\n            const boolMethod = lookUpObjectMember(type, '__bool__');\n            if (boolMethod) {\n                return true;\n            }\n\n            // Check for Literal[False].\n            if (ClassType.isBuiltIn(type.classType, 'bool')) {\n                if (type.classType.literalValue === false) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n}\n\nexport function canBeTruthy(type: Type, recursionLevel = 0): boolean {\n    if (recursionLevel > maxTypeRecursionCount) {\n        return true;\n    }\n\n    switch (type.category) {\n        case TypeCategory.Unknown:\n        case TypeCategory.Function:\n        case TypeCategory.OverloadedFunction:\n        case TypeCategory.Class:\n        case TypeCategory.Module:\n        case TypeCategory.TypeVar:\n        case TypeCategory.Never:\n        case TypeCategory.Any: {\n            return true;\n        }\n\n        case TypeCategory.Union: {\n            return type.subtypes.some((t) => canBeTruthy(t, recursionLevel + 1));\n        }\n\n        case TypeCategory.Unbound:\n        case TypeCategory.None: {\n            return false;\n        }\n\n        case TypeCategory.Object: {\n            // Check for Tuple[()] (an empty tuple).\n            if (isTupleClass(type.classType)) {\n                if (type.classType.typeArguments && type.classType.typeArguments.length === 0) {\n                    return false;\n                }\n            }\n\n            // Check for Literal[False].\n            if (ClassType.isBuiltIn(type.classType, 'bool')) {\n                if (type.classType.literalValue === false) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n    }\n}\n\n// Determines whether the type is a Tuple class or object.\nexport function getSpecializedTupleType(type: Type): ClassType | undefined {\n    let classType: ClassType | undefined;\n\n    if (isClass(type)) {\n        classType = type;\n    } else if (isObject(type)) {\n        classType = type.classType;\n    }\n\n    if (!classType) {\n        return undefined;\n    }\n\n    // See if this class derives from Tuple or tuple. If it does, we'll assume that it\n    // hasn't been overridden in a way that changes the behavior of the tuple class.\n    const tupleClass = classType.details.mro.find((mroClass) => isClass(mroClass) && isTupleClass(mroClass));\n    if (!tupleClass || !isClass(tupleClass)) {\n        return undefined;\n    }\n\n    if (ClassType.isSameGenericClass(classType, tupleClass)) {\n        return classType;\n    }\n\n    const typeVarMap = buildTypeVarMapFromSpecializedClass(classType);\n    return specializeType(tupleClass, typeVarMap) as ClassType;\n}\n\nexport function isLiteralType(type: Type, allowLiteralUnions = true): boolean {\n    if (isObject(type)) {\n        return type.classType.literalValue !== undefined;\n    }\n\n    if (allowLiteralUnions && type.category === TypeCategory.Union) {\n        return !type.subtypes.some((t) => !isObject(t) || t.classType.literalValue === undefined);\n    }\n\n    return false;\n}\n\nexport function isEllipsisType(type: Type): boolean {\n    // Ellipses are translated into both a special form of \"Any\" or\n    // a distinct class depending on the context.\n    if (type.category === TypeCategory.Any && type.isEllipsis) {\n        return true;\n    }\n\n    return isClass(type) && ClassType.isBuiltIn(type, 'ellipsis');\n}\n\nexport function isNoReturnType(type: Type): boolean {\n    if (isObject(type)) {\n        const classType = type.classType;\n        if (ClassType.isBuiltIn(classType, 'NoReturn')) {\n            return true;\n        }\n    }\n    return false;\n}\n\nexport function isParamSpecType(type: Type): boolean {\n    if (!isTypeVar(type)) {\n        return false;\n    }\n\n    return type.details.isParamSpec;\n}\n\nexport function isProperty(type: Type): type is ObjectType {\n    return isObject(type) && ClassType.isPropertyClass(type.classType);\n}\n\nexport function isTupleClass(type: ClassType) {\n    return ClassType.isBuiltIn(type) && (type.details.name === 'Tuple' || type.details.name === 'tuple');\n}\n\n// Partially specializes a type within the context of a specified\n// (presumably specialized) class.\nexport function partiallySpecializeType(type: Type, contextClassType: ClassType): Type {\n    // If the context class is not specialized (or doesn't need specialization),\n    // then there's no need to do any more work.\n    if (ClassType.isGeneric(contextClassType)) {\n        return type;\n    }\n\n    // Partially specialize the type using the specialized class type vars.\n    const typeVarMap = buildTypeVarMapFromSpecializedClass(contextClassType);\n    return specializeType(type, typeVarMap, /* makeConcrete */ false);\n}\n\n// Replaces all of the top-level TypeVars (as opposed to TypeVars\n// used as type arguments in other types) with their concrete form.\nexport function makeTypeVarsConcrete(type: Type): Type {\n    return doForSubtypes(type, (subtype) => {\n        if (isTypeVar(subtype)) {\n            if (subtype.details.boundType) {\n                return subtype.details.boundType;\n            }\n\n            // If this is a recursive type alias placeholder\n            // that hasn't yet been resolved, return it as is.\n            if (subtype.details.recursiveTypeAliasName) {\n                return subtype;\n            }\n\n            // Normally, we would use UnknownType here, but we need\n            // to use Any because unknown types will generate diagnostics\n            // in strictly-typed files that cannot be suppressed in\n            // any reasonable manner.\n            return AnyType.create();\n        }\n\n        return subtype;\n    });\n}\n\n// Specializes a (potentially generic) type by substituting\n// type variables with specified types. If typeVarMap is not\n// provided or makeConcrete is true, type variables are replaced\n// with a concrete type derived from the type variable if there\n// is no corresponding definition in the typeVarMap.\nexport function specializeType(\n    type: Type,\n    typeVarMap: TypeVarMap | undefined,\n    makeConcrete = false,\n    recursionLevel = 0\n): Type {\n    if (recursionLevel > maxTypeRecursionCount) {\n        return type;\n    }\n\n    // Shortcut the operation if possible.\n    if (!requiresSpecialization(type)) {\n        return type;\n    }\n\n    // Shortcut if there are no type variables defined.\n    if (typeVarMap && !makeConcrete && typeVarMap.typeVarCount() === 0) {\n        return type;\n    }\n\n    if (isAnyOrUnknown(type)) {\n        return type;\n    }\n\n    if (isNone(type)) {\n        return type;\n    }\n\n    if (isTypeVar(type)) {\n        if (typeVarMap) {\n            const replacementType = typeVarMap.getTypeVar(type);\n            if (replacementType) {\n                // If we're replacing a TypeVar with another type and the\n                // original is not an instance, convert the replacement so it's also\n                // not an instance. This happens in the case where a type alias refers\n                // to a union that includes a TypeVar.\n                if (TypeBase.isInstantiable(type) && !TypeBase.isInstantiable(replacementType)) {\n                    return convertToInstantiable(replacementType);\n                }\n                return replacementType;\n            }\n        } else {\n            if (type.details.boundType) {\n                return specializeType(type.details.boundType, undefined, /* makeConcrete */ false, recursionLevel + 1);\n            }\n\n            return makeConcrete ? UnknownType.create() : type;\n        }\n\n        return type;\n    }\n\n    if (type.category === TypeCategory.Union) {\n        const subtypes: Type[] = [];\n        type.subtypes.forEach((typeEntry) => {\n            subtypes.push(specializeType(typeEntry, typeVarMap, makeConcrete, recursionLevel + 1));\n        });\n\n        return combineTypes(subtypes);\n    }\n\n    if (isObject(type)) {\n        const classType = _specializeClassType(type.classType, typeVarMap, makeConcrete, recursionLevel + 1);\n\n        // Handle the \"Type\" special class.\n        if (ClassType.isBuiltIn(classType, 'Type')) {\n            const typeArgs = classType.typeArguments;\n            if (typeArgs && typeArgs.length >= 1) {\n                const firstTypeArg = typeArgs[0];\n                if (isObject(firstTypeArg)) {\n                    return specializeType(firstTypeArg.classType, typeVarMap, makeConcrete, recursionLevel + 1);\n                } else if (isTypeVar(firstTypeArg)) {\n                    if (typeVarMap) {\n                        const replacementType = typeVarMap.getTypeVar(firstTypeArg);\n                        if (replacementType && isObject(replacementType)) {\n                            return replacementType.classType;\n                        }\n                    }\n                }\n            }\n        }\n\n        // Don't allocate a new ObjectType class if the class\n        // didn't need to be specialized.\n        if (classType === type.classType) {\n            return type;\n        }\n        return ObjectType.create(classType);\n    }\n\n    if (isClass(type)) {\n        return _specializeClassType(type, typeVarMap, makeConcrete, recursionLevel + 1);\n    }\n\n    if (type.category === TypeCategory.Function) {\n        return _specializeFunctionType(type, typeVarMap, makeConcrete, recursionLevel + 1);\n    }\n\n    if (type.category === TypeCategory.OverloadedFunction) {\n        return _specializeOverloadedFunctionType(type, typeVarMap, makeConcrete, recursionLevel + 1);\n    }\n\n    return type;\n}\n\nexport function lookUpObjectMember(\n    objectType: Type,\n    memberName: string,\n    flags = ClassMemberLookupFlags.Default\n): ClassMember | undefined {\n    if (isObject(objectType)) {\n        return lookUpClassMember(objectType.classType, memberName, flags);\n    }\n\n    return undefined;\n}\n\n// Looks up a member in a class using the multiple-inheritance rules\n// defined by Python. For more details, see this note on method resolution\n// order: https://www.python.org/download/releases/2.3/mro/.\n// As it traverses the inheritance tree, it applies partial specialization\n// to the the base class and member. For example, if ClassA inherits from\n// ClassB[str] which inherits from Dict[_T1, int], a search for '__iter__'\n// would return a class type of Dict[str, int] and a symbolType of\n// (self) -> Iterator[str].\nexport function lookUpClassMember(\n    classType: Type,\n    memberName: string,\n    flags = ClassMemberLookupFlags.Default\n): ClassMember | undefined {\n    const declaredTypesOnly = (flags & ClassMemberLookupFlags.DeclaredTypesOnly) !== 0;\n\n    if (isClass(classType)) {\n        let foundUnknownBaseClass = false;\n\n        for (const mroClass of classType.details.mro) {\n            if (!isClass(mroClass)) {\n                foundUnknownBaseClass = true;\n                continue;\n            }\n\n            // If mroClass is an ancestor of classType, partially specialize\n            // it in the context of classType.\n            const specializedMroClass = partiallySpecializeType(mroClass, classType);\n            if (!isClass(specializedMroClass)) {\n                continue;\n            }\n\n            // Should we ignore members on the 'object' base class?\n            if (flags & ClassMemberLookupFlags.SkipObjectBaseClass) {\n                if (ClassType.isBuiltIn(specializedMroClass, 'object')) {\n                    continue;\n                }\n            }\n\n            if (\n                (flags & ClassMemberLookupFlags.SkipOriginalClass) === 0 ||\n                specializedMroClass.details !== classType.details\n            ) {\n                const memberFields = specializedMroClass.details.fields;\n\n                // Look at instance members first if requested.\n                if ((flags & ClassMemberLookupFlags.SkipInstanceVariables) === 0) {\n                    const symbol = memberFields.get(memberName);\n                    if (symbol && symbol.isInstanceMember()) {\n                        const hasDeclaredType = symbol.hasTypedDeclarations();\n                        if (!declaredTypesOnly || hasDeclaredType) {\n                            return {\n                                symbol,\n                                isInstanceMember: true,\n                                classType: specializedMroClass,\n                                isTypeDeclared: hasDeclaredType,\n                            };\n                        }\n                    }\n                }\n\n                // Next look at class members.\n                const symbol = memberFields.get(memberName);\n                if (symbol && symbol.isClassMember()) {\n                    const hasDeclaredType = symbol.hasTypedDeclarations();\n                    if (!declaredTypesOnly || hasDeclaredType) {\n                        let isInstanceMember = false;\n\n                        // For data classes and typed dicts, variables that are declared\n                        // within the class are treated as instance variables. This distinction\n                        // is important in cases where a variable is a callable type because\n                        // we don't want to bind it to the instance like we would for a\n                        // class member.\n                        if (\n                            ClassType.isDataClass(specializedMroClass) ||\n                            ClassType.isTypedDictClass(specializedMroClass)\n                        ) {\n                            const decls = symbol.getDeclarations();\n                            if (decls.length > 0 && decls[0].type === DeclarationType.Variable) {\n                                isInstanceMember = true;\n                            }\n                        }\n\n                        return {\n                            symbol,\n                            isInstanceMember,\n                            classType: specializedMroClass,\n                            isTypeDeclared: hasDeclaredType,\n                        };\n                    }\n                }\n            }\n\n            if ((flags & ClassMemberLookupFlags.SkipBaseClasses) !== 0) {\n                break;\n            }\n        }\n\n        if (foundUnknownBaseClass && !declaredTypesOnly) {\n            // The class derives from an unknown type, so all bets are off\n            // when trying to find a member. Return an unknown symbol.\n            return {\n                symbol: Symbol.createWithType(SymbolFlags.None, UnknownType.create()),\n                isInstanceMember: false,\n                classType: UnknownType.create(),\n                isTypeDeclared: false,\n            };\n        }\n    } else if (isAnyOrUnknown(classType)) {\n        // The class derives from an unknown type, so all bets are off\n        // when trying to find a member. Return an unknown symbol.\n        return {\n            symbol: Symbol.createWithType(SymbolFlags.None, UnknownType.create()),\n            isInstanceMember: false,\n            classType: UnknownType.create(),\n            isTypeDeclared: false,\n        };\n    }\n\n    return undefined;\n}\n\n// Combines two lists of type var types, maintaining the combined order\n// but removing any duplicates.\nexport function addTypeVarsToListIfUnique(list1: TypeVarType[], list2: TypeVarType[]) {\n    for (const type2 of list2) {\n        if (!list1.find((type1) => isTypeSame(type1, type2))) {\n            list1.push(type2);\n        }\n    }\n}\n\n// Walks the type recursively (in a depth-first manner), finds all\n// type variables that are referenced, and returns an ordered list\n// of unique type variables. For example, if the type is\n// Union[List[Dict[_T1, _T2]], _T1, _T3], the result would be\n// [_T1, _T2, _T3].\nexport function getTypeVarArgumentsRecursive(type: Type, recursionCount = 0): TypeVarType[] {\n    if (recursionCount > maxTypeRecursionCount) {\n        return [];\n    }\n\n    const getTypeVarsFromClass = (classType: ClassType) => {\n        const combinedList: TypeVarType[] = [];\n        if (classType.typeArguments) {\n            classType.typeArguments.forEach((typeArg) => {\n                addTypeVarsToListIfUnique(combinedList, getTypeVarArgumentsRecursive(typeArg, recursionCount + 1));\n            });\n        }\n\n        return combinedList;\n    };\n\n    if (isTypeVar(type)) {\n        // Don't return any recursive type alias placeholders.\n        if (type.details.recursiveTypeAliasName) {\n            return [];\n        }\n        return [type];\n    } else if (isClass(type)) {\n        return getTypeVarsFromClass(type);\n    } else if (isObject(type)) {\n        return getTypeVarsFromClass(type.classType);\n    } else if (type.category === TypeCategory.Union) {\n        const combinedList: TypeVarType[] = [];\n        for (const subtype of type.subtypes) {\n            addTypeVarsToListIfUnique(combinedList, getTypeVarArgumentsRecursive(subtype, recursionCount + 1));\n        }\n        return combinedList;\n    } else if (type.category === TypeCategory.Function) {\n        const combinedList: TypeVarType[] = [];\n\n        type.details.parameters.forEach((param) => {\n            addTypeVarsToListIfUnique(combinedList, getTypeVarArgumentsRecursive(param.type, recursionCount + 1));\n        });\n\n        if (type.details.declaredReturnType) {\n            addTypeVarsToListIfUnique(\n                combinedList,\n                getTypeVarArgumentsRecursive(type.details.declaredReturnType, recursionCount + 1)\n            );\n        }\n\n        return combinedList;\n    }\n\n    return [];\n}\n\n// If the class is generic, the type is cloned, and its own\n// type parameters are used as type arguments. This is useful\n// for typing \"self\" or \"cls\" within a class's implementation.\nexport function selfSpecializeClassType(type: ClassType, setSkipAbstractClassTest = false): ClassType {\n    if (!ClassType.isGeneric(type) && !setSkipAbstractClassTest) {\n        return type;\n    }\n\n    const typeArgs = ClassType.getTypeParameters(type);\n    return ClassType.cloneForSpecialization(\n        type,\n        typeArgs,\n        /* isTypeArgumentExplicit */ false,\n        setSkipAbstractClassTest\n    );\n}\n\n// Removes the first parameter of the function and returns a new function.\nexport function stripFirstParameter(type: FunctionType): FunctionType {\n    if (type.details.parameters.length > 0 && type.details.parameters[0].category === ParameterCategory.Simple) {\n        return FunctionType.clone(type, true);\n    }\n    return type;\n}\n\n// Recursively finds all of the type arguments and sets them\n// to the specified srcType.\nexport function setTypeArgumentsRecursive(destType: Type, srcType: Type, typeVarMap: TypeVarMap, recursionCount = 0) {\n    if (recursionCount > maxTypeRecursionCount) {\n        return;\n    }\n\n    if (typeVarMap.isLocked()) {\n        return;\n    }\n\n    switch (destType.category) {\n        case TypeCategory.Union:\n            destType.subtypes.forEach((subtype) => {\n                setTypeArgumentsRecursive(subtype, srcType, typeVarMap, recursionCount + 1);\n            });\n            break;\n\n        case TypeCategory.Class:\n            if (destType.typeArguments) {\n                destType.typeArguments.forEach((typeArg) => {\n                    setTypeArgumentsRecursive(typeArg, srcType, typeVarMap, recursionCount + 1);\n                });\n            }\n            if (destType.effectiveTypeArguments) {\n                destType.effectiveTypeArguments.forEach((typeArg) => {\n                    setTypeArgumentsRecursive(typeArg, srcType, typeVarMap, recursionCount + 1);\n                });\n            }\n            break;\n\n        case TypeCategory.Object:\n            setTypeArgumentsRecursive(destType.classType, srcType, typeVarMap, recursionCount + 1);\n            break;\n\n        case TypeCategory.Function:\n            if (destType.specializedTypes) {\n                destType.specializedTypes.parameterTypes.forEach((paramType) => {\n                    setTypeArgumentsRecursive(paramType, srcType, typeVarMap, recursionCount + 1);\n                });\n                if (destType.specializedTypes.returnType) {\n                    setTypeArgumentsRecursive(\n                        destType.specializedTypes.returnType,\n                        srcType,\n                        typeVarMap,\n                        recursionCount + 1\n                    );\n                }\n            } else {\n                destType.details.parameters.forEach((param) => {\n                    setTypeArgumentsRecursive(param.type, srcType, typeVarMap, recursionCount + 1);\n                });\n                if (destType.details.declaredReturnType) {\n                    setTypeArgumentsRecursive(\n                        destType.details.declaredReturnType,\n                        srcType,\n                        typeVarMap,\n                        recursionCount + 1\n                    );\n                }\n            }\n            break;\n\n        case TypeCategory.OverloadedFunction:\n            destType.overloads.forEach((subtype) => {\n                setTypeArgumentsRecursive(subtype, srcType, typeVarMap, recursionCount + 1);\n            });\n            break;\n\n        case TypeCategory.TypeVar:\n            if (!typeVarMap.hasTypeVar(destType)) {\n                typeVarMap.setTypeVar(destType, srcType, typeVarMap.isNarrowable(destType));\n            }\n            break;\n    }\n}\n\n// Builds a mapping between type parameters and their specialized\n// types. For example, if the generic type is Dict[_T1, _T2] and the\n// specialized type is Dict[str, int], it returns a map that associates\n// _T1 with str and _T2 with int.\nexport function buildTypeVarMapFromSpecializedClass(classType: ClassType, makeConcrete = true): TypeVarMap {\n    const typeParameters = ClassType.getTypeParameters(classType);\n    let typeArguments = classType.typeArguments;\n\n    // If there are no type arguments, we can either use the type variables\n    // from the type parameters (keeping the type arguments generic) or\n    // fill in concrete types.\n    if (!typeArguments && !makeConcrete) {\n        typeArguments = typeParameters;\n    }\n\n    return buildTypeVarMap(typeParameters, typeArguments);\n}\n\nexport function buildTypeVarMap(typeParameters: TypeVarType[], typeArgs: Type[] | undefined): TypeVarMap {\n    const typeVarMap = new TypeVarMap();\n    typeParameters.forEach((typeParam, index) => {\n        let typeArgType: Type;\n\n        if (typeArgs) {\n            if (index >= typeArgs.length) {\n                typeArgType = AnyType.create();\n            } else {\n                typeArgType = typeArgs[index];\n            }\n        } else {\n            typeArgType = getConcreteTypeFromTypeVar(typeParam);\n        }\n\n        typeVarMap.setTypeVar(typeParam, typeArgType, false);\n    });\n\n    return typeVarMap;\n}\n\n// If ignoreUnknown is true, an unknown base class is ignored when\n// checking for derivation. If ignoreUnknown is false, a return value\n// of true is assumed.\nexport function derivesFromClassRecursive(classType: ClassType, baseClassToFind: ClassType, ignoreUnknown: boolean) {\n    if (ClassType.isSameGenericClass(classType, baseClassToFind)) {\n        return true;\n    }\n\n    for (const baseClass of classType.details.baseClasses) {\n        if (isClass(baseClass)) {\n            if (derivesFromClassRecursive(baseClass, baseClassToFind, ignoreUnknown)) {\n                return true;\n            }\n        } else if (!ignoreUnknown && isAnyOrUnknown(baseClass)) {\n            // If the base class is unknown, we have to make a conservative assumption.\n            return true;\n        }\n    }\n\n    return false;\n}\n\n// Filters a type such that that no part of it is definitely\n// falsy. For example, if a type is a union of None\n// and an \"int\", this method would strip off the \"None\"\n// and return only the \"int\".\nexport function removeFalsinessFromType(type: Type): Type {\n    return doForSubtypes(type, (subtype) => {\n        if (isObject(subtype)) {\n            if (subtype.classType.literalValue !== undefined) {\n                // If the object is already definitely truthy, it's fine to\n                // include, otherwise it should be removed.\n                return subtype.classType.literalValue ? subtype : undefined;\n            }\n\n            // If the object is a bool, make it \"true\", since\n            // \"false\" is a falsy value.\n            if (ClassType.isBuiltIn(subtype.classType, 'bool')) {\n                return ObjectType.create(ClassType.cloneWithLiteral(subtype.classType, true));\n            }\n        }\n\n        // If it's possible for the type to be truthy, include it.\n        if (canBeTruthy(subtype)) {\n            return subtype;\n        }\n\n        return undefined;\n    });\n}\n\n// Filters a type such that that no part of it is definitely\n// truthy. For example, if a type is a union of None\n// and a custom class \"Foo\" that has no __len__ or __nonzero__\n// method, this method would strip off the \"Foo\"\n// and return only the \"None\".\nexport function removeTruthinessFromType(type: Type): Type {\n    return doForSubtypes(type, (subtype) => {\n        if (isObject(subtype)) {\n            if (subtype.classType.literalValue !== undefined) {\n                // If the object is already definitely falsy, it's fine to\n                // include, otherwise it should be removed.\n                return !subtype.classType.literalValue ? subtype : undefined;\n            }\n\n            // If the object is a bool, make it \"false\", since\n            // \"true\" is a truthy value.\n            if (ClassType.isBuiltIn(subtype.classType, 'bool')) {\n                return ObjectType.create(ClassType.cloneWithLiteral(subtype.classType, false));\n            }\n        }\n\n        // If it's possible for the type to be falsy, include it.\n        if (canBeFalsy(subtype)) {\n            return subtype;\n        }\n\n        return undefined;\n    });\n}\n\n// Returns the declared yield type if provided, or undefined otherwise.\nexport function getDeclaredGeneratorYieldType(functionType: FunctionType, iteratorType: Type): Type | undefined {\n    const returnType = FunctionType.getSpecializedReturnType(functionType);\n    if (returnType) {\n        const generatorTypeArgs = _getGeneratorReturnTypeArgs(returnType);\n\n        if (generatorTypeArgs && generatorTypeArgs.length >= 1 && isClass(iteratorType)) {\n            // The yield type is the first type arg. Wrap it in an iterator.\n            return ObjectType.create(\n                ClassType.cloneForSpecialization(\n                    iteratorType,\n                    [generatorTypeArgs[0]],\n                    /* isTypeArgumentExplicit */ false\n                )\n            );\n        }\n\n        // If the return type isn't a Generator, assume that it's the\n        // full return type.\n        return returnType;\n    }\n\n    return undefined;\n}\n\n// Returns the declared \"send\" type (the type returned from the yield\n// statement) if it was declared, or undefined otherwise.\nexport function getDeclaredGeneratorSendType(functionType: FunctionType): Type | undefined {\n    const returnType = FunctionType.getSpecializedReturnType(functionType);\n    if (returnType) {\n        const generatorTypeArgs = _getGeneratorReturnTypeArgs(returnType);\n\n        if (generatorTypeArgs && generatorTypeArgs.length >= 2) {\n            // The send type is the second type arg.\n            return generatorTypeArgs[1];\n        }\n\n        return UnknownType.create();\n    }\n\n    return undefined;\n}\n\n// Returns the declared \"return\" type (the type returned from a return statement)\n// if it was declared, or undefined otherwise.\nexport function getDeclaredGeneratorReturnType(functionType: FunctionType): Type | undefined {\n    const returnType = FunctionType.getSpecializedReturnType(functionType);\n    if (returnType) {\n        const generatorTypeArgs = _getGeneratorReturnTypeArgs(returnType);\n\n        if (generatorTypeArgs && generatorTypeArgs.length >= 3) {\n            // The send type is the third type arg.\n            return generatorTypeArgs[2];\n        }\n\n        return UnknownType.create();\n    }\n\n    return undefined;\n}\n\nexport function convertToInstance(type: Type): Type {\n    let result = doForSubtypes(type, (subtype) => {\n        subtype = transformTypeObjectToClass(subtype);\n\n        switch (subtype.category) {\n            case TypeCategory.Class: {\n                return ObjectType.create(subtype);\n            }\n\n            case TypeCategory.None: {\n                return NoneType.createInstance();\n            }\n\n            case TypeCategory.Function: {\n                if (TypeBase.isInstantiable(subtype)) {\n                    return FunctionType.cloneAsInstance(subtype);\n                }\n                break;\n            }\n\n            case TypeCategory.TypeVar: {\n                if (TypeBase.isInstantiable(subtype)) {\n                    return TypeVarType.cloneAsInstance(subtype);\n                }\n                break;\n            }\n        }\n\n        return subtype;\n    });\n\n    // Copy over any type alias information.\n    if (type.typeAliasInfo && type !== result) {\n        result = TypeBase.cloneForTypeAlias(\n            result,\n            type.typeAliasInfo.aliasName,\n            type.typeAliasInfo.typeParameters,\n            type.typeAliasInfo.typeArguments\n        );\n    }\n\n    return result;\n}\n\nexport function convertToInstantiable(type: Type): Type {\n    let result = doForSubtypes(type, (subtype) => {\n        switch (subtype.category) {\n            case TypeCategory.Object: {\n                return subtype.classType;\n            }\n\n            case TypeCategory.None: {\n                return NoneType.createType();\n            }\n\n            case TypeCategory.Function: {\n                if (TypeBase.isInstance(subtype)) {\n                    return FunctionType.cloneAsInstantiable(subtype);\n                }\n                break;\n            }\n\n            case TypeCategory.TypeVar: {\n                if (TypeBase.isInstance(subtype)) {\n                    return TypeVarType.cloneAsInstantiable(subtype);\n                }\n                break;\n            }\n        }\n\n        return subtype;\n    });\n\n    // Copy over any type alias information.\n    if (type.typeAliasInfo && type !== result) {\n        result = TypeBase.cloneForTypeAlias(\n            result,\n            type.typeAliasInfo.aliasName,\n            type.typeAliasInfo.typeParameters,\n            type.typeAliasInfo.typeArguments\n        );\n    }\n\n    return result;\n}\n\nexport function getMembersForClass(classType: ClassType, symbolTable: SymbolTable, includeInstanceVars: boolean) {\n    for (let i = classType.details.mro.length - 1; i >= 0; i--) {\n        const mroClass = classType.details.mro[i];\n\n        if (isClass(mroClass)) {\n            // Add any new member variables from this class.\n            const isClassTypedDict = ClassType.isTypedDictClass(mroClass);\n            mroClass.details.fields.forEach((symbol, name) => {\n                if (symbol.isClassMember() || (includeInstanceVars && symbol.isInstanceMember())) {\n                    if (!isClassTypedDict || !isTypedDictMemberAccessedThroughIndex(symbol)) {\n                        if (!symbolTable.get(name)) {\n                            symbolTable.set(name, symbol);\n                        }\n                    }\n                }\n            });\n        }\n    }\n\n    // Add members of the metaclass as well.\n    if (!includeInstanceVars) {\n        const metaclass = classType.details.effectiveMetaclass;\n        if (metaclass && isClass(metaclass)) {\n            for (const mroClass of metaclass.details.mro) {\n                if (isClass(mroClass)) {\n                    mroClass.details.fields.forEach((symbol, name) => {\n                        if (!symbolTable.get(name)) {\n                            symbolTable.set(name, symbol);\n                        }\n                    });\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n}\n\nexport function getMembersForModule(moduleType: ModuleType, symbolTable: SymbolTable) {\n    // Start with the loader fields. If there are any symbols of the\n    // same name defined within the module, they will overwrite the\n    // loader fields.\n    if (moduleType.loaderFields) {\n        moduleType.loaderFields.forEach((symbol, name) => {\n            symbolTable.set(name, symbol);\n        });\n    }\n\n    moduleType.fields.forEach((symbol, name) => {\n        symbolTable.set(name, symbol);\n    });\n}\n\nexport function isPartlyUnknown(type: Type, allowUnknownTypeArgsForClasses = false, recursionCount = 0): boolean {\n    if (recursionCount > maxTypeRecursionCount) {\n        return false;\n    }\n\n    if (isUnknown(type)) {\n        return true;\n    }\n\n    // See if a union contains an unknown type.\n    if (type.category === TypeCategory.Union) {\n        for (const subtype of type.subtypes) {\n            if (isPartlyUnknown(subtype, allowUnknownTypeArgsForClasses, recursionCount + 1)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    // See if an object or class has an unknown type argument.\n    if (isObject(type)) {\n        return isPartlyUnknown(type.classType, false, recursionCount + 1);\n    }\n\n    if (isClass(type)) {\n        if (type.typeArguments && !allowUnknownTypeArgsForClasses && !ClassType.isPseudoGenericClass(type)) {\n            for (const argType of type.typeArguments) {\n                if (isPartlyUnknown(argType, allowUnknownTypeArgsForClasses, recursionCount + 1)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    // See if a function has an unknown type.\n    if (type.category === TypeCategory.OverloadedFunction) {\n        return type.overloads.some((overload) => {\n            return isPartlyUnknown(overload, false, recursionCount + 1);\n        });\n    }\n\n    if (type.category === TypeCategory.Function) {\n        for (let i = 0; i < type.details.parameters.length; i++) {\n            // Ignore parameters such as \"*\" that have no name.\n            if (type.details.parameters[i].name) {\n                const paramType = FunctionType.getEffectiveParameterType(type, i);\n                if (isPartlyUnknown(paramType, false, recursionCount + 1)) {\n                    return true;\n                }\n            }\n        }\n\n        if (\n            type.details.declaredReturnType &&\n            isPartlyUnknown(type.details.declaredReturnType, false, recursionCount + 1)\n        ) {\n            return true;\n        }\n\n        return false;\n    }\n\n    return false;\n}\n\nfunction _specializeClassType(\n    classType: ClassType,\n    typeVarMap: TypeVarMap | undefined,\n    makeConcrete: boolean,\n    recursionLevel: number\n): ClassType {\n    // Handle the common case where the class has no type parameters.\n    if (ClassType.getTypeParameters(classType).length === 0) {\n        return classType;\n    }\n\n    let newTypeArgs: Type[] = [];\n    let newEffectiveTypeArgs: Type[] | undefined;\n    let specializationNeeded = false;\n\n    // If type args were previously provided, specialize them.\n    if (classType.typeArguments) {\n        newTypeArgs = classType.typeArguments.map((oldTypeArgType) => {\n            const newTypeArgType = specializeType(oldTypeArgType, typeVarMap, makeConcrete, recursionLevel + 1);\n            if (newTypeArgType !== oldTypeArgType) {\n                specializationNeeded = true;\n            }\n            return newTypeArgType;\n        });\n\n        if (classType.effectiveTypeArguments) {\n            newEffectiveTypeArgs = classType.effectiveTypeArguments.map((oldTypeArgType) => {\n                const newTypeArgType = specializeType(oldTypeArgType, typeVarMap, makeConcrete, recursionLevel + 1);\n                if (newTypeArgType !== oldTypeArgType) {\n                    specializationNeeded = true;\n                }\n                return newTypeArgType;\n            });\n        }\n    } else {\n        ClassType.getTypeParameters(classType).forEach((typeParam) => {\n            let typeArgType: Type;\n\n            if (typeVarMap && typeVarMap.hasTypeVar(typeParam)) {\n                // If the type var map already contains this type var, use\n                // the existing type.\n                typeArgType = typeVarMap.getTypeVar(typeParam)!;\n                specializationNeeded = true;\n            } else {\n                // If the type var map wasn't provided or doesn't contain this\n                // type var, specialize the type var.\n                typeArgType = makeConcrete ? getConcreteTypeFromTypeVar(typeParam) : typeParam;\n                if (typeArgType !== typeParam) {\n                    specializationNeeded = true;\n                }\n            }\n\n            newTypeArgs.push(typeArgType);\n        });\n    }\n\n    // If specialization wasn't needed, don't allocate a new class.\n    if (!specializationNeeded) {\n        return classType;\n    }\n\n    return ClassType.cloneForSpecialization(\n        classType,\n        newTypeArgs,\n        /* isTypeArgumentExplicit */ false,\n        /* skipAbstractClassTest */ undefined,\n        newEffectiveTypeArgs\n    );\n}\n\n// Converts a type var type into the most specific type\n// that fits the specified constraints.\nexport function getConcreteTypeFromTypeVar(type: TypeVarType, recursionLevel = 0): Type {\n    if (type.details.boundType) {\n        // If this is a recursive type alias placeholder, don't continue\n        // to specialize it because it will expand it out until we hit the\n        // recursion limit.\n        if (type.details.recursiveTypeAliasName) {\n            return type.details.boundType;\n        }\n\n        return specializeType(type.details.boundType, undefined, /* makeConcrete */ false, recursionLevel + 1);\n    }\n\n    // Note that we can't use constraints for specialization because\n    // the union of constraints is not the same as individual constraints.\n\n    // In all other cases, treat as unknown.\n    return UnknownType.create();\n}\n\nfunction _specializeOverloadedFunctionType(\n    type: OverloadedFunctionType,\n    typeVarMap: TypeVarMap | undefined,\n    makeConcrete: boolean,\n    recursionLevel: number\n): OverloadedFunctionType {\n    // Specialize each of the functions in the overload.\n    const overloads = type.overloads.map((entry) =>\n        _specializeFunctionType(entry, typeVarMap, makeConcrete, recursionLevel)\n    );\n\n    // Construct a new overload with the specialized function types.\n    const newOverloadType = OverloadedFunctionType.create();\n    overloads.forEach((overload) => {\n        OverloadedFunctionType.addOverload(newOverloadType, overload);\n    });\n\n    return newOverloadType;\n}\n\nfunction _specializeFunctionType(\n    sourceType: FunctionType,\n    typeVarMap: TypeVarMap | undefined,\n    makeConcrete: boolean,\n    recursionLevel: number\n): FunctionType {\n    let functionType = sourceType;\n\n    // Handle functions with a parameter specification in a special manner.\n    if (functionType.details.paramSpec) {\n        let paramSpec = typeVarMap?.getParamSpec(functionType.details.paramSpec);\n        if (!paramSpec && makeConcrete) {\n            paramSpec = [\n                { name: 'args', type: AnyType.create() },\n                { name: 'kwargs', type: AnyType.create() },\n            ];\n        }\n        if (paramSpec) {\n            functionType = FunctionType.cloneForParamSpec(functionType, paramSpec);\n        }\n    }\n\n    const declaredReturnType =\n        functionType.specializedTypes && functionType.specializedTypes.returnType\n            ? functionType.specializedTypes.returnType\n            : functionType.details.declaredReturnType;\n    const specializedReturnType = declaredReturnType\n        ? specializeType(declaredReturnType, typeVarMap, makeConcrete, recursionLevel + 1)\n        : undefined;\n    let typesRequiredSpecialization = declaredReturnType !== specializedReturnType;\n\n    const specializedParameters: SpecializedFunctionTypes = {\n        parameterTypes: [],\n        returnType: specializedReturnType,\n    };\n\n    for (let i = 0; i < functionType.details.parameters.length; i++) {\n        const paramType = FunctionType.getEffectiveParameterType(functionType, i);\n        const specializedType = specializeType(paramType, typeVarMap, makeConcrete, recursionLevel + 1);\n        specializedParameters.parameterTypes.push(specializedType);\n\n        if (paramType !== specializedType) {\n            typesRequiredSpecialization = true;\n        }\n    }\n\n    if (!typesRequiredSpecialization) {\n        return functionType;\n    }\n\n    let specializedInferredReturnType: Type | undefined;\n    if (functionType.inferredReturnType) {\n        specializedInferredReturnType = specializeType(\n            functionType.inferredReturnType,\n            typeVarMap,\n            makeConcrete,\n            recursionLevel + 1\n        );\n    }\n\n    return FunctionType.cloneForSpecialization(functionType, specializedParameters, specializedInferredReturnType);\n}\n\n// If the declared return type for the function is a Generator, AsyncGenerator,\n// Iterator, or AsyncIterator, returns the type arguments for the type.\nfunction _getGeneratorReturnTypeArgs(returnType: Type): Type[] | undefined {\n    if (isObject(returnType)) {\n        const classType = returnType.classType;\n        if (ClassType.isBuiltIn(classType)) {\n            const className = classType.details.name;\n            if (className === 'Generator' || className === 'AsyncGenerator') {\n                return classType.typeArguments;\n            }\n\n            if (className === 'Iterator' || className === 'AsyncIterator' || className === 'AsyncIterable') {\n                return classType.typeArguments;\n            }\n        }\n    }\n\n    return undefined;\n}\n\nexport function requiresTypeArguments(classType: ClassType) {\n    if (classType.details.typeParameters.length > 0) {\n        // If there are type parameters, type arguments are needed.\n        // The exception is if type parameters have been synthesized\n        // for classes that have untyped constructors.\n        return !classType.details.typeParameters[0].details.isSynthesized;\n    }\n\n    // There are a few built-in special classes that require\n    // type arguments even though typeParameters is empty.\n    if (ClassType.isBuiltIn(classType)) {\n        const specialClasses = [\n            'Tuple',\n            'Callable',\n            'Generic',\n            'Type',\n            'Optional',\n            'Union',\n            'Final',\n            'Literal',\n            'Annotated',\n        ];\n        if (specialClasses.some((t) => t === classType.details.name)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nexport function requiresSpecialization(type: Type, recursionCount = 0): boolean {\n    switch (type.category) {\n        case TypeCategory.Class: {\n            if (type.typeArguments) {\n                if (recursionCount > maxTypeRecursionCount) {\n                    return false;\n                }\n\n                return (\n                    type.typeArguments.find((typeArg) => requiresSpecialization(typeArg, recursionCount + 1)) !==\n                    undefined\n                );\n            }\n\n            // If there are any type parameters, we need to specialize\n            // since there are no corresponding type arguments.\n            return ClassType.getTypeParameters(type).length > 0;\n        }\n\n        case TypeCategory.Object: {\n            if (recursionCount > maxTypeRecursionCount) {\n                return false;\n            }\n\n            return requiresSpecialization(type.classType, recursionCount + 1);\n        }\n\n        case TypeCategory.Function: {\n            if (recursionCount > maxTypeRecursionCount) {\n                return false;\n            }\n\n            for (let i = 0; i < type.details.parameters.length; i++) {\n                if (requiresSpecialization(FunctionType.getEffectiveParameterType(type, i), recursionCount + 1)) {\n                    return true;\n                }\n            }\n\n            const declaredReturnType =\n                type.specializedTypes && type.specializedTypes.returnType\n                    ? type.specializedTypes.returnType\n                    : type.details.declaredReturnType;\n            if (declaredReturnType) {\n                if (requiresSpecialization(declaredReturnType, recursionCount + 1)) {\n                    return true;\n                }\n            } else if (type.inferredReturnType) {\n                if (requiresSpecialization(type.inferredReturnType, recursionCount + 1)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        case TypeCategory.OverloadedFunction: {\n            return (\n                type.overloads.find((overload) => requiresSpecialization(overload, recursionCount + 1)) !== undefined\n            );\n        }\n\n        case TypeCategory.Union: {\n            return type.subtypes.find((type) => requiresSpecialization(type, recursionCount + 1)) !== undefined;\n        }\n\n        case TypeCategory.TypeVar: {\n            // If this is a recursive type alias, don't treat it like other TypeVars.\n            return type.details.recursiveTypeAliasName === undefined;\n        }\n    }\n\n    return false;\n}\n\n// Computes the method resolution ordering for a class whose base classes\n// have already been filled in. The algorithm for computing MRO is described\n// here: https://www.python.org/download/releases/2.3/mro/. It returns true\n// if an MRO was possible, false otherwise.\nexport function computeMroLinearization(classType: ClassType): boolean {\n    let isMroFound = true;\n\n    // Construct the list of class lists that need to be merged.\n    const classListsToMerge: Type[][] = [];\n\n    // Remove any Generic class. It appears not to participate in MRO calculations.\n    const baseClassesToInclude = classType.details.baseClasses.filter(\n        (baseClass) => !isClass(baseClass) || !ClassType.isBuiltIn(baseClass, 'Generic')\n    );\n\n    baseClassesToInclude.forEach((baseClass) => {\n        if (isClass(baseClass)) {\n            const typeVarMap = buildTypeVarMapFromSpecializedClass(baseClass, /* makeConcrete */ false);\n            classListsToMerge.push(\n                baseClass.details.mro.map((mroClass) => {\n                    return specializeType(mroClass, typeVarMap);\n                })\n            );\n        } else {\n            classListsToMerge.push([baseClass]);\n        }\n    });\n\n    classListsToMerge.push(\n        baseClassesToInclude.map((baseClass) => {\n            const typeVarMap = buildTypeVarMapFromSpecializedClass(classType, /* makeConcrete */ false);\n            return specializeType(baseClass, typeVarMap);\n        })\n    );\n\n    // The first class in the MRO is the class itself.\n    const typeVarMap = buildTypeVarMapFromSpecializedClass(classType, /* makeConcrete */ false);\n    classType.details.mro.push(specializeType(classType, typeVarMap));\n\n    // Helper function that returns true if the specified searchClass\n    // is found in the \"tail\" (i.e. in elements 1 through n) of any\n    // of the class lists.\n    const isInTail = (searchClass: ClassType, classLists: Type[][]) => {\n        return classLists.some((classList) => {\n            return (\n                classList.findIndex(\n                    (value) => isClass(value) && ClassType.isSameGenericClass(value, searchClass, false)\n                ) > 0\n            );\n        });\n    };\n\n    const filterClass = (classToFilter: ClassType, classLists: Type[][]) => {\n        for (let i = 0; i < classLists.length; i++) {\n            classLists[i] = classLists[i].filter(\n                (value) => !isClass(value) || !ClassType.isSameGenericClass(value, classToFilter, false)\n            );\n        }\n    };\n\n    while (true) {\n        let foundValidHead = false;\n        let nonEmptyList: Type[] | undefined = undefined;\n\n        for (let i = 0; i < classListsToMerge.length; i++) {\n            const classList = classListsToMerge[i];\n\n            if (classList.length > 0) {\n                if (nonEmptyList === undefined) {\n                    nonEmptyList = classList;\n                }\n\n                if (!isClass(classList[0])) {\n                    foundValidHead = true;\n                    classType.details.mro.push(classList[0]);\n                    classList.shift();\n                    break;\n                } else if (!isInTail(classList[0], classListsToMerge)) {\n                    foundValidHead = true;\n                    classType.details.mro.push(classList[0]);\n                    filterClass(classList[0], classListsToMerge);\n                    break;\n                }\n            }\n        }\n\n        // If all lists are empty, we are done.\n        if (!nonEmptyList) {\n            break;\n        }\n\n        // We made it all the way through the list of class lists without\n        // finding a valid head, but there is at least one list that's not\n        // yet empty. This means there's no valid MRO order.\n        if (!foundValidHead) {\n            isMroFound = false;\n\n            // Handle the situation by pull the head off the first empty list.\n            // This allows us to make forward progress.\n            if (!isClass(nonEmptyList[0])) {\n                classType.details.mro.push(nonEmptyList[0]);\n                nonEmptyList.shift();\n            } else {\n                classType.details.mro.push(nonEmptyList[0]);\n                filterClass(nonEmptyList[0], classListsToMerge);\n            }\n        }\n    }\n\n    return isMroFound;\n}\n\nexport function printLiteralValue(type: ClassType): string {\n    const literalValue = type.literalValue;\n    if (literalValue === undefined) {\n        return '';\n    }\n\n    let literalStr: string;\n    if (typeof literalValue === 'string') {\n        const prefix = type.details.name === 'bytes' ? 'b' : '';\n        literalStr = literalValue.toString();\n        if (literalStr.indexOf('\\n') >= 0) {\n            literalStr = `${prefix}'''${literalStr.replace(tripleTickRegEx, \"\\\\'\\\\'\\\\'\")}'''`;\n        } else {\n            literalStr = `${prefix}'${literalStr.replace(singleTickRegEx, \"\\\\'\")}'`;\n        }\n    } else if (typeof literalValue === 'boolean') {\n        literalStr = literalValue ? 'True' : 'False';\n    } else if (literalValue instanceof EnumLiteral) {\n        literalStr = `${literalValue.className}.${literalValue.itemName}`;\n    } else {\n        literalStr = literalValue.toString();\n    }\n\n    return literalStr;\n}\n\nexport function printLiteralType(type: ObjectType): string {\n    const literalStr = printLiteralValue(type.classType);\n    if (!literalStr) {\n        return '';\n    }\n\n    return `Literal[${literalStr}]`;\n}\n\n// Returns zero or more unique module names that point to the place(s)\n// where the type is declared. Unions, for example, can result in more\n// than one result. Type arguments are not included.\nexport function getDeclaringModulesForType(type: Type): string[] {\n    const moduleList: string[] = [];\n    addDeclaringModuleNamesForType(type, moduleList);\n    return moduleList;\n}\n\nfunction addDeclaringModuleNamesForType(type: Type, moduleList: string[], recursionCount = 0) {\n    if (recursionCount > maxTypeRecursionCount) {\n        return;\n    }\n\n    const addIfUnique = (moduleName: string) => {\n        if (moduleName && !moduleList.some((n) => n === moduleName)) {\n            moduleList.push(moduleName);\n        }\n    };\n\n    switch (type.category) {\n        case TypeCategory.Class: {\n            addIfUnique(type.details.moduleName);\n            break;\n        }\n\n        case TypeCategory.Object: {\n            addIfUnique(type.classType.details.moduleName);\n            break;\n        }\n\n        case TypeCategory.Function: {\n            addIfUnique(type.details.moduleName);\n            break;\n        }\n\n        case TypeCategory.OverloadedFunction: {\n            type.overloads.forEach((overload) => {\n                addDeclaringModuleNamesForType(overload, moduleList, recursionCount + 1);\n            });\n            break;\n        }\n\n        case TypeCategory.Union: {\n            type.subtypes.forEach((subtype) => {\n                addDeclaringModuleNamesForType(subtype, moduleList, recursionCount + 1);\n            });\n            break;\n        }\n\n        case TypeCategory.Module: {\n            addIfUnique(type.moduleName);\n            break;\n        }\n    }\n}\n","/*\n * typeVarMap.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Module that records the relationship between named TypeVars\n * (type variables) and their types. It is used by the type\n * evaluator to \"solve\" for the type of each type variable.\n */\n\nimport { assert } from '../common/debug';\nimport { ClassType, maxTypeRecursionCount, ParamSpecEntry, Type, TypeCategory, TypeVarType } from './types';\n\nexport interface TypeVarMapEntry {\n    typeVar: TypeVarType;\n    type: Type;\n}\n\nexport interface ParamSpecMapEntry {\n    paramSpec: TypeVarType;\n    type: ParamSpecEntry[];\n}\n\nexport class TypeVarMap {\n    private _typeVarMap: Map<string, TypeVarMapEntry>;\n    private _paramSpecMap: Map<string, ParamSpecMapEntry>;\n    private _isNarrowableMap: Map<string, boolean>;\n    private _isLocked = false;\n\n    constructor() {\n        this._typeVarMap = new Map<string, TypeVarMapEntry>();\n        this._paramSpecMap = new Map<string, ParamSpecMapEntry>();\n        this._isNarrowableMap = new Map<string, boolean>();\n    }\n\n    clone() {\n        const newTypeVarMap = new TypeVarMap();\n\n        this._typeVarMap.forEach((value) => {\n            newTypeVarMap.setTypeVar(value.typeVar, value.type, this.isNarrowable(value.typeVar));\n        });\n\n        this._paramSpecMap.forEach((value) => {\n            newTypeVarMap.setParamSpec(value.paramSpec, value.type);\n        });\n\n        newTypeVarMap._isLocked = this._isLocked;\n\n        return newTypeVarMap;\n    }\n\n    // Copies a cloned type var map back into this object.\n    copyFromClone(clone: TypeVarMap) {\n        this._typeVarMap = clone._typeVarMap;\n        this._paramSpecMap = clone._paramSpecMap;\n        this._isNarrowableMap = clone._isNarrowableMap;\n        this._isLocked = clone._isLocked;\n    }\n\n    // Provides a \"score\" - a value that values completeness (number\n    // of type variables that are assigned) and completeness.\n    getScore() {\n        let score = 0;\n\n        // Sum the scores for the defined type vars.\n        this._typeVarMap.forEach((value) => {\n            // Add 1 to the score for each type variable defined.\n            score += 1;\n\n            // Add a fractional amount based on the complexity of the definition.\n            // The more complex, the lower the score. In the spirit of Occam's\n            // Razor, we always want to favor simple answers.\n            score += this._getComplexityScoreForType(value.type);\n        });\n\n        score += this._paramSpecMap.size;\n\n        return score;\n    }\n\n    hasTypeVar(reference: TypeVarType): boolean {\n        return this._typeVarMap.has(this._getKey(reference));\n    }\n\n    getTypeVar(reference: TypeVarType): Type | undefined {\n        return this._typeVarMap.get(this._getKey(reference))?.type;\n    }\n\n    setTypeVar(reference: TypeVarType, type: Type, isNarrowable: boolean) {\n        assert(!this._isLocked);\n        const key = this._getKey(reference);\n        this._typeVarMap.set(key, { typeVar: reference, type });\n        this._isNarrowableMap.set(key, isNarrowable);\n    }\n\n    getTypeVars(): TypeVarMapEntry[] {\n        const entries: TypeVarMapEntry[] = [];\n\n        this._typeVarMap.forEach((entry) => {\n            entries.push(entry);\n        });\n\n        return entries;\n    }\n\n    hasParamSpec(reference: TypeVarType): boolean {\n        return this._paramSpecMap.has(this._getKey(reference));\n    }\n\n    getParamSpec(reference: TypeVarType): ParamSpecEntry[] | undefined {\n        return this._paramSpecMap.get(this._getKey(reference))?.type;\n    }\n\n    setParamSpec(reference: TypeVarType, type: ParamSpecEntry[]) {\n        assert(!this._isLocked);\n        this._paramSpecMap.set(this._getKey(reference), { paramSpec: reference, type });\n    }\n\n    typeVarCount() {\n        return this._typeVarMap.size;\n    }\n\n    isNarrowable(reference: TypeVarType): boolean {\n        const key = this._getKey(reference);\n\n        return this._isNarrowableByKey(key);\n    }\n\n    lock() {\n        // Locks the type var map, preventing any further changes.\n        assert(!this._isLocked);\n        this._isLocked = true;\n    }\n\n    isLocked(): boolean {\n        return this._isLocked;\n    }\n\n    private _getKey(reference: TypeVarType) {\n        return reference.scopeId || reference.details.name;\n    }\n\n    private _isNarrowableByKey(key: string) {\n        const isNarrowable = this._isNarrowableMap.get(key);\n\n        // Unless told otherwise, assume type is narrowable.\n        return isNarrowable !== undefined ? isNarrowable : true;\n    }\n\n    // Returns a \"score\" for a type that captures the relative complexity\n    // of the type. Scores should all be between 0 and 1 where 0 means\n    // very complex and 1 means simple. This is a heuristic, so there's\n    // often no objectively correct answer.\n    private _getComplexityScoreForType(type: Type, recursionCount = 0): number {\n        if (recursionCount > maxTypeRecursionCount) {\n            return 0;\n        }\n\n        switch (type.category) {\n            case TypeCategory.Function:\n            case TypeCategory.OverloadedFunction: {\n                // For now, return a constant for functions. We may want\n                // to make this heuristic in the future.\n                return 0.5;\n            }\n\n            case TypeCategory.Union: {\n                let minScore = 1;\n                type.subtypes.forEach((subtype) => {\n                    const subtypeScore = this._getComplexityScoreForType(subtype, recursionCount + 1);\n                    if (subtypeScore < minScore) {\n                        minScore = subtypeScore;\n                    }\n                });\n\n                // Assume that a union is more complex than a non-union,\n                // and return half of the minimum score of the subtypes.\n                return minScore / 2;\n            }\n\n            case TypeCategory.Class: {\n                // Score a class as 0.5 plus half of the average complexity\n                // score of its type arguments.\n                return this._getComplexityScoreForClass(type, recursionCount + 1);\n            }\n\n            case TypeCategory.Object: {\n                return this._getComplexityScoreForClass(type.classType, recursionCount + 1);\n            }\n        }\n\n        // For all other types, return a score of 0.\n        return 0;\n    }\n\n    private _getComplexityScoreForClass(classType: ClassType, recursionCount: number): number {\n        let typeArgScoreSum = 0;\n        let typeArgCount = 0;\n\n        if (classType.typeArguments) {\n            classType.typeArguments.forEach((type) => {\n                typeArgScoreSum += this._getComplexityScoreForType(type, recursionCount + 1);\n                typeArgCount++;\n            });\n        }\n\n        let score = 0.5;\n        if (typeArgCount > 0) {\n            score += (typeArgScoreSum / typeArgCount) * 0.5;\n        }\n\n        return score;\n    }\n}\n","/*\n * types.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Representation of types used during type analysis within Python.\n */\n\nimport { assert } from '../common/debug';\nimport { ParameterCategory } from '../parser/parseNodes';\nimport { FunctionDeclaration } from './declaration';\nimport { Symbol, SymbolTable } from './symbol';\n\nexport const enum TypeCategory {\n    // Name is not bound to a value of any type.\n    Unbound,\n\n    // Type exists but is not currently known by the\n    // type analyzer (e.g. there is no available typings file).\n    // Unknown types are treated the same as \"Any\" at analysis time.\n    Unknown,\n\n    // Type can be anything.\n    Any,\n\n    // Special \"None\" type defined in Python.\n    None,\n\n    // Used in type constraints to indicate that all possible\n    // union types have been filtered, and execution should never\n    // get to this point.\n    Never,\n\n    // Callable type with typed input parameters and return parameter.\n    Function,\n\n    // Functions defined with @overload decorator in stub files that\n    // have multiple function declarations for a common implementation.\n    OverloadedFunction,\n\n    // Class definition, including associated instance methods,\n    // class methods, static methods, properties, and variables.\n    Class,\n\n    // Class instance.\n    Object,\n\n    // Module instance.\n    Module,\n\n    // Composite type (e.g. Number OR String OR None).\n    Union,\n\n    // Type variable (defined with TypeVar)\n    TypeVar,\n}\n\nexport const enum TypeFlags {\n    None = 0,\n\n    // This type refers to something that can be instantiated.\n    Instantiable = 1 << 0,\n\n    // This type refers to something that has been instantiated.\n    Instance = 1 << 1,\n}\n\nexport type Type =\n    | UnboundType\n    | UnknownType\n    | AnyType\n    | NoneType\n    | NeverType\n    | FunctionType\n    | OverloadedFunctionType\n    | ClassType\n    | ObjectType\n    | ModuleType\n    | UnionType\n    | TypeVarType;\n\nexport class EnumLiteral {\n    constructor(public className: string, public itemName: string) {}\n}\n\nexport type LiteralValue = number | boolean | string | EnumLiteral;\n\nexport type TypeSourceId = number;\nexport const maxTypeRecursionCount = 16;\n\nexport type InheritanceChain = (ClassType | UnknownType)[];\n\ninterface TypeAliasInfo {\n    aliasName: string;\n    typeParameters?: TypeVarType[];\n    typeArguments?: Type[];\n}\n\ninterface TypeBase {\n    category: TypeCategory;\n    flags: TypeFlags;\n    typeAliasInfo?: TypeAliasInfo;\n}\n\nexport namespace TypeBase {\n    export function isInstantiable(type: TypeBase) {\n        return (type.flags & TypeFlags.Instantiable) !== 0;\n    }\n\n    export function isInstance(type: TypeBase) {\n        return (type.flags & TypeFlags.Instance) !== 0;\n    }\n\n    export function cloneForTypeAlias(type: Type, name: string, typeParams?: TypeVarType[], typeArgs?: Type[]): Type {\n        const typeClone = { ...type };\n\n        typeClone.typeAliasInfo = {\n            aliasName: name,\n            typeParameters: typeParams,\n            typeArguments: typeArgs,\n        };\n\n        return typeClone;\n    }\n}\n\nexport interface UnboundType extends TypeBase {\n    category: TypeCategory.Unbound;\n}\n\nexport namespace UnboundType {\n    const _instance: UnboundType = {\n        category: TypeCategory.Unbound,\n        flags: TypeFlags.Instantiable | TypeFlags.Instance,\n    };\n\n    export function create() {\n        // All Unbound objects are the same, so use a shared instance.\n        return _instance;\n    }\n}\n\nexport interface UnknownType extends TypeBase {\n    category: TypeCategory.Unknown;\n}\n\nexport namespace UnknownType {\n    const _instance: UnknownType = {\n        category: TypeCategory.Unknown,\n        flags: TypeFlags.Instantiable | TypeFlags.Instance,\n    };\n\n    export function create() {\n        // All Unknown objects are the same, so use a shared instance.\n        return _instance;\n    }\n}\n\nexport interface ModuleType extends TypeBase {\n    category: TypeCategory.Module;\n    fields: SymbolTable;\n    docString?: string;\n\n    // A \"loader\" module includes symbols that were injected by\n    // the module loader. We keep these separate so we don't\n    // pollute the symbols exported by the module itself.\n    loaderFields: SymbolTable;\n\n    // The period-delimited import name of this module.\n    moduleName: string;\n}\n\nexport namespace ModuleType {\n    export function create(moduleName: string, symbolTable?: SymbolTable) {\n        const newModuleType: ModuleType = {\n            category: TypeCategory.Module,\n            fields: symbolTable || new Map<string, Symbol>(),\n            loaderFields: new Map<string, Symbol>(),\n            flags: TypeFlags.Instantiable | TypeFlags.Instantiable,\n            moduleName,\n        };\n        return newModuleType;\n    }\n\n    export function getField(moduleType: ModuleType, name: string): Symbol | undefined {\n        // Always look for the symbol in the module's fields before consulting\n        // the loader fields. The loader runs before the module, so its values\n        // will be overwritten by the module.\n        let symbol = moduleType.fields.get(name);\n\n        if (!symbol && moduleType.loaderFields) {\n            symbol = moduleType.loaderFields.get(name);\n        }\n        return symbol;\n    }\n}\n\nexport interface DataClassEntry {\n    name: string;\n    hasDefault: boolean;\n    includeInInit: boolean;\n    type: Type;\n}\n\nexport interface TypedDictEntry {\n    valueType: Type;\n    isRequired: boolean;\n    isProvided: boolean;\n}\n\nexport const enum ClassTypeFlags {\n    None = 0,\n\n    // Class is defined in the \"builtins\" or \"typing\" file.\n    BuiltInClass = 1 << 0,\n\n    // Class requires special-case handling because it\n    // exhibits non-standard behavior or is not defined\n    // formally as a class. Examples include 'Optional'\n    // and 'Union'.\n    SpecialBuiltIn = 1 << 1,\n\n    // Introduced in Python 3.7 - class either derives directly\n    // from NamedTuple or has a @dataclass class decorator.\n    DataClass = 1 << 2,\n\n    // Flags that control whether methods should be\n    // synthesized for a dataclass class.\n    SkipSynthesizedInit = 1 << 3,\n\n    // Introduced in PEP 589, TypedDict classes provide a way\n    // to specify type hints for dictionaries with different\n    // value types and a limited set of static keys.\n    TypedDictClass = 1 << 4,\n\n    // Used in conjunction with TypedDictClass, indicates that\n    // the dictionary values can be omitted.\n    CanOmitDictValues = 1 << 5,\n\n    // The class has a metaclass of EnumMet or derives from\n    // a class that has this metaclass.\n    EnumClass = 1 << 6,\n\n    // The class derives from a class that has the ABCMeta\n    // metaclass. Such classes are allowed to contain\n    // @abstractmethod decorators.\n    SupportsAbstractMethods = 1 << 7,\n\n    // The class has at least one abstract method or derives\n    // from a base class that is abstract without providing\n    // non-abstract overrides for all abstract methods.\n    HasAbstractMethods = 1 << 8,\n\n    // Derives from property class and has the semantics of\n    // a property (with optional setter, deleter).\n    PropertyClass = 1 << 9,\n\n    // The class is decorated with a \"@final\" decorator\n    // indicating that it cannot be subclassed.\n    Final = 1 << 10,\n\n    // The class derives directly from \"Protocol\".\n    ProtocolClass = 1 << 11,\n\n    // A class whose constructor (__init__ method) does not have\n    // annotated types and is treated as though each parameter\n    // is a generic type for purposes of type inference.\n    PseudoGenericClass = 1 << 12,\n\n    // A protocol class that is \"runtime checkable\" can be used\n    // in an isinstance call.\n    RuntimeCheckable = 1 << 13,\n\n    // The type is defined in the typing_extensions.pyi file.\n    TypingExtensionClass = 1 << 14,\n\n    // The class type is in the process of being constructed and\n    // is not yet complete. This allows us to detect cases where\n    // the class refers to itself (e.g. uses itself as a type\n    // argument to one of its generic base classes).\n    PartiallyConstructed = 1 << 15,\n}\n\ninterface ClassDetails {\n    name: string;\n    fullName: string;\n    moduleName: string;\n    flags: ClassTypeFlags;\n    typeSourceId: TypeSourceId;\n    baseClasses: Type[];\n    mro: Type[];\n    declaredMetaclass?: ClassType | UnknownType;\n    effectiveMetaclass?: ClassType | UnknownType;\n    aliasClass?: ClassType;\n    fields: SymbolTable;\n    typeParameters: TypeVarType[];\n    docString?: string;\n    dataClassEntries?: DataClassEntry[];\n    typedDictEntries?: Map<string, TypedDictEntry>;\n}\n\nexport interface ClassType extends TypeBase {\n    category: TypeCategory.Class;\n\n    details: ClassDetails;\n\n    // A generic class that has been completely or partially\n    // specialized will have type arguments that correspond to\n    // some or all of the type parameters.\n    typeArguments?: Type[];\n\n    // For a few classes (e.g., Tuple and tuple), the class definition\n    // calls for a single type parameter but the spec allows the programmer\n    // to provide variadic type arguments. To make these compatible, we need\n    // to derive a single effective type argument from the provided type\n    // arguments.\n    effectiveTypeArguments?: Type[];\n\n    // If type arguments are present, were they explicit (i.e.\n    // provided explicitly in the code)?\n    isTypeArgumentExplicit?: boolean;\n\n    skipAbstractClassTest: boolean;\n\n    // Some types can be further constrained to have\n    // literal types (e.g. true or 'string' or 3).\n    literalValue?: LiteralValue;\n}\n\nexport namespace ClassType {\n    export function create(\n        name: string,\n        fullName: string,\n        moduleName: string,\n        flags: ClassTypeFlags,\n        typeSourceId: TypeSourceId,\n        declaredMetaclass: ClassType | UnknownType | undefined,\n        effectiveMetaclass: ClassType | UnknownType | undefined,\n        docString?: string\n    ) {\n        const newClass: ClassType = {\n            category: TypeCategory.Class,\n            details: {\n                name,\n                fullName,\n                moduleName,\n                flags,\n                typeSourceId,\n                baseClasses: [],\n                declaredMetaclass,\n                effectiveMetaclass,\n                mro: [],\n                fields: new Map<string, Symbol>(),\n                typeParameters: [],\n                docString,\n            },\n            skipAbstractClassTest: false,\n            flags: TypeFlags.Instantiable,\n        };\n\n        return newClass;\n    }\n\n    export function cloneForSpecialization(\n        classType: ClassType,\n        typeArguments: Type[] | undefined,\n        isTypeArgumentExplicit: boolean,\n        skipAbstractClassTest = false,\n        effectiveTypeArguments?: Type[]\n    ): ClassType {\n        const newClassType = create(\n            classType.details.name,\n            classType.details.fullName,\n            classType.details.moduleName,\n            classType.details.flags,\n            classType.details.typeSourceId,\n            classType.details.declaredMetaclass,\n            classType.details.effectiveMetaclass\n        );\n\n        newClassType.details = classType.details;\n        if (typeArguments) {\n            newClassType.typeArguments = typeArguments;\n        }\n        newClassType.isTypeArgumentExplicit = isTypeArgumentExplicit;\n        if (effectiveTypeArguments) {\n            newClassType.effectiveTypeArguments = effectiveTypeArguments;\n        }\n\n        if (classType.literalValue !== undefined) {\n            newClassType.literalValue = classType.literalValue;\n        }\n\n        if (classType.typeAliasInfo !== undefined) {\n            newClassType.typeAliasInfo = classType.typeAliasInfo;\n        }\n\n        if (skipAbstractClassTest) {\n            newClassType.skipAbstractClassTest = true;\n        }\n\n        return newClassType;\n    }\n\n    export function cloneWithLiteral(classType: ClassType, value: LiteralValue | undefined): ClassType {\n        const newClassType = create(\n            classType.details.name,\n            classType.details.fullName,\n            classType.details.moduleName,\n            classType.details.flags,\n            classType.details.typeSourceId,\n            classType.details.declaredMetaclass,\n            classType.details.effectiveMetaclass\n        );\n        newClassType.details = classType.details;\n        if (classType.typeArguments) {\n            newClassType.typeArguments = classType.typeArguments;\n        }\n        if (value !== undefined) {\n            newClassType.literalValue = value;\n        }\n        if (classType.typeAliasInfo !== undefined) {\n            newClassType.typeAliasInfo = classType.typeAliasInfo;\n        }\n        if (classType.skipAbstractClassTest) {\n            newClassType.skipAbstractClassTest = true;\n        }\n        return newClassType;\n    }\n\n    export function isLiteralValueSame(type1: ClassType, type2: ClassType) {\n        if (type1.literalValue === undefined) {\n            return type2.literalValue === undefined;\n        } else if (type2.literalValue === undefined) {\n            return false;\n        }\n\n        if (type1.literalValue instanceof EnumLiteral) {\n            if (type2.literalValue instanceof EnumLiteral) {\n                return type1.literalValue.itemName === type2.literalValue.itemName;\n            }\n            return false;\n        }\n\n        return type1.literalValue === type2.literalValue;\n    }\n\n    // Specifies whether the class type is generic (unspecialized)\n    // or specialized.\n    export function isGeneric(classType: ClassType) {\n        return classType.details.typeParameters.length > 0 && classType.typeArguments === undefined;\n    }\n\n    export function isSpecialBuiltIn(classType: ClassType, className?: string) {\n        if (!(classType.details.flags & ClassTypeFlags.SpecialBuiltIn)) {\n            return false;\n        }\n\n        if (className !== undefined) {\n            return classType.details.name === className;\n        }\n\n        return true;\n    }\n\n    export function isBuiltIn(classType: ClassType, className?: string) {\n        if (!(classType.details.flags & ClassTypeFlags.BuiltInClass)) {\n            return false;\n        }\n\n        if (className !== undefined) {\n            return classType.details.name === className;\n        }\n\n        return true;\n    }\n\n    export function hasAbstractMethods(classType: ClassType) {\n        return !!(classType.details.flags & ClassTypeFlags.HasAbstractMethods) && !classType.skipAbstractClassTest;\n    }\n\n    export function supportsAbstractMethods(classType: ClassType) {\n        return !!(classType.details.flags & ClassTypeFlags.SupportsAbstractMethods);\n    }\n\n    export function isDataClass(classType: ClassType) {\n        return !!(classType.details.flags & ClassTypeFlags.DataClass);\n    }\n\n    export function isSkipSynthesizedInit(classType: ClassType) {\n        return !!(classType.details.flags & ClassTypeFlags.SkipSynthesizedInit);\n    }\n\n    export function isTypedDictClass(classType: ClassType) {\n        return !!(classType.details.flags & ClassTypeFlags.TypedDictClass);\n    }\n\n    export function isCanOmitDictValues(classType: ClassType) {\n        return !!(classType.details.flags & ClassTypeFlags.CanOmitDictValues);\n    }\n\n    export function isEnumClass(classType: ClassType) {\n        return !!(classType.details.flags & ClassTypeFlags.EnumClass);\n    }\n\n    export function isPropertyClass(classType: ClassType) {\n        return !!(classType.details.flags & ClassTypeFlags.PropertyClass);\n    }\n\n    export function isFinal(classType: ClassType) {\n        return !!(classType.details.flags & ClassTypeFlags.Final);\n    }\n\n    export function isProtocolClass(classType: ClassType) {\n        return !!(classType.details.flags & ClassTypeFlags.ProtocolClass);\n    }\n\n    export function isPseudoGenericClass(classType: ClassType) {\n        return !!(classType.details.flags & ClassTypeFlags.PseudoGenericClass);\n    }\n\n    export function getDataClassEntries(classType: ClassType): DataClassEntry[] {\n        return classType.details.dataClassEntries || [];\n    }\n\n    export function isRuntimeCheckable(classType: ClassType) {\n        return !!(classType.details.flags & ClassTypeFlags.RuntimeCheckable);\n    }\n\n    export function isTypingExtensionClass(classType: ClassType) {\n        return !!(classType.details.flags & ClassTypeFlags.TypingExtensionClass);\n    }\n\n    export function isPartiallyConstructed(classType: ClassType) {\n        return !!(classType.details.flags & ClassTypeFlags.PartiallyConstructed);\n    }\n\n    export function getTypeParameters(classType: ClassType) {\n        // If this is a special class, use the alias class' type\n        // parameters instead.\n        if (classType.details.aliasClass) {\n            return classType.details.aliasClass.details.typeParameters;\n        }\n        return classType.details.typeParameters;\n    }\n\n    export function hasUnknownBaseClass(classType: ClassType) {\n        return classType.details.mro.some((baseClass) => isAnyOrUnknown(baseClass));\n    }\n\n    // Same as isSame except that it doesn't compare type arguments.\n    export function isSameGenericClass(\n        classType: ClassType,\n        type2: ClassType,\n        treatAliasAsSame = true,\n        recursionCount = 0\n    ) {\n        if (recursionCount > maxTypeRecursionCount) {\n            return true;\n        }\n\n        // If the class details match, it's definitely the same class.\n        if (classType.details === type2.details) {\n            return true;\n        }\n\n        // If either or both have aliases (e.g. List -> list), use the\n        // aliases for comparison purposes.\n        const class1Details =\n            treatAliasAsSame && classType.details.aliasClass ? classType.details.aliasClass.details : classType.details;\n        const class2Details =\n            treatAliasAsSame && type2.details.aliasClass ? type2.details.aliasClass.details : type2.details;\n\n        if (class1Details === class2Details) {\n            return true;\n        }\n\n        // Compare most of the details fields. We intentionally skip the isAbstractClass\n        // flag because it gets set dynamically.\n        if (\n            class1Details.name !== class2Details.name ||\n            class1Details.flags !== class2Details.flags ||\n            class1Details.typeSourceId !== class2Details.typeSourceId ||\n            class1Details.baseClasses.length !== class2Details.baseClasses.length ||\n            class1Details.typeParameters.length !== class2Details.typeParameters.length\n        ) {\n            return false;\n        }\n\n        for (let i = 0; i < class1Details.baseClasses.length; i++) {\n            if (!isTypeSame(class1Details.baseClasses[i], class2Details.baseClasses[i], recursionCount + 1)) {\n                return false;\n            }\n        }\n\n        if (class1Details.declaredMetaclass || class2Details.declaredMetaclass) {\n            if (\n                !class1Details.declaredMetaclass ||\n                !class2Details.declaredMetaclass ||\n                !isTypeSame(class1Details.declaredMetaclass, class2Details.declaredMetaclass)\n            ) {\n                return false;\n            }\n        }\n\n        for (let i = 0; i < class1Details.typeParameters.length; i++) {\n            if (!isTypeSame(class1Details.typeParameters[i], class2Details.typeParameters[i], recursionCount + 1)) {\n                return false;\n            }\n        }\n\n        const dataClassEntries1 = class1Details.dataClassEntries || [];\n        const dataClassEntries2 = class2Details.dataClassEntries || [];\n        if (dataClassEntries1.length !== dataClassEntries2.length) {\n            return false;\n        }\n\n        for (let i = 0; i < dataClassEntries1.length; i++) {\n            if (\n                dataClassEntries1[i].name !== dataClassEntries2[i].name ||\n                dataClassEntries1[i].hasDefault !== dataClassEntries2[i].hasDefault ||\n                !isTypeSame(dataClassEntries1[i].type, dataClassEntries2[i].type, recursionCount + 1)\n            ) {\n                return false;\n            }\n        }\n\n        // If the two types don't have the same symbol table, they are probably\n        // using synthesized (undeclared) symbols. Make sure that they contain the\n        // same number of symbols and types.\n        if (class1Details.fields !== class2Details.fields) {\n            if (class1Details.fields.size !== class2Details.fields.size) {\n                return false;\n            }\n\n            let symbolsMatch = true;\n            class1Details.fields.forEach((symbol1, name) => {\n                const symbol2 = class2Details.fields.get(name);\n                if (!symbol2) {\n                    symbolsMatch = false;\n                } else {\n                    const symbol1Type = symbol1.getSynthesizedType() || UnknownType.create();\n                    const symbol2Type = symbol2.getSynthesizedType() || UnknownType.create();\n                    if (!isTypeSame(symbol1Type, symbol2Type, recursionCount + 1)) {\n                        symbolsMatch = false;\n                    }\n                }\n            });\n\n            if (!symbolsMatch) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    // Determines whether this is a subclass (derived class)\n    // of the specified class. If the caller passes an empty\n    // array to inheritanceChain, it will be filled in by\n    // the call to include the chain of inherited classes starting\n    // with type2 and ending with this type.\n    export function isDerivedFrom(\n        subclassType: ClassType,\n        parentClassType: ClassType,\n        inheritanceChain?: InheritanceChain\n    ): boolean {\n        // Is it the exact same class?\n        if (isSameGenericClass(subclassType, parentClassType)) {\n            if (inheritanceChain) {\n                inheritanceChain.push(subclassType);\n            }\n            return true;\n        }\n\n        // Handle built-in types like 'dict' and 'list', which are all\n        // subclasses of object even though they are not explicitly declared\n        // that way.\n        if (isBuiltIn(subclassType) && isBuiltIn(parentClassType, 'object')) {\n            if (inheritanceChain) {\n                inheritanceChain.push(parentClassType);\n            }\n            return true;\n        }\n\n        const aliasedSubclass = subclassType.details.aliasClass || subclassType;\n        for (const baseClass of aliasedSubclass.details.baseClasses) {\n            if (isClass(baseClass)) {\n                if (isDerivedFrom(baseClass, parentClassType, inheritanceChain)) {\n                    if (inheritanceChain) {\n                        inheritanceChain.push(subclassType);\n                    }\n                    return true;\n                }\n            } else if (isAnyOrUnknown(baseClass)) {\n                if (inheritanceChain) {\n                    inheritanceChain.push(UnknownType.create());\n                }\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n\nexport interface ObjectType extends TypeBase {\n    category: TypeCategory.Object;\n\n    classType: ClassType;\n}\n\nexport namespace ObjectType {\n    export function create(classType: ClassType) {\n        const newObjectType: ObjectType = {\n            category: TypeCategory.Object,\n            classType,\n            flags: TypeFlags.Instance,\n        };\n        return newObjectType;\n    }\n}\n\nexport interface FunctionParameter {\n    category: ParameterCategory;\n    name?: string;\n    isNameSynthesized?: boolean;\n    isTypeInferred?: boolean;\n    hasDefault?: boolean;\n    defaultType?: Type;\n    hasDeclaredType?: boolean;\n    type: Type;\n}\n\nexport const enum FunctionTypeFlags {\n    None = 0,\n\n    // Function is a __new__ method; first parameter is \"cls\"\n    ConstructorMethod = 1 << 0,\n\n    // Function is decorated with @classmethod; first parameter is \"cls\";\n    // can be bound to associated class\n    ClassMethod = 1 << 1,\n\n    // Function is decorated with @staticmethod; cannot be bound to class\n    StaticMethod = 1 << 2,\n\n    // Function is decorated with @abstractmethod\n    AbstractMethod = 1 << 3,\n\n    // Function contains \"yield\" or \"yield from\" statements\n    Generator = 1 << 4,\n\n    // Skip check that validates that all parameters without default\n    // value expressions have corresponding arguments; used for\n    // named tuples in some cases\n    DisableDefaultChecks = 1 << 5,\n\n    // Method has no declaration in user code, it's synthesized; used\n    // for implied methods such as those used in namedtuple, dataclass, etc.\n    SynthesizedMethod = 1 << 6,\n\n    // For some synthesized classes (in particular, NamedTuple), the\n    // __init__ method is created with default parameters, so we will\n    // skip the constructor check for these methods.\n    SkipConstructorCheck = 1 << 7,\n\n    // Function is decorated with @overload\n    Overloaded = 1 << 8,\n\n    // Function is declared with async keyword\n    Async = 1 << 9,\n\n    // Indicates that return type should be wrapped in an awaitable type\n    WrapReturnTypeInAwait = 1 << 10,\n\n    // Function is declared within a type stub fille\n    StubDefinition = 1 << 11,\n\n    // Function is declared within a module that claims to be fully typed\n    // (i.e. a \"py.typed\" file is present).\n    PyTypedDefinition = 1 << 12,\n\n    // Function is decorated with @final\n    Final = 1 << 13,\n\n    // Function has one or more parameters that are missing type annotations\n    UnannotatedParams = 1 << 14,\n\n    // Any collection of parameters will match this function. This is used\n    // for Callable[..., x].\n    SkipParamCompatibilityCheck = 1 << 15,\n}\n\ninterface FunctionDetails {\n    name: string;\n    moduleName: string;\n    flags: FunctionTypeFlags;\n    parameters: FunctionParameter[];\n    declaredReturnType?: Type;\n    declaration?: FunctionDeclaration;\n    builtInName?: string;\n    docString?: string;\n\n    // Parameter specification used only for Callable types created\n    // with a ParamSpec representing the parameters.\n    paramSpec?: TypeVarType;\n}\n\nexport interface SpecializedFunctionTypes {\n    parameterTypes: Type[];\n    returnType?: Type;\n}\n\nexport interface FunctionType extends TypeBase {\n    category: TypeCategory.Function;\n\n    details: FunctionDetails;\n\n    // This flag is set when the first parameter is stripped\n    // (see \"clone\" method below).\n    ignoreFirstParamOfDeclaration?: boolean;\n\n    // A function type can be specialized (i.e. generic type\n    // variables replaced by a concrete type).\n    specializedTypes?: SpecializedFunctionTypes;\n\n    // Filled in lazily\n    inferredReturnType?: Type;\n}\n\nexport interface ParamSpecEntry {\n    name: string;\n    type: Type;\n}\n\nexport namespace FunctionType {\n    export function createInstance(\n        name: string,\n        moduleName: string,\n        functionFlags: FunctionTypeFlags,\n        docString?: string\n    ) {\n        return create(name, moduleName, functionFlags, TypeFlags.Instance, docString);\n    }\n\n    export function createInstantiable(\n        name: string,\n        moduleName: string,\n        functionFlags: FunctionTypeFlags,\n        docString?: string\n    ) {\n        return create(name, moduleName, functionFlags, TypeFlags.Instantiable, docString);\n    }\n\n    function create(\n        name: string,\n        moduleName: string,\n        functionFlags: FunctionTypeFlags,\n        typeFlags: TypeFlags,\n        docString?: string\n    ) {\n        const newFunctionType: FunctionType = {\n            category: TypeCategory.Function,\n            details: {\n                name,\n                moduleName,\n                flags: functionFlags,\n                parameters: [],\n                docString,\n            },\n            flags: typeFlags,\n        };\n        return newFunctionType;\n    }\n\n    // Creates a deep copy of the function type, including a fresh\n    // version of _functionDetails.\n    export function clone(type: FunctionType, deleteFirstParam = false): FunctionType {\n        const newFunction = create(\n            type.details.name,\n            type.details.moduleName,\n            type.details.flags,\n            type.flags,\n            type.details.docString\n        );\n        const startParam = deleteFirstParam ? 1 : 0;\n\n        newFunction.details = {\n            name: type.details.name,\n            moduleName: type.details.moduleName,\n            flags: type.details.flags,\n            parameters: type.details.parameters.slice(startParam),\n            declaredReturnType: type.details.declaredReturnType,\n            declaration: type.details.declaration,\n            builtInName: type.details.builtInName,\n            docString: type.details.docString,\n        };\n\n        // If we strip off the first parameter, this is no longer an\n        // instance method or class method.\n        if (deleteFirstParam) {\n            newFunction.details.flags &= ~(FunctionTypeFlags.ConstructorMethod | FunctionTypeFlags.ClassMethod);\n            newFunction.details.flags |= FunctionTypeFlags.StaticMethod;\n            newFunction.ignoreFirstParamOfDeclaration = true;\n        }\n\n        if (type.typeAliasInfo !== undefined) {\n            newFunction.typeAliasInfo = type.typeAliasInfo;\n        }\n\n        if (type.specializedTypes) {\n            newFunction.specializedTypes = {\n                parameterTypes: type.specializedTypes.parameterTypes.slice(startParam),\n                returnType: type.specializedTypes.returnType,\n            };\n        }\n\n        newFunction.inferredReturnType = type.inferredReturnType;\n\n        return newFunction;\n    }\n\n    export function cloneAsInstance(type: FunctionType) {\n        assert(TypeBase.isInstantiable(type));\n        const newInstance: FunctionType = { ...type };\n        newInstance.flags &= ~TypeFlags.Instantiable;\n        newInstance.flags |= TypeFlags.Instance;\n        return newInstance;\n    }\n\n    export function cloneAsInstantiable(type: FunctionType) {\n        assert(TypeBase.isInstance(type));\n        const newInstance: FunctionType = { ...type };\n        newInstance.flags &= ~TypeFlags.Instance;\n        newInstance.flags |= TypeFlags.Instantiable;\n        return newInstance;\n    }\n\n    // Creates a shallow copy of the function type with new\n    // specialized types. The clone shares the _functionDetails\n    // with the object being cloned.\n    export function cloneForSpecialization(\n        type: FunctionType,\n        specializedTypes: SpecializedFunctionTypes,\n        specializedInferredReturnType: Type | undefined\n    ): FunctionType {\n        const newFunction = create(\n            type.details.name,\n            type.details.moduleName,\n            type.details.flags,\n            type.flags,\n            type.details.docString\n        );\n        newFunction.details = type.details;\n\n        assert(specializedTypes.parameterTypes.length === type.details.parameters.length);\n        newFunction.specializedTypes = specializedTypes;\n\n        if (specializedInferredReturnType) {\n            newFunction.inferredReturnType = specializedInferredReturnType;\n        }\n\n        return newFunction;\n    }\n\n    // Creates a new function based on the parameters of another function.\n    export function cloneForParamSpec(type: FunctionType, paramTypes: ParamSpecEntry[] | undefined) {\n        const newFunction = create(\n            type.details.name,\n            type.details.moduleName,\n            type.details.flags,\n            type.flags,\n            type.details.docString\n        );\n\n        // Make a shallow clone of the details.\n        newFunction.details = { ...type.details };\n\n        // The clone should no longer have a parameter specification\n        // since we're replacing it.\n        delete newFunction.details.paramSpec;\n\n        if (paramTypes) {\n            newFunction.details.parameters = paramTypes.map((specEntry, index) => {\n                return {\n                    category: ParameterCategory.Simple,\n                    name: specEntry.name,\n                    isNameSynthesized: true,\n                    hasDeclaredType: true,\n                    type: specEntry.type,\n                };\n            });\n        }\n\n        return newFunction;\n    }\n\n    export function addDefaultParameters(functionType: FunctionType, useUnknown = false) {\n        FunctionType.addParameter(functionType, {\n            category: ParameterCategory.VarArgList,\n            name: 'args',\n            type: useUnknown ? UnknownType.create() : AnyType.create(),\n        });\n        FunctionType.addParameter(functionType, {\n            category: ParameterCategory.VarArgDictionary,\n            name: 'kwargs',\n            type: useUnknown ? UnknownType.create() : AnyType.create(),\n        });\n    }\n\n    export function isInstanceMethod(type: FunctionType): boolean {\n        return (\n            (type.details.flags &\n                (FunctionTypeFlags.ConstructorMethod |\n                    FunctionTypeFlags.StaticMethod |\n                    FunctionTypeFlags.ClassMethod)) ===\n            0\n        );\n    }\n\n    export function isConstructorMethod(type: FunctionType): boolean {\n        return (type.details.flags & FunctionTypeFlags.ConstructorMethod) !== 0;\n    }\n\n    export function isStaticMethod(type: FunctionType): boolean {\n        return (type.details.flags & FunctionTypeFlags.StaticMethod) !== 0;\n    }\n\n    export function isClassMethod(type: FunctionType): boolean {\n        return (type.details.flags & FunctionTypeFlags.ClassMethod) !== 0;\n    }\n\n    export function isAbstractMethod(type: FunctionType): boolean {\n        return (type.details.flags & FunctionTypeFlags.AbstractMethod) !== 0;\n    }\n\n    export function isGenerator(type: FunctionType): boolean {\n        return (type.details.flags & FunctionTypeFlags.Generator) !== 0;\n    }\n\n    export function isSynthesizedMethod(type: FunctionType): boolean {\n        return (type.details.flags & FunctionTypeFlags.SynthesizedMethod) !== 0;\n    }\n\n    export function isSkipConstructorCheck(type: FunctionType): boolean {\n        return (type.details.flags & FunctionTypeFlags.SkipConstructorCheck) !== 0;\n    }\n\n    export function isOverloaded(type: FunctionType): boolean {\n        return (type.details.flags & FunctionTypeFlags.Overloaded) !== 0;\n    }\n\n    export function isDefaultParameterCheckDisabled(type: FunctionType) {\n        return (type.details.flags & FunctionTypeFlags.DisableDefaultChecks) !== 0;\n    }\n\n    export function isAsync(type: FunctionType) {\n        return (type.details.flags & FunctionTypeFlags.Async) !== 0;\n    }\n\n    export function isWrapReturnTypeInAwait(type: FunctionType) {\n        return (type.details.flags & FunctionTypeFlags.WrapReturnTypeInAwait) !== 0;\n    }\n\n    export function isStubDefinition(type: FunctionType) {\n        return (type.details.flags & FunctionTypeFlags.StubDefinition) !== 0;\n    }\n\n    export function isPyTypedDefinition(type: FunctionType) {\n        return (type.details.flags & FunctionTypeFlags.PyTypedDefinition) !== 0;\n    }\n\n    export function isFinal(type: FunctionType) {\n        return (type.details.flags & FunctionTypeFlags.Final) !== 0;\n    }\n\n    export function hasUnannotatedParams(type: FunctionType) {\n        return (type.details.flags & FunctionTypeFlags.UnannotatedParams) !== 0;\n    }\n\n    export function shouldSkipParamCompatibilityCheck(type: FunctionType) {\n        return (type.details.flags & FunctionTypeFlags.SkipParamCompatibilityCheck) !== 0;\n    }\n\n    export function getEffectiveParameterType(type: FunctionType, index: number): Type {\n        assert(index < type.details.parameters.length);\n        if (type.specializedTypes) {\n            return type.specializedTypes.parameterTypes[index];\n        }\n\n        return type.details.parameters[index].type;\n    }\n\n    export function addParameter(type: FunctionType, param: FunctionParameter) {\n        type.details.parameters.push(param);\n    }\n\n    export function getSpecializedReturnType(type: FunctionType) {\n        return type.specializedTypes && type.specializedTypes.returnType\n            ? type.specializedTypes.returnType\n            : type.details.declaredReturnType;\n    }\n}\n\nexport interface OverloadedFunctionType extends TypeBase {\n    category: TypeCategory.OverloadedFunction;\n    overloads: FunctionType[];\n}\n\nexport namespace OverloadedFunctionType {\n    export function create(overloads: FunctionType[] = []) {\n        const newType: OverloadedFunctionType = {\n            category: TypeCategory.OverloadedFunction,\n            overloads,\n            flags: TypeFlags.Instance,\n        };\n        return newType;\n    }\n\n    export function addOverload(type: OverloadedFunctionType, functionType: FunctionType) {\n        type.overloads.push(functionType);\n    }\n}\n\nexport interface NoneType extends TypeBase {\n    category: TypeCategory.None;\n}\n\nexport namespace NoneType {\n    const _noneInstance: NoneType = {\n        category: TypeCategory.None,\n        flags: TypeFlags.Instance,\n    };\n\n    const _noneType: NoneType = {\n        category: TypeCategory.None,\n        flags: TypeFlags.Instantiable,\n    };\n\n    export function createInstance() {\n        return _noneInstance;\n    }\n\n    export function createType() {\n        return _noneType;\n    }\n}\n\nexport interface NeverType extends TypeBase {\n    category: TypeCategory.Never;\n}\n\nexport namespace NeverType {\n    const _neverInstance: NeverType = {\n        category: TypeCategory.Never,\n        flags: TypeFlags.Instance | TypeFlags.Instantiable,\n    };\n\n    export function create() {\n        return _neverInstance;\n    }\n}\n\nexport interface AnyType extends TypeBase {\n    category: TypeCategory.Any;\n    isEllipsis: boolean;\n}\n\nexport namespace AnyType {\n    const _anyInstance: AnyType = {\n        category: TypeCategory.Any,\n        isEllipsis: false,\n        flags: TypeFlags.Instance | TypeFlags.Instantiable,\n    };\n    const _ellipsisInstance: AnyType = {\n        category: TypeCategory.Any,\n        isEllipsis: true,\n        flags: TypeFlags.Instance | TypeFlags.Instantiable,\n    };\n\n    export function create(isEllipsis = false) {\n        return isEllipsis ? _ellipsisInstance : _anyInstance;\n    }\n}\n\nexport interface UnionType extends TypeBase {\n    category: TypeCategory.Union;\n    subtypes: Type[];\n    literalStrMap?: Map<string, Type>;\n    literalIntMap?: Map<number, Type>;\n}\n\nexport namespace UnionType {\n    export function create() {\n        const newUnionType: UnionType = {\n            category: TypeCategory.Union,\n            subtypes: [],\n            flags: TypeFlags.Instance | TypeFlags.Instantiable,\n        };\n\n        return newUnionType;\n    }\n\n    export function addType(unionType: UnionType, newType: Type) {\n        assert(newType.category !== TypeCategory.Union);\n        assert(newType.category !== TypeCategory.Never);\n\n        // If we're adding a string literal type, add it to the\n        // literal string map to speed up some operations. It's not\n        // uncommon for unions to contain hundreds of string literals.\n        if (\n            isObject(newType) &&\n            ClassType.isBuiltIn(newType.classType, 'str') &&\n            newType.classType.literalValue !== undefined\n        ) {\n            if (unionType.literalStrMap === undefined) {\n                unionType.literalStrMap = new Map<string, Type>();\n            }\n            unionType.literalStrMap.set(newType.classType.literalValue as string, newType);\n        } else if (\n            isObject(newType) &&\n            ClassType.isBuiltIn(newType.classType, 'int') &&\n            newType.classType.literalValue !== undefined\n        ) {\n            if (unionType.literalIntMap === undefined) {\n                unionType.literalIntMap = new Map<number, Type>();\n            }\n            unionType.literalIntMap.set(newType.classType.literalValue as number, newType);\n        }\n\n        unionType.flags &= newType.flags;\n        unionType.subtypes.push(newType);\n    }\n\n    export function containsType(unionType: UnionType, subtype: Type, recursionCount = 0): boolean {\n        // Handle string literals as a special case because unions can sometimes\n        // contain hundreds of string literal types.\n        if (isObject(subtype)) {\n            if (\n                ClassType.isBuiltIn(subtype.classType, 'str') &&\n                subtype.classType.literalValue !== undefined &&\n                unionType.literalStrMap !== undefined\n            ) {\n                return unionType.literalStrMap.has(subtype.classType.literalValue as string);\n            } else if (\n                ClassType.isBuiltIn(subtype.classType, 'int') &&\n                subtype.classType.literalValue !== undefined &&\n                unionType.literalIntMap !== undefined\n            ) {\n                return unionType.literalIntMap.has(subtype.classType.literalValue as number);\n            }\n        }\n\n        return unionType.subtypes.find((t) => isTypeSame(t, subtype, recursionCount + 1)) !== undefined;\n    }\n}\n\nexport interface TypeVarDetails {\n    name: string;\n    constraints: Type[];\n    boundType?: Type;\n    isCovariant: boolean;\n    isContravariant: boolean;\n    isParamSpec: boolean;\n\n    // Internally created (e.g. for pseudo-generic classes)\n    isSynthesized: boolean;\n    synthesizedIndex?: number;\n\n    // Used for recursive type aliases.\n    recursiveTypeAliasName?: string;\n}\n\nexport interface TypeVarType extends TypeBase {\n    category: TypeCategory.TypeVar;\n    details: TypeVarDetails;\n\n    // An id that uniquely identifies the scope in which this TypeVar is\n    // defined. Valid scopes include classes or functions. The scopeId\n    // is a string formatted as <name>.<nodeId> where nodeId is the\n    // parse node of a class or function declaration.\n    scopeId?: string;\n}\n\nexport namespace TypeVarType {\n    export function createInstance(name: string, isParamSpec: boolean, isSynthesized = false) {\n        return create(name, isParamSpec, isSynthesized, TypeFlags.Instance);\n    }\n\n    export function createInstantiable(name: string, isParamSpec: boolean, isSynthesized = false) {\n        return create(name, isParamSpec, isSynthesized, TypeFlags.Instantiable);\n    }\n\n    export function cloneAsInstance(type: TypeVarType) {\n        assert(TypeBase.isInstantiable(type));\n        const newInstance: TypeVarType = { ...type };\n        newInstance.flags &= ~TypeFlags.Instantiable;\n        newInstance.flags |= TypeFlags.Instance;\n        return newInstance;\n    }\n\n    export function cloneAsInstantiable(type: TypeVarType) {\n        assert(TypeBase.isInstance(type));\n        const newInstance: TypeVarType = { ...type };\n        newInstance.flags &= ~TypeFlags.Instance;\n        newInstance.flags |= TypeFlags.Instantiable;\n        return newInstance;\n    }\n\n    export function cloneForScopeId(type: TypeVarType, nodeId: number) {\n        const newInstance: TypeVarType = { ...type };\n        newInstance.scopeId = makeScopeId(type.details.name, nodeId);\n        return newInstance;\n    }\n\n    export function makeScopeId(name: string, nodeId: number) {\n        return `${name}.${nodeId.toString()}`;\n    }\n\n    function create(name: string, isParamSpec: boolean, isSynthesized: boolean, typeFlags: TypeFlags) {\n        const newTypeVarType: TypeVarType = {\n            category: TypeCategory.TypeVar,\n            details: {\n                name,\n                constraints: [],\n                isCovariant: false,\n                isContravariant: false,\n                isParamSpec,\n                isSynthesized,\n            },\n            flags: typeFlags,\n        };\n        return newTypeVarType;\n    }\n\n    export function addConstraint(typeVarType: TypeVarType, constraintType: Type) {\n        typeVarType.details.constraints.push(constraintType);\n    }\n}\n\nexport function isNever(type: Type): type is NeverType {\n    return type.category === TypeCategory.Never;\n}\n\nexport function isNone(type: Type): type is NoneType {\n    return type.category === TypeCategory.None;\n}\n\nexport function isUnknown(type: Type): type is UnknownType {\n    return type.category === TypeCategory.Unknown;\n}\n\nexport function isAnyOrUnknown(type: Type): type is AnyType | UnknownType {\n    if (type.category === TypeCategory.Any || type.category === TypeCategory.Unknown) {\n        return true;\n    }\n\n    if (type.category === TypeCategory.Union) {\n        return type.subtypes.find((t) => !isAnyOrUnknown(t)) === undefined;\n    }\n\n    return false;\n}\n\nexport function isUnbound(type: Type): type is UnboundType {\n    return type.category === TypeCategory.Unbound;\n}\n\nexport function isPossiblyUnbound(type: Type): boolean {\n    if (type.category === TypeCategory.Unbound) {\n        return true;\n    }\n\n    if (type.category === TypeCategory.Union) {\n        return type.subtypes.find((t) => isPossiblyUnbound(t)) !== undefined;\n    }\n\n    return false;\n}\n\nexport function isClass(type: Type): type is ClassType {\n    return type.category === TypeCategory.Class;\n}\n\nexport function isObject(type: Type): type is ObjectType {\n    return type.category === TypeCategory.Object;\n}\n\nexport function isModule(type: Type): type is ModuleType {\n    return type.category === TypeCategory.Module;\n}\n\nexport function isTypeVar(type: Type): type is TypeVarType {\n    return type.category === TypeCategory.TypeVar;\n}\n\nexport function isFunction(type: Type): type is FunctionType {\n    return type.category === TypeCategory.Function;\n}\n\nexport function isOverloadedFunction(type: Type): type is OverloadedFunctionType {\n    return type.category === TypeCategory.OverloadedFunction;\n}\n\nexport function isTypeSame(type1: Type, type2: Type, recursionCount = 0): boolean {\n    if (type1.category !== type2.category) {\n        return false;\n    }\n\n    if (recursionCount > maxTypeRecursionCount) {\n        return true;\n    }\n\n    switch (type1.category) {\n        case TypeCategory.Class: {\n            const classType2 = type2 as ClassType;\n\n            // If the details are not the same it's not the same class.\n            if (!ClassType.isSameGenericClass(type1, classType2, true, recursionCount + 1)) {\n                return false;\n            }\n\n            // Make sure the type args match.\n            const type1TypeArgs = type1.typeArguments || [];\n            const type2TypeArgs = classType2.typeArguments || [];\n            const typeArgCount = Math.max(type1TypeArgs.length, type2TypeArgs.length);\n\n            for (let i = 0; i < typeArgCount; i++) {\n                // Assume that missing type args are \"Any\".\n                const typeArg1 = i < type1TypeArgs.length ? type1TypeArgs[i] : AnyType.create();\n                const typeArg2 = i < type2TypeArgs.length ? type2TypeArgs[i] : AnyType.create();\n\n                if (!isTypeSame(typeArg1, typeArg2, recursionCount + 1)) {\n                    return false;\n                }\n            }\n\n            if (!ClassType.isLiteralValueSame(type1, classType2)) {\n                return false;\n            }\n\n            return true;\n        }\n\n        case TypeCategory.Object: {\n            const objType2 = type2 as ObjectType;\n\n            return isTypeSame(type1.classType, objType2.classType, recursionCount + 1);\n        }\n\n        case TypeCategory.Function: {\n            // Make sure the parameter counts match.\n            const functionType2 = type2 as FunctionType;\n            const params1 = type1.details.parameters;\n            const params2 = functionType2.details.parameters;\n\n            if (params1.length !== params2.length) {\n                return false;\n            }\n\n            // Make sure the parameter details match.\n            for (let i = 0; i < params1.length; i++) {\n                const param1 = params1[i];\n                const param2 = params2[i];\n\n                if (param1.category !== param2.category) {\n                    return false;\n                }\n\n                if (param1.name !== param2.name) {\n                    return false;\n                }\n\n                const param1Type = FunctionType.getEffectiveParameterType(type1, i);\n                const param2Type = FunctionType.getEffectiveParameterType(functionType2, i);\n                if (!isTypeSame(param1Type, param2Type, recursionCount + 1)) {\n                    return false;\n                }\n            }\n\n            // Make sure the return types match.\n            let return1Type = type1.details.declaredReturnType;\n            if (type1.specializedTypes && type1.specializedTypes.returnType) {\n                return1Type = type1.specializedTypes.returnType;\n            }\n            let return2Type = functionType2.details.declaredReturnType;\n            if (functionType2.specializedTypes && functionType2.specializedTypes.returnType) {\n                return2Type = functionType2.specializedTypes.returnType;\n            }\n            if (return1Type || return2Type) {\n                if (!return1Type || !return2Type || !isTypeSame(return1Type, return2Type, recursionCount + 1)) {\n                    return false;\n                }\n            }\n\n            if (type1.details.declaration !== functionType2.details.declaration) {\n                return false;\n            }\n\n            return true;\n        }\n\n        case TypeCategory.OverloadedFunction: {\n            // Make sure the overload counts match.\n            const functionType2 = type2 as OverloadedFunctionType;\n            if (type1.overloads.length !== functionType2.overloads.length) {\n                return false;\n            }\n\n            // We assume here that overloaded functions always appear\n            // in the same order from one analysis pass to another.\n            for (let i = 0; i < type1.overloads.length; i++) {\n                if (!isTypeSame(type1.overloads[i], functionType2.overloads[i])) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        case TypeCategory.Union: {\n            const unionType2 = type2 as UnionType;\n            const subtypes1 = type1.subtypes;\n            const subtypes2 = unionType2.subtypes;\n\n            if (subtypes1.length !== subtypes2.length) {\n                return false;\n            }\n\n            // The types do not have a particular order, so we need to\n            // do the comparison in an order-independent manner.\n            return subtypes1.find((t) => !UnionType.containsType(unionType2, t, recursionCount + 1)) === undefined;\n        }\n\n        case TypeCategory.TypeVar: {\n            const type2TypeVar = type2 as TypeVarType;\n\n            if (type1.scopeId !== type2TypeVar.scopeId) {\n                return false;\n            }\n\n            if (type1.details.name !== type2TypeVar.details.name) {\n                return false;\n            }\n\n            const boundType1 = type1.details.boundType;\n            const boundType2 = type2TypeVar.details.boundType;\n            if (boundType1) {\n                if (!boundType2 || !isTypeSame(boundType1, boundType2, recursionCount + 1)) {\n                    return false;\n                }\n            } else {\n                if (boundType2) {\n                    return false;\n                }\n            }\n\n            if (type1.details.isContravariant !== type2TypeVar.details.isContravariant) {\n                return false;\n            }\n\n            if (type1.details.isCovariant !== type2TypeVar.details.isCovariant) {\n                return false;\n            }\n\n            const constraints1 = type1.details.constraints;\n            const constraints2 = type2TypeVar.details.constraints;\n            if (constraints1.length !== constraints2.length) {\n                return false;\n            }\n\n            for (let i = 0; i < constraints1.length; i++) {\n                if (!isTypeSame(constraints1[i], constraints2[i], recursionCount + 1)) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        case TypeCategory.Module: {\n            const type2Module = type2 as ModuleType;\n\n            // Module types are the same if they share the same\n            // module symbol table.\n            if (type1.fields === type2Module.fields) {\n                return true;\n            }\n\n            // If both symbol tables are empty, we can also assume\n            // they're equal.\n            if (type1.fields.size === 0 && type2Module.fields.size === 0) {\n                return true;\n            }\n\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// If the type is a union, remove any \"unknown\" or \"any\" type\n// from the union, returning only the known types.\nexport function removeAnyFromUnion(type: Type): Type {\n    return removeFromUnion(type, (t: Type) => isAnyOrUnknown(t));\n}\n\n// If the type is a union, remove an \"unknown\" type from the union,\n// returning only the known types.\nexport function removeUnknownFromUnion(type: Type): Type {\n    return removeFromUnion(type, (t: Type) => t.category === TypeCategory.Unknown);\n}\n\n// If the type is a union, remove an \"unbound\" type from the union,\n// returning only the known types.\nexport function removeUnboundFromUnion(type: Type): Type {\n    return removeFromUnion(type, (t: Type) => isUnbound(t));\n}\n\n// If the type is a union, remove an \"None\" type from the union,\n// returning only the known types.\nexport function removeNoneFromUnion(type: Type): Type {\n    return removeFromUnion(type, (t: Type) => t.category === TypeCategory.None);\n}\n\nexport function removeFromUnion(type: Type, removeFilter: (type: Type) => boolean) {\n    if (type.category === TypeCategory.Union) {\n        const remainingTypes = type.subtypes.filter((t) => !removeFilter(t));\n        if (remainingTypes.length < type.subtypes.length) {\n            return combineTypes(remainingTypes);\n        }\n    }\n\n    return type;\n}\n\n// Determines whether the specified type is a type that can be\n// combined with other types for a union.\nexport function isUnionableType(subtypes: Type[]): boolean {\n    let typeFlags = TypeFlags.Instance | TypeFlags.Instantiable;\n\n    for (const subtype of subtypes) {\n        typeFlags &= subtype.flags;\n    }\n\n    // All subtypes need to be instantiable. Some types (like Any\n    // and None) are both instances and instantiable. It's OK to\n    // include some of these, but at least one subtype needs to\n    // be definitively instantiable (not an instance).\n    return (typeFlags & TypeFlags.Instantiable) !== 0 && (typeFlags & TypeFlags.Instance) === 0;\n}\n\n// Combines multiple types into a single type. If the types are\n// the same, only one is returned. If they differ, they\n// are combined into a UnionType. NeverTypes are filtered out.\n// If no types remain in the end, a NeverType is returned.\nexport function combineTypes(types: Type[]): Type {\n    // Filter out any \"Never\" types.\n    types = types.filter((type) => type.category !== TypeCategory.Never);\n    if (types.length === 0) {\n        return NeverType.create();\n    }\n\n    // Handle the common case where there is only one type.\n    if (types.length === 1) {\n        return types[0];\n    }\n\n    // Expand all union types.\n    let expandedTypes: Type[] = [];\n    for (const type of types) {\n        if (type.category === TypeCategory.Union) {\n            expandedTypes = expandedTypes.concat(type.subtypes);\n        } else {\n            expandedTypes.push(type);\n        }\n    }\n\n    // Sort all of the literal types to the end.\n    expandedTypes = expandedTypes.sort((type1, type2) => {\n        if (\n            (isObject(type1) && type1.classType.literalValue !== undefined) ||\n            (isClass(type1) && type1.literalValue !== undefined)\n        ) {\n            return 1;\n        } else if (\n            (isObject(type2) && type2.classType.literalValue !== undefined) ||\n            (isClass(type2) && type2.literalValue !== undefined)\n        ) {\n            return -1;\n        }\n        return 0;\n    });\n\n    // If the union contains a NoReturn, remove it. NoReturn should\n    // be used only when it's by itself.\n    const isNoReturn = (t: Type) => isObject(t) && ClassType.isBuiltIn(t.classType, 'NoReturn');\n    if (expandedTypes.find((t) => isNoReturn(t))) {\n        expandedTypes = expandedTypes.filter((t) => !isNoReturn(t));\n    }\n\n    // If removing all NoReturn types results in no remaining types,\n    // convert it to an unknown.\n    if (expandedTypes.length === 0) {\n        return UnknownType.create();\n    }\n\n    const newUnionType = UnionType.create();\n\n    expandedTypes.forEach((t, index) => {\n        if (index === 0) {\n            UnionType.addType(newUnionType, t);\n        } else {\n            _addTypeIfUnique(newUnionType, t);\n        }\n    });\n\n    // If only one type remains, convert it from a union to a simple type.\n    if (newUnionType.subtypes.length === 1) {\n        return newUnionType.subtypes[0];\n    }\n\n    return newUnionType;\n}\n\n// Determines whether the dest type is the same as the source type with\n// the possible exception that the source type has a literal value when\n// the dest does not.\nexport function isSameWithoutLiteralValue(destType: Type, srcType: Type): boolean {\n    // If it's the same with literals, great.\n    if (isTypeSame(destType, srcType)) {\n        return true;\n    }\n\n    if (isClass(srcType) && srcType.literalValue !== undefined) {\n        // Strip the literal.\n        srcType = ClassType.cloneWithLiteral(srcType, undefined);\n        return isTypeSame(destType, srcType);\n    }\n\n    if (isObject(srcType) && srcType.classType.literalValue !== undefined) {\n        // Strip the literal.\n        srcType = ObjectType.create(ClassType.cloneWithLiteral(srcType.classType, undefined));\n        return isTypeSame(destType, srcType);\n    }\n\n    return false;\n}\n\nfunction _addTypeIfUnique(unionType: UnionType, typeToAdd: Type) {\n    // Handle the addition of a string literal in a special manner to\n    // avoid n^2 behavior in unions that contain hundreds of string\n    // literal types.\n    if (isObject(typeToAdd)) {\n        if (\n            ClassType.isBuiltIn(typeToAdd.classType, 'str') &&\n            typeToAdd.classType.literalValue !== undefined &&\n            unionType.literalStrMap !== undefined\n        ) {\n            if (!unionType.literalStrMap.has(typeToAdd.classType.literalValue as string)) {\n                UnionType.addType(unionType, typeToAdd);\n            }\n            return;\n        } else if (\n            ClassType.isBuiltIn(typeToAdd.classType, 'int') &&\n            typeToAdd.classType.literalValue !== undefined &&\n            unionType.literalIntMap !== undefined\n        ) {\n            if (!unionType.literalIntMap.has(typeToAdd.classType.literalValue as number)) {\n                UnionType.addType(unionType, typeToAdd);\n            }\n            return;\n        }\n    }\n\n    for (let i = 0; i < unionType.subtypes.length; i++) {\n        const type = unionType.subtypes[i];\n\n        // Does this type already exist in the types array?\n        if (isTypeSame(type, typeToAdd)) {\n            return;\n        }\n\n        // If the typeToAdd is a literal value and there's already\n        // a non-literal type that matches, don't add the literal value.\n        if (isObject(type) && isObject(typeToAdd)) {\n            if (isSameWithoutLiteralValue(type, typeToAdd)) {\n                if (type.classType.literalValue === undefined) {\n                    return;\n                }\n            }\n\n            // If we're adding Literal[False] or Literal[True] to its\n            // opposite, combine them into a non-literal 'bool' type.\n            if (ClassType.isBuiltIn(type.classType, 'bool')) {\n                if (\n                    typeToAdd.classType.literalValue !== undefined &&\n                    !typeToAdd.classType.literalValue === type.classType.literalValue\n                ) {\n                    unionType.subtypes[i] = ObjectType.create(ClassType.cloneWithLiteral(type.classType, undefined));\n                    return;\n                }\n            }\n        }\n    }\n\n    UnionType.addType(unionType, typeToAdd);\n}\n","/*\n * backgroundAnalysis.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * run analyzer from background thread\n */\n\nimport { Worker } from 'worker_threads';\n\nimport { BackgroundAnalysisBase, BackgroundAnalysisRunnerBase, InitializationData } from './backgroundAnalysisBase';\nimport { getCancellationFolderName } from './common/cancellationUtils';\nimport { ConsoleInterface } from './common/console';\n\nexport class BackgroundAnalysis extends BackgroundAnalysisBase {\n    constructor(console: ConsoleInterface) {\n        super(console);\n\n        const initialData: InitializationData = {\n            rootDirectory: (global as any).__rootDirectory as string,\n            cancellationFolderName: getCancellationFolderName(),\n        };\n\n        // this will load this same file in BG thread and start listener\n        const worker = new Worker(__filename, { workerData: initialData });\n        this.setup(worker);\n    }\n}\n\nexport class BackgroundAnalysisRunner extends BackgroundAnalysisRunnerBase {\n    constructor() {\n        super();\n    }\n}\n","/*\n * backgroundAnalysisBase.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * run analyzer from background thread\n */\n\nimport { CancellationToken } from 'vscode-languageserver/node';\nimport { MessageChannel, MessagePort, parentPort, threadId, Worker, workerData } from 'worker_threads';\n\nimport { AnalysisCompleteCallback, AnalysisResults, analyzeProgram, nullCallback } from './analyzer/analysis';\nimport { ImportResolver } from './analyzer/importResolver';\nimport { Indices, Program } from './analyzer/program';\nimport {\n    BackgroundThreadBase,\n    createConfigOptionsFrom,\n    getBackgroundWaiter,\n    LogData,\n    run,\n} from './backgroundThreadBase';\nimport {\n    disposeCancellationToken,\n    getCancellationTokenFromId,\n    getCancellationTokenId,\n    throwIfCancellationRequested,\n} from './common/cancellationUtils';\nimport { ConfigOptions } from './common/configOptions';\nimport { ConsoleInterface, log, LogLevel } from './common/console';\nimport * as debug from './common/debug';\nimport { Diagnostic } from './common/diagnostic';\nimport { FileDiagnostics } from './common/diagnosticSink';\nimport { LanguageServiceExtension } from './common/extensibility';\nimport { FileSystem } from './common/fileSystem';\nimport { Range } from './common/textRange';\nimport { IndexResults } from './languageService/documentSymbolProvider';\n\nexport class BackgroundAnalysisBase {\n    private _worker: Worker | undefined;\n    private _onAnalysisCompletion: AnalysisCompleteCallback = nullCallback;\n\n    protected constructor(protected console: ConsoleInterface) {\n        // Don't allow instantiation of this type directly.\n    }\n\n    protected setup(worker: Worker) {\n        this._worker = worker;\n\n        // global channel to communicate from BG channel to main thread.\n        worker.on('message', (msg: AnalysisResponse) => {\n            switch (msg.requestType) {\n                case 'log': {\n                    const logData = msg.data as LogData;\n                    this.log(logData.level, logData.message);\n                    break;\n                }\n\n                case 'analysisResult': {\n                    // Change in diagnostics due to host such as file closed rather than\n                    // analyzing files.\n                    this._onAnalysisCompletion(convertAnalysisResults(msg.data));\n                    break;\n                }\n\n                default:\n                    debug.fail(`${msg.requestType} is not expected`);\n            }\n        });\n\n        // this will catch any exception thrown from background thread,\n        // print log and ignore exception\n        worker.on('error', (msg) => {\n            this.log(LogLevel.Error, `Error occurred on background thread: ${JSON.stringify(msg)}`);\n        });\n    }\n\n    setCompletionCallback(callback?: AnalysisCompleteCallback) {\n        this._onAnalysisCompletion = callback ?? nullCallback;\n    }\n\n    setConfigOptions(configOptions: ConfigOptions) {\n        this.enqueueRequest({ requestType: 'setConfigOptions', data: configOptions });\n    }\n\n    setTrackedFiles(filePaths: string[]) {\n        this.enqueueRequest({ requestType: 'setTrackedFiles', data: filePaths });\n    }\n\n    setAllowedThirdPartyImports(importNames: string[]) {\n        this.enqueueRequest({ requestType: 'setAllowedThirdPartyImports', data: importNames });\n    }\n\n    setFileOpened(filePath: string, version: number | null, contents: string) {\n        this.enqueueRequest({ requestType: 'setFileOpened', data: { filePath, version, contents } });\n    }\n\n    setFileClosed(filePath: string) {\n        this.enqueueRequest({ requestType: 'setFileClosed', data: filePath });\n    }\n\n    markAllFilesDirty(evenIfContentsAreSame: boolean) {\n        this.enqueueRequest({ requestType: 'markAllFilesDirty', data: evenIfContentsAreSame });\n    }\n\n    markFilesDirty(filePaths: string[], evenIfContentsAreSame: boolean) {\n        this.enqueueRequest({ requestType: 'markFilesDirty', data: { filePaths, evenIfContentsAreSame } });\n    }\n\n    startAnalysis(indices: Indices | undefined, token: CancellationToken) {\n        this._startOrResumeAnalysis('analyze', indices, token);\n    }\n\n    private _startOrResumeAnalysis(\n        requestType: 'analyze' | 'resumeAnalysis',\n        indices: Indices | undefined,\n        token: CancellationToken\n    ) {\n        const { port1, port2 } = new MessageChannel();\n\n        // Handle response from background thread to main thread.\n        port1.on('message', (msg: AnalysisResponse) => {\n            switch (msg.requestType) {\n                case 'analysisResult': {\n                    this._onAnalysisCompletion(convertAnalysisResults(msg.data));\n                    break;\n                }\n\n                case 'analysisPaused': {\n                    disposeCancellationToken(token);\n                    port2.close();\n                    port1.close();\n\n                    // Analysis request has completed, but there is more to\n                    // analyze, so queue another message to resume later.\n                    this._startOrResumeAnalysis('resumeAnalysis', indices, token);\n                    break;\n                }\n\n                case 'indexResult': {\n                    const { path, indexResults } = msg.data;\n                    indices?.setWorkspaceIndex(path, indexResults);\n                    break;\n                }\n\n                case 'analysisDone': {\n                    disposeCancellationToken(token);\n                    port2.close();\n                    port1.close();\n                    break;\n                }\n\n                default:\n                    debug.fail(`${msg.requestType} is not expected`);\n            }\n        });\n\n        const cancellationId = getCancellationTokenId(token);\n        this.enqueueRequest({ requestType, data: cancellationId, port: port2 });\n    }\n\n    startIndexing(configOptions: ConfigOptions, indices: Indices) {\n        /* noop */\n    }\n\n    refreshIndexing(configOptions: ConfigOptions, indices?: Indices) {\n        /* noop */\n    }\n\n    cancelIndexing(configOptions: ConfigOptions) {\n        /* noop */\n    }\n\n    async getDiagnosticsForRange(filePath: string, range: Range, token: CancellationToken): Promise<Diagnostic[]> {\n        throwIfCancellationRequested(token);\n\n        const { port1, port2 } = new MessageChannel();\n        const waiter = getBackgroundWaiter<Diagnostic[]>(port1);\n\n        const cancellationId = getCancellationTokenId(token);\n        this.enqueueRequest({\n            requestType: 'getDiagnosticsForRange',\n            data: { filePath, range, cancellationId },\n            port: port2,\n        });\n\n        const result = await waiter;\n\n        port2.close();\n        port1.close();\n\n        return convertDiagnostics(result);\n    }\n\n    async writeTypeStub(\n        targetImportPath: string,\n        targetIsSingleFile: boolean,\n        stubPath: string,\n        token: CancellationToken\n    ): Promise<any> {\n        throwIfCancellationRequested(token);\n\n        const { port1, port2 } = new MessageChannel();\n        const waiter = getBackgroundWaiter(port1);\n\n        const cancellationId = getCancellationTokenId(token);\n        this.enqueueRequest({\n            requestType: 'writeTypeStub',\n            data: { targetImportPath, targetIsSingleFile, stubPath, cancellationId },\n            port: port2,\n        });\n\n        await waiter;\n\n        port2.close();\n        port1.close();\n    }\n\n    invalidateAndForceReanalysis() {\n        this.enqueueRequest({ requestType: 'invalidateAndForceReanalysis', data: null });\n    }\n\n    restart() {\n        this.enqueueRequest({ requestType: 'restart', data: null });\n    }\n\n    protected enqueueRequest(request: AnalysisRequest) {\n        if (this._worker) {\n            this._worker.postMessage(request, request.port ? [request.port] : undefined);\n        }\n    }\n\n    protected log(level: LogLevel, msg: string) {\n        log(this.console, level, msg);\n    }\n}\n\nexport class BackgroundAnalysisRunnerBase extends BackgroundThreadBase {\n    private _configOptions: ConfigOptions;\n    private _importResolver: ImportResolver;\n    private _program: Program;\n\n    get program(): Program {\n        return this._program;\n    }\n\n    protected constructor(private _extension?: LanguageServiceExtension) {\n        super(workerData as InitializationData);\n\n        // Stash the base directory into a global variable.\n        const data = workerData as InitializationData;\n        this.log(LogLevel.Info, `Background analysis(${threadId}) root directory: ${data.rootDirectory}`);\n\n        this._configOptions = new ConfigOptions(data.rootDirectory);\n        this._importResolver = this.createImportResolver(this.fs, this._configOptions);\n        this._program = new Program(\n            this._importResolver,\n            this._configOptions,\n            this.getConsole(),\n            this._extension,\n            `BG(${threadId})`\n        );\n    }\n\n    start() {\n        this.log(LogLevel.Info, `Background analysis(${threadId}) started`);\n\n        // Get requests from main thread.\n        parentPort?.on('message', (msg: AnalysisRequest) => this.onMessage(msg));\n\n        parentPort?.on('error', (msg) => debug.fail(`failed ${msg}`));\n        parentPort?.on('exit', (c) => {\n            if (c !== 0) {\n                debug.fail(`worker stopped with exit code ${c}`);\n            }\n        });\n    }\n\n    protected onMessage(msg: AnalysisRequest) {\n        this.log(LogLevel.Log, `Background analysis message: ${msg.requestType}`);\n\n        switch (msg.requestType) {\n            case 'analyze': {\n                const port = msg.port!;\n                const token = getCancellationTokenFromId(msg.data);\n\n                // Report files to analyze first.\n                const filesLeftToAnalyze = this.program.getFilesToAnalyzeCount();\n\n                this._onAnalysisCompletion(port, {\n                    diagnostics: [],\n                    filesInProgram: this.program.getFileCount(),\n                    filesRequiringAnalysis: filesLeftToAnalyze,\n                    checkingOnlyOpenFiles: this.program.isCheckingOnlyOpenFiles(),\n                    fatalErrorOccurred: false,\n                    configParseErrorOccurred: false,\n                    elapsedTime: 0,\n                });\n\n                this._analyzeOneChunk(port, token, msg);\n                break;\n            }\n\n            case 'resumeAnalysis': {\n                const port = msg.port!;\n                const token = getCancellationTokenFromId(msg.data);\n\n                this._analyzeOneChunk(port, token, msg);\n                break;\n            }\n\n            case 'getDiagnosticsForRange': {\n                run(() => {\n                    const { filePath, range, cancellationId } = msg.data;\n                    const token = getCancellationTokenFromId(cancellationId);\n                    throwIfCancellationRequested(token);\n\n                    return this.program.getDiagnosticsForRange(filePath, range);\n                }, msg.port!);\n                break;\n            }\n\n            case 'writeTypeStub': {\n                run(() => {\n                    const { targetImportPath, targetIsSingleFile, stubPath, cancellationId } = msg.data;\n                    const token = getCancellationTokenFromId(cancellationId);\n\n                    analyzeProgram(\n                        this.program,\n                        undefined,\n                        this._configOptions,\n                        nullCallback,\n                        this.getConsole(),\n                        token\n                    );\n                    this.program.writeTypeStub(targetImportPath, targetIsSingleFile, stubPath, token);\n                }, msg.port!);\n                break;\n            }\n\n            case 'setConfigOptions': {\n                this._configOptions = createConfigOptionsFrom(msg.data);\n                this._importResolver = this.createImportResolver(this.fs, this._configOptions);\n                this.program.setConfigOptions(this._configOptions);\n                this.program.setImportResolver(this._importResolver);\n                break;\n            }\n\n            case 'setTrackedFiles': {\n                const diagnostics = this.program.setTrackedFiles(msg.data);\n                this._reportDiagnostics(diagnostics, this.program.getFilesToAnalyzeCount(), 0);\n                break;\n            }\n\n            case 'setAllowedThirdPartyImports': {\n                this.program.setAllowedThirdPartyImports(msg.data);\n                break;\n            }\n\n            case 'setFileOpened': {\n                const { filePath, version, contents } = msg.data;\n                this.program.setFileOpened(filePath, version, contents);\n                break;\n            }\n\n            case 'setFileClosed': {\n                const diagnostics = this.program.setFileClosed(msg.data);\n                this._reportDiagnostics(diagnostics, this.program.getFilesToAnalyzeCount(), 0);\n                break;\n            }\n\n            case 'markAllFilesDirty': {\n                this.program.markAllFilesDirty(msg.data);\n                break;\n            }\n\n            case 'markFilesDirty': {\n                const { filePaths, evenIfContentsAreSame } = msg.data;\n                this.program.markFilesDirty(filePaths, evenIfContentsAreSame);\n                break;\n            }\n\n            case 'invalidateAndForceReanalysis': {\n                // Make sure the import resolver doesn't have invalid\n                // cached entries.\n                this._importResolver.invalidateCache();\n\n                // Mark all files with one or more errors dirty.\n                this.program.markAllFilesDirty(true);\n                break;\n            }\n\n            case 'restart': {\n                // recycle import resolver\n                this._importResolver = this.createImportResolver(this.fs, this._configOptions);\n                this.program.setImportResolver(this._importResolver);\n                break;\n            }\n\n            default: {\n                debug.fail(`${msg.requestType} is not expected`);\n            }\n        }\n    }\n\n    private _analyzeOneChunk(port: MessagePort, token: CancellationToken, msg: AnalysisRequest) {\n        // Report results at the interval of the max analysis time.\n        const maxTime = { openFilesTimeInMs: 50, noOpenFilesTimeInMs: 200 };\n        const moreToAnalyze = analyzeProgram(\n            this.program,\n            maxTime,\n            this._configOptions,\n            (result) => this._onAnalysisCompletion(port, result),\n            this.getConsole(),\n            token\n        );\n\n        if (moreToAnalyze) {\n            // There's more to analyze after we exceeded max time,\n            // so report that we are paused. The foreground thread will\n            // then queue up a message to resume the analysis.\n            this._analysisPaused(port, msg.data);\n        } else {\n            this.processIndexing(port, token);\n            this._analysisDone(port, msg.data);\n        }\n    }\n\n    protected createImportResolver(fs: FileSystem, options: ConfigOptions): ImportResolver {\n        return new ImportResolver(fs, options);\n    }\n\n    protected processIndexing(port: MessagePort, token: CancellationToken) {\n        /* noop */\n    }\n\n    protected reportIndex(port: MessagePort, result: { path: string; indexResults: IndexResults }) {\n        port.postMessage({ requestType: 'indexResult', data: result });\n    }\n\n    private _reportDiagnostics(diagnostics: FileDiagnostics[], filesLeftToAnalyze: number, elapsedTime: number) {\n        if (parentPort) {\n            this._onAnalysisCompletion(parentPort, {\n                diagnostics,\n                filesInProgram: this.program.getFileCount(),\n                filesRequiringAnalysis: filesLeftToAnalyze,\n                checkingOnlyOpenFiles: this.program.isCheckingOnlyOpenFiles(),\n                fatalErrorOccurred: false,\n                configParseErrorOccurred: false,\n                elapsedTime,\n            });\n        }\n    }\n\n    private _onAnalysisCompletion(port: MessagePort, result: AnalysisResults) {\n        port.postMessage({ requestType: 'analysisResult', data: result });\n    }\n\n    private _analysisPaused(port: MessagePort, cancellationId: string) {\n        port.postMessage({ requestType: 'analysisPaused', data: cancellationId });\n    }\n\n    private _analysisDone(port: MessagePort, cancellationId: string) {\n        port.postMessage({ requestType: 'analysisDone', data: cancellationId });\n    }\n}\n\nfunction convertAnalysisResults(result: AnalysisResults): AnalysisResults {\n    result.diagnostics = result.diagnostics.map((f: FileDiagnostics) => {\n        return {\n            filePath: f.filePath,\n            diagnostics: convertDiagnostics(f.diagnostics),\n        };\n    });\n\n    return result;\n}\n\nfunction convertDiagnostics(diagnostics: Diagnostic[]) {\n    // Elements are typed as \"any\" since data crossing the process\n    // boundary loses type info.\n    return diagnostics.map<Diagnostic>((d: any) => {\n        const diag = new Diagnostic(d.category, d.message, d.range);\n        if (d._actions) {\n            for (const action of d._actions) {\n                diag.addAction(action);\n            }\n        }\n\n        if (d._rule) {\n            diag.setRule(d._rule);\n        }\n\n        if (d._relatedInfo) {\n            for (const info of d._relatedInfo) {\n                diag.addRelatedInfo(info.message, info.filePath, info.range);\n            }\n        }\n\n        return diag;\n    });\n}\n\nexport interface InitializationData {\n    rootDirectory: string;\n    cancellationFolderName?: string;\n    runner?: string;\n}\n\nexport interface AnalysisRequest {\n    requestType:\n        | 'analyze'\n        | 'resumeAnalysis'\n        | 'setConfigOptions'\n        | 'setTrackedFiles'\n        | 'setAllowedThirdPartyImports'\n        | 'setFileOpened'\n        | 'setFileClosed'\n        | 'markAllFilesDirty'\n        | 'markFilesDirty'\n        | 'invalidateAndForceReanalysis'\n        | 'restart'\n        | 'getDiagnosticsForRange'\n        | 'writeTypeStub'\n        | 'getSemanticTokens';\n\n    data: any;\n    port?: MessagePort;\n}\n\ninterface AnalysisResponse {\n    requestType: 'log' | 'analysisResult' | 'analysisPaused' | 'indexResult' | 'analysisDone';\n    data: any;\n}\n","/*\n * backgroundThreadBase.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * base class for background worker thread.\n */\n\nimport { MessagePort, parentPort } from 'worker_threads';\n\nimport { OperationCanceledException, setCancellationFolderName } from './common/cancellationUtils';\nimport { ConfigOptions } from './common/configOptions';\nimport { LogLevel } from './common/console';\nimport * as debug from './common/debug';\nimport { createFromRealFileSystem, FileSystem } from './common/fileSystem';\nimport { FileSpec } from './common/pathUtils';\n\nexport class BackgroundThreadBase {\n    protected fs: FileSystem;\n\n    protected constructor(data: InitializationData) {\n        setCancellationFolderName(data.cancellationFolderName);\n\n        // Stash the base directory into a global variable.\n        (global as any).__rootDirectory = data.rootDirectory;\n\n        this.fs = createFromRealFileSystem(this.getConsole());\n    }\n\n    protected log(level: LogLevel, msg: string) {\n        parentPort?.postMessage({ requestType: 'log', data: { level: level, message: msg } });\n    }\n\n    protected getConsole() {\n        return {\n            log: (msg: string) => {\n                this.log(LogLevel.Log, msg);\n            },\n            info: (msg: string) => {\n                this.log(LogLevel.Info, msg);\n            },\n            warn: (msg: string) => {\n                this.log(LogLevel.Warn, msg);\n            },\n            error: (msg: string) => {\n                this.log(LogLevel.Error, msg);\n            },\n            // We always generate logs in the background. For the foreground,\n            // we'll decide decide based on user setting whether.\n            level: LogLevel.Log,\n        };\n    }\n}\n\nexport function createConfigOptionsFrom(jsonObject: any): ConfigOptions {\n    const configOptions = new ConfigOptions(jsonObject.projectRoot);\n    const getFileSpec = (fileSpec: any): FileSpec => {\n        return { wildcardRoot: fileSpec.wildcardRoot, regExp: new RegExp(fileSpec.regExp.source) };\n    };\n\n    configOptions.pythonPath = jsonObject.pythonPath;\n    configOptions.typeshedPath = jsonObject.typeshedPath;\n    configOptions.stubPath = jsonObject.stubPath;\n    configOptions.autoExcludeVenv = jsonObject.autoExcludeVenv;\n    configOptions.verboseOutput = jsonObject.verboseOutput;\n    configOptions.checkOnlyOpenFiles = jsonObject.checkOnlyOpenFiles;\n    configOptions.useLibraryCodeForTypes = jsonObject.useLibraryCodeForTypes;\n    configOptions.internalTestMode = jsonObject.internalTestMode;\n    configOptions.venvPath = jsonObject.venvPath;\n    configOptions.defaultVenv = jsonObject.defaultVenv;\n    configOptions.defaultPythonVersion = jsonObject.defaultPythonVersion;\n    configOptions.defaultPythonPlatform = jsonObject.defaultPythonPlatform;\n    configOptions.diagnosticRuleSet = jsonObject.diagnosticRuleSet;\n    configOptions.executionEnvironments = jsonObject.executionEnvironments;\n    configOptions.autoImportCompletions = jsonObject.autoImportCompletions;\n    configOptions.indexing = jsonObject.indexing;\n    configOptions.include = jsonObject.include.map((f: any) => getFileSpec(f));\n    configOptions.exclude = jsonObject.exclude.map((f: any) => getFileSpec(f));\n    configOptions.ignore = jsonObject.ignore.map((f: any) => getFileSpec(f));\n    configOptions.strict = jsonObject.strict.map((f: any) => getFileSpec(f));\n\n    return configOptions;\n}\n\nexport function run(code: () => any, port: MessagePort) {\n    try {\n        const result = code();\n        port.postMessage({ kind: 'ok', data: result });\n    } catch (e) {\n        if (OperationCanceledException.is(e)) {\n            port.postMessage({ kind: 'cancelled', data: e.message });\n            return;\n        }\n\n        port.postMessage({ kind: 'failed', data: `Exception: ${e.message} in ${e.stack}` });\n    }\n}\n\nexport function getBackgroundWaiter<T>(port: MessagePort): Promise<T> {\n    return new Promise((resolve, reject) => {\n        port.on('message', (m: RequestResponse) => {\n            switch (m.kind) {\n                case 'ok':\n                    resolve(m.data);\n                    break;\n\n                case 'cancelled':\n                    reject(new OperationCanceledException());\n                    break;\n\n                case 'failed':\n                    reject(m.data);\n                    break;\n\n                default:\n                    debug.fail(`unknown kind ${m.kind}`);\n            }\n        });\n    });\n}\n\nexport interface InitializationData {\n    rootDirectory: string;\n    cancellationFolderName?: string;\n    runner?: string;\n}\n\nexport interface RequestResponse {\n    kind: 'ok' | 'failed' | 'cancelled';\n    data: any;\n}\n\nexport interface LogData {\n    level: LogLevel;\n    message: string;\n}\n","/*\n * commandController.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * Implements language server commands execution functionality.\n */\n\nimport { CancellationToken, ExecuteCommandParams, ResponseError } from 'vscode-languageserver';\n\nimport { LanguageServerInterface } from '../languageServerBase';\nimport { Commands } from './commands';\nimport { CreateTypeStubCommand } from './createTypeStub';\nimport { QuickActionCommand } from './quickActionCommand';\nimport { RestartServerCommand } from './restartServer';\n\nexport interface ServerCommand {\n    execute(cmdParams: ExecuteCommandParams, token: CancellationToken): Promise<any>;\n}\n\nexport class CommandController implements ServerCommand {\n    private _createStub: CreateTypeStubCommand;\n    private _restartServer: RestartServerCommand;\n    private _quickAction: QuickActionCommand;\n\n    constructor(ls: LanguageServerInterface) {\n        this._createStub = new CreateTypeStubCommand(ls);\n        this._restartServer = new RestartServerCommand(ls);\n        this._quickAction = new QuickActionCommand(ls);\n    }\n\n    async execute(cmdParams: ExecuteCommandParams, token: CancellationToken): Promise<any> {\n        switch (cmdParams.command) {\n            case Commands.orderImports:\n            case Commands.addMissingOptionalToParam: {\n                return this._quickAction.execute(cmdParams, token);\n            }\n\n            case Commands.createTypeStub: {\n                return this._createStub.execute(cmdParams, token);\n            }\n\n            case Commands.restartServer: {\n                return this._restartServer.execute(cmdParams);\n            }\n\n            default: {\n                return new ResponseError<string>(1, 'Unsupported command');\n            }\n        }\n    }\n\n    isLongRunningCommand(command: string): boolean {\n        switch (command) {\n            case Commands.createTypeStub:\n                return true;\n\n            default:\n                return false;\n        }\n    }\n}\n","/*\n * createTypeStub.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * Implements 'create stub' command functionality.\n */\n\nimport { CancellationToken, ExecuteCommandParams } from 'vscode-languageserver';\n\nimport { AnalyzerService } from '../analyzer/service';\nimport { OperationCanceledException } from '../common/cancellationUtils';\nimport { createDeferred } from '../common/deferred';\nimport { convertPathToUri } from '../common/pathUtils';\nimport { LanguageServerInterface, WorkspaceServiceInstance } from '../languageServerBase';\nimport { AnalyzerServiceExecutor } from '../languageService/analyzerServiceExecutor';\nimport { ServerCommand } from './commandController';\n\nexport class CreateTypeStubCommand implements ServerCommand {\n    constructor(private _ls: LanguageServerInterface) {}\n\n    async execute(cmdParams: ExecuteCommandParams, token: CancellationToken): Promise<any> {\n        if (cmdParams.arguments && cmdParams.arguments.length >= 2) {\n            const workspaceRoot = cmdParams.arguments[0];\n            const importName = cmdParams.arguments[1];\n            const callingFile = cmdParams.arguments[2];\n\n            const service = await this._createTypeStubService(callingFile);\n\n            // Allocate a temporary pseudo-workspace to perform this job.\n            const workspace: WorkspaceServiceInstance = {\n                workspaceName: `Create Type Stub ${importName}`,\n                rootPath: workspaceRoot,\n                rootUri: convertPathToUri(workspaceRoot),\n                serviceInstance: service,\n                disableLanguageServices: true,\n                disableOrganizeImports: true,\n                isInitialized: createDeferred<boolean>(),\n            };\n\n            const serverSettings = await this._ls.getSettings(workspace);\n            AnalyzerServiceExecutor.runWithOptions(this._ls.rootPath, workspace, serverSettings, importName, false);\n\n            try {\n                await service.writeTypeStubInBackground(token);\n                service.dispose();\n                const infoMessage = `Type stub was successfully created for '${importName}'.`;\n                this._ls.window.showInformationMessage(infoMessage);\n                this._handlePostCreateTypeStub();\n            } catch (err) {\n                const isCancellation = OperationCanceledException.is(err);\n                if (isCancellation) {\n                    const errMessage = `Type stub creation for '${importName}' was canceled`;\n                    this._ls.console.error(errMessage);\n                } else {\n                    let errMessage = '';\n                    if (err instanceof Error) {\n                        errMessage = ': ' + err.message;\n                    }\n                    errMessage = `An error occurred when creating type stub for '${importName}'` + errMessage;\n                    this._ls.console.error(errMessage);\n                    this._ls.window.showErrorMessage(errMessage);\n                }\n            }\n        }\n    }\n\n    // Creates a service instance that's used for creating type\n    // stubs for a specified target library.\n    private async _createTypeStubService(callingFile?: string): Promise<AnalyzerService> {\n        if (callingFile) {\n            // this should let us to inherit all execution env of the calling file\n            // if it is invoked from IDE through code action\n            const workspace = await this._ls.getWorkspaceForFile(callingFile);\n\n            // new service has its own background analysis running on its own thread\n            // to not block main bg running background analysis\n            return workspace.serviceInstance.clone('Type stub', this._ls.createBackgroundAnalysis());\n        }\n\n        return new AnalyzerService('Type stub', this._ls.fs, this._ls.console);\n    }\n\n    private _handlePostCreateTypeStub() {\n        this._ls.reanalyze();\n    }\n}\n","/*\n * quickActionCommand.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * Implements command that maps to a quick action.\n */\n\nimport { CancellationToken, ExecuteCommandParams } from 'vscode-languageserver';\n\nimport { convertUriToPath } from '../common/pathUtils';\nimport { convertTextEdits } from '../common/textEditUtils';\nimport { LanguageServerInterface } from '../languageServerBase';\nimport { ServerCommand } from './commandController';\nimport { Commands } from './commands';\n\nexport class QuickActionCommand implements ServerCommand {\n    constructor(private _ls: LanguageServerInterface) {}\n\n    async execute(params: ExecuteCommandParams, token: CancellationToken): Promise<any> {\n        if (params.arguments && params.arguments.length >= 1) {\n            const docUri = params.arguments[0];\n            const otherArgs = params.arguments.slice(1);\n            const filePath = convertUriToPath(docUri);\n            const workspace = await this._ls.getWorkspaceForFile(filePath);\n\n            if (params.command === Commands.orderImports && workspace.disableOrganizeImports) {\n                return [];\n            }\n\n            const editActions = workspace.serviceInstance.performQuickAction(\n                filePath,\n                params.command,\n                otherArgs,\n                token\n            );\n\n            return convertTextEdits(docUri, editActions);\n        }\n    }\n}\n","/*\n * restartServer.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * Implements 'restart server' command functionality.\n */\n\nimport { ExecuteCommandParams } from 'vscode-languageserver';\n\nimport { LanguageServerInterface } from '../languageServerBase';\nimport { ServerCommand } from './commandController';\n\nexport class RestartServerCommand implements ServerCommand {\n    constructor(private _ls: LanguageServerInterface) {}\n\n    async execute(cmdParams: ExecuteCommandParams): Promise<any> {\n        this._ls.restart();\n    }\n}\n","/*\n * cancellationUtils.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * Helper methods relating to cancellation.\n */\n\nimport * as fs from 'fs';\nimport * as os from 'os';\nimport * as path from 'path';\nimport { CancellationId, CancellationTokenSource } from 'vscode-jsonrpc';\nimport {\n    AbstractCancellationTokenSource,\n    CancellationReceiverStrategy,\n    CancellationSenderStrategy,\n    CancellationStrategy,\n    CancellationToken,\n    Disposable,\n    Emitter,\n    ErrorCodes,\n    Event,\n    ResponseError,\n} from 'vscode-languageserver';\n\nclass CancellationThrottle {\n    private static _lastCheckTimestamp = 0;\n\n    static shouldCheck() {\n        // Throttle cancellation checks to one every 5ms. This value\n        // was selected through empirical testing. If we call the\n        // file system more often than this, type analysis performance\n        // is affected. If we call it less often, performance doesn't\n        // improve much, but responsiveness suffers.\n        const minTimeBetweenChecksInMs = 5;\n        const curTimestamp = Date.now().valueOf();\n        const timeSinceLastCheck = curTimestamp - this._lastCheckTimestamp;\n\n        if (timeSinceLastCheck >= minTimeBetweenChecksInMs) {\n            this._lastCheckTimestamp = curTimestamp;\n            return true;\n        }\n\n        return false;\n    }\n}\n\nclass FileBasedToken implements CancellationToken {\n    protected isCancelled = false;\n    private _emitter: Emitter<any> | undefined;\n\n    constructor(readonly cancellationFilePath: string) {}\n\n    public cancel() {\n        if (!this.isCancelled) {\n            this.isCancelled = true;\n            if (this._emitter) {\n                this._emitter.fire(undefined);\n                this._disposeEmitter();\n            }\n        }\n    }\n\n    get isCancellationRequested(): boolean {\n        if (this.isCancelled) {\n            return true;\n        }\n\n        if (CancellationThrottle.shouldCheck() && this._pipeExists()) {\n            // The first time it encounters the cancellation file, it will\n            // cancel itself and raise a cancellation event.\n            // In this mode, cancel() might not be called explicitly by\n            // jsonrpc layer.\n            this.cancel();\n        }\n\n        return this.isCancelled;\n    }\n\n    get onCancellationRequested(): Event<any> {\n        if (!this._emitter) {\n            this._emitter = new Emitter<any>();\n        }\n        return this._emitter.event;\n    }\n\n    public dispose(): void {\n        this._disposeEmitter();\n    }\n\n    private _disposeEmitter() {\n        if (this._emitter) {\n            this._emitter.dispose();\n            this._emitter = undefined;\n        }\n    }\n\n    private _pipeExists(): boolean {\n        try {\n            fs.statSync(this.cancellationFilePath);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n}\n\nclass OwningFileToken extends FileBasedToken {\n    private _disposed = false;\n\n    constructor(cancellationFilePath: string) {\n        super(cancellationFilePath);\n    }\n\n    public cancel() {\n        if (!this._disposed && !this.isCancelled) {\n            this._createPipe();\n            super.cancel();\n        }\n    }\n\n    get isCancellationRequested(): boolean {\n        // Since this object owns the file and it gets created when the\n        // token is cancelled, there's no point in checking the pipe.\n        return this.isCancelled;\n    }\n\n    public dispose(): void {\n        this._disposed = true;\n\n        super.dispose();\n        this._removePipe();\n    }\n\n    private _createPipe() {\n        try {\n            fs.writeFileSync(this.cancellationFilePath, '', { flag: 'w' });\n        } catch {\n            // Ignore the exception.\n        }\n    }\n\n    private _removePipe() {\n        try {\n            fs.unlinkSync(this.cancellationFilePath);\n        } catch {\n            // Ignore the exception.\n        }\n    }\n}\n\nclass FileBasedCancellationTokenSource implements AbstractCancellationTokenSource {\n    private _token: CancellationToken | undefined;\n    constructor(private _cancellationFilePath: string, private _ownFile: boolean = false) {}\n\n    get token(): CancellationToken {\n        if (!this._token) {\n            // Be lazy and create the token only when actually needed.\n            this._token = this._ownFile\n                ? new OwningFileToken(this._cancellationFilePath)\n                : new FileBasedToken(this._cancellationFilePath);\n        }\n        return this._token;\n    }\n\n    cancel(): void {\n        if (!this._token) {\n            // Save an object by returning the default\n            // cancelled token when cancellation happens\n            // before someone asks for the token.\n            this._token = CancellationToken.Cancelled;\n        } else {\n            (this._token as FileBasedToken).cancel();\n        }\n    }\n\n    dispose(): void {\n        if (!this._token) {\n            // Make sure to initialize with an empty token if we had none.\n            this._token = CancellationToken.None;\n        } else if (this._token instanceof FileBasedToken) {\n            // Actually dispose.\n            this._token.dispose();\n        }\n    }\n}\n\nfunction getCancellationFolderPath(folderName: string) {\n    return path.join(os.tmpdir(), 'python-languageserver-cancellation', folderName);\n}\n\nfunction getCancellationFilePath(folderName: string, id: CancellationId) {\n    return path.join(getCancellationFolderPath(folderName), `cancellation-${String(id)}.tmp`);\n}\n\nclass FileCancellationReceiverStrategy implements CancellationReceiverStrategy {\n    constructor(readonly folderName: string) {}\n\n    createCancellationTokenSource(id: CancellationId): AbstractCancellationTokenSource {\n        return new FileBasedCancellationTokenSource(getCancellationFilePath(this.folderName, id));\n    }\n}\n\nexport class OperationCanceledException extends ResponseError<void> {\n    constructor() {\n        super(ErrorCodes.RequestCancelled, 'request cancelled');\n    }\n\n    static is(e: any) {\n        return e.code === ErrorCodes.RequestCancelled;\n    }\n}\n\nexport function throwIfCancellationRequested(token: CancellationToken) {\n    if (token.isCancellationRequested) {\n        throw new OperationCanceledException();\n    }\n}\n\nlet cancellationFolderName: string | undefined;\n\nexport function getCancellationFolderName() {\n    return cancellationFolderName;\n}\n\nexport function setCancellationFolderName(folderName?: string) {\n    cancellationFolderName = folderName;\n}\n\nexport function getCancellationStrategyFromArgv(argv: string[]): CancellationStrategy {\n    let receiver: CancellationReceiverStrategy | undefined;\n\n    for (let i = 0; i < argv.length; i++) {\n        const arg = argv[i];\n        if (arg === '--cancellationReceive') {\n            receiver = createReceiverStrategyFromArgv(argv[i + 1]);\n        } else {\n            const args = arg.split('=');\n            if (args[0] === '--cancellationReceive') {\n                receiver = createReceiverStrategyFromArgv(args[1]);\n            }\n        }\n    }\n\n    if (receiver && !cancellationFolderName) {\n        setCancellationFolderName((receiver as FileCancellationReceiverStrategy).folderName);\n    }\n\n    receiver = receiver ? receiver : CancellationReceiverStrategy.Message;\n    return { receiver, sender: CancellationSenderStrategy.Message };\n\n    function createReceiverStrategyFromArgv(arg: string): CancellationReceiverStrategy | undefined {\n        const folderName = extractCancellationFolderName(arg);\n        return folderName ? new FileCancellationReceiverStrategy(folderName) : undefined;\n    }\n\n    function extractCancellationFolderName(arg: string): string | undefined {\n        const fileRegex = /^file:(.+)$/;\n        const folderName = arg.match(fileRegex);\n        return folderName ? folderName[1] : undefined;\n    }\n}\n\nlet cancellationSourceId = 0;\nexport function createBackgroundThreadCancellationTokenSource(): AbstractCancellationTokenSource {\n    if (!cancellationFolderName) {\n        // File-based cancellation is not used.\n        // Return regular cancellation token source.\n        return new CancellationTokenSource();\n    }\n\n    return new FileBasedCancellationTokenSource(\n        getCancellationFilePath(cancellationFolderName, `source-${String(cancellationSourceId++)}`),\n        true\n    );\n}\n\nexport function disposeCancellationToken(token: CancellationToken) {\n    if (token instanceof FileBasedToken) {\n        token.dispose();\n    }\n}\n\nexport function getCancellationTokenFromId(cancellationId: string) {\n    if (!cancellationId) {\n        return CancellationToken.None;\n    }\n\n    return new FileBasedToken(cancellationId);\n}\n\nexport function getCancellationTokenId(token: CancellationToken) {\n    return token instanceof FileBasedToken ? token.cancellationFilePath : undefined;\n}\n\nexport function CancelAfter(...tokens: CancellationToken[]) {\n    const source = new CancellationTokenSource();\n    const disposables: Disposable[] = [];\n\n    for (const token of tokens) {\n        disposables.push(\n            token.onCancellationRequested((_) => {\n                source.cancel();\n            })\n        );\n    }\n\n    disposables.push(\n        source.token.onCancellationRequested((_) => {\n            disposables.forEach((d) => d.dispose());\n        })\n    );\n\n    return source;\n}\n","/*\n * collectionUtils.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * Helper functions relating to collections and arrays.\n */\n\nimport { compareValues, Comparison, equateValues, isArray } from './core';\n\nexport const emptyArray: never[] = [] as never[];\nexport type EqualityComparer<T> = (a: T, b: T) => boolean;\n\nexport function contains<T>(\n    array: readonly T[] | undefined,\n    value: T,\n    equalityComparer: EqualityComparer<T> = equateValues\n): boolean {\n    if (array) {\n        for (const v of array) {\n            if (equalityComparer(v, value)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n/** Array that is only intended to be pushed to, never read. */\nexport interface Push<T> {\n    push(...values: T[]): void;\n}\n\n/**\n * Appends a value to an array, returning the array.\n *\n * @param to The array to which `value` is to be appended. If `to` is `undefined`, a new array\n * is created if `value` was appended.\n * @param value The value to append to the array. If `value` is `undefined`, nothing is\n * appended.\n */\nexport function append<TArray extends any[] | undefined, TValue extends NonNullable<TArray>[number] | undefined>(\n    to: TArray,\n    value: TValue\n): [undefined, undefined] extends [TArray, TValue] ? TArray : NonNullable<TArray>[number][];\nexport function append<T>(to: T[], value: T | undefined): T[];\nexport function append<T>(to: T[] | undefined, value: T): T[];\nexport function append<T>(to: T[] | undefined, value: T | undefined): T[] | undefined;\nexport function append<T>(to: T[] | undefined, value: T | undefined): T[] | undefined {\n    if (value === undefined) {\n        return to;\n    }\n    if (to === undefined) {\n        return [value];\n    }\n    to.push(value);\n    return to;\n}\n\n/** Works like Array.prototype.find, returning `undefined` if no element satisfying the predicate is found. */\nexport function find<T, U extends T>(\n    array: readonly T[],\n    predicate: (element: T, index: number) => element is U\n): U | undefined;\nexport function find<T>(array: readonly T[], predicate: (element: T, index: number) => boolean): T | undefined;\nexport function find<T>(array: readonly T[], predicate: (element: T, index: number) => boolean): T | undefined {\n    for (let i = 0; i < array.length; i++) {\n        const value = array[i];\n        if (predicate(value, i)) {\n            return value;\n        }\n    }\n    return undefined;\n}\n\n/**\n * Gets the actual offset into an array for a relative offset. Negative offsets indicate a\n * position offset from the end of the array.\n */\nfunction toOffset(array: readonly any[], offset: number) {\n    return offset < 0 ? array.length + offset : offset;\n}\n\n/**\n * Appends a range of value to an array, returning the array.\n *\n * @param to The array to which `value` is to be appended. If `to` is `undefined`, a new array\n * is created if `value` was appended.\n * @param from The values to append to the array. If `from` is `undefined`, nothing is\n * appended. If an element of `from` is `undefined`, that element is not appended.\n * @param start The offset in `from` at which to start copying values.\n * @param end The offset in `from` at which to stop copying values (non-inclusive).\n */\nexport function addRange<T>(to: T[], from: readonly T[] | undefined, start?: number, end?: number): T[];\nexport function addRange<T>(\n    to: T[] | undefined,\n    from: readonly T[] | undefined,\n    start?: number,\n    end?: number\n): T[] | undefined;\nexport function addRange<T>(\n    to: T[] | undefined,\n    from: readonly T[] | undefined,\n    start?: number,\n    end?: number\n): T[] | undefined {\n    if (from === undefined || from.length === 0) {\n        return to;\n    }\n    if (to === undefined) {\n        return from.slice(start, end);\n    }\n    start = start === undefined ? 0 : toOffset(from, start);\n    end = end === undefined ? from.length : toOffset(from, end);\n    for (let i = start; i < end && i < from.length; i++) {\n        if (from[i] !== undefined) {\n            to.push(from[i]);\n        }\n    }\n    return to;\n}\n\nexport function insertAt<T>(array: T[], index: number, value: T) {\n    if (index === 0) {\n        array.unshift(value);\n    } else if (index === array.length) {\n        array.push(value);\n    } else {\n        for (let i = array.length; i > index; i--) {\n            array[i] = array[i - 1];\n        }\n        array[index] = value;\n    }\n    return array;\n}\n\nexport type Comparer<T> = (a: T, b: T) => Comparison;\n\nexport interface SortedReadonlyArray<T> extends ReadonlyArray<T> {\n    ' __sortedArrayBrand': any;\n}\n\nexport interface SortedArray<T> extends Array<T> {\n    ' __sortedArrayBrand': any;\n}\n\n/**\n * Returns a new sorted array.\n */\nexport function cloneAndSort<T>(array: readonly T[], comparer?: Comparer<T>): SortedReadonlyArray<T> {\n    return (array.length === 0 ? array : array.slice().sort(comparer)) as SortedReadonlyArray<T>;\n}\n\nfunction selectIndex(_: unknown, i: number) {\n    return i;\n}\n\nfunction indicesOf(array: readonly unknown[]): number[] {\n    return array.map(selectIndex);\n}\n\n/**\n * Stable sort of an array. Elements equal to each other maintain their relative position in the array.\n */\nexport function stableSort<T>(array: readonly T[], comparer: Comparer<T>): SortedReadonlyArray<T> {\n    const indices = indicesOf(array);\n    stableSortIndices(array, indices, comparer);\n    return (indices.map((i) => array[i]) as SortedArray<T>) as SortedReadonlyArray<T>;\n}\n\nfunction stableSortIndices<T>(array: readonly T[], indices: number[], comparer: Comparer<T>) {\n    // sort indices by value then position\n    indices.sort((x, y) => comparer(array[x], array[y]) || compareValues(x, y));\n}\n\nexport function map<T, U>(array: readonly T[], f: (x: T, i: number) => U): U[];\nexport function map<T, U>(array: readonly T[] | undefined, f: (x: T, i: number) => U): U[] | undefined;\nexport function map<T, U>(array: readonly T[] | undefined, f: (x: T, i: number) => U): U[] | undefined {\n    if (array) {\n        return array.map(f);\n    }\n    return undefined;\n}\n\nexport function some<T>(array: readonly T[] | undefined): array is readonly T[];\nexport function some<T>(array: readonly T[] | undefined, predicate: (value: T) => boolean): boolean;\nexport function some<T>(array: readonly T[] | undefined, predicate?: (value: T) => boolean): boolean {\n    if (array) {\n        if (predicate) {\n            return array.some(predicate);\n        } else {\n            return array.length > 0;\n        }\n    }\n    return false;\n}\n\n/**\n * Iterates through `array` by index and performs the callback on each element of array until the callback\n * returns a falsey value, then returns false.\n * If no such value is found, the callback is applied to each element of array and `true` is returned.\n */\nexport function every<T>(array: readonly T[], callback: (element: T, index: number) => boolean): boolean {\n    if (array) {\n        return array.every(callback);\n    }\n\n    return true;\n}\n\n/**\n * Performs a binary search, finding the index at which `value` occurs in `array`.\n * If no such index is found, returns the 2's-complement of first index at which\n * `array[index]` exceeds `value`.\n * @param array A sorted array whose first element must be no larger than number\n * @param value The value to be searched for in the array.\n * @param keySelector A callback used to select the search key from `value` and each element of\n * `array`.\n * @param keyComparer A callback used to compare two keys in a sorted array.\n * @param offset An offset into `array` at which to start the search.\n */\nexport function binarySearch<T, U>(\n    array: readonly T[],\n    value: T,\n    keySelector: (v: T) => U,\n    keyComparer: Comparer<U>,\n    offset?: number\n): number {\n    return binarySearchKey(array, keySelector(value), keySelector, keyComparer, offset);\n}\n\n/**\n * Performs a binary search, finding the index at which an object with `key` occurs in `array`.\n * If no such index is found, returns the 2's-complement of first index at which\n * `array[index]` exceeds `key`.\n * @param array A sorted array whose first element must be no larger than number\n * @param key The key to be searched for in the array.\n * @param keySelector A callback used to select the search key from each element of `array`.\n * @param keyComparer A callback used to compare two keys in a sorted array.\n * @param offset An offset into `array` at which to start the search.\n */\nexport function binarySearchKey<T, U>(\n    array: readonly T[],\n    key: U,\n    keySelector: (v: T) => U,\n    keyComparer: Comparer<U>,\n    offset?: number\n): number {\n    if (!some(array)) {\n        return -1;\n    }\n\n    let low = offset || 0;\n    let high = array.length - 1;\n    while (low <= high) {\n        const middle = low + ((high - low) >> 1);\n        const midKey = keySelector(array[middle]);\n        switch (keyComparer(midKey, key)) {\n            case Comparison.LessThan:\n                low = middle + 1;\n                break;\n            case Comparison.EqualTo:\n                return middle;\n            case Comparison.GreaterThan:\n                high = middle - 1;\n                break;\n        }\n    }\n\n    return ~low;\n}\n\n/**\n * Flattens an array containing a mix of array or non-array elements.\n *\n * @param array The array to flatten.\n */\nexport function flatten<T>(array: T[][] | readonly (T | readonly T[] | undefined)[]): T[] {\n    const result = [];\n    for (const v of array) {\n        if (v) {\n            if (isArray(v)) {\n                addRange(result, v);\n            } else {\n                result.push(v);\n            }\n        }\n    }\n    return result;\n}\n\n/**\n * Retrieves nested objects by parsing chained properties. ie. \"a.b.c\"\n * Returns undefined if not found\n * @param object The object to query\n * @param property The property to be searched for in the object ie. \"a.b.c\"\n */\nexport function getNestedProperty(object: any, property: string) {\n    const value = property.split('.').reduce((obj, prop) => {\n        return obj && obj[prop];\n    }, object);\n    return value;\n}\n","/*\n * commandLineOptions.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Class that holds the command-line options (those that can be\n * passed into the main entry point of the command-line version\n * of the analyzer).\n */\n\nexport const enum DiagnosticSeverityOverrides {\n    Error = 'error',\n    Warning = 'warning',\n    Information = 'information',\n    None = 'none',\n}\n\nexport function getDiagnosticSeverityOverrides() {\n    return [\n        DiagnosticSeverityOverrides.Error,\n        DiagnosticSeverityOverrides.Warning,\n        DiagnosticSeverityOverrides.Information,\n        DiagnosticSeverityOverrides.None,\n    ];\n}\n\nexport type DiagnosticSeverityOverridesMap = { [ruleName: string]: DiagnosticSeverityOverrides };\n\n// Some options can be specified from a source other than the pyright config file.\n// This can be from command-line parameters or some other settings mechanism, like\n// that provided through a language client like the VS Code editor. These options\n// are later combined with those from the config file to produce the final configuration.\nexport class CommandLineOptions {\n    constructor(executionRoot: string, fromVsCodeExtension: boolean) {\n        this.executionRoot = executionRoot;\n        this.fromVsCodeExtension = fromVsCodeExtension;\n    }\n\n    // A list of file specs to include in the analysis. Can contain\n    // directories, in which case all \"*.py\" files within those directories\n    // are included.\n    fileSpecs: string[] = [];\n\n    // Watch for changes in workspace source files.\n    watchForSourceChanges?: boolean;\n\n    // Watch for changes in environment library/search paths.\n    watchForLibraryChanges?: boolean;\n\n    // Path of config file. This option cannot be combined with\n    // file specs.\n    configFilePath?: string;\n\n    // Virtual environments directory.\n    venvPath?: string;\n\n    // Path to python interpreter.\n    pythonPath?: string;\n\n    // Path of typeshed stubs.\n    typeshedPath?: string;\n\n    // Path of typing folder\n    stubPath?: string;\n\n    // Absolute execution root (current working directory).\n    executionRoot: string;\n\n    // Type stub import target (for creation of type stubs).\n    typeStubTargetImportName?: string;\n\n    // Emit verbose information to console?\n    verboseOutput?: boolean;\n\n    // Indicates that only open files should be checked.\n    checkOnlyOpenFiles?: boolean;\n\n    // In the absence of type stubs, use library implementations\n    // to extract type information?\n    useLibraryCodeForTypes?: boolean;\n\n    // Look for a common root folders such as 'src' and automatically\n    // add them as extra paths if the user has not explicitly defined\n    // execution environments.\n    autoSearchPaths?: boolean;\n\n    // Extra paths to add to the default execution environment\n    // when user has not explicitly defined execution environments.\n    extraPaths?: string[];\n\n    // Default type-checking rule set. Should be one of 'off',\n    // 'basic', or 'strict'.\n    typeCheckingMode?: string;\n\n    // Indicates that the settings came from VS Code rather than\n    // from the command-line. Useful for providing clearer error\n    // messages.\n    fromVsCodeExtension: boolean;\n\n    // Indicates diagnostic severity overrides\n    diagnosticSeverityOverrides?: DiagnosticSeverityOverridesMap;\n\n    // Offer auto-import completions.\n    autoImportCompletions?: boolean;\n\n    // Use indexing.\n    indexing?: boolean;\n}\n","/*\n * configOptions.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Class that holds the configuration options for the analyzer.\n */\n\nimport * as child_process from 'child_process';\nimport { isAbsolute } from 'path';\n\nimport * as pathConsts from '../common/pathConsts';\nimport { DiagnosticSeverityOverridesMap } from './commandLineOptions';\nimport { ConsoleInterface } from './console';\nimport { DiagnosticRule } from './diagnosticRules';\nimport { FileSystem } from './fileSystem';\nimport { combinePaths, ensureTrailingDirectorySeparator, FileSpec, getFileSpec, normalizePath } from './pathUtils';\nimport {\n    latestStablePythonVersion,\n    PythonVersion,\n    versionFromMajorMinor,\n    versionFromString,\n    versionToString,\n} from './pythonVersion';\n\nexport class ExecutionEnvironment {\n    // Default to \".\" which indicates every file in the project.\n    constructor(root: string, defaultPythonVersion?: PythonVersion, defaultPythonPlatform?: string) {\n        this.root = root;\n        this.pythonVersion = defaultPythonVersion || latestStablePythonVersion;\n        this.pythonPlatform = defaultPythonPlatform;\n    }\n\n    // Root directory for execution - absolute or relative to the\n    // project root.\n    root: string;\n\n    // Always default to the latest stable version of the language.\n    pythonVersion: PythonVersion;\n\n    // Default to no platform.\n    pythonPlatform?: string;\n\n    // Default to no extra paths.\n    extraPaths: string[] = [];\n\n    // Name of virtual environment to use.\n    venv?: string;\n}\n\nexport type DiagnosticLevel = 'none' | 'information' | 'warning' | 'error';\n\nexport interface DiagnosticRuleSet {\n    // Should \"Unknown\" types be reported as \"Any\"?\n    printUnknownAsAny: boolean;\n\n    // Should type arguments to a generic class be omitted\n    // when printed if all arguments are Unknown or Any?\n    omitTypeArgsIfAny: boolean;\n\n    // Should parameter type be omitted if it is not annotated?\n    omitUnannotatedParamType: boolean;\n\n    // Should Union and Optional types be printed in PEP 604 format?\n    pep604Printing: boolean;\n\n    // Use strict inference rules for list expressions?\n    strictListInference: boolean;\n\n    // Use strict inference rules for dictionary expressions?\n    strictDictionaryInference: boolean;\n\n    // Use strict type rules for parameters assigned default of None?\n    strictParameterNoneValue: boolean;\n\n    // Enable support for type: ignore comments?\n    enableTypeIgnoreComments: boolean;\n\n    // Report general type issues?\n    reportGeneralTypeIssues: DiagnosticLevel;\n\n    // Report mismatch in types between property getter and setter?\n    reportPropertyTypeMismatch: DiagnosticLevel;\n\n    // Report missing imports?\n    reportMissingImports: DiagnosticLevel;\n\n    // Report missing imported module source files?\n    reportMissingModuleSource: DiagnosticLevel;\n\n    // Report missing type stub files?\n    reportMissingTypeStubs: DiagnosticLevel;\n\n    // Report cycles in import graph?\n    reportImportCycles: DiagnosticLevel;\n\n    // Report imported symbol that is not accessed?\n    reportUnusedImport: DiagnosticLevel;\n\n    // Report private class that is not accessed?\n    reportUnusedClass: DiagnosticLevel;\n\n    // Report private function or method that is not accessed?\n    reportUnusedFunction: DiagnosticLevel;\n\n    // Report variable that is not accessed?\n    reportUnusedVariable: DiagnosticLevel;\n\n    // Report symbol or module that is imported more than once?\n    reportDuplicateImport: DiagnosticLevel;\n\n    // Report use of wildcard import for non-local imports?\n    reportWildcardImportFromLibrary: DiagnosticLevel;\n\n    // Report attempts to subscript (index) an Optional type?\n    reportOptionalSubscript: DiagnosticLevel;\n\n    // Report attempts to access members on a Optional type?\n    reportOptionalMemberAccess: DiagnosticLevel;\n\n    // Report attempts to call a Optional type?\n    reportOptionalCall: DiagnosticLevel;\n\n    // Report attempts to use an Optional type as an iterable?\n    reportOptionalIterable: DiagnosticLevel;\n\n    // Report attempts to use an Optional type in a \"with\" statement?\n    reportOptionalContextManager: DiagnosticLevel;\n\n    // Report attempts to use an Optional type in a binary or unary operation.\n    reportOptionalOperand: DiagnosticLevel;\n\n    // Report untyped function decorators that obscure the function type?\n    reportUntypedFunctionDecorator: DiagnosticLevel;\n\n    // Report untyped class decorators that obscure the class type?\n    reportUntypedClassDecorator: DiagnosticLevel;\n\n    // Report untyped base class that obscure the class type?\n    reportUntypedBaseClass: DiagnosticLevel;\n\n    // Report use of untyped namedtuple factory method?\n    reportUntypedNamedTuple: DiagnosticLevel;\n\n    // Report usage of private variables and functions outside of\n    // the owning class or module?\n    reportPrivateUsage: DiagnosticLevel;\n\n    // Report attempts to redefine variables that are in all-caps.\n    reportConstantRedefinition: DiagnosticLevel;\n\n    // Report usage of method override that is incompatible with\n    // the base class method of the same name?\n    reportIncompatibleMethodOverride: DiagnosticLevel;\n\n    // Report usage of variable override that is incompatible with\n    // the base class symbol of the same name?\n    reportIncompatibleVariableOverride: DiagnosticLevel;\n\n    // Report usage of invalid escape sequences in string literals?\n    reportInvalidStringEscapeSequence: DiagnosticLevel;\n\n    // Report usage of unknown input or return parameters for functions?\n    reportUnknownParameterType: DiagnosticLevel;\n\n    // Report usage of unknown arguments for function calls?\n    reportUnknownArgumentType: DiagnosticLevel;\n\n    // Report usage of unknown input or return parameters for lambdas?\n    reportUnknownLambdaType: DiagnosticLevel;\n\n    // Report usage of unknown input or return parameters?\n    reportUnknownVariableType: DiagnosticLevel;\n\n    // Report usage of unknown input or return parameters?\n    reportUnknownMemberType: DiagnosticLevel;\n\n    // Report usage of generic class without explicit type arguments?\n    reportMissingTypeArgument: DiagnosticLevel;\n\n    // Report usage of function call within default value\n    // initialization expression?\n    reportCallInDefaultInitializer: DiagnosticLevel;\n\n    // Report calls to isinstance or issubclass that are statically determined\n    // to always be true or false.\n    reportUnnecessaryIsInstance: DiagnosticLevel;\n\n    // Report calls to cast that are statically determined\n    // to always unnecessary.\n    reportUnnecessaryCast: DiagnosticLevel;\n\n    // Report assert expressions that will always evaluate to true.\n    reportAssertAlwaysTrue: DiagnosticLevel;\n\n    // Report when \"self\" or \"cls\" parameter is missing or is misnamed.\n    reportSelfClsParameterName: DiagnosticLevel;\n\n    // Report implicit concatenation of string literals.\n    reportImplicitStringConcatenation: DiagnosticLevel;\n\n    // Report usage of undefined variables.\n    reportUndefinedVariable: DiagnosticLevel;\n\n    // Report usage of unbound or possibly unbound variables.\n    reportUnboundVariable: DiagnosticLevel;\n\n    // Report statements that are syntactically correct but\n    // have no semantic meaning within a type stub file.\n    reportInvalidStubStatement: DiagnosticLevel;\n}\n\nexport function cloneDiagnosticRuleSet(diagSettings: DiagnosticRuleSet): DiagnosticRuleSet {\n    // Create a shallow copy of the existing object.\n    return Object.assign({}, diagSettings);\n}\n\nexport function getBooleanDiagnosticRules() {\n    return [\n        DiagnosticRule.strictListInference,\n        DiagnosticRule.strictDictionaryInference,\n        DiagnosticRule.strictParameterNoneValue,\n\n        // Do not include this this one because we don't\n        // want to override it in strict mode or support\n        // it within pyright comments.\n        // DiagnosticRule.enableTypeIgnoreComments\n    ];\n}\n\nexport function getDiagLevelDiagnosticRules() {\n    return [\n        DiagnosticRule.reportGeneralTypeIssues,\n        DiagnosticRule.reportPropertyTypeMismatch,\n        DiagnosticRule.reportMissingImports,\n        DiagnosticRule.reportMissingModuleSource,\n        DiagnosticRule.reportMissingTypeStubs,\n        DiagnosticRule.reportImportCycles,\n        DiagnosticRule.reportUnusedImport,\n        DiagnosticRule.reportUnusedClass,\n        DiagnosticRule.reportUnusedFunction,\n        DiagnosticRule.reportUnusedVariable,\n        DiagnosticRule.reportDuplicateImport,\n        DiagnosticRule.reportWildcardImportFromLibrary,\n        DiagnosticRule.reportOptionalSubscript,\n        DiagnosticRule.reportOptionalMemberAccess,\n        DiagnosticRule.reportOptionalCall,\n        DiagnosticRule.reportOptionalIterable,\n        DiagnosticRule.reportOptionalContextManager,\n        DiagnosticRule.reportOptionalOperand,\n        DiagnosticRule.reportUntypedFunctionDecorator,\n        DiagnosticRule.reportUntypedClassDecorator,\n        DiagnosticRule.reportUntypedBaseClass,\n        DiagnosticRule.reportUntypedNamedTuple,\n        DiagnosticRule.reportPrivateUsage,\n        DiagnosticRule.reportConstantRedefinition,\n        DiagnosticRule.reportIncompatibleMethodOverride,\n        DiagnosticRule.reportIncompatibleVariableOverride,\n        DiagnosticRule.reportInvalidStringEscapeSequence,\n        DiagnosticRule.reportUnknownParameterType,\n        DiagnosticRule.reportUnknownArgumentType,\n        DiagnosticRule.reportUnknownLambdaType,\n        DiagnosticRule.reportUnknownVariableType,\n        DiagnosticRule.reportUnknownMemberType,\n        DiagnosticRule.reportMissingTypeArgument,\n        DiagnosticRule.reportCallInDefaultInitializer,\n        DiagnosticRule.reportUnnecessaryIsInstance,\n        DiagnosticRule.reportUnnecessaryCast,\n        DiagnosticRule.reportAssertAlwaysTrue,\n        DiagnosticRule.reportSelfClsParameterName,\n        DiagnosticRule.reportImplicitStringConcatenation,\n        DiagnosticRule.reportUndefinedVariable,\n        DiagnosticRule.reportUnboundVariable,\n        DiagnosticRule.reportInvalidStubStatement,\n    ];\n}\n\nexport function getStrictModeNotOverriddenRules() {\n    // In strict mode, the value in the user config file should be honored and\n    // not overwritten by the value from the strict rule set.\n    return [DiagnosticRule.reportMissingModuleSource];\n}\n\nexport function getOffDiagnosticRuleSet(): DiagnosticRuleSet {\n    const diagSettings: DiagnosticRuleSet = {\n        printUnknownAsAny: true,\n        omitTypeArgsIfAny: true,\n        omitUnannotatedParamType: true,\n        pep604Printing: true,\n        strictListInference: false,\n        strictDictionaryInference: false,\n        strictParameterNoneValue: false,\n        enableTypeIgnoreComments: true,\n        reportGeneralTypeIssues: 'none',\n        reportPropertyTypeMismatch: 'none',\n        reportMissingImports: 'warning',\n        reportMissingModuleSource: 'warning',\n        reportMissingTypeStubs: 'none',\n        reportImportCycles: 'none',\n        reportUnusedImport: 'none',\n        reportUnusedClass: 'none',\n        reportUnusedFunction: 'none',\n        reportUnusedVariable: 'none',\n        reportDuplicateImport: 'none',\n        reportWildcardImportFromLibrary: 'none',\n        reportOptionalSubscript: 'none',\n        reportOptionalMemberAccess: 'none',\n        reportOptionalCall: 'none',\n        reportOptionalIterable: 'none',\n        reportOptionalContextManager: 'none',\n        reportOptionalOperand: 'none',\n        reportUntypedFunctionDecorator: 'none',\n        reportUntypedClassDecorator: 'none',\n        reportUntypedBaseClass: 'none',\n        reportUntypedNamedTuple: 'none',\n        reportPrivateUsage: 'none',\n        reportConstantRedefinition: 'none',\n        reportIncompatibleMethodOverride: 'none',\n        reportIncompatibleVariableOverride: 'none',\n        reportInvalidStringEscapeSequence: 'none',\n        reportUnknownParameterType: 'none',\n        reportUnknownArgumentType: 'none',\n        reportUnknownLambdaType: 'none',\n        reportUnknownVariableType: 'none',\n        reportUnknownMemberType: 'none',\n        reportMissingTypeArgument: 'none',\n        reportCallInDefaultInitializer: 'none',\n        reportUnnecessaryIsInstance: 'none',\n        reportUnnecessaryCast: 'none',\n        reportAssertAlwaysTrue: 'none',\n        reportSelfClsParameterName: 'none',\n        reportImplicitStringConcatenation: 'none',\n        reportUnboundVariable: 'warning',\n        reportUndefinedVariable: 'warning',\n        reportInvalidStubStatement: 'none',\n    };\n\n    return diagSettings;\n}\n\nexport function getBasicDiagnosticRuleSet(): DiagnosticRuleSet {\n    const diagSettings: DiagnosticRuleSet = {\n        printUnknownAsAny: false,\n        omitTypeArgsIfAny: false,\n        omitUnannotatedParamType: true,\n        pep604Printing: true,\n        strictListInference: false,\n        strictDictionaryInference: false,\n        strictParameterNoneValue: false,\n        enableTypeIgnoreComments: true,\n        reportGeneralTypeIssues: 'error',\n        reportPropertyTypeMismatch: 'error',\n        reportMissingImports: 'error',\n        reportMissingModuleSource: 'warning',\n        reportMissingTypeStubs: 'none',\n        reportImportCycles: 'none',\n        reportUnusedImport: 'none',\n        reportUnusedClass: 'none',\n        reportUnusedFunction: 'none',\n        reportUnusedVariable: 'none',\n        reportDuplicateImport: 'none',\n        reportWildcardImportFromLibrary: 'warning',\n        reportOptionalSubscript: 'none',\n        reportOptionalMemberAccess: 'none',\n        reportOptionalCall: 'none',\n        reportOptionalIterable: 'none',\n        reportOptionalContextManager: 'none',\n        reportOptionalOperand: 'none',\n        reportUntypedFunctionDecorator: 'none',\n        reportUntypedClassDecorator: 'none',\n        reportUntypedBaseClass: 'none',\n        reportUntypedNamedTuple: 'none',\n        reportPrivateUsage: 'none',\n        reportConstantRedefinition: 'none',\n        reportIncompatibleMethodOverride: 'none',\n        reportIncompatibleVariableOverride: 'none',\n        reportInvalidStringEscapeSequence: 'warning',\n        reportUnknownParameterType: 'none',\n        reportUnknownArgumentType: 'none',\n        reportUnknownLambdaType: 'none',\n        reportUnknownVariableType: 'none',\n        reportUnknownMemberType: 'none',\n        reportMissingTypeArgument: 'none',\n        reportCallInDefaultInitializer: 'none',\n        reportUnnecessaryIsInstance: 'none',\n        reportUnnecessaryCast: 'none',\n        reportAssertAlwaysTrue: 'warning',\n        reportSelfClsParameterName: 'warning',\n        reportImplicitStringConcatenation: 'none',\n        reportUnboundVariable: 'error',\n        reportUndefinedVariable: 'error',\n        reportInvalidStubStatement: 'none',\n    };\n\n    return diagSettings;\n}\n\nexport function getStrictDiagnosticRuleSet(): DiagnosticRuleSet {\n    const diagSettings: DiagnosticRuleSet = {\n        printUnknownAsAny: false,\n        omitTypeArgsIfAny: false,\n        omitUnannotatedParamType: false,\n        pep604Printing: true,\n        strictListInference: true,\n        strictDictionaryInference: true,\n        strictParameterNoneValue: true,\n        enableTypeIgnoreComments: true, // Not overridden by strict mode\n        reportGeneralTypeIssues: 'error',\n        reportPropertyTypeMismatch: 'error',\n        reportMissingImports: 'error',\n        reportMissingModuleSource: 'warning',\n        reportMissingTypeStubs: 'error',\n        reportImportCycles: 'error',\n        reportUnusedImport: 'error',\n        reportUnusedClass: 'error',\n        reportUnusedFunction: 'error',\n        reportUnusedVariable: 'error',\n        reportDuplicateImport: 'error',\n        reportWildcardImportFromLibrary: 'error',\n        reportOptionalSubscript: 'error',\n        reportOptionalMemberAccess: 'error',\n        reportOptionalCall: 'error',\n        reportOptionalIterable: 'error',\n        reportOptionalContextManager: 'error',\n        reportOptionalOperand: 'error',\n        reportUntypedFunctionDecorator: 'error',\n        reportUntypedClassDecorator: 'error',\n        reportUntypedBaseClass: 'error',\n        reportUntypedNamedTuple: 'error',\n        reportPrivateUsage: 'error',\n        reportConstantRedefinition: 'error',\n        reportIncompatibleMethodOverride: 'error',\n        reportIncompatibleVariableOverride: 'error',\n        reportInvalidStringEscapeSequence: 'error',\n        reportUnknownParameterType: 'error',\n        reportUnknownArgumentType: 'error',\n        reportUnknownLambdaType: 'error',\n        reportUnknownVariableType: 'error',\n        reportUnknownMemberType: 'error',\n        reportMissingTypeArgument: 'error',\n        reportCallInDefaultInitializer: 'none',\n        reportUnnecessaryIsInstance: 'error',\n        reportUnnecessaryCast: 'error',\n        reportAssertAlwaysTrue: 'error',\n        reportSelfClsParameterName: 'error',\n        reportImplicitStringConcatenation: 'none',\n        reportUnboundVariable: 'error',\n        reportUndefinedVariable: 'error',\n        reportInvalidStubStatement: 'error',\n    };\n\n    return diagSettings;\n}\n\n// Internal configuration options. These are derived from a combination\n// of the command line and from a JSON-based config file.\nexport class ConfigOptions {\n    constructor(projectRoot: string, typeCheckingMode?: string) {\n        this.projectRoot = projectRoot;\n        this.diagnosticRuleSet = ConfigOptions.getDiagnosticRuleSet(typeCheckingMode);\n\n        // If type checking mode is off, allow inference for py.typed sources\n        // since there is little or no downside and possible upside of discovering\n        // more type information in this case. If type checking is enabled, using\n        // type inference in this case can result in false positive errors.\n        if (typeCheckingMode === 'off') {\n            this.disableInferenceForPyTypedSources = false;\n        }\n    }\n\n    // Absolute directory of project. All relative paths in the config\n    // are based on this path.\n    projectRoot: string;\n\n    // Path to python interpreter.\n    pythonPath?: string;\n\n    // Path to use for typeshed definitions.\n    typeshedPath?: string;\n\n    // Path to custom typings (stub) modules.\n    stubPath?: string;\n\n    // A list of file specs to include in the analysis. Can contain\n    // directories, in which case all \"*.py\" files within those directories\n    // are included.\n    include: FileSpec[] = [];\n\n    // A list of file specs to exclude from the analysis (overriding include\n    // if necessary). Can contain directories, in which case all \"*.py\" files\n    // within those directories are included.\n    exclude: FileSpec[] = [];\n\n    // Automatically detect virtual environment folders and exclude them.\n    // This property is for internal use and not exposed externally\n    // as a config setting.\n    // It is used to store whether the user has specified directories in\n    // the exclude setting, which is later modified to include a default set.\n    // This setting is true when user has not specified any exclude.\n    autoExcludeVenv?: boolean;\n\n    // A list of file specs whose errors and warnings should be ignored even\n    // if they are included in the transitive closure of included files.\n    ignore: FileSpec[] = [];\n\n    // A list of file specs that should be analyzed using \"strict\" mode.\n    strict: FileSpec[] = [];\n\n    // Emit verbose information to console?\n    verboseOutput?: boolean;\n\n    // Perform type checking and report diagnostics only for open files?\n    checkOnlyOpenFiles?: boolean;\n\n    // In the absence of type stubs, use library implementations to extract\n    // type information?\n    useLibraryCodeForTypes?: boolean;\n\n    // Offer auto-import completions.\n    autoImportCompletions = true;\n\n    // Use indexing.\n    indexing = false;\n\n    // Avoid using type inferencing for files within packages that claim\n    // to contain type annotations?\n    disableInferenceForPyTypedSources = true;\n\n    //---------------------------------------------------------------\n    // Diagnostics Rule Set\n\n    diagnosticRuleSet: DiagnosticRuleSet;\n\n    //---------------------------------------------------------------\n    // Parsing and Import Resolution Settings\n\n    // Parameters that specify the execution environment for\n    // the files being analyzed.\n    executionEnvironments: ExecutionEnvironment[] = [];\n\n    // Path to a directory containing one or more virtual environment\n    // directories. This is used in conjunction with the \"venv\" name in\n    // the config file to identify the python environment used for resolving\n    // third-party modules.\n    venvPath?: string;\n\n    // Default venv environment. Can be overridden by executionEnvironment.\n    defaultVenv?: string;\n\n    // Default pythonVersion. Can be overridden by executionEnvironment.\n    defaultPythonVersion?: PythonVersion;\n\n    // Default pythonPlatform. Can be overridden by executionEnvironment.\n    defaultPythonPlatform?: string;\n\n    //---------------------------------------------------------------\n    // Internal-only switches\n\n    // Run additional analysis as part of test cases?\n    internalTestMode?: boolean;\n\n    static getDiagnosticRuleSet(typeCheckingMode?: string): DiagnosticRuleSet {\n        if (typeCheckingMode === 'strict') {\n            return getStrictDiagnosticRuleSet();\n        }\n\n        if (typeCheckingMode === 'off') {\n            return getOffDiagnosticRuleSet();\n        }\n\n        return getBasicDiagnosticRuleSet();\n    }\n\n    // Finds the best execution environment for a given file path. The\n    // specified file path should be absolute.\n    // If no matching execution environment can be found, a default\n    // execution environment is used.\n    findExecEnvironment(filePath: string): ExecutionEnvironment {\n        let execEnv = this.executionEnvironments.find((env) => {\n            const envRoot = ensureTrailingDirectorySeparator(normalizePath(combinePaths(this.projectRoot, env.root)));\n            return filePath.startsWith(envRoot);\n        });\n\n        if (!execEnv) {\n            execEnv = new ExecutionEnvironment(this.projectRoot, this.defaultPythonVersion, this.defaultPythonPlatform);\n        }\n\n        return execEnv;\n    }\n\n    getDefaultExecEnvironment(): ExecutionEnvironment {\n        return new ExecutionEnvironment(this.projectRoot, this.defaultPythonVersion, this.defaultPythonPlatform);\n    }\n\n    addExecEnvironmentForExtraPaths(fs: FileSystem, autoSearchPaths: boolean, extraPaths: string[]) {\n        const paths: string[] = [];\n\n        if (autoSearchPaths) {\n            // Auto-detect the common scenario where the sources are under the src folder\n            const srcPath = normalizePath(combinePaths(this.projectRoot, pathConsts.src));\n            if (fs.existsSync(srcPath) && !fs.existsSync(combinePaths(srcPath, '__init__.py'))) {\n                paths.push(srcPath);\n            }\n        }\n\n        if (extraPaths.length > 0) {\n            for (const p of extraPaths) {\n                paths.push(normalizePath(combinePaths(this.projectRoot, p)));\n            }\n        }\n\n        if (paths.length > 0) {\n            const execEnv = new ExecutionEnvironment(\n                this.projectRoot,\n                this.defaultPythonVersion,\n                this.defaultPythonPlatform\n            );\n\n            execEnv.extraPaths.push(...paths);\n\n            this.executionEnvironments.push(execEnv);\n        }\n    }\n\n    // Initialize the structure from a JSON object.\n    initializeFromJson(\n        configObj: any,\n        typeCheckingMode: string | undefined,\n        console: ConsoleInterface,\n        diagnosticOverrides?: DiagnosticSeverityOverridesMap,\n        pythonPath?: string,\n        skipIncludeSection = false\n    ) {\n        // Read the \"include\" entry.\n        if (!skipIncludeSection) {\n            this.include = [];\n            if (configObj.include !== undefined) {\n                if (!Array.isArray(configObj.include)) {\n                    console.error(`Config \"include\" entry must must contain an array.`);\n                } else {\n                    const filesList = configObj.include as string[];\n                    filesList.forEach((fileSpec, index) => {\n                        if (typeof fileSpec !== 'string') {\n                            console.error(`Index ${index} of \"include\" array should be a string.`);\n                        } else if (isAbsolute(fileSpec)) {\n                            console.error(`Ignoring path \"${fileSpec}\" in \"include\" array because it is not relative.`);\n                        } else {\n                            this.include.push(getFileSpec(this.projectRoot, fileSpec));\n                        }\n                    });\n                }\n            }\n        }\n\n        // Read the \"exclude\" entry.\n        this.exclude = [];\n        if (configObj.exclude !== undefined) {\n            if (!Array.isArray(configObj.exclude)) {\n                console.error(`Config \"exclude\" entry must contain an array.`);\n            } else {\n                const filesList = configObj.exclude as string[];\n                filesList.forEach((fileSpec, index) => {\n                    if (typeof fileSpec !== 'string') {\n                        console.error(`Index ${index} of \"exclude\" array should be a string.`);\n                    } else if (isAbsolute(fileSpec)) {\n                        console.error(`Ignoring path \"${fileSpec}\" in \"exclude\" array because it is not relative.`);\n                    } else {\n                        this.exclude.push(getFileSpec(this.projectRoot, fileSpec));\n                    }\n                });\n            }\n        }\n\n        // Read the \"ignore\" entry.\n        this.ignore = [];\n        if (configObj.ignore !== undefined) {\n            if (!Array.isArray(configObj.ignore)) {\n                console.error(`Config \"ignore\" entry must contain an array.`);\n            } else {\n                const filesList = configObj.ignore as string[];\n                filesList.forEach((fileSpec, index) => {\n                    if (typeof fileSpec !== 'string') {\n                        console.error(`Index ${index} of \"ignore\" array should be a string.`);\n                    } else if (isAbsolute(fileSpec)) {\n                        console.error(`Ignoring path \"${fileSpec}\" in \"ignore\" array because it is not relative.`);\n                    } else {\n                        this.ignore.push(getFileSpec(this.projectRoot, fileSpec));\n                    }\n                });\n            }\n        }\n\n        // Read the \"strict\" entry.\n        this.strict = [];\n        if (configObj.strict !== undefined) {\n            if (!Array.isArray(configObj.strict)) {\n                console.error(`Config \"strict\" entry must contain an array.`);\n            } else {\n                const filesList = configObj.strict as string[];\n                filesList.forEach((fileSpec, index) => {\n                    if (typeof fileSpec !== 'string') {\n                        console.error(`Index ${index} of \"strict\" array should be a string.`);\n                    } else if (isAbsolute(fileSpec)) {\n                        console.error(`Ignoring path \"${fileSpec}\" in \"strict\" array because it is not relative.`);\n                    } else {\n                        this.strict.push(getFileSpec(this.projectRoot, fileSpec));\n                    }\n                });\n            }\n        }\n\n        // If there is a \"typeCheckingMode\", it can override the provided setting.\n        let configTypeCheckingMode: string | undefined;\n        if (configObj.typeCheckingMode !== undefined) {\n            if (\n                configObj.typeCheckingMode === 'off' ||\n                configObj.typeCheckingMode === 'basic' ||\n                configObj.typeCheckingMode === 'strict'\n            ) {\n                configTypeCheckingMode = configObj.typeCheckingMode;\n            } else {\n                console.error(`Config \"typeCheckingMode\" entry must contain \"off\", \"basic\", or \"strict\".`);\n            }\n        }\n\n        if (configObj.useLibraryCodeForTypes !== undefined) {\n            if (typeof configObj.useLibraryCodeForTypes === 'boolean') {\n                this.useLibraryCodeForTypes = configObj.useLibraryCodeForTypes;\n            } else {\n                console.error(`Config \"useLibraryCodeForTypes\" entry must be true or false.`);\n            }\n        }\n\n        const effectiveTypeCheckingMode = configTypeCheckingMode || typeCheckingMode;\n        const defaultSettings = ConfigOptions.getDiagnosticRuleSet(effectiveTypeCheckingMode);\n        if (effectiveTypeCheckingMode === 'off') {\n            this.disableInferenceForPyTypedSources = false;\n        }\n\n        // Apply host provided overrides first and then overrides from the config file\n        this.applyDiagnosticOverrides(diagnosticOverrides);\n\n        this.diagnosticRuleSet = {\n            printUnknownAsAny: defaultSettings.printUnknownAsAny,\n            omitTypeArgsIfAny: defaultSettings.omitTypeArgsIfAny,\n            omitUnannotatedParamType: defaultSettings.omitUnannotatedParamType,\n            pep604Printing: defaultSettings.pep604Printing,\n\n            // Use strict inference rules for list expressions?\n            strictListInference: this._convertBoolean(\n                configObj.strictListInference,\n                DiagnosticRule.strictListInference,\n                defaultSettings.strictListInference\n            ),\n\n            // Use strict inference rules for dictionary expressions?\n            strictDictionaryInference: this._convertBoolean(\n                configObj.strictDictionaryInference,\n                DiagnosticRule.strictDictionaryInference,\n                defaultSettings.strictDictionaryInference\n            ),\n\n            // Should a None default value imply that the parameter type\n            // is Optional?\n            strictParameterNoneValue: this._convertBoolean(\n                configObj.strictParameterNoneValue,\n                DiagnosticRule.strictParameterNoneValue,\n                defaultSettings.strictParameterNoneValue\n            ),\n\n            // Should \"# type: ignore\" be honored?\n            enableTypeIgnoreComments: this._convertBoolean(\n                configObj.enableTypeIgnoreComments,\n                DiagnosticRule.enableTypeIgnoreComments,\n                defaultSettings.enableTypeIgnoreComments\n            ),\n\n            // Read the \"reportGeneralTypeIssues\" entry.\n            reportGeneralTypeIssues: this._convertDiagnosticLevel(\n                configObj.reportGeneralTypeIssues,\n                DiagnosticRule.reportGeneralTypeIssues,\n                defaultSettings.reportGeneralTypeIssues\n            ),\n\n            // Read the \"reportPropertyTypeMismatch\" entry.\n            reportPropertyTypeMismatch: this._convertDiagnosticLevel(\n                configObj.reportPropertyTypeMismatch,\n                DiagnosticRule.reportPropertyTypeMismatch,\n                defaultSettings.reportPropertyTypeMismatch\n            ),\n\n            // Read the \"reportMissingImports\" entry.\n            reportMissingImports: this._convertDiagnosticLevel(\n                configObj.reportMissingImports,\n                DiagnosticRule.reportMissingImports,\n                defaultSettings.reportMissingImports\n            ),\n\n            // Read the \"reportUnusedImport\" entry.\n            reportUnusedImport: this._convertDiagnosticLevel(\n                configObj.reportUnusedImport,\n                DiagnosticRule.reportUnusedImport,\n                defaultSettings.reportUnusedImport\n            ),\n\n            // Read the \"reportUnusedClass\" entry.\n            reportUnusedClass: this._convertDiagnosticLevel(\n                configObj.reportUnusedClass,\n                DiagnosticRule.reportUnusedClass,\n                defaultSettings.reportUnusedClass\n            ),\n\n            // Read the \"reportUnusedFunction\" entry.\n            reportUnusedFunction: this._convertDiagnosticLevel(\n                configObj.reportUnusedFunction,\n                DiagnosticRule.reportUnusedFunction,\n                defaultSettings.reportUnusedFunction\n            ),\n\n            // Read the \"reportUnusedVariable\" entry.\n            reportUnusedVariable: this._convertDiagnosticLevel(\n                configObj.reportUnusedVariable,\n                DiagnosticRule.reportUnusedVariable,\n                defaultSettings.reportUnusedVariable\n            ),\n\n            // Read the \"reportDuplicateImport\" entry.\n            reportDuplicateImport: this._convertDiagnosticLevel(\n                configObj.reportDuplicateImport,\n                DiagnosticRule.reportDuplicateImport,\n                defaultSettings.reportDuplicateImport\n            ),\n\n            // Read the \"reportWildcardImportFromLibrary\" entry.\n            reportWildcardImportFromLibrary: this._convertDiagnosticLevel(\n                configObj.reportWildcardImportFromLibrary,\n                DiagnosticRule.reportWildcardImportFromLibrary,\n                defaultSettings.reportWildcardImportFromLibrary\n            ),\n\n            // Read the \"reportMissingModuleSource\" entry.\n            reportMissingModuleSource: this._convertDiagnosticLevel(\n                configObj.reportMissingModuleSource,\n                DiagnosticRule.reportMissingModuleSource,\n                defaultSettings.reportMissingModuleSource\n            ),\n\n            // Read the \"reportMissingTypeStubs\" entry.\n            reportMissingTypeStubs: this._convertDiagnosticLevel(\n                configObj.reportMissingTypeStubs,\n                DiagnosticRule.reportMissingTypeStubs,\n                defaultSettings.reportMissingTypeStubs\n            ),\n\n            // Read the \"reportImportCycles\" entry.\n            reportImportCycles: this._convertDiagnosticLevel(\n                configObj.reportImportCycles,\n                DiagnosticRule.reportImportCycles,\n                defaultSettings.reportImportCycles\n            ),\n\n            // Read the \"reportOptionalSubscript\" entry.\n            reportOptionalSubscript: this._convertDiagnosticLevel(\n                configObj.reportOptionalSubscript,\n                DiagnosticRule.reportOptionalSubscript,\n                defaultSettings.reportOptionalSubscript\n            ),\n\n            // Read the \"reportOptionalMemberAccess\" entry.\n            reportOptionalMemberAccess: this._convertDiagnosticLevel(\n                configObj.reportOptionalMemberAccess,\n                DiagnosticRule.reportOptionalMemberAccess,\n                defaultSettings.reportOptionalMemberAccess\n            ),\n\n            // Read the \"reportOptionalCall\" entry.\n            reportOptionalCall: this._convertDiagnosticLevel(\n                configObj.reportOptionalCall,\n                DiagnosticRule.reportOptionalCall,\n                defaultSettings.reportOptionalCall\n            ),\n\n            // Read the \"reportOptionalIterable\" entry.\n            reportOptionalIterable: this._convertDiagnosticLevel(\n                configObj.reportOptionalIterable,\n                DiagnosticRule.reportOptionalIterable,\n                defaultSettings.reportOptionalIterable\n            ),\n\n            // Read the \"reportOptionalContextManager\" entry.\n            reportOptionalContextManager: this._convertDiagnosticLevel(\n                configObj.reportOptionalContextManager,\n                DiagnosticRule.reportOptionalContextManager,\n                defaultSettings.reportOptionalContextManager\n            ),\n\n            // Read the \"reportOptionalOperand\" entry.\n            reportOptionalOperand: this._convertDiagnosticLevel(\n                configObj.reportOptionalOperand,\n                DiagnosticRule.reportOptionalOperand,\n                defaultSettings.reportOptionalOperand\n            ),\n\n            // Read the \"reportUntypedFunctionDecorator\" entry.\n            reportUntypedFunctionDecorator: this._convertDiagnosticLevel(\n                configObj.reportUntypedFunctionDecorator,\n                DiagnosticRule.reportUntypedFunctionDecorator,\n                defaultSettings.reportUntypedFunctionDecorator\n            ),\n\n            // Read the \"reportUntypedClassDecorator\" entry.\n            reportUntypedClassDecorator: this._convertDiagnosticLevel(\n                configObj.reportUntypedClassDecorator,\n                DiagnosticRule.reportUntypedClassDecorator,\n                defaultSettings.reportUntypedClassDecorator\n            ),\n\n            // Read the \"reportUntypedBaseClass\" entry.\n            reportUntypedBaseClass: this._convertDiagnosticLevel(\n                configObj.reportUntypedBaseClass,\n                DiagnosticRule.reportUntypedBaseClass,\n                defaultSettings.reportUntypedBaseClass\n            ),\n\n            // Read the \"reportUntypedNamedTuple\" entry.\n            reportUntypedNamedTuple: this._convertDiagnosticLevel(\n                configObj.reportUntypedNamedTuple,\n                DiagnosticRule.reportUntypedNamedTuple,\n                defaultSettings.reportUntypedNamedTuple\n            ),\n\n            // Read the \"reportPrivateUsage\" entry.\n            reportPrivateUsage: this._convertDiagnosticLevel(\n                configObj.reportPrivateUsage,\n                DiagnosticRule.reportPrivateUsage,\n                defaultSettings.reportPrivateUsage\n            ),\n\n            // Read the \"reportConstantRedefinition\" entry.\n            reportConstantRedefinition: this._convertDiagnosticLevel(\n                configObj.reportConstantRedefinition,\n                DiagnosticRule.reportConstantRedefinition,\n                defaultSettings.reportConstantRedefinition\n            ),\n\n            // Read the \"reportIncompatibleMethodOverride\" entry.\n            reportIncompatibleMethodOverride: this._convertDiagnosticLevel(\n                configObj.reportIncompatibleMethodOverride,\n                DiagnosticRule.reportIncompatibleMethodOverride,\n                defaultSettings.reportIncompatibleMethodOverride\n            ),\n\n            // Read the \"reportIncompatibleVariableOverride\" entry.\n            reportIncompatibleVariableOverride: this._convertDiagnosticLevel(\n                configObj.reportIncompatibleVariableOverride,\n                DiagnosticRule.reportIncompatibleVariableOverride,\n                defaultSettings.reportIncompatibleVariableOverride\n            ),\n\n            // Read the \"reportInvalidStringEscapeSequence\" entry.\n            reportInvalidStringEscapeSequence: this._convertDiagnosticLevel(\n                configObj.reportInvalidStringEscapeSequence,\n                DiagnosticRule.reportInvalidStringEscapeSequence,\n                defaultSettings.reportInvalidStringEscapeSequence\n            ),\n\n            // Read the \"reportUnknownParameterType\" entry.\n            reportUnknownParameterType: this._convertDiagnosticLevel(\n                configObj.reportUnknownParameterType,\n                DiagnosticRule.reportUnknownParameterType,\n                defaultSettings.reportUnknownParameterType\n            ),\n\n            // Read the \"reportUnknownArgumentType\" entry.\n            reportUnknownArgumentType: this._convertDiagnosticLevel(\n                configObj.reportUnknownArgumentType,\n                DiagnosticRule.reportUnknownArgumentType,\n                defaultSettings.reportUnknownArgumentType\n            ),\n\n            // Read the \"reportUnknownLambdaType\" entry.\n            reportUnknownLambdaType: this._convertDiagnosticLevel(\n                configObj.reportUnknownLambdaType,\n                DiagnosticRule.reportUnknownLambdaType,\n                defaultSettings.reportUnknownLambdaType\n            ),\n\n            // Read the \"reportUnknownVariableType\" entry.\n            reportUnknownVariableType: this._convertDiagnosticLevel(\n                configObj.reportUnknownVariableType,\n                DiagnosticRule.reportUnknownVariableType,\n                defaultSettings.reportUnknownVariableType\n            ),\n\n            // Read the \"reportUnknownMemberType\" entry.\n            reportUnknownMemberType: this._convertDiagnosticLevel(\n                configObj.reportUnknownMemberType,\n                DiagnosticRule.reportUnknownMemberType,\n                defaultSettings.reportUnknownMemberType\n            ),\n\n            // Read the \"reportMissingTypeArgument\" entry.\n            reportMissingTypeArgument: this._convertDiagnosticLevel(\n                configObj.reportMissingTypeArgument,\n                DiagnosticRule.reportMissingTypeArgument,\n                defaultSettings.reportMissingTypeArgument\n            ),\n\n            // Read the \"reportCallInDefaultInitializer\" entry.\n            reportCallInDefaultInitializer: this._convertDiagnosticLevel(\n                configObj.reportCallInDefaultInitializer,\n                DiagnosticRule.reportCallInDefaultInitializer,\n                defaultSettings.reportCallInDefaultInitializer\n            ),\n\n            // Read the \"reportUnnecessaryIsInstance\" entry.\n            reportUnnecessaryIsInstance: this._convertDiagnosticLevel(\n                configObj.reportUnnecessaryIsInstance,\n                DiagnosticRule.reportUnnecessaryIsInstance,\n                defaultSettings.reportUnnecessaryIsInstance\n            ),\n\n            // Read the \"reportUnnecessaryCast\" entry.\n            reportUnnecessaryCast: this._convertDiagnosticLevel(\n                configObj.reportUnnecessaryCast,\n                DiagnosticRule.reportUnnecessaryCast,\n                defaultSettings.reportUnnecessaryCast\n            ),\n\n            // Read the \"reportAssertAlwaysTrue\" entry.\n            reportAssertAlwaysTrue: this._convertDiagnosticLevel(\n                configObj.reportAssertAlwaysTrue,\n                DiagnosticRule.reportAssertAlwaysTrue,\n                defaultSettings.reportAssertAlwaysTrue\n            ),\n\n            // Read the \"reportSelfClsParameterName\" entry.\n            reportSelfClsParameterName: this._convertDiagnosticLevel(\n                configObj.reportSelfClsParameterName,\n                DiagnosticRule.reportSelfClsParameterName,\n                defaultSettings.reportSelfClsParameterName\n            ),\n\n            // Read the \"reportImplicitStringConcatenation\" entry.\n            reportImplicitStringConcatenation: this._convertDiagnosticLevel(\n                configObj.reportImplicitStringConcatenation,\n                DiagnosticRule.reportImplicitStringConcatenation,\n                defaultSettings.reportImplicitStringConcatenation\n            ),\n\n            // Read the \"reportUndefinedVariable\" entry.\n            reportUndefinedVariable: this._convertDiagnosticLevel(\n                configObj.reportUndefinedVariable,\n                DiagnosticRule.reportUndefinedVariable,\n                defaultSettings.reportUndefinedVariable\n            ),\n\n            // Read the \"reportUnboundVariable\" entry.\n            reportUnboundVariable: this._convertDiagnosticLevel(\n                configObj.reportUnboundVariable,\n                DiagnosticRule.reportUnboundVariable,\n                defaultSettings.reportUnboundVariable\n            ),\n\n            // Read the \"reportInvalidStubStatement\" entry.\n            reportInvalidStubStatement: this._convertDiagnosticLevel(\n                configObj.reportInvalidStubStatement,\n                DiagnosticRule.reportInvalidStubStatement,\n                defaultSettings.reportInvalidStubStatement\n            ),\n        };\n\n        // Read the \"venvPath\".\n        this.venvPath = undefined;\n        if (configObj.venvPath !== undefined) {\n            if (typeof configObj.venvPath !== 'string') {\n                console.error(`Config \"venvPath\" field must contain a string.`);\n            } else {\n                this.venvPath = normalizePath(combinePaths(this.projectRoot, configObj.venvPath));\n            }\n        }\n\n        // Read the default \"venv\".\n        this.defaultVenv = undefined;\n        if (configObj.venv !== undefined) {\n            if (typeof configObj.venv !== 'string') {\n                console.error(`Config \"venv\" field must contain a string.`);\n            } else {\n                this.defaultVenv = configObj.venv;\n            }\n        }\n\n        // Read the default \"pythonVersion\".\n        this.defaultPythonVersion = undefined;\n        if (configObj.pythonVersion !== undefined) {\n            if (typeof configObj.pythonVersion === 'string') {\n                const version = versionFromString(configObj.pythonVersion);\n                if (version) {\n                    this.defaultPythonVersion = version;\n                } else {\n                    console.error(`Config \"pythonVersion\" field contains unsupported version.`);\n                }\n            } else {\n                console.error(`Config \"pythonVersion\" field must contain a string.`);\n            }\n        }\n\n        this.ensureDefaultPythonVersion(pythonPath, console);\n\n        // Read the default \"pythonPlatform\".\n        this.defaultPythonPlatform = undefined;\n        if (configObj.pythonPlatform !== undefined) {\n            if (typeof configObj.pythonPlatform !== 'string') {\n                console.error(`Config \"pythonPlatform\" field must contain a string.`);\n            } else {\n                this.defaultPythonPlatform = configObj.pythonPlatform;\n            }\n        }\n\n        this.ensureDefaultPythonPlatform(console);\n\n        // Read the \"typeshedPath\" setting.\n        this.typeshedPath = undefined;\n        if (configObj.typeshedPath !== undefined) {\n            if (typeof configObj.typeshedPath !== 'string') {\n                console.error(`Config \"typeshedPath\" field must contain a string.`);\n            } else {\n                this.typeshedPath = configObj.typeshedPath\n                    ? normalizePath(combinePaths(this.projectRoot, configObj.typeshedPath))\n                    : '';\n            }\n        }\n\n        // Read the \"stubPath\" setting.\n        this.stubPath = undefined;\n\n        // Keep this for backward compatibility\n        if (configObj.typingsPath !== undefined) {\n            if (typeof configObj.typingsPath !== 'string') {\n                console.error(`Config \"typingsPath\" field must contain a string.`);\n            } else {\n                console.error(`Config \"typingsPath\" is now deprecated. Please, use stubPath instead.`);\n                this.stubPath = normalizePath(combinePaths(this.projectRoot, configObj.typingsPath));\n            }\n        }\n\n        if (configObj.stubPath !== undefined) {\n            if (typeof configObj.stubPath !== 'string') {\n                console.error(`Config \"stubPath\" field must contain a string.`);\n            } else {\n                this.stubPath = normalizePath(combinePaths(this.projectRoot, configObj.stubPath));\n            }\n        }\n\n        // Read the \"verboseOutput\" setting.\n        // Don't initialize to a default value because we want the command-line \"verbose\"\n        // switch to apply if this setting isn't specified in the config file.\n        if (configObj.verboseOutput !== undefined) {\n            if (typeof configObj.verboseOutput !== 'boolean') {\n                console.error(`Config \"verboseOutput\" field must be true or false.`);\n            } else {\n                this.verboseOutput = configObj.verboseOutput;\n            }\n        }\n\n        // Read the \"useLibraryCodeForTypes\" setting.\n        if (configObj.useLibraryCodeForTypes !== undefined) {\n            if (typeof configObj.useLibraryCodeForTypes !== 'boolean') {\n                console.error(`Config \"useLibraryCodeForTypes\" field must be true or false.`);\n            } else {\n                this.useLibraryCodeForTypes = configObj.useLibraryCodeForTypes;\n            }\n        }\n\n        // Read the \"executionEnvironments\" array. This should be done at the end\n        // after we've established default values.\n        this.executionEnvironments = [];\n        if (configObj.executionEnvironments !== undefined) {\n            if (!Array.isArray(configObj.executionEnvironments)) {\n                console.error(`Config \"executionEnvironments\" field must contain an array.`);\n            } else {\n                const execEnvironments = configObj.executionEnvironments as ExecutionEnvironment[];\n                execEnvironments.forEach((env, index) => {\n                    const execEnv = this._initExecutionEnvironmentFromJson(env, index, console);\n                    if (execEnv) {\n                        this.executionEnvironments.push(execEnv);\n                    }\n                });\n            }\n        }\n\n        // Read the \"autoImportCompletions\" setting.\n        if (configObj.autoImportCompletions !== undefined) {\n            if (typeof configObj.autoImportCompletions !== 'boolean') {\n                console.error(`Config \"autoImportCompletions\" field must be true or false.`);\n            } else {\n                this.autoImportCompletions = configObj.autoImportCompletions;\n            }\n        }\n\n        // Read the \"indexing\" setting.\n        if (configObj.indexing !== undefined) {\n            if (typeof configObj.indexing !== 'boolean') {\n                console.error(`Config \"indexing\" field must be true or false.`);\n            } else {\n                this.indexing = configObj.indexing;\n            }\n        }\n    }\n\n    ensureDefaultPythonPlatform(console: ConsoleInterface) {\n        // If no default python platform was specified, assume that the\n        // user wants to use the current platform.\n        if (this.defaultPythonPlatform !== undefined) {\n            return;\n        }\n\n        if (process.platform === 'darwin') {\n            this.defaultPythonPlatform = 'Darwin';\n        } else if (process.platform === 'linux') {\n            this.defaultPythonPlatform = 'Linux';\n        } else if (process.platform === 'win32') {\n            this.defaultPythonPlatform = 'Windows';\n        }\n\n        if (this.defaultPythonPlatform !== undefined) {\n            console.info(`Assuming Python platform ${this.defaultPythonPlatform}`);\n        }\n    }\n\n    ensureDefaultPythonVersion(pythonPath: string | undefined, console: ConsoleInterface) {\n        // If no default python version was specified, retrieve the version\n        // from the currently-selected python interpreter.\n        if (this.defaultPythonVersion !== undefined) {\n            return;\n        }\n\n        this.defaultPythonVersion = this._getPythonVersionFromPythonInterpreter(pythonPath, console);\n        if (this.defaultPythonVersion !== undefined) {\n            console.info(`Assuming Python version ${versionToString(this.defaultPythonVersion)}`);\n        }\n    }\n\n    applyDiagnosticOverrides(diagnosticSeverityOverrides: DiagnosticSeverityOverridesMap | undefined) {\n        if (!diagnosticSeverityOverrides) {\n            return;\n        }\n\n        for (const [ruleName, severity] of Object.entries(diagnosticSeverityOverrides)) {\n            (this.diagnosticRuleSet as any)[ruleName] = severity;\n        }\n    }\n\n    private _convertBoolean(value: any, fieldName: string, defaultValue: boolean): boolean {\n        if (value === undefined) {\n            return defaultValue;\n        } else if (typeof value === 'boolean') {\n            return value ? true : false;\n        }\n\n        console.log(`Config \"${fieldName}\" entry must be true or false.`);\n        return defaultValue;\n    }\n\n    private _convertDiagnosticLevel(value: any, fieldName: string, defaultValue: DiagnosticLevel): DiagnosticLevel {\n        if (value === undefined) {\n            return defaultValue;\n        } else if (typeof value === 'boolean') {\n            return value ? 'error' : 'none';\n        } else if (typeof value === 'string') {\n            if (value === 'error' || value === 'warning' || value === 'information' || value === 'none') {\n                return value;\n            }\n        }\n\n        console.log(`Config \"${fieldName}\" entry must be true, false, \"error\", \"warning\", \"information\" or \"none\".`);\n        return defaultValue;\n    }\n\n    private _initExecutionEnvironmentFromJson(\n        envObj: any,\n        index: number,\n        console: ConsoleInterface\n    ): ExecutionEnvironment | undefined {\n        try {\n            const newExecEnv = new ExecutionEnvironment(\n                this.projectRoot,\n                this.defaultPythonVersion,\n                this.defaultPythonPlatform\n            );\n\n            // Validate the root.\n            if (envObj.root && typeof envObj.root === 'string') {\n                newExecEnv.root = normalizePath(combinePaths(this.projectRoot, envObj.root));\n            } else {\n                console.error(`Config executionEnvironments index ${index}: missing root value.`);\n            }\n\n            // Validate the extraPaths.\n            if (envObj.extraPaths) {\n                if (!Array.isArray(envObj.extraPaths)) {\n                    console.error(\n                        `Config executionEnvironments index ${index}: extraPaths field must contain an array.`\n                    );\n                } else {\n                    const pathList = envObj.extraPaths as string[];\n                    pathList.forEach((path, pathIndex) => {\n                        if (typeof path !== 'string') {\n                            console.error(\n                                `Config executionEnvironments index ${index}:` +\n                                    ` extraPaths field ${pathIndex} must be a string.`\n                            );\n                        } else {\n                            newExecEnv.extraPaths.push(normalizePath(combinePaths(this.projectRoot, path)));\n                        }\n                    });\n                }\n            }\n\n            // Validate the pythonVersion.\n            if (envObj.pythonVersion) {\n                if (typeof envObj.pythonVersion === 'string') {\n                    const version = versionFromString(envObj.pythonVersion);\n                    if (version) {\n                        newExecEnv.pythonVersion = version;\n                    } else {\n                        console.warn(`Config executionEnvironments index ${index} contains unsupported pythonVersion.`);\n                    }\n                } else {\n                    console.error(`Config executionEnvironments index ${index} pythonVersion must be a string.`);\n                }\n            }\n\n            // Validate the pythonPlatform.\n            if (envObj.pythonPlatform) {\n                if (typeof envObj.pythonPlatform === 'string') {\n                    newExecEnv.pythonPlatform = envObj.pythonPlatform;\n                } else {\n                    console.error(`Config executionEnvironments index ${index} pythonPlatform must be a string.`);\n                }\n            }\n\n            // Validate the venv.\n            if (envObj.venv) {\n                if (typeof envObj.venv === 'string') {\n                    newExecEnv.venv = envObj.venv;\n                } else {\n                    console.error(`Config executionEnvironments index ${index} venv must be a string.`);\n                }\n            }\n\n            return newExecEnv;\n        } catch {\n            console.error(`Config executionEnvironments index ${index} is not accessible.`);\n        }\n\n        return undefined;\n    }\n\n    private _getPythonVersionFromPythonInterpreter(\n        interpreterPath: string | undefined,\n        console: ConsoleInterface\n    ): PythonVersion | undefined {\n        try {\n            const commandLineArgs: string[] = [\n                '-c',\n                'import sys, json; json.dump(dict(major=sys.version_info[0], minor=sys.version_info[1]), sys.stdout)',\n            ];\n            let execOutput: string;\n\n            if (interpreterPath) {\n                execOutput = child_process.execFileSync(interpreterPath, commandLineArgs, { encoding: 'utf8' });\n            } else {\n                execOutput = child_process.execFileSync('python', commandLineArgs, { encoding: 'utf8' });\n            }\n\n            const versionJson: { major: number; minor: number } = JSON.parse(execOutput);\n\n            const version = versionFromMajorMinor(versionJson.major, versionJson.minor);\n            if (version === undefined) {\n                console.warn(\n                    `Python version ${versionJson.major}.${versionJson.minor} from interpreter is unsupported`\n                );\n                return undefined;\n            }\n\n            return version;\n        } catch {\n            console.info('Unable to get Python version from interpreter');\n            return undefined;\n        }\n    }\n}\n","/*\n * console.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Provides an abstraction for console logging and error-reporting\n * methods.\n */\n\nimport * as debug from './debug';\n\nexport enum LogLevel {\n    Error = 'error',\n    Warn = 'warn',\n    Info = 'info',\n    Log = 'log',\n}\n\nexport interface ConsoleInterface {\n    error: (message: string) => void;\n    warn: (message: string) => void;\n    info: (message: string) => void;\n    log: (message: string) => void;\n}\n\n// Avoids outputting errors to the console but counts\n// the number of logs and errors, which can be useful\n// for unit tests.\nexport class NullConsole implements ConsoleInterface {\n    logCount = 0;\n    infoCount = 0;\n    warnCount = 0;\n    errorCount = 0;\n\n    log(message: string) {\n        this.logCount++;\n    }\n\n    info(message: string) {\n        this.infoCount++;\n    }\n\n    warn(message: string) {\n        this.warnCount++;\n    }\n\n    error(message: string) {\n        this.errorCount++;\n    }\n}\n\nexport class StandardConsole implements ConsoleInterface {\n    log(message: string) {\n        console.info(message);\n    }\n\n    info(message: string) {\n        console.info(message);\n    }\n\n    warn(message: string) {\n        console.warn(message);\n    }\n\n    error(message: string) {\n        console.error(message);\n    }\n}\n\nexport class ConsoleWithLogLevel implements ConsoleInterface {\n    private _levelMap: Map<string, number> = new Map([\n        [LogLevel.Error, 0],\n        [LogLevel.Warn, 1],\n        [LogLevel.Info, 2],\n        [LogLevel.Log, 3],\n    ]);\n\n    private _maxLevel = 2;\n\n    constructor(private _console: ConsoleInterface) {}\n\n    get level(): LogLevel {\n        switch (this._maxLevel) {\n            case 0:\n                return LogLevel.Error;\n\n            case 1:\n                return LogLevel.Warn;\n\n            case 2:\n                return LogLevel.Info;\n        }\n\n        return LogLevel.Log;\n    }\n\n    set level(value: LogLevel) {\n        let maxLevel = this._levelMap.get(value);\n        if (maxLevel === undefined) {\n            maxLevel = this._levelMap.get(LogLevel.Info)!;\n        }\n\n        this._maxLevel = maxLevel;\n    }\n\n    error(message: string) {\n        this._log(LogLevel.Error, message);\n    }\n\n    warn(message: string) {\n        this._log(LogLevel.Warn, message);\n    }\n\n    info(message: string) {\n        this._log(LogLevel.Info, message);\n    }\n\n    log(message: string) {\n        this._log(LogLevel.Log, message);\n    }\n\n    private _log(level: LogLevel, message: string): void {\n        if (this._getNumericalLevel(level) > this._maxLevel) {\n            return;\n        }\n\n        log(this._console, level, message);\n    }\n\n    private _getNumericalLevel(level: LogLevel): number {\n        const numericLevel = this._levelMap.get(level);\n        debug.assert(numericLevel !== undefined, 'Logger: unknown log level.');\n        return numericLevel !== undefined ? numericLevel : 2;\n    }\n}\n\nexport function log(console: ConsoleInterface, logType: LogLevel, msg: string) {\n    switch (logType) {\n        case LogLevel.Log:\n            console.log(msg);\n            break;\n\n        case LogLevel.Info:\n            console.info(msg);\n            break;\n\n        case LogLevel.Warn:\n            console.warn(msg);\n            break;\n\n        case LogLevel.Error:\n            console.error(msg);\n            break;\n\n        default:\n            debug.fail(`${logType} is not expected`);\n    }\n}\n","/*\n * core.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * Various helpers that don't have a dependency on other code files.\n */\n\nexport const enum Comparison {\n    LessThan = -1,\n    EqualTo = 0,\n    GreaterThan = 1,\n}\n\n/**\n * Safer version of `Function` which should not be called.\n * Every function should be assignable to this, but this should not be assignable to every function.\n */\nexport type AnyFunction = (...args: never[]) => void;\n\n/** Do nothing and return false */\nexport function returnFalse(): false {\n    return false;\n}\n\n/** Do nothing and return true */\nexport function returnTrue(): true {\n    return true;\n}\n\n/** Do nothing and return undefined */\nexport function returnUndefined(): undefined {\n    return undefined;\n}\n\n/** Returns its argument. */\nexport function identity<T>(x: T) {\n    return x;\n}\n\n/** Returns lower case string */\nexport function toLowerCase(x: string) {\n    return x.toLowerCase();\n}\n\nexport function equateValues<T>(a: T, b: T) {\n    return a === b;\n}\n\nexport type GetCanonicalFileName = (fileName: string) => string;\n\nexport function compareComparableValues(a: string | undefined, b: string | undefined): Comparison;\nexport function compareComparableValues(a: number | undefined, b: number | undefined): Comparison;\nexport function compareComparableValues(a: string | number | undefined, b: string | number | undefined) {\n    return a === b\n        ? Comparison.EqualTo\n        : a === undefined\n        ? Comparison.LessThan\n        : b === undefined\n        ? Comparison.GreaterThan\n        : a < b\n        ? Comparison.LessThan\n        : Comparison.GreaterThan;\n}\n\n/**\n * Compare two numeric values for their order relative to each other.\n * To compare strings, use any of the `compareStrings` functions.\n */\nexport function compareValues(a: number | undefined, b: number | undefined): Comparison {\n    return compareComparableValues(a, b);\n}\n\n/**\n * Tests whether a value is an array.\n */\nexport function isArray(value: any): value is readonly {}[] {\n    return Array.isArray ? Array.isArray(value) : value instanceof Array;\n}\n\n/**\n * Tests whether a value is string\n */\nexport function isString(text: unknown): text is string {\n    return typeof text === 'string';\n}\n\nexport function isNumber(x: unknown): x is number {\n    return typeof x === 'number';\n}\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Type of objects whose values are all of the same type.\n * The `in` and `for-in` operators can *not* be safely used,\n * since `Object.prototype` may be modified by outside code.\n */\nexport interface MapLike<T> {\n    [index: string]: T;\n}\n\n/**\n * Indicates whether a map-like contains an own property with the specified key.\n *\n * @param map A map-like.\n * @param key A property key.\n */\nexport function hasProperty(map: MapLike<any>, key: string): boolean {\n    return hasOwnProperty.call(map, key);\n}\n\n/**\n * Convert the given value to boolean\n * @param trueOrFalse string value 'true' or 'false'\n */\nexport function toBoolean(trueOrFalse: string): boolean {\n    const normalized = trueOrFalse?.trim().toUpperCase();\n    if (normalized === 'TRUE') {\n        return true;\n    }\n\n    return false;\n}\n\nexport function isDebugMode() {\n    const argv = process.execArgv.join();\n    return argv.includes('inspect') || argv.includes('debug');\n}\n","/*\n * debug.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * Helper functions that display user friendly debugging info.\n */\n\nimport { stableSort } from './collectionUtils';\nimport { AnyFunction, compareValues, hasProperty } from './core';\n\nexport function assert(\n    expression: boolean,\n    message?: string,\n    verboseDebugInfo?: string | (() => string),\n    stackCrawlMark?: AnyFunction\n): void {\n    if (!expression) {\n        if (verboseDebugInfo) {\n            message +=\n                '\\r\\nVerbose Debug Information: ' +\n                (typeof verboseDebugInfo === 'string' ? verboseDebugInfo : verboseDebugInfo());\n        }\n        fail(message ? 'False expression: ' + message : 'False expression.', stackCrawlMark || assert);\n    }\n}\n\nexport function fail(message?: string, stackCrawlMark?: AnyFunction): never {\n    // debugger;\n    const e = new Error(message ? `Debug Failure. ${message}` : 'Debug Failure.');\n    if ((Error as any).captureStackTrace) {\n        (Error as any).captureStackTrace(e, stackCrawlMark || fail);\n    }\n    throw e;\n}\n\nexport function assertDefined<T>(value: T | null | undefined, message?: string): T {\n    if (value === undefined || value === null) {\n        return fail(message);\n    }\n    return value;\n}\n\nexport function assertEachDefined<T, A extends readonly T[]>(value: A, message?: string): A {\n    for (const v of value) {\n        assertDefined(v, message);\n    }\n    return value;\n}\n\nexport function assertNever(member: never, message = 'Illegal value:', stackCrawlMark?: AnyFunction): never {\n    const detail = JSON.stringify(member);\n    return fail(`${message} ${detail}`, stackCrawlMark || assertNever);\n}\n\nexport function getFunctionName(func: AnyFunction) {\n    if (typeof func !== 'function') {\n        return '';\n    } else if (hasProperty(func, 'name')) {\n        return (func as any).name;\n    } else {\n        const text = Function.prototype.toString.call(func);\n        const match = /^function\\s+([\\w$]+)\\s*\\(/.exec(text);\n        return match ? match[1] : '';\n    }\n}\n\n/**\n * Formats an enum value as a string for debugging and debug assertions.\n */\nexport function formatEnum(value = 0, enumObject: any, isFlags?: boolean) {\n    const members = getEnumMembers(enumObject);\n    if (value === 0) {\n        return members.length > 0 && members[0][0] === 0 ? members[0][1] : '0';\n    }\n    if (isFlags) {\n        let result = '';\n        let remainingFlags = value;\n        for (const [enumValue, enumName] of members) {\n            if (enumValue > value) {\n                break;\n            }\n            if (enumValue !== 0 && enumValue & value) {\n                result = `${result}${result ? '|' : ''}${enumName}`;\n                remainingFlags &= ~enumValue;\n            }\n        }\n        if (remainingFlags === 0) {\n            return result;\n        }\n    } else {\n        for (const [enumValue, enumName] of members) {\n            if (enumValue === value) {\n                return enumName;\n            }\n        }\n    }\n    return value.toString();\n}\n\nexport function getErrorString(error: any): string {\n    return (\n        (error.stack ? error.stack.toString() : undefined) ||\n        (typeof error.message === 'string' ? error.message : undefined) ||\n        JSON.stringify(error)\n    );\n}\n\nfunction getEnumMembers(enumObject: any) {\n    const result: [number, string][] = [];\n    for (const name of Object.keys(enumObject)) {\n        const value = enumObject[name];\n        if (typeof value === 'number') {\n            result.push([value, name]);\n        }\n    }\n\n    return stableSort<[number, string]>(result, (x, y) => compareValues(x[0], y[0]));\n}\n","/*\n * deferred.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * Promise utilities for async operations.\n */\n\nexport interface Deferred<T> {\n    readonly promise: Promise<T>;\n    readonly resolved: boolean;\n    readonly rejected: boolean;\n    readonly completed: boolean;\n    resolve(value?: T | PromiseLike<T>): void;\n    reject(reason?: any): void;\n}\n\nclass DeferredImpl<T> implements Deferred<T> {\n    private _resolve!: (value?: T | PromiseLike<T>) => void;\n    private _reject!: (reason?: any) => void;\n    private _resolved = false;\n    private _rejected = false;\n    private _promise: Promise<T>;\n\n    constructor(private scope: any = null) {\n        this._promise = new Promise<T>((res, rej) => {\n            this._resolve = res;\n            this._reject = rej;\n        });\n    }\n\n    public resolve(_value?: T | PromiseLike<T>) {\n        // eslint-disable-next-line prefer-rest-params\n        this._resolve.apply(this.scope ? this.scope : this, arguments as any);\n        this._resolved = true;\n    }\n\n    public reject(_reason?: any) {\n        // eslint-disable-next-line prefer-rest-params\n        this._reject.apply(this.scope ? this.scope : this, arguments as any);\n        this._rejected = true;\n    }\n\n    get promise(): Promise<T> {\n        return this._promise;\n    }\n\n    get resolved(): boolean {\n        return this._resolved;\n    }\n\n    get rejected(): boolean {\n        return this._rejected;\n    }\n\n    get completed(): boolean {\n        return this._rejected || this._resolved;\n    }\n}\n\nexport function createDeferred<T>(scope: any = null): Deferred<T> {\n    return new DeferredImpl<T>(scope);\n}\n\nexport function createDeferredFrom<T>(...promises: Promise<T>[]): Deferred<T> {\n    const deferred = createDeferred<T>();\n    Promise.all<T>(promises)\n        .then(deferred.resolve.bind(deferred) as any)\n        .catch(deferred.reject.bind(deferred) as any);\n\n    return deferred;\n}\n\nexport function createDeferredFromPromise<T>(promise: Promise<T>): Deferred<T> {\n    const deferred = createDeferred<T>();\n    promise.then(deferred.resolve.bind(deferred)).catch(deferred.reject.bind(deferred));\n    return deferred;\n}\n","/*\n * diagnostics.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Class that represents errors and warnings.\n */\n\nimport { Commands } from '../commands/commands';\nimport { DiagnosticLevel } from './configOptions';\nimport { Range } from './textRange';\n\nconst defaultMaxDepth = 5;\nconst defaultMaxLineCount = 8;\n\nexport const enum DiagnosticCategory {\n    Error,\n    Warning,\n    Information,\n    UnusedCode,\n}\n\nexport function convertLevelToCategory(level: DiagnosticLevel) {\n    switch (level) {\n        case 'error':\n            return DiagnosticCategory.Error;\n\n        case 'warning':\n            return DiagnosticCategory.Warning;\n\n        case 'information':\n            return DiagnosticCategory.Information;\n\n        default:\n            throw new Error(`${level} is not expected`);\n    }\n}\n\nexport interface DiagnosticAction {\n    action: string;\n}\n\nexport interface CreateTypeStubFileAction extends DiagnosticAction {\n    action: Commands.createTypeStub;\n    moduleName: string;\n}\n\nexport interface AddMissingOptionalToParamAction extends DiagnosticAction {\n    action: Commands.addMissingOptionalToParam;\n    offsetOfTypeNode: number;\n}\n\nexport interface DiagnosticRelatedInfo {\n    message: string;\n    filePath: string;\n    range: Range;\n}\n\n// Represents a single error or warning.\nexport class Diagnostic {\n    private _actions: DiagnosticAction[] | undefined;\n    private _rule: string | undefined;\n    private _relatedInfo: DiagnosticRelatedInfo[] = [];\n\n    constructor(readonly category: DiagnosticCategory, readonly message: string, readonly range: Range) {}\n\n    addAction(action: DiagnosticAction) {\n        if (this._actions === undefined) {\n            this._actions = [action];\n        } else {\n            this._actions.push(action);\n        }\n    }\n\n    getActions() {\n        return this._actions;\n    }\n\n    setRule(rule: string) {\n        this._rule = rule;\n    }\n\n    getRule() {\n        return this._rule;\n    }\n\n    addRelatedInfo(message: string, filePath: string, range: Range) {\n        this._relatedInfo.push({ filePath, message, range });\n    }\n\n    getRelatedInfo() {\n        return this._relatedInfo;\n    }\n}\n\n// Helps to build additional information that can be appended to a diagnostic\n// message. It supports hierarchical information and flexible formatting.\nexport class DiagnosticAddendum {\n    private _messages: string[] = [];\n    private _childAddenda: DiagnosticAddendum[] = [];\n\n    addMessage(message: string) {\n        this._messages.push(message);\n    }\n\n    // Create a new (nested) addendum to which messages can be added.\n    createAddendum() {\n        const newAddendum = new DiagnosticAddendum();\n        this.addAddendum(newAddendum);\n        return newAddendum;\n    }\n\n    getString(maxDepth = defaultMaxDepth, maxLineCount = defaultMaxLineCount): string {\n        let lines = this._getLinesRecursive(maxDepth);\n\n        if (lines.length > maxLineCount) {\n            lines = lines.slice(0, maxLineCount);\n            lines.push('...');\n        }\n\n        const text = lines.join('\\n');\n        if (text.length > 0) {\n            return '\\n' + text;\n        }\n\n        return '';\n    }\n\n    isEmpty() {\n        return this._getMessageCount() === 0;\n    }\n\n    addAddendum(addendum: DiagnosticAddendum) {\n        this._childAddenda.push(addendum);\n    }\n\n    private _getMessageCount() {\n        // Get the nested message count.\n        let messageCount = this._messages.length;\n\n        for (const diag of this._childAddenda) {\n            messageCount += diag._getMessageCount();\n        }\n\n        return messageCount;\n    }\n\n    private _getLinesRecursive(maxDepth: number): string[] {\n        if (maxDepth <= 0) {\n            return [];\n        }\n\n        const childLines: string[] = [];\n        for (const addendum of this._childAddenda) {\n            const maxDepthRemaining = this._messages.length > 0 ? maxDepth - 1 : maxDepth;\n            childLines.push(...addendum._getLinesRecursive(maxDepthRemaining));\n        }\n\n        // Prepend indentation for readability. Skip if there are no\n        // messages at this level.\n        const extraSpace = this._messages.length > 0 ? '  ' : '';\n        return this._messages.concat(childLines).map((line) => extraSpace + line);\n    }\n}\n","/*\n * diagnosticRules.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Strings that represent each of the diagnostic rules\n * that can be enabled or disabled in the configuration.\n */\n\n// Not const enum since keys need to be inspected in tests\n// to match declaration of user-visible settings in package.json\nexport enum DiagnosticRule {\n    strictListInference = 'strictListInference',\n    strictDictionaryInference = 'strictDictionaryInference',\n    strictParameterNoneValue = 'strictParameterNoneValue',\n    enableTypeIgnoreComments = 'enableTypeIgnoreComments',\n\n    reportGeneralTypeIssues = 'reportGeneralTypeIssues',\n    reportPropertyTypeMismatch = 'reportPropertyTypeMismatch',\n    reportMissingImports = 'reportMissingImports',\n    reportMissingModuleSource = 'reportMissingModuleSource',\n    reportMissingTypeStubs = 'reportMissingTypeStubs',\n    reportImportCycles = 'reportImportCycles',\n    reportUnusedImport = 'reportUnusedImport',\n    reportUnusedClass = 'reportUnusedClass',\n    reportUnusedFunction = 'reportUnusedFunction',\n    reportUnusedVariable = 'reportUnusedVariable',\n    reportDuplicateImport = 'reportDuplicateImport',\n    reportWildcardImportFromLibrary = 'reportWildcardImportFromLibrary',\n    reportOptionalSubscript = 'reportOptionalSubscript',\n    reportOptionalMemberAccess = 'reportOptionalMemberAccess',\n    reportOptionalCall = 'reportOptionalCall',\n    reportOptionalIterable = 'reportOptionalIterable',\n    reportOptionalContextManager = 'reportOptionalContextManager',\n    reportOptionalOperand = 'reportOptionalOperand',\n    reportUntypedFunctionDecorator = 'reportUntypedFunctionDecorator',\n    reportUntypedClassDecorator = 'reportUntypedClassDecorator',\n    reportUntypedBaseClass = 'reportUntypedBaseClass',\n    reportUntypedNamedTuple = 'reportUntypedNamedTuple',\n    reportPrivateUsage = 'reportPrivateUsage',\n    reportConstantRedefinition = 'reportConstantRedefinition',\n    reportIncompatibleMethodOverride = 'reportIncompatibleMethodOverride',\n    reportIncompatibleVariableOverride = 'reportIncompatibleVariableOverride',\n    reportInvalidStringEscapeSequence = 'reportInvalidStringEscapeSequence',\n    reportUnknownParameterType = 'reportUnknownParameterType',\n    reportUnknownArgumentType = 'reportUnknownArgumentType',\n    reportUnknownLambdaType = 'reportUnknownLambdaType',\n    reportUnknownVariableType = 'reportUnknownVariableType',\n    reportUnknownMemberType = 'reportUnknownMemberType',\n    reportMissingTypeArgument = 'reportMissingTypeArgument',\n    reportCallInDefaultInitializer = 'reportCallInDefaultInitializer',\n    reportUnnecessaryIsInstance = 'reportUnnecessaryIsInstance',\n    reportUnnecessaryCast = 'reportUnnecessaryCast',\n    reportAssertAlwaysTrue = 'reportAssertAlwaysTrue',\n    reportSelfClsParameterName = 'reportSelfClsParameterName',\n    reportImplicitStringConcatenation = 'reportImplicitStringConcatenation',\n    reportUndefinedVariable = 'reportUndefinedVariable',\n    reportUnboundVariable = 'reportUnboundVariable',\n    reportInvalidStubStatement = 'reportInvalidStubStatement',\n}\n","/*\n * diagnostics.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Class that represents errors and warnings.\n */\n\nimport { DiagnosticLevel } from './configOptions';\nimport { Diagnostic, DiagnosticAction, DiagnosticCategory } from './diagnostic';\nimport { convertOffsetsToRange } from './positionUtils';\nimport { Range, TextRange } from './textRange';\nimport { TextRangeCollection } from './textRangeCollection';\n\n// Represents a collection of diagnostics within a file.\nexport interface FileDiagnostics {\n    filePath: string;\n    diagnostics: Diagnostic[];\n}\n\n// Creates and tracks a list of diagnostics.\nexport class DiagnosticSink {\n    private _diagnosticList: Diagnostic[];\n    private _diagnosticMap: Map<string, Diagnostic>;\n\n    constructor(diagnostics?: Diagnostic[]) {\n        this._diagnosticList = diagnostics || [];\n        this._diagnosticMap = new Map<string, Diagnostic>();\n    }\n\n    fetchAndClear() {\n        const prevDiagnostics = this._diagnosticList;\n        this._diagnosticList = [];\n        this._diagnosticMap.clear();\n        return prevDiagnostics;\n    }\n\n    addError(message: string, range: Range) {\n        return this.addDiagnostic(new Diagnostic(DiagnosticCategory.Error, message, range));\n    }\n\n    addWarning(message: string, range: Range) {\n        return this.addDiagnostic(new Diagnostic(DiagnosticCategory.Warning, message, range));\n    }\n\n    addInformation(message: string, range: Range) {\n        return this.addDiagnostic(new Diagnostic(DiagnosticCategory.Information, message, range));\n    }\n\n    addUnusedCode(message: string, range: Range, action?: DiagnosticAction) {\n        const diag = new Diagnostic(DiagnosticCategory.UnusedCode, message, range);\n        if (action) {\n            diag.addAction(action);\n        }\n        return this.addDiagnostic(diag);\n    }\n\n    addDiagnostic(diag: Diagnostic) {\n        // Create a unique key for the diagnostic to prevent\n        // adding duplicates.\n        const key =\n            `${diag.range.start.line},${diag.range.start.character}-` +\n            `${diag.range.end.line}-${diag.range.end.character}:${diag.message.substr(0, 25)}}`;\n        if (!this._diagnosticMap.has(key)) {\n            this._diagnosticList.push(diag);\n            this._diagnosticMap.set(key, diag);\n        }\n        return diag;\n    }\n\n    addDiagnostics(diagsToAdd: Diagnostic[]) {\n        this._diagnosticList.push(...diagsToAdd);\n    }\n\n    getErrors() {\n        return this._diagnosticList.filter((diag) => diag.category === DiagnosticCategory.Error);\n    }\n\n    getWarnings() {\n        return this._diagnosticList.filter((diag) => diag.category === DiagnosticCategory.Warning);\n    }\n\n    getInformation() {\n        return this._diagnosticList.filter((diag) => diag.category === DiagnosticCategory.Information);\n    }\n\n    getUnusedCode() {\n        return this._diagnosticList.filter((diag) => diag.category === DiagnosticCategory.UnusedCode);\n    }\n}\n\n// Specialized version of DiagnosticSink that works with TextRange objects\n// and converts text ranges to line and column numbers.\nexport class TextRangeDiagnosticSink extends DiagnosticSink {\n    private _lines: TextRangeCollection<TextRange>;\n\n    constructor(lines: TextRangeCollection<TextRange>, diagnostics?: Diagnostic[]) {\n        super(diagnostics);\n        this._lines = lines;\n    }\n\n    addDiagnosticWithTextRange(level: DiagnosticLevel, message: string, range: TextRange) {\n        const positionRange = convertOffsetsToRange(range.start, range.start + range.length, this._lines);\n        switch (level) {\n            case 'error':\n                return this.addError(message, positionRange);\n            case 'warning':\n                return this.addWarning(message, positionRange);\n            case 'information':\n                return this.addInformation(message, positionRange);\n            default:\n                throw new Error(`${level} is not expected value`);\n        }\n    }\n\n    addUnusedCodeWithTextRange(message: string, range: TextRange, action?: DiagnosticAction) {\n        return this.addUnusedCode(\n            message,\n            convertOffsetsToRange(range.start, range.start + range.length, this._lines),\n            action\n        );\n    }\n}\n","/*\n * extensions.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Extension methods to various types.\n */\n\n// Jest won't load index.d.ts so put it in the same file.\ndeclare interface Promise<T> {\n    // Catches task error and ignores them.\n    ignoreErrors(): void;\n}\n\n/* eslint-disable @typescript-eslint/no-empty-function */\n// Explicitly tells that promise should be run asynchronously.\nPromise.prototype.ignoreErrors = function <T>(this: Promise<T>) {\n    this.catch(() => {});\n};\n","/*\n * fileSystem.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * A \"file system provider\" abstraction that allows us to swap out a\n * real file system implementation for a virtual (mocked) implementation\n * for testing.\n */\n\n/* eslint-disable no-dupe-class-members */\n\n// * NOTE * except tests, this should be only file that import \"fs\"\nimport * as chokidar from 'chokidar';\nimport * as fs from 'fs';\nimport * as os from 'os';\n\nimport { ConsoleInterface, NullConsole } from './console';\nimport { createDeferred } from './deferred';\n\nexport type FileWatcherEventType = 'add' | 'addDir' | 'change' | 'unlink' | 'unlinkDir';\nexport type FileWatcherEventHandler = (eventName: FileWatcherEventType, path: string, stats?: Stats) => void;\n\nexport interface FileWatcher {\n    close(): void;\n}\n\nexport interface Stats {\n    size: number;\n\n    isFile(): boolean;\n    isDirectory(): boolean;\n    isBlockDevice(): boolean;\n    isCharacterDevice(): boolean;\n    isSymbolicLink(): boolean;\n    isFIFO(): boolean;\n    isSocket(): boolean;\n}\n\nexport interface MkDirOptions {\n    recursive: boolean;\n    // Not supported on Windows so commented out.\n    // mode: string | number;\n}\n\nexport interface FileSystem {\n    existsSync(path: string): boolean;\n    mkdirSync(path: string, options?: MkDirOptions | number): void;\n    chdir(path: string): void;\n    readdirEntriesSync(path: string): fs.Dirent[];\n    readdirSync(path: string): string[];\n    readFileSync(path: string, encoding?: null): Buffer;\n    readFileSync(path: string, encoding: BufferEncoding): string;\n    readFileSync(path: string, encoding?: BufferEncoding | null): string | Buffer;\n    writeFileSync(path: string, data: string | Buffer, encoding: BufferEncoding | null): void;\n    statSync(path: string): Stats;\n    unlinkSync(path: string): void;\n    realpathSync(path: string): string;\n    getModulePath(): string;\n    createFileSystemWatcher(paths: string[], listener: FileWatcherEventHandler): FileWatcher;\n    createReadStream(path: string): fs.ReadStream;\n    createWriteStream(path: string): fs.WriteStream;\n    copyFileSync(src: string, dst: string): void;\n    // Async I/O\n    readFile(path: string): Promise<Buffer>;\n    readFileText(path: string, encoding?: BufferEncoding): Promise<string>;\n    tmpdir(): string;\n}\n\nexport interface FileWatcherProvider {\n    createFileWatcher(paths: string[], listener: FileWatcherEventHandler): FileWatcher;\n}\n\n// Callers can specify a different file watcher provider if desired.\n// By default, we'll use the file watcher based on chokidar.\nexport function createFromRealFileSystem(\n    console?: ConsoleInterface,\n    fileWatcherProvider?: FileWatcherProvider\n): FileSystem {\n    return new RealFileSystem(fileWatcherProvider ?? new ChokidarFileWatcherProvider(console ?? new NullConsole()));\n}\n\n// File watchers can give \"changed\" event even for a file open. but for those cases,\n// it will give relative path rather than absolute path. To get rid of such cases,\n// we will drop any event with relative paths. this trick is copied from VS Code\n// (https://github.com/microsoft/vscode/blob/master/src/vs/platform/files/node/watcher/unix/chokidarWatcherService.ts)\nexport function ignoredWatchEventFunction(paths: string[]) {\n    const normalizedPaths = paths.map((p) => p.toLowerCase());\n    return (path: string): boolean => {\n        if (!path || path.indexOf('__pycache__') >= 0) {\n            return true;\n        }\n        const normalizedPath = path.toLowerCase();\n        return normalizedPaths.every((p) => normalizedPath.indexOf(p) < 0);\n    };\n}\n\nconst _isMacintosh = process.platform === 'darwin';\nconst _isLinux = process.platform === 'linux';\n\nclass RealFileSystem implements FileSystem {\n    private _fileWatcherProvider: FileWatcherProvider;\n\n    constructor(fileWatcherProvider: FileWatcherProvider) {\n        this._fileWatcherProvider = fileWatcherProvider;\n    }\n\n    existsSync(path: string) {\n        return fs.existsSync(path);\n    }\n\n    mkdirSync(path: string, options?: MkDirOptions | number) {\n        fs.mkdirSync(path, options);\n    }\n\n    chdir(path: string) {\n        process.chdir(path);\n    }\n\n    readdirSync(path: string): string[] {\n        return fs.readdirSync(path);\n    }\n    readdirEntriesSync(path: string): fs.Dirent[] {\n        return fs.readdirSync(path, { withFileTypes: true });\n    }\n\n    readFileSync(path: string, encoding?: null): Buffer;\n    readFileSync(path: string, encoding: BufferEncoding): string;\n    readFileSync(path: string, encoding?: BufferEncoding | null): Buffer | string;\n    readFileSync(path: string, encoding: BufferEncoding | null = null) {\n        return fs.readFileSync(path, { encoding });\n    }\n\n    writeFileSync(path: string, data: string | Buffer, encoding: BufferEncoding | null) {\n        fs.writeFileSync(path, data, { encoding });\n    }\n\n    statSync(path: string) {\n        return fs.statSync(path);\n    }\n\n    unlinkSync(path: string) {\n        fs.unlinkSync(path);\n    }\n\n    realpathSync(path: string) {\n        return fs.realpathSync(path);\n    }\n\n    getModulePath(): string {\n        // The entry point to the tool should have set the __rootDirectory\n        // global variable to point to the directory that contains the\n        // typeshed-fallback directory.\n        return (global as any).__rootDirectory;\n    }\n\n    createFileSystemWatcher(paths: string[], listener: FileWatcherEventHandler): FileWatcher {\n        return this._fileWatcherProvider.createFileWatcher(paths, listener);\n    }\n\n    createReadStream(path: string): fs.ReadStream {\n        return fs.createReadStream(path);\n    }\n\n    createWriteStream(path: string): fs.WriteStream {\n        return fs.createWriteStream(path);\n    }\n\n    copyFileSync(src: string, dst: string): void {\n        fs.copyFileSync(src, dst);\n    }\n\n    readFile(path: string): Promise<Buffer> {\n        const d = createDeferred<Buffer>();\n        fs.readFile(path, (e, b) => {\n            if (e) {\n                d.reject(e);\n            } else {\n                d.resolve(b);\n            }\n        });\n        return d.promise;\n    }\n\n    readFileText(path: string, encoding: BufferEncoding): Promise<string> {\n        const d = createDeferred<string>();\n        fs.readFile(path, { encoding }, (e, s) => {\n            if (e) {\n                d.reject(e);\n            } else {\n                d.resolve(s);\n            }\n        });\n        return d.promise;\n    }\n\n    tmpdir() {\n        return os.tmpdir();\n    }\n}\n\nclass ChokidarFileWatcherProvider implements FileWatcherProvider {\n    constructor(private _console: ConsoleInterface) {}\n\n    createFileWatcher(paths: string[], listener: FileWatcherEventHandler): FileWatcher {\n        return this._createFileSystemWatcher(paths).on('all', listener);\n    }\n\n    createReadStream(path: string): fs.ReadStream {\n        return fs.createReadStream(path);\n    }\n    createWriteStream(path: string): fs.WriteStream {\n        return fs.createWriteStream(path);\n    }\n\n    private _createFileSystemWatcher(paths: string[]): chokidar.FSWatcher {\n        // The following options are copied from VS Code source base. It also\n        // uses chokidar for its file watching.\n        const watcherOptions: chokidar.WatchOptions = {\n            ignoreInitial: true,\n            ignorePermissionErrors: true,\n            followSymlinks: true, // this is the default of chokidar and supports file events through symlinks\n            interval: 1000, // while not used in normal cases, if any error causes chokidar to fallback to polling, increase its intervals\n            binaryInterval: 1000,\n            disableGlobbing: true, // fix https://github.com/Microsoft/vscode/issues/4586\n            awaitWriteFinish: {\n                // this will make sure we re-scan files once file changes are written to disk\n                stabilityThreshold: 1000,\n                pollInterval: 1000,\n            },\n        };\n\n        if (_isMacintosh) {\n            // Explicitly disable on MacOS because it uses up large amounts of memory\n            // and CPU for large file hierarchies, resulting in instability and crashes.\n            watcherOptions.usePolling = false;\n        }\n\n        const excludes: string[] = ['**/__pycache__/**'];\n        if (_isMacintosh || _isLinux) {\n            if (paths.some((path) => path === '' || path === '/')) {\n                excludes.push('/dev/**');\n                if (_isLinux) {\n                    excludes.push('/proc/**', '/sys/**');\n                }\n            }\n        }\n        watcherOptions.ignored = excludes;\n\n        const watcher = chokidar.watch(paths, watcherOptions);\n        watcher.on('error', (_) => {\n            this._console.error('Error returned from file system watcher.');\n        });\n\n        // Detect if for some reason the native watcher library fails to load\n        if (_isMacintosh && !watcher.options.useFsEvents) {\n            this._console.info('Watcher could not use native fsevents library. File system watcher disabled.');\n        }\n\n        return watcher;\n    }\n\n    readFile(path: string): Promise<Buffer> {\n        const d = createDeferred<Buffer>();\n        fs.readFile(path, (e, b) => {\n            if (e) {\n                d.reject(e);\n            } else {\n                d.resolve(b);\n            }\n        });\n        return d.promise;\n    }\n\n    readFileText(path: string, encoding: BufferEncoding): Promise<string> {\n        const d = createDeferred<string>();\n        fs.readFile(path, { encoding }, (e, s) => {\n            if (e) {\n                d.reject(e);\n            } else {\n                d.resolve(s);\n            }\n        });\n        return d.promise;\n    }\n}\n","/*\n * logTracker.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * A simple logging class that can be used to track nested loggings.\n */\n\nimport { ConsoleInterface, LogLevel } from './console';\nimport { Duration } from './timing';\n\n// Consider an operation \"long running\" if it goes longer than this.\nconst durationThresholdForInfoInMs = 2000;\n\nexport class LogTracker {\n    private _dummyState = new State();\n    private _indentation = '';\n    private _previousTitles: string[] = [];\n\n    constructor(private _console: ConsoleInterface | undefined, private _prefix: string) {}\n\n    log<T>(title: string, callback: (state: LogState) => T) {\n        // If no console is given, don't do anything.\n        if (this._console === undefined) {\n            return callback(this._dummyState);\n        }\n\n        // This is enabled only when level is LogLevel.Log or does not exist.\n        const level = (this._console as any).level;\n        if (level === undefined || (level !== LogLevel.Log && level !== LogLevel.Info)) {\n            return callback(this._dummyState);\n        }\n\n        // Since this is only used when LogLevel.Log or LogLevel.Info is set or BG,\n        // we don't care much about extra logging cost.\n        const duration = new Duration();\n\n        const current = this._indentation;\n        this._previousTitles.push(`${current}${title} ...`);\n\n        this._indentation += '  ';\n        const state = new State();\n\n        try {\n            return callback(state);\n        } finally {\n            this._printPreviousTitles();\n\n            this._indentation = current;\n            const msDuration = duration.getDurationInMilliseconds();\n\n            if (!state.isSuppressed()) {\n                this._console.log(`[${this._prefix}] ${this._indentation}${title}${state.get()} (${msDuration}ms)`);\n\n                // If the operation took really long, log it as \"info\" so it is more visible.\n                if (msDuration >= durationThresholdForInfoInMs) {\n                    this._console.info(`[${this._prefix}] Long operation: ${title} (${msDuration}ms)`);\n                }\n            }\n        }\n    }\n\n    private _printPreviousTitles() {\n        // Get rid of myself\n        this._previousTitles.pop();\n\n        if (this._previousTitles.length <= 0) {\n            return;\n        }\n\n        for (const previousTitle of this._previousTitles) {\n            this._console!.log(`[${this._prefix}] ${previousTitle}`);\n        }\n\n        this._previousTitles.length = 0;\n    }\n}\n\nexport interface LogState {\n    add(_addendum: string): void;\n    suppress(): void;\n}\n\nclass State {\n    private _addendum: string | undefined;\n    private _suppress: boolean | undefined;\n\n    add(_addendum: string) {\n        this._addendum = _addendum;\n    }\n\n    get() {\n        if (this._addendum) {\n            return ` [${this._addendum}]`;\n        }\n\n        return '';\n    }\n\n    suppress() {\n        this._suppress = true;\n    }\n\n    isSuppressed() {\n        return !!this._suppress;\n    }\n}\n","/*\n * pathConsts.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * Path-related constants.\n */\n\nexport const typeshedFallback = 'typeshed-fallback';\nexport const lib = 'lib';\nexport const sitePackages = 'site-packages';\nexport const src = 'src';\n","/*\n * pathUtils.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Pathname utility functions.\n */\n\nimport { randomBytes } from 'crypto';\nimport * as path from 'path';\nimport Char from 'typescript-char';\nimport { URI } from 'vscode-uri';\n\nimport { some } from './collectionUtils';\nimport { compareValues, Comparison, GetCanonicalFileName, identity } from './core';\nimport * as debug from './debug';\nimport { FileSystem } from './fileSystem';\nimport {\n    compareStringsCaseInsensitive,\n    compareStringsCaseSensitive,\n    equateStringsCaseInsensitive,\n    equateStringsCaseSensitive,\n    getStringComparer,\n} from './stringUtils';\n\nlet _fsCaseSensitivity: boolean | undefined = undefined;\n\nexport interface FileSpec {\n    // File specs can contain wildcard characters (**, *, ?). This\n    // specifies the first portion of the file spec that contains\n    // no wildcards.\n    wildcardRoot: string;\n\n    // Regular expression that can be used to match against this\n    // file spec.\n    regExp: RegExp;\n}\n\nexport namespace FileSpec {\n    export function is(value: any): value is FileSpec {\n        const candidate: FileSpec = value as FileSpec;\n        return candidate && !!candidate.wildcardRoot && !!candidate.regExp;\n    }\n}\n\nexport interface FileSystemEntries {\n    files: string[];\n    directories: string[];\n}\n\nexport function forEachAncestorDirectory(\n    directory: string,\n    callback: (directory: string) => string | undefined\n): string | undefined {\n    while (true) {\n        const result = callback(directory);\n        if (result !== undefined) {\n            return result;\n        }\n\n        const parentPath = getDirectoryPath(directory);\n        if (parentPath === directory) {\n            return undefined;\n        }\n\n        directory = parentPath;\n    }\n}\n\nexport function getDirectoryPath(pathString: string): string {\n    return pathString.substr(0, Math.max(getRootLength(pathString), pathString.lastIndexOf(path.sep)));\n}\n\nexport function getRootLength(pathString: string): number {\n    if (pathString.charAt(0) === path.sep) {\n        if (pathString.charAt(1) !== path.sep) {\n            return 1;\n        }\n        const p1 = pathString.indexOf(path.sep, 2);\n        if (p1 < 0) {\n            return 2;\n        }\n        const p2 = pathString.indexOf(path.sep, p1 + 1);\n        if (p2 < 0) {\n            return p1 + 1;\n        }\n        return p2 + 1;\n    }\n    if (pathString.charAt(1) === ':') {\n        if (pathString.charAt(2) === path.sep) {\n            return 3;\n        }\n    }\n    return 0;\n}\n\nexport function getPathComponents(pathString: string) {\n    const normalizedPath = normalizeSlashes(pathString);\n    const rootLength = getRootLength(normalizedPath);\n    const root = normalizedPath.substring(0, rootLength);\n    const rest = normalizedPath.substring(rootLength).split(path.sep);\n    if (rest.length > 0 && !rest[rest.length - 1]) {\n        rest.pop();\n    }\n\n    return reducePathComponents([root, ...rest]);\n}\n\nexport function reducePathComponents(components: readonly string[]) {\n    if (!some(components)) {\n        return [];\n    }\n\n    // Reduce the path components by eliminating\n    // any '.' or '..'.\n    const reduced = [components[0]];\n    for (let i = 1; i < components.length; i++) {\n        const component = components[i];\n        if (!component || component === '.') {\n            continue;\n        }\n\n        if (component === '..') {\n            if (reduced.length > 1) {\n                if (reduced[reduced.length - 1] !== '..') {\n                    reduced.pop();\n                    continue;\n                }\n            } else if (reduced[0]) {\n                continue;\n            }\n        }\n        reduced.push(component);\n    }\n\n    return reduced;\n}\n\nexport function combinePathComponents(components: string[]): string {\n    if (components.length === 0) {\n        return '';\n    }\n\n    const root = components[0] && ensureTrailingDirectorySeparator(components[0]);\n    return normalizeSlashes(root + components.slice(1).join(path.sep));\n}\n\nexport function getRelativePath(dirPath: string, relativeTo: string) {\n    if (!dirPath.startsWith(ensureTrailingDirectorySeparator(relativeTo))) {\n        return undefined;\n    }\n\n    const pathComponents = getPathComponents(dirPath);\n    const relativeToComponents = getPathComponents(relativeTo);\n\n    let relativePath = '.';\n    for (let i = relativeToComponents.length; i < pathComponents.length; i++) {\n        relativePath += path.sep + pathComponents[i];\n    }\n\n    return relativePath;\n}\n\n// Creates a directory hierarchy for a path, starting from some ancestor path.\nexport function makeDirectories(fs: FileSystem, dirPath: string, startingFromDirPath: string) {\n    if (!dirPath.startsWith(startingFromDirPath)) {\n        return;\n    }\n\n    const pathComponents = getPathComponents(dirPath);\n    const relativeToComponents = getPathComponents(startingFromDirPath);\n    let curPath = startingFromDirPath;\n\n    for (let i = relativeToComponents.length; i < pathComponents.length; i++) {\n        curPath = combinePaths(curPath, pathComponents[i]);\n        if (!fs.existsSync(curPath)) {\n            fs.mkdirSync(curPath);\n        }\n    }\n}\n\nexport function getFileSize(fs: FileSystem, path: string) {\n    try {\n        const stat = fs.statSync(path);\n        if (stat.isFile()) {\n            return stat.size;\n        }\n    } catch {\n        // Ignore the exception.\n    }\n    return 0;\n}\n\nexport function fileExists(fs: FileSystem, path: string): boolean {\n    return fileSystemEntryExists(fs, path, FileSystemEntryKind.File);\n}\n\nexport function directoryExists(fs: FileSystem, path: string): boolean {\n    return fileSystemEntryExists(fs, path, FileSystemEntryKind.Directory);\n}\n\nexport function normalizeSlashes(pathString: string): string {\n    const separatorRegExp = /[\\\\/]/g;\n    return pathString.replace(separatorRegExp, path.sep);\n}\n\n/**\n * Combines and resolves paths. If a path is absolute, it replaces any previous path. Any\n * `.` and `..` path components are resolved. Trailing directory separators are preserved.\n *\n * ```ts\n * resolvePath(\"/path\", \"to\", \"file.ext\") === \"path/to/file.ext\"\n * resolvePath(\"/path\", \"to\", \"file.ext/\") === \"path/to/file.ext/\"\n * resolvePath(\"/path\", \"dir\", \"..\", \"to\", \"file.ext\") === \"path/to/file.ext\"\n * ```\n */\nexport function resolvePaths(path: string, ...paths: (string | undefined)[]): string {\n    return normalizePath(some(paths) ? combinePaths(path, ...paths) : normalizeSlashes(path));\n}\n\nexport function combinePaths(pathString: string, ...paths: (string | undefined)[]): string {\n    if (pathString) {\n        pathString = normalizeSlashes(pathString);\n    }\n\n    for (let relativePath of paths) {\n        if (!relativePath) {\n            continue;\n        }\n\n        relativePath = normalizeSlashes(relativePath);\n\n        if (!pathString || getRootLength(relativePath) !== 0) {\n            pathString = relativePath;\n        } else {\n            pathString = ensureTrailingDirectorySeparator(pathString) + relativePath;\n        }\n    }\n\n    return pathString;\n}\n\n/**\n * Compare two paths using the provided case sensitivity.\n */\nexport function comparePaths(a: string, b: string, ignoreCase?: boolean): Comparison;\nexport function comparePaths(a: string, b: string, currentDirectory: string, ignoreCase?: boolean): Comparison;\nexport function comparePaths(a: string, b: string, currentDirectory?: string | boolean, ignoreCase?: boolean) {\n    a = normalizePath(a);\n    b = normalizePath(b);\n\n    if (typeof currentDirectory === 'string') {\n        a = combinePaths(currentDirectory, a);\n        b = combinePaths(currentDirectory, b);\n    } else if (typeof currentDirectory === 'boolean') {\n        ignoreCase = currentDirectory;\n    }\n    return comparePathsWorker(a, b, getStringComparer(ignoreCase));\n}\n\n/**\n * Determines whether a `parent` path contains a `child` path using the provide case sensitivity.\n */\nexport function containsPath(parent: string, child: string, ignoreCase?: boolean): boolean;\nexport function containsPath(parent: string, child: string, currentDirectory: string, ignoreCase?: boolean): boolean;\nexport function containsPath(parent: string, child: string, currentDirectory?: string | boolean, ignoreCase?: boolean) {\n    if (typeof currentDirectory === 'string') {\n        parent = combinePaths(currentDirectory, parent);\n        child = combinePaths(currentDirectory, child);\n    } else if (typeof currentDirectory === 'boolean') {\n        ignoreCase = currentDirectory;\n    }\n\n    if (parent === undefined || child === undefined) {\n        return false;\n    }\n    if (parent === child) {\n        return true;\n    }\n\n    const parentComponents = getPathComponents(parent);\n    const childComponents = getPathComponents(child);\n\n    if (childComponents.length < parentComponents.length) {\n        return false;\n    }\n\n    const componentEqualityComparer = ignoreCase ? equateStringsCaseInsensitive : equateStringsCaseSensitive;\n    for (let i = 0; i < parentComponents.length; i++) {\n        const equalityComparer = i === 0 ? equateStringsCaseInsensitive : componentEqualityComparer;\n        if (!equalityComparer(parentComponents[i], childComponents[i])) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Changes the extension of a path to the provided extension.\n *\n * ```ts\n * changeAnyExtension(\"/path/to/file.ext\", \".js\") === \"/path/to/file.js\"\n * ```\n */\nexport function changeAnyExtension(path: string, ext: string): string;\n\n/**\n * Changes the extension of a path to the provided extension if it has one of the provided extensions.\n *\n * ```ts\n * changeAnyExtension(\"/path/to/file.ext\", \".js\", \".ext\") === \"/path/to/file.js\"\n * changeAnyExtension(\"/path/to/file.ext\", \".js\", \".ts\") === \"/path/to/file.ext\"\n * changeAnyExtension(\"/path/to/file.ext\", \".js\", [\".ext\", \".ts\"]) === \"/path/to/file.js\"\n * ```\n */\nexport function changeAnyExtension(\n    path: string,\n    ext: string,\n    extensions: string | readonly string[],\n    ignoreCase: boolean\n): string;\nexport function changeAnyExtension(\n    path: string,\n    ext: string,\n    extensions?: string | readonly string[],\n    ignoreCase?: boolean\n): string {\n    const pathExt =\n        extensions !== undefined && ignoreCase !== undefined\n            ? getAnyExtensionFromPath(path, extensions, ignoreCase)\n            : getAnyExtensionFromPath(path);\n\n    return pathExt ? path.slice(0, path.length - pathExt.length) + (ext.startsWith('.') ? ext : '.' + ext) : path;\n}\n\n/**\n * Gets the file extension for a path.\n *\n * ```ts\n * getAnyExtensionFromPath(\"/path/to/file.ext\") === \".ext\"\n * getAnyExtensionFromPath(\"/path/to/file.ext/\") === \".ext\"\n * getAnyExtensionFromPath(\"/path/to/file\") === \"\"\n * getAnyExtensionFromPath(\"/path/to.ext/file\") === \"\"\n * ```\n */\nexport function getAnyExtensionFromPath(path: string): string;\n/**\n * Gets the file extension for a path, provided it is one of the provided extensions.\n *\n * ```ts\n * getAnyExtensionFromPath(\"/path/to/file.ext\", \".ext\", true) === \".ext\"\n * getAnyExtensionFromPath(\"/path/to/file.js\", \".ext\", true) === \"\"\n * getAnyExtensionFromPath(\"/path/to/file.js\", [\".ext\", \".js\"], true) === \".js\"\n * getAnyExtensionFromPath(\"/path/to/file.ext\", \".EXT\", false) === \"\"\n */\nexport function getAnyExtensionFromPath(\n    path: string,\n    extensions: string | readonly string[],\n    ignoreCase: boolean\n): string;\nexport function getAnyExtensionFromPath(\n    path: string,\n    extensions?: string | readonly string[],\n    ignoreCase?: boolean\n): string {\n    // Retrieves any string from the final \".\" onwards from a base file name.\n    // Unlike extensionFromPath, which throws an exception on unrecognized extensions.\n    if (extensions) {\n        return getAnyExtensionFromPathWorker(\n            stripTrailingDirectorySeparator(path),\n            extensions,\n            ignoreCase ? equateStringsCaseInsensitive : equateStringsCaseSensitive\n        );\n    }\n    const baseFileName = getBaseFileName(path);\n    const extensionIndex = baseFileName.lastIndexOf('.');\n    if (extensionIndex >= 0) {\n        return baseFileName.substring(extensionIndex);\n    }\n    return '';\n}\n\n/**\n * Returns the path except for its containing directory name.\n * Semantics align with NodeJS's `path.basename` except that we support URLs as well.\n *\n * ```ts\n * // POSIX\n * getBaseFileName(\"/path/to/file.ext\") === \"file.ext\"\n * getBaseFileName(\"/path/to/\") === \"to\"\n * getBaseFileName(\"/\") === \"\"\n * // DOS\n * getBaseFileName(\"c:/path/to/file.ext\") === \"file.ext\"\n * getBaseFileName(\"c:/path/to/\") === \"to\"\n * getBaseFileName(\"c:/\") === \"\"\n * getBaseFileName(\"c:\") === \"\"\n * ```\n */\nexport function getBaseFileName(pathString: string): string;\n/**\n * Gets the portion of a path following the last (non-terminal) separator (`/`).\n * Semantics align with NodeJS's `path.basename` except that we support URLs as well.\n * If the base name has any one of the provided extensions, it is removed.\n *\n * ```ts\n * getBaseFileName(\"/path/to/file.ext\", \".ext\", true) === \"file\"\n * getBaseFileName(\"/path/to/file.js\", \".ext\", true) === \"file.js\"\n * getBaseFileName(\"/path/to/file.js\", [\".ext\", \".js\"], true) === \"file\"\n * getBaseFileName(\"/path/to/file.ext\", \".EXT\", false) === \"file.ext\"\n * ```\n */\nexport function getBaseFileName(\n    pathString: string,\n    extensions: string | readonly string[],\n    ignoreCase: boolean\n): string;\nexport function getBaseFileName(pathString: string, extensions?: string | readonly string[], ignoreCase?: boolean) {\n    pathString = normalizeSlashes(pathString);\n\n    // if the path provided is itself the root, then it has not file name.\n    const rootLength = getRootLength(pathString);\n    if (rootLength === pathString.length) {\n        return '';\n    }\n\n    // return the trailing portion of the path starting after the last (non-terminal) directory\n    // separator but not including any trailing directory separator.\n    pathString = stripTrailingDirectorySeparator(pathString);\n    const name = pathString.slice(Math.max(getRootLength(pathString), pathString.lastIndexOf(path.sep) + 1));\n    const extension =\n        extensions !== undefined && ignoreCase !== undefined\n            ? getAnyExtensionFromPath(name, extensions, ignoreCase)\n            : undefined;\n\n    return extension ? name.slice(0, name.length - extension.length) : name;\n}\n\n/**\n * Gets a relative path that can be used to traverse between `from` and `to`.\n */\nexport function getRelativePathFromDirectory(from: string, to: string, ignoreCase: boolean): string;\n/**\n * Gets a relative path that can be used to traverse between `from` and `to`.\n */\nexport function getRelativePathFromDirectory(\n    fromDirectory: string,\n    to: string,\n    getCanonicalFileName: GetCanonicalFileName\n): string;\nexport function getRelativePathFromDirectory(\n    fromDirectory: string,\n    to: string,\n    getCanonicalFileNameOrIgnoreCase: GetCanonicalFileName | boolean\n) {\n    const pathComponents = getRelativePathComponentsFromDirectory(fromDirectory, to, getCanonicalFileNameOrIgnoreCase);\n    return combinePathComponents(pathComponents);\n}\n\nexport function getRelativePathComponentsFromDirectory(\n    fromDirectory: string,\n    to: string,\n    getCanonicalFileNameOrIgnoreCase: GetCanonicalFileName | boolean\n) {\n    debug.assert(\n        getRootLength(fromDirectory) > 0 === getRootLength(to) > 0,\n        'Paths must either both be absolute or both be relative'\n    );\n    const getCanonicalFileName =\n        typeof getCanonicalFileNameOrIgnoreCase === 'function' ? getCanonicalFileNameOrIgnoreCase : identity;\n    const ignoreCase = typeof getCanonicalFileNameOrIgnoreCase === 'boolean' ? getCanonicalFileNameOrIgnoreCase : false;\n    const pathComponents = getPathComponentsRelativeTo(\n        fromDirectory,\n        to,\n        ignoreCase ? equateStringsCaseInsensitive : equateStringsCaseSensitive,\n        getCanonicalFileName\n    );\n\n    return pathComponents;\n}\n\n/**\n * Performs a case-sensitive comparison of two paths. Path roots are always compared case-insensitively.\n */\nexport function comparePathsCaseSensitive(a: string, b: string) {\n    return comparePathsWorker(a, b, compareStringsCaseSensitive);\n}\n\n/**\n * Performs a case-insensitive comparison of two paths.\n */\nexport function comparePathsCaseInsensitive(a: string, b: string) {\n    return comparePathsWorker(a, b, compareStringsCaseInsensitive);\n}\n\nexport function ensureTrailingDirectorySeparator(pathString: string): string {\n    if (!hasTrailingDirectorySeparator(pathString)) {\n        return pathString + path.sep;\n    }\n\n    return pathString;\n}\n\nexport function hasTrailingDirectorySeparator(pathString: string) {\n    if (pathString.length === 0) {\n        return false;\n    }\n\n    const ch = pathString.charCodeAt(pathString.length - 1);\n    return ch === Char.Slash || ch === Char.Backslash;\n}\n\nexport function stripTrailingDirectorySeparator(pathString: string) {\n    if (!hasTrailingDirectorySeparator(pathString)) {\n        return pathString;\n    }\n    return pathString.substr(0, pathString.length - 1);\n}\n\nexport function getFileExtension(fileName: string, multiDotExtension = false) {\n    if (!multiDotExtension) {\n        return path.extname(fileName);\n    }\n\n    fileName = getFileName(fileName);\n    const firstDotIndex = fileName.indexOf('.');\n    return fileName.substr(firstDotIndex);\n}\n\nexport function getFileName(pathString: string) {\n    return path.basename(pathString);\n}\n\nexport function stripFileExtension(fileName: string, multiDotExtension = false) {\n    const ext = getFileExtension(fileName, multiDotExtension);\n    return fileName.substr(0, fileName.length - ext.length);\n}\n\nexport function normalizePath(pathString: string): string {\n    return normalizeSlashes(path.normalize(pathString));\n}\n\nexport function isDirectory(fs: FileSystem, path: string): boolean {\n    let stat: any;\n    try {\n        stat = fs.statSync(path);\n    } catch (e) {\n        return false;\n    }\n\n    return stat.isDirectory();\n}\n\nexport function isFile(fs: FileSystem, path: string): boolean {\n    let stat: any;\n    try {\n        stat = fs.statSync(path);\n    } catch (e) {\n        return false;\n    }\n\n    return stat.isFile();\n}\n\nexport function getFileSystemEntries(fs: FileSystem, path: string): FileSystemEntries {\n    try {\n        const entries = fs.readdirEntriesSync(path || '.').sort((a, b) => {\n            if (a.name < b.name) {\n                return -1;\n            } else if (a.name > b.name) {\n                return 1;\n            } else {\n                return 0;\n            }\n        });\n        const files: string[] = [];\n        const directories: string[] = [];\n        for (const entry of entries) {\n            // This is necessary because on some file system node fails to exclude\n            // \".\" and \"..\". See https://github.com/nodejs/node/issues/4002\n            if (entry.name === '.' || entry.name === '..') {\n                continue;\n            }\n\n            if (entry.isFile()) {\n                files.push(entry.name);\n            } else if (entry.isDirectory()) {\n                // Don't traverse symbolic links. They can lead to cycles.\n                if (!entry.isSymbolicLink()) {\n                    directories.push(entry.name);\n                }\n            }\n        }\n        return { files, directories };\n    } catch (e) {\n        return { files: [], directories: [] };\n    }\n}\n\n// Transforms a relative file spec (one that potentially contains\n// escape characters **, * or ?) and returns a regular expression\n// that can be used for matching against.\nexport function getWildcardRegexPattern(rootPath: string, fileSpec: string): string {\n    let absolutePath = normalizePath(combinePaths(rootPath, fileSpec));\n    if (!absolutePath.endsWith('.py') && !absolutePath.endsWith('.pyi')) {\n        absolutePath = ensureTrailingDirectorySeparator(absolutePath);\n    }\n\n    const pathComponents = getPathComponents(absolutePath);\n\n    const escapedSeparator = getRegexEscapedSeparator();\n    const doubleAsteriskRegexFragment = `(${escapedSeparator}[^${escapedSeparator}.][^${escapedSeparator}]*)*?`;\n    const reservedCharacterPattern = new RegExp(`[^\\\\w\\\\s${escapedSeparator}]`, 'g');\n\n    // Strip the directory separator from the root component.\n    if (pathComponents.length > 0) {\n        pathComponents[0] = stripTrailingDirectorySeparator(pathComponents[0]);\n    }\n\n    let regExPattern = '';\n    let firstComponent = true;\n\n    for (let component of pathComponents) {\n        if (component === '**') {\n            regExPattern += doubleAsteriskRegexFragment;\n        } else {\n            if (!firstComponent) {\n                component = escapedSeparator + component;\n            }\n\n            regExPattern += component.replace(reservedCharacterPattern, (match) => {\n                if (match === '*') {\n                    return `[^${escapedSeparator}]*`;\n                } else if (match === '?') {\n                    return `[^${escapedSeparator}]`;\n                } else {\n                    // escaping anything that is not reserved characters - word/space/separator\n                    return '\\\\' + match;\n                }\n            });\n\n            firstComponent = false;\n        }\n    }\n\n    return regExPattern;\n}\n\n// Returns the topmost path that contains no wildcard characters.\nexport function getWildcardRoot(rootPath: string, fileSpec: string): string {\n    let absolutePath = normalizePath(combinePaths(rootPath, fileSpec));\n    if (!absolutePath.endsWith('.py') && !absolutePath.endsWith('.pyi')) {\n        absolutePath = ensureTrailingDirectorySeparator(absolutePath);\n    }\n\n    const pathComponents = getPathComponents(absolutePath);\n\n    // Strip the directory separator from the root component.\n    if (pathComponents.length > 0) {\n        pathComponents[0] = stripTrailingDirectorySeparator(pathComponents[0]);\n    }\n\n    let wildcardRoot = '';\n    let firstComponent = true;\n\n    for (let component of pathComponents) {\n        if (component === '**') {\n            break;\n        } else {\n            if (component.match(/[*?]/)) {\n                break;\n            }\n\n            if (!firstComponent) {\n                component = path.sep + component;\n            }\n\n            wildcardRoot += component;\n            firstComponent = false;\n        }\n    }\n\n    return wildcardRoot;\n}\n\nexport function getFileSpec(rootPath: string, fileSpec: string): FileSpec {\n    let regExPattern = getWildcardRegexPattern(rootPath, fileSpec);\n    const escapedSeparator = getRegexEscapedSeparator();\n    regExPattern = `^(${regExPattern})($|${escapedSeparator})`;\n\n    const regExp = new RegExp(regExPattern);\n    const wildcardRoot = getWildcardRoot(rootPath, fileSpec);\n\n    return {\n        wildcardRoot,\n        regExp,\n    };\n}\n\nexport function getRegexEscapedSeparator() {\n    // we don't need to escape \"/\" in typescript regular expression\n    return path.sep === '/' ? '/' : '\\\\\\\\';\n}\n\n/**\n * Determines whether a path is an absolute disk path (e.g. starts with `/`, or a dos path\n * like `c:`, `c:\\` or `c:/`).\n */\nexport function isRootedDiskPath(path: string) {\n    return getRootLength(path) > 0;\n}\n\n/**\n * Determines whether a path consists only of a path root.\n */\nexport function isDiskPathRoot(path: string) {\n    const rootLength = getRootLength(path);\n    return rootLength > 0 && rootLength === path.length;\n}\n\n//// Path Comparisons\nfunction comparePathsWorker(a: string, b: string, componentComparer: (a: string, b: string) => Comparison) {\n    if (a === b) {\n        return Comparison.EqualTo;\n    }\n    if (a === undefined) {\n        return Comparison.LessThan;\n    }\n    if (b === undefined) {\n        return Comparison.GreaterThan;\n    }\n\n    // NOTE: Performance optimization - shortcut if the root segments differ as there would be no\n    //       need to perform path reduction.\n    const aRoot = a.substring(0, getRootLength(a));\n    const bRoot = b.substring(0, getRootLength(b));\n    const result = compareStringsCaseInsensitive(aRoot, bRoot);\n    if (result !== Comparison.EqualTo) {\n        return result;\n    }\n\n    // check path for these segments: '', '.'. '..'\n    const escapedSeparator = getRegexEscapedSeparator();\n    const relativePathSegmentRegExp = new RegExp(`(^|${escapedSeparator}).{0,2}($|${escapedSeparator})`);\n\n    // NOTE: Performance optimization - shortcut if there are no relative path segments in\n    //       the non-root portion of the path\n    const aRest = a.substring(aRoot.length);\n    const bRest = b.substring(bRoot.length);\n    if (!relativePathSegmentRegExp.test(aRest) && !relativePathSegmentRegExp.test(bRest)) {\n        return componentComparer(aRest, bRest);\n    }\n\n    // The path contains a relative path segment. Normalize the paths and perform a slower component\n    // by component comparison.\n    const aComponents = getPathComponents(a);\n    const bComponents = getPathComponents(b);\n    const sharedLength = Math.min(aComponents.length, bComponents.length);\n    for (let i = 1; i < sharedLength; i++) {\n        const result = componentComparer(aComponents[i], bComponents[i]);\n        if (result !== Comparison.EqualTo) {\n            return result;\n        }\n    }\n\n    return compareValues(aComponents.length, bComponents.length);\n}\n\nfunction getAnyExtensionFromPathWorker(\n    path: string,\n    extensions: string | readonly string[],\n    stringEqualityComparer: (a: string, b: string) => boolean\n) {\n    if (typeof extensions === 'string') {\n        return tryGetExtensionFromPath(path, extensions, stringEqualityComparer) || '';\n    }\n    for (const extension of extensions) {\n        const result = tryGetExtensionFromPath(path, extension, stringEqualityComparer);\n        if (result) {\n            return result;\n        }\n    }\n    return '';\n}\n\nfunction tryGetExtensionFromPath(\n    path: string,\n    extension: string,\n    stringEqualityComparer: (a: string, b: string) => boolean\n) {\n    if (!extension.startsWith('.')) {\n        extension = '.' + extension;\n    }\n    if (path.length >= extension.length && path.charCodeAt(path.length - extension.length) === Char.Period) {\n        const pathExtension = path.slice(path.length - extension.length);\n        if (stringEqualityComparer(pathExtension, extension)) {\n            return pathExtension;\n        }\n    }\n\n    return undefined;\n}\n\nfunction getPathComponentsRelativeTo(\n    from: string,\n    to: string,\n    stringEqualityComparer: (a: string, b: string) => boolean,\n    getCanonicalFileName: GetCanonicalFileName\n) {\n    const fromComponents = getPathComponents(from);\n    const toComponents = getPathComponents(to);\n\n    let start: number;\n    for (start = 0; start < fromComponents.length && start < toComponents.length; start++) {\n        const fromComponent = getCanonicalFileName(fromComponents[start]);\n        const toComponent = getCanonicalFileName(toComponents[start]);\n        const comparer = start === 0 ? equateStringsCaseInsensitive : stringEqualityComparer;\n        if (!comparer(fromComponent, toComponent)) {\n            break;\n        }\n    }\n\n    if (start === 0) {\n        return toComponents;\n    }\n\n    const components = toComponents.slice(start);\n    const relative: string[] = [];\n    for (; start < fromComponents.length; start++) {\n        relative.push('..');\n    }\n    return ['', ...relative, ...components];\n}\n\nconst enum FileSystemEntryKind {\n    File,\n    Directory,\n}\n\nfunction fileSystemEntryExists(fs: FileSystem, path: string, entryKind: FileSystemEntryKind): boolean {\n    try {\n        const stat = fs.statSync(path);\n        switch (entryKind) {\n            case FileSystemEntryKind.File:\n                return stat.isFile();\n            case FileSystemEntryKind.Directory:\n                return stat.isDirectory();\n            default:\n                return false;\n        }\n    } catch (e) {\n        return false;\n    }\n}\n\nexport function convertUriToPath(uriString: string): string {\n    const uri = URI.parse(uriString);\n    let convertedPath = normalizePath(uri.path);\n    // If this is a DOS-style path with a drive letter, remove\n    // the leading slash.\n    if (convertedPath.match(/^\\\\[a-zA-Z]:\\\\/)) {\n        convertedPath = convertedPath.substr(1);\n    }\n    return convertedPath;\n}\n\nexport function convertPathToUri(path: string): string {\n    return URI.file(path).toString();\n}\n\n// For file systems that are case-insensitive, returns a lowercase\n// version of the path. For case-sensitive file systems, leaves the\n// path as is.\nexport function normalizePathCase(fs: FileSystem, path: string) {\n    if (isFileSystemCaseSensitive(fs)) {\n        return path;\n    }\n\n    return path.toLowerCase();\n}\n\nexport function isFileSystemCaseSensitive(fs: FileSystem) {\n    if (_fsCaseSensitivity !== undefined) {\n        return _fsCaseSensitivity;\n    }\n\n    _fsCaseSensitivity = isFileSystemCaseSensitiveInternal(fs);\n    return _fsCaseSensitivity;\n}\n\nexport function isFileSystemCaseSensitiveInternal(fs: FileSystem) {\n    let filePath: string | undefined = undefined;\n    try {\n        // Make sure tmp dir exists.\n        if (!fs.existsSync(fs.tmpdir())) {\n            fs.mkdirSync(fs.tmpdir(), { recursive: true });\n        }\n\n        // Make unique file name.\n        let name: string;\n        let mangledFilePath: string;\n        do {\n            name = `${randomBytes(21).toString('hex')}-a`;\n            filePath = path.join(fs.tmpdir(), name);\n            mangledFilePath = path.join(fs.tmpdir(), name.toUpperCase());\n        } while (fs.existsSync(filePath) || fs.existsSync(mangledFilePath));\n\n        fs.writeFileSync(filePath, '', 'utf8');\n\n        // If file exists, then it is insensitive.\n        return !fs.existsSync(mangledFilePath);\n    } catch (e) {\n        return false;\n    } finally {\n        if (filePath) {\n            // remove temp file created\n            fs.unlinkSync(filePath);\n        }\n    }\n}\n","/*\n * positionUtils.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Utility routines for converting between file offsets and\n * line/column positions.\n */\n\nimport { assert } from './debug';\nimport { Position, Range, TextRange } from './textRange';\nimport { TextRangeCollection } from './textRangeCollection';\n\n// Translates a file offset into a line/column pair.\nexport function convertOffsetToPosition(offset: number, lines: TextRangeCollection<TextRange>): Position {\n    // Handle the case where the file is empty.\n    if (lines.end === 0) {\n        return {\n            line: 0,\n            character: 0,\n        };\n    }\n\n    // Handle the case where we're pointing to the last line of the file.\n    let offsetAdjustment = 0;\n    if (offset >= lines.end) {\n        offset = lines.end - 1;\n        offsetAdjustment = 1;\n    }\n\n    const itemIndex = lines.getItemContaining(offset);\n    assert(itemIndex >= 0 && itemIndex <= lines.length);\n    const lineRange = lines.getItemAt(itemIndex);\n    assert(lineRange !== undefined);\n    return {\n        line: itemIndex,\n        character: offset - lineRange.start + offsetAdjustment,\n    };\n}\n\n// Translates a start/end file offset into a pair of line/column positions.\nexport function convertOffsetsToRange(\n    startOffset: number,\n    endOffset: number,\n    lines: TextRangeCollection<TextRange>\n): Range {\n    const start = convertOffsetToPosition(startOffset, lines);\n    const end = convertOffsetToPosition(endOffset, lines);\n    return { start, end };\n}\n\n// Translates a position (line and col) into a file offset.\nexport function convertPositionToOffset(position: Position, lines: TextRangeCollection<TextRange>): number | undefined {\n    if (position.line >= lines.count) {\n        return undefined;\n    }\n\n    return lines.getItemAt(position.line).start + position.character;\n}\n\nexport function convertRangeToTextRange(range: Range, lines: TextRangeCollection<TextRange>): TextRange | undefined {\n    const start = convertPositionToOffset(range.start, lines);\n    if (start === undefined) {\n        return undefined;\n    }\n\n    const end = convertPositionToOffset(range.end, lines);\n    if (end === undefined) {\n        return undefined;\n    }\n\n    return TextRange.fromBounds(start, end);\n}\n","/*\n * progressReporter.ts\n *\n * Implements progress reporter.\n */\n\nexport interface ProgressReporter {\n    isEnabled(data: any): boolean;\n    begin(): void;\n    report(message: string): void;\n    end(): void;\n}\n\nexport class ProgressReportTracker implements ProgressReporter {\n    // Tracks whether we're currently displaying progress.\n    private _isDisplayingProgress = false;\n\n    constructor(private _reporter?: ProgressReporter) {}\n\n    isEnabled(data: any): boolean {\n        if (this._isDisplayingProgress) {\n            return true;\n        }\n\n        return this._reporter?.isEnabled(data) ?? false;\n    }\n\n    begin(): void {\n        if (this._isDisplayingProgress) {\n            return;\n        }\n\n        this._isDisplayingProgress = true;\n        this._reporter?.begin();\n    }\n\n    report(message: string): void {\n        if (!this._isDisplayingProgress) {\n            return;\n        }\n\n        this._reporter?.report(message);\n    }\n\n    end(): void {\n        if (!this._isDisplayingProgress) {\n            return;\n        }\n\n        this._isDisplayingProgress = false;\n        this._reporter?.end();\n    }\n}\n","/*\n * pythonLanguageVersion.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Types and functions that relate to the Python language version\n * and features within them.\n */\n\nexport enum PythonVersion {\n    // The order of this enumeration is significant. We assume\n    // that we can use comparison operators to check for older\n    // or newer versions.\n    V3_0 = 0x0300,\n    V3_1 = 0x0301,\n    V3_2 = 0x0302,\n    V3_3 = 0x0303,\n    V3_4 = 0x0304,\n    V3_5 = 0x0305,\n    V3_6 = 0x0306,\n    V3_7 = 0x0307,\n    V3_8 = 0x0308,\n    V3_9 = 0x0309,\n    V3_10 = 0x030a,\n}\n\nexport const latestStablePythonVersion = PythonVersion.V3_9;\nexport const latestPythonVersion = PythonVersion.V3_9;\n\nexport function versionToString(version: PythonVersion): string {\n    const majorVersion = (version >> 8) & 0xff;\n    const minorVersion = version & 0xff;\n    return `${majorVersion}.${minorVersion}`;\n}\n\nexport function versionFromString(verString: string): PythonVersion | undefined {\n    const split = verString.split('.');\n    if (split.length < 2) {\n        return undefined;\n    }\n\n    const majorVersion = parseInt(split[0], 10);\n    const minorVersion = parseInt(split[1], 10);\n\n    return versionFromMajorMinor(majorVersion, minorVersion);\n}\n\nexport function versionFromMajorMinor(major: number, minor: number): PythonVersion | undefined {\n    if (isNaN(major) || isNaN(minor)) {\n        return undefined;\n    }\n\n    if (major > 255 || minor > 255) {\n        return undefined;\n    }\n\n    const value = major * 256 + minor;\n    if (PythonVersion[value] === undefined) {\n        return undefined;\n    }\n\n    // Pyright currently supports only 3.x.\n    if (!is3x(value)) {\n        return undefined;\n    }\n\n    return value;\n}\n\nexport function is3x(version: PythonVersion): boolean {\n    return version >> 8 === 3;\n}\n","/*\n * stringUtils.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Utility methods for manipulating and comparing strings.\n */\n\nimport leven from 'leven';\n\nimport { compareComparableValues, Comparison } from './core';\n\n// Determines how closely a typed string matches a symbol\n// name. An exact match returns 1. A match that differs\n// only in case returns a slightly lower number. A match\n// that involves a few missing or added characters returns\n// an even lower number.\nexport function computeCompletionSimilarity(typedValue: string, symbolName: string): number {\n    if (symbolName.startsWith(typedValue)) {\n        return 1;\n    }\n\n    const symbolLower = symbolName.toLocaleLowerCase();\n    const typedLower = typedValue.toLocaleLowerCase();\n\n    if (symbolLower.startsWith(typedLower)) {\n        return 0.75;\n    }\n\n    // How far apart are the two strings? Find the smallest edit\n    // distance for each of the substrings taken from the start of\n    // symbolName.\n    let symbolSubstrLength = symbolLower.length;\n    let smallestEditDistance = Number.MAX_VALUE;\n    while (symbolSubstrLength > 0) {\n        const editDistance = leven(symbolLower.substr(0, symbolSubstrLength), typedLower);\n        if (editDistance < smallestEditDistance) {\n            smallestEditDistance = editDistance;\n        }\n        symbolSubstrLength--;\n    }\n\n    // We'll take into account the length of the typed value. If the user\n    // has typed more characters, and they largely match the symbol name,\n    // it is considered more similar. If the the edit distance is similar\n    // to the number of characters the user has typed, then there's almost\n    // no similarity.\n    if (smallestEditDistance >= typedValue.length) {\n        return 0;\n    }\n\n    const similarity = (typedValue.length - smallestEditDistance) / typedValue.length;\n    return 0.5 * similarity;\n}\n\n// This is a simple, non-cryptographic hash function for text.\nexport function hashString(contents: string) {\n    let hash = 0;\n\n    for (let i = 0; i < contents.length; i++) {\n        hash = ((hash << 5) - hash + contents.charCodeAt(i)) | 0;\n    }\n    return hash;\n}\n\n/**\n * Compare two strings using a case-insensitive ordinal comparison.\n *\n * Ordinal comparisons are based on the difference between the unicode code points of both\n * strings. Characters with multiple unicode representations are considered unequal. Ordinal\n * comparisons provide predictable ordering, but place \"a\" after \"B\".\n *\n * Case-insensitive comparisons compare both strings one code-point at a time using the integer\n * value of each code-point after applying `toUpperCase` to each string. We always map both\n * strings to their upper-case form as some unicode characters do not properly round-trip to\n * lowercase (such as `áºž` (German sharp capital s)).\n */\nexport function compareStringsCaseInsensitive(a: string | undefined, b: string | undefined): Comparison {\n    return a === b\n        ? Comparison.EqualTo\n        : a === undefined\n        ? Comparison.LessThan\n        : b === undefined\n        ? Comparison.GreaterThan\n        : compareComparableValues(a.toUpperCase(), b.toUpperCase());\n}\n\n/**\n * Compare two strings using a case-sensitive ordinal comparison.\n *\n * Ordinal comparisons are based on the difference between the unicode code points of both\n * strings. Characters with multiple unicode representations are considered unequal. Ordinal\n * comparisons provide predictable ordering, but place \"a\" after \"B\".\n *\n * Case-sensitive comparisons compare both strings one code-point at a time using the integer\n * value of each code-point.\n */\nexport function compareStringsCaseSensitive(a: string | undefined, b: string | undefined): Comparison {\n    return compareComparableValues(a, b);\n}\n\nexport function getStringComparer(ignoreCase?: boolean) {\n    return ignoreCase ? compareStringsCaseInsensitive : compareStringsCaseSensitive;\n}\n\n/**\n * Compare the equality of two strings using a case-insensitive ordinal comparison.\n *\n * Case-insensitive comparisons compare both strings one code-point at a time using the integer\n * value of each code-point after applying `toUpperCase` to each string. We always map both\n * strings to their upper-case form as some unicode characters do not properly round-trip to\n * lowercase (such as `ẞ` (German sharp capital s)).\n */\nexport function equateStringsCaseInsensitive(a: string, b: string) {\n    return compareStringsCaseInsensitive(a, b) === Comparison.EqualTo;\n}\n\n/**\n * Compare the equality of two strings using a case-sensitive ordinal comparison.\n *\n * Case-sensitive comparisons compare both strings one code-point at a time using the\n * integer value of each code-point.\n */\nexport function equateStringsCaseSensitive(a: string, b: string) {\n    return compareStringsCaseSensitive(a, b) === Comparison.EqualTo;\n}\n\nexport function getCharacterCount(value: string, ch: string) {\n    let result = 0;\n    for (let i = 0; i < value.length; i++) {\n        if (value[i] === ch) {\n            result++;\n        }\n    }\n    return result;\n}\n","/*\n * textEditUtils.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * Language server command execution functionality.\n */\n\nimport { TextEdit, WorkspaceEdit } from 'vscode-languageserver';\n\nimport { FileEditAction, TextEditAction } from '../common/editAction';\nimport { convertPathToUri } from '../common/pathUtils';\n\nexport function convertTextEdits(uri: string, editActions: TextEditAction[] | undefined): WorkspaceEdit {\n    if (!editActions) {\n        return {};\n    }\n\n    const edits: TextEdit[] = [];\n    editActions.forEach((editAction) => {\n        edits.push({\n            range: editAction.range,\n            newText: editAction.replacementText,\n        });\n    });\n\n    return {\n        changes: {\n            [uri]: edits,\n        },\n    };\n}\n\nexport function convertWorkspaceEdits(edits: FileEditAction[]) {\n    const workspaceEdits: WorkspaceEdit = {\n        changes: {},\n    };\n\n    edits.forEach((edit) => {\n        const uri = convertPathToUri(edit.filePath);\n        workspaceEdits.changes![uri] = workspaceEdits.changes![uri] || [];\n        workspaceEdits.changes![uri].push({ range: edit.range, newText: edit.replacementText });\n    });\n\n    return workspaceEdits;\n}\n","/*\n * textRange.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Specifies the range of text within a larger string.\n */\n\nexport interface TextRange {\n    start: number;\n    length: number;\n}\n\nexport namespace TextRange {\n    export function create(start: number, length: number): TextRange {\n        if (start < 0) {\n            throw new Error('start must be non-negative');\n        }\n        if (length < 0) {\n            throw new Error('length must be non-negative');\n        }\n        return { start, length };\n    }\n\n    export function fromBounds(start: number, end: number): TextRange {\n        if (start < 0) {\n            throw new Error('start must be non-negative');\n        }\n        if (start > end) {\n            throw new Error('end must be greater than or equal to start');\n        }\n        return create(start, end - start);\n    }\n\n    export function getEnd(range: TextRange): number {\n        return range.start + range.length;\n    }\n\n    export function contains(range: TextRange, position: number): boolean {\n        return position >= range.start && position < getEnd(range);\n    }\n\n    export function extend(range: TextRange, extension: TextRange | TextRange[] | undefined) {\n        if (extension) {\n            if (Array.isArray(extension)) {\n                extension.forEach((r) => {\n                    extend(range, r);\n                });\n            } else {\n                if (extension.start < range.start) {\n                    range.length += range.start - extension.start;\n                    range.start = extension.start;\n                }\n\n                if (getEnd(extension) > getEnd(range)) {\n                    range.length += getEnd(extension) - getEnd(range);\n                }\n            }\n        }\n    }\n}\n\nexport interface Position {\n    // Both line and column are zero-based\n    line: number;\n    character: number;\n}\n\nnamespace Position {\n    export function is(value: any): value is Position {\n        const candidate = value as Position;\n        return candidate && candidate.line !== void 0 && candidate.character !== void 0;\n    }\n}\n\nexport interface Range {\n    start: Position;\n    end: Position;\n}\n\nnamespace Range {\n    export function is(value: any): value is Range {\n        const candidate = value as Range;\n        return candidate && candidate.start !== void 0 && candidate.end !== void 0;\n    }\n}\n\n// Represents a range within a particular document.\nexport interface DocumentRange {\n    path: string;\n    range: Range;\n}\n\nexport function comparePositions(a: Position, b: Position) {\n    if (a.line < b.line) {\n        return -1;\n    } else if (a.line > b.line) {\n        return 1;\n    } else if (a.character < b.character) {\n        return -1;\n    } else if (a.character > b.character) {\n        return 1;\n    }\n    return 0;\n}\n\nexport function getEmptyPosition(): Position {\n    return {\n        line: 0,\n        character: 0,\n    };\n}\n\nexport function doRangesOverlap(a: Range, b: Range) {\n    if (comparePositions(b.start, a.end) >= 0) {\n        return false;\n    } else if (comparePositions(a.start, b.end) >= 0) {\n        return false;\n    }\n    return true;\n}\n\nexport function doRangesIntersect(a: Range, b: Range) {\n    if (comparePositions(b.start, a.end) > 0) {\n        return false;\n    } else if (comparePositions(a.start, b.end) > 0) {\n        return false;\n    }\n    return true;\n}\n\nexport function doesRangeContain(range: Range, positionOrRange: Position | Range): boolean {\n    if (Position.is(positionOrRange)) {\n        return comparePositions(range.start, positionOrRange) <= 0 && comparePositions(range.end, positionOrRange) >= 0;\n    }\n\n    return doesRangeContain(range, positionOrRange.start) && doesRangeContain(range, positionOrRange.end);\n}\n\nexport function rangesAreEqual(a: Range, b: Range) {\n    return comparePositions(a.start, b.start) === 0 && comparePositions(a.end, b.end) === 0;\n}\n\nexport function getEmptyRange(): Range {\n    return {\n        start: getEmptyPosition(),\n        end: getEmptyPosition(),\n    };\n}\n","/*\n * textRangeCollection.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Based on code from vscode-python repository:\n *  https://github.com/Microsoft/vscode-python\n *\n * Class that maintains an ordered list of text ranges and allows\n * for indexing and fast lookups within this list.\n */\n\nimport { TextRange } from './textRange';\n\nexport class TextRangeCollection<T extends TextRange> {\n    private _items: T[];\n\n    constructor(items: T[]) {\n        this._items = items;\n    }\n\n    get start(): number {\n        return this._items.length > 0 ? this._items[0].start : 0;\n    }\n\n    get end(): number {\n        const lastItem = this._items[this._items.length - 1];\n        return this._items.length > 0 ? lastItem.start + lastItem.length : 0;\n    }\n\n    get length(): number {\n        return this.end - this.start;\n    }\n\n    get count(): number {\n        return this._items.length;\n    }\n\n    contains(position: number) {\n        return position >= this.start && position < this.end;\n    }\n\n    getItemAt(index: number): T {\n        if (index < 0 || index >= this._items.length) {\n            throw new Error('index is out of range');\n        }\n        return this._items[index];\n    }\n\n    // Returns the nearest item prior to the position.\n    // The position may not be contained within the item.\n    getItemAtPosition(position: number): number {\n        if (this.count === 0) {\n            return -1;\n        }\n        if (position < this.start) {\n            return -1;\n        }\n        if (position > this.end) {\n            return -1;\n        }\n\n        let min = 0;\n        let max = this.count - 1;\n\n        while (min < max) {\n            const mid = Math.floor(min + (max - min) / 2);\n            const item = this._items[mid];\n\n            // Is the position past the start of this item but before\n            // the start of the next item? If so, we found our item.\n            if (position >= item.start) {\n                if (mid >= this.count - 1 || position < this._items[mid + 1].start) {\n                    return mid;\n                }\n            }\n\n            if (position < item.start) {\n                max = mid - 1;\n            } else {\n                min = mid + 1;\n            }\n        }\n        return min;\n    }\n\n    getItemContaining(position: number): number {\n        if (this.count === 0) {\n            return -1;\n        }\n        if (position < this.start) {\n            return -1;\n        }\n        if (position > this.end) {\n            return -1;\n        }\n\n        let min = 0;\n        let max = this.count - 1;\n\n        while (min <= max) {\n            const mid = Math.floor(min + (max - min) / 2);\n            const item = this._items[mid];\n\n            if (TextRange.contains(item, position)) {\n                return mid;\n            }\n\n            if (mid < this.count - 1 && TextRange.getEnd(item) <= position && position < this._items[mid + 1].start) {\n                return -1;\n            }\n\n            if (position < item.start) {\n                max = mid - 1;\n            } else {\n                min = mid + 1;\n            }\n        }\n        return -1;\n    }\n}\n","/*\n * timing.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * A simple duration class that can be used to record and report\n * durations at the millisecond level of resolution.\n */\n\nimport { ConsoleInterface } from './console';\n\nexport class Duration {\n    private _startTime: number;\n\n    constructor() {\n        this._startTime = Date.now();\n    }\n\n    getDurationInMilliseconds() {\n        const curTime = Date.now();\n        return curTime - this._startTime;\n    }\n\n    getDurationInSeconds() {\n        return this.getDurationInMilliseconds() / 1000;\n    }\n}\n\nexport class TimingStat {\n    totalTime = 0;\n    isTiming = false;\n\n    timeOperation(callback: () => void) {\n        // Handle reentrancy.\n        if (this.isTiming) {\n            callback();\n        } else {\n            this.isTiming = true;\n            const duration = new Duration();\n            callback();\n            this.totalTime += duration.getDurationInMilliseconds();\n            this.isTiming = false;\n        }\n    }\n\n    subtractFromTime(callback: () => void) {\n        if (this.isTiming) {\n            this.isTiming = false;\n            const duration = new Duration();\n            callback();\n            this.totalTime -= duration.getDurationInMilliseconds();\n            this.isTiming = true;\n        } else {\n            callback();\n        }\n    }\n\n    printTime(): string {\n        const totalTimeInSec = this.totalTime / 1000;\n        const roundedTime = Math.round(totalTimeInSec * 100) / 100;\n        return roundedTime.toString() + 'sec';\n    }\n}\n\nexport class TimingStats {\n    totalDuration = new Duration();\n    findFilesTime = new TimingStat();\n    readFileTime = new TimingStat();\n    tokenizeFileTime = new TimingStat();\n    parseFileTime = new TimingStat();\n    resolveImportsTime = new TimingStat();\n    cycleDetectionTime = new TimingStat();\n    bindTime = new TimingStat();\n    typeCheckerTime = new TimingStat();\n\n    printSummary(console: ConsoleInterface) {\n        console.info(`Completed in ${this.totalDuration.getDurationInSeconds()}sec`);\n    }\n\n    printDetails(console: ConsoleInterface) {\n        console.info('');\n        console.info('Timing stats');\n        console.info('Find Source Files:    ' + this.findFilesTime.printTime());\n        console.info('Read Source Files:    ' + this.readFileTime.printTime());\n        console.info('Tokenize:             ' + this.tokenizeFileTime.printTime());\n        console.info('Parse:                ' + this.parseFileTime.printTime());\n        console.info('Resolve Imports:      ' + this.resolveImportsTime.printTime());\n        console.info('Bind:                 ' + this.bindTime.printTime());\n        console.info('Check:                ' + this.typeCheckerTime.printTime());\n        console.info('Detect Cycles:        ' + this.cycleDetectionTime.printTime());\n    }\n}\n\nexport const timingStats = new TimingStats();\n","/*\n * languageServerBase.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * Implements common language server functionality.\n * This is split out as a base class to allow for\n * different language server variants to be created\n * from the same core functionality.\n */\n\nimport './common/extensions';\n\nimport * as fs from 'fs';\nimport {\n    CancellationToken,\n    CancellationTokenSource,\n    CodeAction,\n    CodeActionParams,\n    Command,\n    CompletionList,\n    CompletionParams,\n    CompletionTriggerKind,\n    ConfigurationItem,\n    Connection,\n    ConnectionOptions,\n    createConnection,\n    Diagnostic,\n    DiagnosticRelatedInformation,\n    DiagnosticSeverity,\n    DiagnosticTag,\n    DidChangeWatchedFilesNotification,\n    DocumentSymbol,\n    ExecuteCommandParams,\n    InitializeParams,\n    InitializeResult,\n    Location,\n    ParameterInformation,\n    RemoteWindow,\n    SignatureHelpTriggerKind,\n    SignatureInformation,\n    SymbolInformation,\n    TextDocumentSyncKind,\n    WatchKind,\n    WorkDoneProgressReporter,\n    WorkspaceEdit,\n    WorkspaceFolder,\n} from 'vscode-languageserver/node';\n\nimport { AnalysisResults } from './analyzer/analysis';\nimport { BackgroundAnalysisProgram } from './analyzer/backgroundAnalysisProgram';\nimport { ImportResolver } from './analyzer/importResolver';\nimport { MaxAnalysisTime } from './analyzer/program';\nimport { AnalyzerService, configFileNames } from './analyzer/service';\nimport { BackgroundAnalysisBase } from './backgroundAnalysisBase';\nimport { CancelAfter, getCancellationStrategyFromArgv } from './common/cancellationUtils';\nimport { getNestedProperty } from './common/collectionUtils';\nimport {\n    DiagnosticSeverityOverrides,\n    DiagnosticSeverityOverridesMap,\n    getDiagnosticSeverityOverrides,\n} from './common/commandLineOptions';\nimport { ConfigOptions, getDiagLevelDiagnosticRules } from './common/configOptions';\nimport { ConsoleInterface, ConsoleWithLogLevel, LogLevel } from './common/console';\nimport { createDeferred, Deferred } from './common/deferred';\nimport { Diagnostic as AnalyzerDiagnostic, DiagnosticCategory } from './common/diagnostic';\nimport { DiagnosticRule } from './common/diagnosticRules';\nimport { LanguageServiceExtension } from './common/extensibility';\nimport {\n    createFromRealFileSystem,\n    FileSystem,\n    FileWatcher,\n    FileWatcherEventHandler,\n    FileWatcherEventType,\n} from './common/fileSystem';\nimport { containsPath, convertPathToUri, convertUriToPath } from './common/pathUtils';\nimport { ProgressReporter, ProgressReportTracker } from './common/progressReporter';\nimport { convertWorkspaceEdits } from './common/textEditUtils';\nimport { Position } from './common/textRange';\nimport { AnalyzerServiceExecutor } from './languageService/analyzerServiceExecutor';\nimport { CompletionItemData, CompletionResults } from './languageService/completionProvider';\nimport { convertHoverResults } from './languageService/hoverProvider';\nimport { Localizer } from './localization/localize';\nimport { WorkspaceMap } from './workspaceMap';\n\nexport interface ServerSettings {\n    venvPath?: string;\n    pythonPath?: string;\n    typeshedPath?: string;\n    stubPath?: string;\n    openFilesOnly?: boolean;\n    typeCheckingMode?: string;\n    useLibraryCodeForTypes?: boolean;\n    disableLanguageServices?: boolean;\n    disableOrganizeImports?: boolean;\n    autoSearchPaths?: boolean;\n    extraPaths?: string[];\n    watchForSourceChanges?: boolean;\n    watchForLibraryChanges?: boolean;\n    diagnosticSeverityOverrides?: DiagnosticSeverityOverridesMap;\n    logLevel?: LogLevel;\n    autoImportCompletions?: boolean;\n    indexing?: boolean;\n}\n\nexport interface WorkspaceServiceInstance {\n    workspaceName: string;\n    rootPath: string;\n    rootUri: string;\n    serviceInstance: AnalyzerService;\n    disableLanguageServices: boolean;\n    disableOrganizeImports: boolean;\n    isInitialized: Deferred<boolean>;\n}\n\nexport interface WindowInterface {\n    showErrorMessage(message: string): void;\n    showWarningMessage(message: string): void;\n    showInformationMessage(message: string): void;\n}\n\nexport interface LanguageServerInterface {\n    getWorkspaceForFile(filePath: string): Promise<WorkspaceServiceInstance>;\n    getSettings(workspace: WorkspaceServiceInstance): Promise<ServerSettings>;\n    createBackgroundAnalysis(): BackgroundAnalysisBase | undefined;\n    reanalyze(): void;\n    restart(): void;\n\n    readonly rootPath: string;\n    readonly console: ConsoleInterface;\n    readonly window: WindowInterface;\n    readonly fs: FileSystem;\n}\n\n// This is a subset of the LSP Connection, defined to not expose the LSP library\n// in the public interface.\nexport interface ProgressReporterConnection {\n    sendNotification: (method: string, params?: any) => void;\n}\n\nexport interface ServerOptions {\n    productName: string;\n    rootDirectory: string;\n    version: string;\n    extension?: LanguageServiceExtension;\n    maxAnalysisTimeInForeground?: MaxAnalysisTime;\n    supportedCommands?: string[];\n    supportedCodeActions?: string[];\n    progressReporterFactory?: (connection: ProgressReporterConnection) => ProgressReporter;\n}\n\ninterface InternalFileWatcher extends FileWatcher {\n    // Paths that are being watched within the workspace\n    workspacePaths: string[];\n\n    // Event handler to call\n    eventHandler: FileWatcherEventHandler;\n}\n\nexport abstract class LanguageServerBase implements LanguageServerInterface {\n    // Create a connection for the server. The connection type can be changed by the process's arguments\n    protected _connection: Connection = createConnection(this._GetConnectionOptions());\n    protected _workspaceMap: WorkspaceMap;\n    protected _hasConfigurationCapability = false;\n    protected _hasVisualStudioExtensionsCapability = false;\n    protected _hasWorkspaceFoldersCapability = false;\n    protected _hasWatchFileCapability = false;\n    protected _hasActiveParameterCapability = false;\n    protected _hasSignatureLabelOffsetCapability = false;\n    protected _supportsUnnecessaryDiagnosticTag = false;\n    protected _defaultClientConfig: any;\n\n    // Tracks active file system watchers.\n    private _fileWatchers: InternalFileWatcher[] = [];\n\n    // We support running only one \"find all reference\" at a time.\n    private _pendingFindAllRefsCancellationSource: CancellationTokenSource | undefined;\n\n    // We support running only one command at a time.\n    private _pendingCommandCancellationSource: CancellationTokenSource | undefined;\n\n    private _progressReporter: ProgressReporter;\n\n    private _lastTriggerKind: CompletionTriggerKind | undefined = CompletionTriggerKind.Invoked;\n\n    // Global root path - the basis for all global settings.\n    rootPath = '';\n\n    // File system abstraction.\n    fs: FileSystem;\n\n    readonly console: ConsoleInterface;\n\n    constructor(private _serverOptions: ServerOptions) {\n        this.console = new ConsoleWithLogLevel(this._connection.console);\n\n        this.console.info(\n            `${_serverOptions.productName} language server ${\n                _serverOptions.version && _serverOptions.version + ' '\n            }starting`\n        );\n\n        this.fs = createFromRealFileSystem(this.console, this);\n\n        // Set the working directory to a known location within\n        // the extension directory. Otherwise the execution of\n        // python can have unintended and surprising results.\n        const moduleDirectory = this.fs.getModulePath();\n        if (moduleDirectory) {\n            this.fs.chdir(moduleDirectory);\n        }\n\n        // Stash the base directory into a global variable.\n        (global as any).__rootDirectory = _serverOptions.rootDirectory;\n        this.console.info(`Server root directory: ${_serverOptions.rootDirectory}`);\n\n        // Create workspace map.\n        this._workspaceMap = new WorkspaceMap(this);\n\n        // Set up callbacks.\n        this.setupConnection(_serverOptions.supportedCommands ?? [], _serverOptions.supportedCodeActions ?? []);\n\n        this._progressReporter = new ProgressReportTracker(\n            this._serverOptions.progressReporterFactory\n                ? this._serverOptions.progressReporterFactory(this._connection)\n                : undefined\n        );\n\n        // Listen on the connection.\n        this._connection.listen();\n    }\n\n    abstract createBackgroundAnalysis(): BackgroundAnalysisBase | undefined;\n\n    protected abstract async executeCommand(params: ExecuteCommandParams, token: CancellationToken): Promise<any>;\n    protected isLongRunningCommand(command: string): boolean {\n        // By default, all commands are considered \"long-running\" and should\n        // display a cancelable progress dialog. Servers can override this\n        // to avoid showing the progress dialog for commands that are\n        // guaranteed to be quick.\n        return true;\n    }\n\n    protected abstract async executeCodeAction(\n        params: CodeActionParams,\n        token: CancellationToken\n    ): Promise<(Command | CodeAction)[] | undefined | null>;\n\n    abstract async getSettings(workspace: WorkspaceServiceInstance): Promise<ServerSettings>;\n\n    protected async getConfiguration(scopeUri: string | undefined, section: string) {\n        if (this._hasConfigurationCapability) {\n            const item: ConfigurationItem = {\n                scopeUri,\n                section,\n            };\n            return this._connection.workspace.getConfiguration(item);\n        }\n\n        if (this._defaultClientConfig) {\n            return getNestedProperty(this._defaultClientConfig, section);\n        }\n\n        return undefined;\n    }\n\n    protected isOpenFilesOnly(diagnosticMode: string): boolean {\n        return diagnosticMode !== 'workspace';\n    }\n\n    protected getSeverityOverrides(value: string): DiagnosticSeverityOverrides | undefined {\n        const enumValue = value as DiagnosticSeverityOverrides;\n        if (getDiagnosticSeverityOverrides().includes(enumValue)) {\n            return enumValue;\n        }\n\n        return undefined;\n    }\n\n    protected getDiagnosticRuleName(value: string): DiagnosticRule | undefined {\n        const enumValue = value as DiagnosticRule;\n        if (getDiagLevelDiagnosticRules().includes(enumValue)) {\n            return enumValue;\n        }\n\n        return undefined;\n    }\n\n    protected createImportResolver(fs: FileSystem, options: ConfigOptions): ImportResolver {\n        return new ImportResolver(fs, options);\n    }\n\n    protected createBackgroundAnalysisProgram(\n        console: ConsoleInterface,\n        configOptions: ConfigOptions,\n        importResolver: ImportResolver,\n        extension?: LanguageServiceExtension,\n        backgroundAnalysis?: BackgroundAnalysisBase,\n        maxAnalysisTime?: MaxAnalysisTime\n    ): BackgroundAnalysisProgram {\n        return new BackgroundAnalysisProgram(\n            console,\n            configOptions,\n            importResolver,\n            extension,\n            backgroundAnalysis,\n            maxAnalysisTime\n        );\n    }\n\n    protected setExtension(extension: any): void {\n        this._serverOptions.extension = extension;\n    }\n\n    // Provides access to the client's window.\n    get window(): RemoteWindow {\n        return this._connection.window;\n    }\n\n    // Creates a service instance that's used for analyzing a\n    // program within a workspace.\n    createAnalyzerService(name: string): AnalyzerService {\n        this.console.log(`Starting service instance \"${name}\"`);\n        const service = new AnalyzerService(\n            name,\n            this.fs,\n            this.console,\n            this.createImportResolver.bind(this),\n            undefined,\n            this._serverOptions.extension,\n            this.createBackgroundAnalysis(),\n            this._serverOptions.maxAnalysisTimeInForeground,\n            this.createBackgroundAnalysisProgram.bind(this)\n        );\n\n        service.setCompletionCallback((results) => this.onAnalysisCompletedHandler(results));\n\n        return service;\n    }\n\n    async getWorkspaceForFile(filePath: string): Promise<WorkspaceServiceInstance> {\n        const workspace = this._workspaceMap.getWorkspaceForFile(filePath);\n        await workspace.isInitialized.promise;\n        return workspace;\n    }\n\n    reanalyze() {\n        this._workspaceMap.forEach((workspace) => {\n            workspace.serviceInstance.invalidateAndForceReanalysis();\n        });\n    }\n\n    restart() {\n        this._workspaceMap.forEach((workspace) => {\n            workspace.serviceInstance.restart();\n        });\n    }\n\n    createFileWatcher(paths: string[], listener: FileWatcherEventHandler): FileWatcher {\n        // Capture \"this\" so we can reference it within the \"close\" method below.\n        const lsBase = this;\n\n        // Determine which paths are located within one or more workspaces.\n        // Those are already covered by existing file watchers handled by\n        // the client.\n        const workspacePaths: string[] = [];\n        const nonWorkspacePaths: string[] = [];\n        const workspaces = this._workspaceMap.getNonDefaultWorkspaces();\n\n        paths.forEach((path) => {\n            if (workspaces.some((workspace) => containsPath(workspace.rootPath, path))) {\n                workspacePaths.push(path);\n            } else {\n                nonWorkspacePaths.push(path);\n            }\n        });\n\n        // For any non-workspace paths, use the node file watcher.\n        const nodeWatchers = nonWorkspacePaths.map((path) => {\n            return fs.watch(path, { recursive: true }, (event, filename) =>\n                listener(event as FileWatcherEventType, filename)\n            );\n        });\n\n        const fileWatcher: InternalFileWatcher = {\n            close() {\n                // Stop listening for workspace paths.\n                lsBase._fileWatchers = lsBase._fileWatchers.filter((watcher) => watcher !== fileWatcher);\n\n                // Close the node watchers.\n                nodeWatchers.forEach((watcher) => {\n                    watcher.close();\n                });\n            },\n            workspacePaths,\n            eventHandler: listener,\n        };\n\n        // Record the file watcher.\n        this._fileWatchers.push(fileWatcher);\n\n        return fileWatcher;\n    }\n\n    protected setupConnection(supportedCommands: string[], supportedCodeActions: string[]): void {\n        // After the server has started the client sends an initialize request. The server receives\n        // in the passed params the rootPath of the workspace plus the client capabilities.\n        this._connection.onInitialize((params) => this.initialize(params, supportedCommands, supportedCodeActions));\n\n        this._connection.onDidChangeConfiguration((params) => {\n            this.console.log(`Received updated settings`);\n            if (params?.settings) {\n                this._defaultClientConfig = params?.settings;\n            }\n            this.updateSettingsForAllWorkspaces();\n        });\n\n        this._connection.onCodeAction((params, token) => this.executeCodeAction(params, token));\n\n        this._connection.onDefinition(async (params, token) => {\n            this.recordUserInteractionTime();\n\n            const filePath = convertUriToPath(params.textDocument.uri);\n\n            const position: Position = {\n                line: params.position.line,\n                character: params.position.character,\n            };\n\n            const workspace = await this.getWorkspaceForFile(filePath);\n            if (workspace.disableLanguageServices) {\n                return;\n            }\n            const locations = workspace.serviceInstance.getDefinitionForPosition(filePath, position, token);\n            if (!locations) {\n                return undefined;\n            }\n            return locations.map((loc) => Location.create(convertPathToUri(loc.path), loc.range));\n        });\n\n        this._connection.onReferences(async (params, token, reporter) => {\n            if (this._pendingFindAllRefsCancellationSource) {\n                this._pendingFindAllRefsCancellationSource.cancel();\n                this._pendingFindAllRefsCancellationSource = undefined;\n            }\n\n            // VS Code doesn't support cancellation of \"final all references\".\n            // We provide a progress bar a cancellation button so the user can cancel\n            // any long-running actions.\n            const progress = await this._getProgressReporter(\n                params.workDoneToken,\n                reporter,\n                Localizer.CodeAction.findingReferences()\n            );\n            const source = CancelAfter(token, progress.token);\n            this._pendingFindAllRefsCancellationSource = source;\n\n            try {\n                const filePath = convertUriToPath(params.textDocument.uri);\n                const position: Position = {\n                    line: params.position.line,\n                    character: params.position.character,\n                };\n\n                const workspace = await this.getWorkspaceForFile(filePath);\n                if (workspace.disableLanguageServices) {\n                    return;\n                }\n\n                const locations = workspace.serviceInstance.getReferencesForPosition(\n                    filePath,\n                    position,\n                    params.context.includeDeclaration,\n                    source.token\n                );\n\n                if (!locations) {\n                    return undefined;\n                }\n\n                return locations.map((loc) => Location.create(convertPathToUri(loc.path), loc.range));\n            } finally {\n                progress.reporter.done();\n                source.dispose();\n            }\n        });\n\n        this._connection.onDocumentSymbol(async (params, token) => {\n            this.recordUserInteractionTime();\n\n            const filePath = convertUriToPath(params.textDocument.uri);\n\n            const workspace = await this.getWorkspaceForFile(filePath);\n            if (workspace.disableLanguageServices) {\n                return undefined;\n            }\n\n            const symbolList: DocumentSymbol[] = [];\n            workspace.serviceInstance.addSymbolsForDocument(filePath, symbolList, token);\n            return symbolList;\n        });\n\n        this._connection.onWorkspaceSymbol(async (params, token) => {\n            const symbolList: SymbolInformation[] = [];\n\n            for (const workspace of this._workspaceMap.values()) {\n                await workspace.isInitialized.promise;\n                if (!workspace.disableLanguageServices) {\n                    workspace.serviceInstance.addSymbolsForWorkspace(symbolList, params.query, token);\n                }\n            }\n\n            return symbolList;\n        });\n\n        this._connection.onHover(async (params, token) => {\n            const filePath = convertUriToPath(params.textDocument.uri);\n\n            const position: Position = {\n                line: params.position.line,\n                character: params.position.character,\n            };\n\n            const workspace = await this.getWorkspaceForFile(filePath);\n            const hoverResults = workspace.serviceInstance.getHoverForPosition(filePath, position, token);\n            return convertHoverResults(hoverResults);\n        });\n\n        this._connection.onDocumentHighlight(async (params, token) => {\n            const filePath = convertUriToPath(params.textDocument.uri);\n\n            const position: Position = {\n                line: params.position.line,\n                character: params.position.character,\n            };\n\n            const workspace = await this.getWorkspaceForFile(filePath);\n            return workspace.serviceInstance.getDocumentHighlight(filePath, position, token);\n        });\n\n        this._connection.onSignatureHelp(async (params, token) => {\n            const filePath = convertUriToPath(params.textDocument.uri);\n\n            const position: Position = {\n                line: params.position.line,\n                character: params.position.character,\n            };\n\n            const workspace = await this.getWorkspaceForFile(filePath);\n            if (workspace.disableLanguageServices) {\n                return;\n            }\n            const signatureHelpResults = workspace.serviceInstance.getSignatureHelpForPosition(\n                filePath,\n                position,\n                token\n            );\n            if (!signatureHelpResults) {\n                return undefined;\n            }\n\n            const signatures = signatureHelpResults.signatures.map((sig) => {\n                let paramInfo: ParameterInformation[] = [];\n                if (sig.parameters) {\n                    paramInfo = sig.parameters.map((param) =>\n                        ParameterInformation.create(\n                            this._hasSignatureLabelOffsetCapability ? [param.startOffset, param.endOffset] : param.text,\n                            param.documentation\n                        )\n                    );\n                }\n\n                const sigInfo = SignatureInformation.create(sig.label, sig.documentation, ...paramInfo);\n                sigInfo.activeParameter = sig.activeParameter;\n                return sigInfo;\n            });\n\n            // A signature is active if it contains an active parameter,\n            // or if both the signature and its invocation have no parameters.\n            const isActive = (sig: SignatureInformation) =>\n                sig.activeParameter !== undefined ||\n                (!signatureHelpResults.callHasParameters && !sig.parameters?.length);\n\n            let activeSignature: number | null = signatures.findIndex(isActive);\n            if (activeSignature === -1) {\n                activeSignature = null;\n            }\n\n            let activeParameter = activeSignature !== null ? signatures[activeSignature].activeParameter! : null;\n\n            // Check if we should reuse the user's signature selection. If the retrigger was not \"invoked\"\n            // (i.e., the signature help call was automatically generated by the client due to some navigation\n            // or text change), check to see if the previous signature is still \"active\". If so, we mark it as\n            // active in our response.\n            //\n            // This isn't a perfect method. For nested calls, we can't tell when we are moving between them.\n            // Ideally, we would include a token in the signature help responses to compare later, allowing us\n            // to know when the user's navigated to a nested call (and therefore the old signature's info does\n            // not apply), but for now manually retriggering the signature help will work around the issue.\n            if (params.context?.isRetrigger && params.context.triggerKind !== SignatureHelpTriggerKind.Invoked) {\n                const prevActiveSignature = params.context.activeSignatureHelp?.activeSignature ?? null;\n                if (prevActiveSignature !== null && prevActiveSignature < signatures.length) {\n                    const sig = signatures[prevActiveSignature];\n                    if (isActive(sig)) {\n                        activeSignature = prevActiveSignature;\n                        activeParameter = sig.activeParameter ?? null;\n                    }\n                }\n            }\n\n            if (this._hasActiveParameterCapability || activeSignature === null) {\n                // A value of -1 is out of bounds but is legal within the LSP (should be treated\n                // as undefined). It produces a better result in VS Code by preventing it from\n                // highlighting the first parameter when no parameter works, since the LSP client\n                // converts null into zero.\n                activeParameter = -1;\n            }\n\n            return { signatures, activeSignature, activeParameter };\n        });\n\n        this._connection.onCompletion((params, token) => this.onCompletion(params, token));\n\n        this._connection.onCompletionResolve(async (params, token) => {\n            // Cancellation bugs in vscode and LSP:\n            // https://github.com/microsoft/vscode-languageserver-node/issues/615\n            // https://github.com/microsoft/vscode/issues/95485\n            //\n            // If resolver throws cancellation exception, LSP and VSCode\n            // cache that result and never call us back.\n            const completionItemData = params.data as CompletionItemData;\n            if (completionItemData && completionItemData.filePath) {\n                const workspace = await this.getWorkspaceForFile(completionItemData.workspacePath);\n                workspace.serviceInstance.resolveCompletionItem(completionItemData.filePath, params, token);\n            }\n            return params;\n        });\n\n        this._connection.onRenameRequest(async (params, token) => {\n            const filePath = convertUriToPath(params.textDocument.uri);\n\n            const position: Position = {\n                line: params.position.line,\n                character: params.position.character,\n            };\n\n            const workspace = await this.getWorkspaceForFile(filePath);\n            if (workspace.disableLanguageServices) {\n                return;\n            }\n\n            const editActions = workspace.serviceInstance.renameSymbolAtPosition(\n                filePath,\n                position,\n                params.newName,\n                token\n            );\n\n            if (!editActions) {\n                return undefined;\n            }\n\n            return convertWorkspaceEdits(editActions);\n        });\n\n        this._connection.languages.callHierarchy.onPrepare(async (params, token) => {\n            const filePath = convertUriToPath(params.textDocument.uri);\n\n            const position: Position = {\n                line: params.position.line,\n                character: params.position.character,\n            };\n\n            const workspace = await this.getWorkspaceForFile(filePath);\n            if (workspace.disableLanguageServices) {\n                return null;\n            }\n\n            const callItem = workspace.serviceInstance.getCallForPosition(filePath, position, token) || null;\n            if (!callItem) {\n                return null;\n            }\n\n            // Convert the file path in the item to proper URI.\n            callItem.uri = convertPathToUri(callItem.uri);\n\n            return [callItem];\n        });\n\n        this._connection.languages.callHierarchy.onIncomingCalls(async (params, token) => {\n            const filePath = convertUriToPath(params.item.uri);\n\n            const position: Position = {\n                line: params.item.range.start.line,\n                character: params.item.range.start.character,\n            };\n\n            const workspace = await this.getWorkspaceForFile(filePath);\n            if (workspace.disableLanguageServices) {\n                return null;\n            }\n\n            const callItems = workspace.serviceInstance.getIncomingCallsForPosition(filePath, position, token) || null;\n            if (!callItems || callItems.length === 0) {\n                return null;\n            }\n\n            // Convert the file paths in the items to proper URIs.\n            callItems.forEach((item) => {\n                item.from.uri = convertPathToUri(item.from.uri);\n            });\n\n            return callItems;\n        });\n\n        this._connection.languages.callHierarchy.onOutgoingCalls(async (params, token) => {\n            const filePath = convertUriToPath(params.item.uri);\n\n            const position: Position = {\n                line: params.item.range.start.line,\n                character: params.item.range.start.character,\n            };\n\n            const workspace = await this.getWorkspaceForFile(filePath);\n            if (workspace.disableLanguageServices) {\n                return null;\n            }\n\n            const callItems = workspace.serviceInstance.getOutgoingCallsForPosition(filePath, position, token) || null;\n            if (!callItems || callItems.length === 0) {\n                return null;\n            }\n\n            // Convert the file paths in the items to proper URIs.\n            callItems.forEach((item) => {\n                item.to.uri = convertPathToUri(item.to.uri);\n            });\n\n            return callItems;\n        });\n\n        this._connection.onDidOpenTextDocument(async (params) => {\n            const filePath = convertUriToPath(params.textDocument.uri);\n            const workspace = await this.getWorkspaceForFile(filePath);\n            workspace.serviceInstance.setFileOpened(filePath, params.textDocument.version, params.textDocument.text);\n        });\n\n        this._connection.onDidChangeTextDocument(async (params) => {\n            this.recordUserInteractionTime();\n\n            const filePath = convertUriToPath(params.textDocument.uri);\n            const workspace = await this.getWorkspaceForFile(filePath);\n            workspace.serviceInstance.updateOpenFileContents(\n                filePath,\n                params.textDocument.version,\n                params.contentChanges[0].text\n            );\n        });\n\n        this._connection.onDidCloseTextDocument(async (params) => {\n            const filePath = convertUriToPath(params.textDocument.uri);\n            const workspace = await this.getWorkspaceForFile(filePath);\n            workspace.serviceInstance.setFileClosed(filePath);\n        });\n\n        this._connection.onDidChangeWatchedFiles((params) => {\n            params.changes.forEach((change) => {\n                const filePath = convertUriToPath(change.uri);\n                const eventType: FileWatcherEventType = change.type === 1 ? 'add' : 'change';\n                this._fileWatchers.forEach((watcher) => {\n                    if (watcher.workspacePaths.some((dirPath) => containsPath(dirPath, filePath))) {\n                        watcher.eventHandler(eventType, filePath);\n                    }\n                });\n            });\n        });\n\n        this._connection.onInitialized(() => {\n            if (this._hasWorkspaceFoldersCapability) {\n                this._connection.workspace.onDidChangeWorkspaceFolders((event) => {\n                    event.removed.forEach((workspace) => {\n                        const rootPath = convertUriToPath(workspace.uri);\n                        this._workspaceMap.delete(rootPath);\n                    });\n\n                    event.added.forEach(async (workspace) => {\n                        const rootPath = convertUriToPath(workspace.uri);\n                        const newWorkspace = this.createWorkspaceServiceInstance(workspace, rootPath);\n                        this._workspaceMap.set(rootPath, newWorkspace);\n                        await this.updateSettingsForWorkspace(newWorkspace);\n                    });\n                });\n            }\n\n            // Set up our file watchers.\n            if (this._hasWatchFileCapability) {\n                this._connection.client.register(DidChangeWatchedFilesNotification.type, {\n                    watchers: [\n                        ...configFileNames.map((fileName) => {\n                            return {\n                                globPattern: `**/${fileName}`,\n                                kind: WatchKind.Create | WatchKind.Change | WatchKind.Delete,\n                            };\n                        }),\n                        {\n                            globPattern: '**/*.{py,pyi}',\n                            kind: WatchKind.Create | WatchKind.Change | WatchKind.Delete,\n                        },\n                    ],\n                });\n            }\n        });\n\n        this._connection.onExecuteCommand(async (params, token, reporter) => {\n            // Cancel running command if there is one.\n            if (this._pendingCommandCancellationSource) {\n                this._pendingCommandCancellationSource.cancel();\n                this._pendingCommandCancellationSource = undefined;\n            }\n\n            const executeCommand = async (token: CancellationToken) => {\n                const result = await this.executeCommand(params, token);\n                if (WorkspaceEdit.is(result)) {\n                    // Tell client to apply edits.\n                    this._connection.workspace.applyEdit(result);\n                }\n            };\n\n            if (this.isLongRunningCommand(params.command)) {\n                // Create a progress dialog for long-running commands.\n                const progress = await this._getProgressReporter(\n                    params.workDoneToken,\n                    reporter,\n                    Localizer.CodeAction.executingCommand()\n                );\n                const source = CancelAfter(token, progress.token);\n                this._pendingCommandCancellationSource = source;\n\n                try {\n                    await executeCommand(source.token);\n                } finally {\n                    progress.reporter.done();\n                    source.dispose();\n                }\n            } else {\n                executeCommand(token);\n            }\n        });\n    }\n\n    protected getWorkspaceCompletionsForPosition(\n        workspace: WorkspaceServiceInstance,\n        filePath: string,\n        position: Position,\n        workspacePath: string,\n        token: CancellationToken\n    ): Promise<CompletionResults | undefined> {\n        return workspace.serviceInstance.getCompletionsForPosition(filePath, position, workspacePath, token);\n    }\n\n    updateSettingsForAllWorkspaces(): void {\n        this._workspaceMap.forEach((workspace) => {\n            this.updateSettingsForWorkspace(workspace).ignoreErrors();\n        });\n    }\n\n    protected initialize(\n        params: InitializeParams,\n        supportedCommands: string[],\n        supportedCodeActions: string[]\n    ): InitializeResult {\n        this.rootPath = params.rootPath || '';\n\n        const capabilities = params.capabilities;\n        this._hasConfigurationCapability = !!capabilities.workspace?.configuration;\n        this._hasWatchFileCapability = !!capabilities.workspace?.didChangeWatchedFiles?.dynamicRegistration;\n        this._hasWorkspaceFoldersCapability = !!capabilities.workspace?.workspaceFolders;\n        this._hasVisualStudioExtensionsCapability = !!(capabilities as any).supportsVisualStudioExtensions;\n        this._hasActiveParameterCapability = !!capabilities.textDocument?.signatureHelp?.signatureInformation\n            ?.activeParameterSupport;\n        this._hasSignatureLabelOffsetCapability = !!capabilities.textDocument?.signatureHelp?.signatureInformation\n            ?.parameterInformation?.labelOffsetSupport;\n        const supportedDiagnosticTags = capabilities.textDocument?.publishDiagnostics?.tagSupport?.valueSet || [];\n        this._supportsUnnecessaryDiagnosticTag = supportedDiagnosticTags.some(\n            (tag) => tag === DiagnosticTag.Unnecessary\n        );\n\n        // Create a service instance for each of the workspace folders.\n        if (params.workspaceFolders) {\n            params.workspaceFolders.forEach((folder) => {\n                const path = convertUriToPath(folder.uri);\n                this._workspaceMap.set(path, this.createWorkspaceServiceInstance(folder, path));\n            });\n        } else if (params.rootPath) {\n            this._workspaceMap.set(params.rootPath, this.createWorkspaceServiceInstance(undefined, params.rootPath));\n        }\n\n        const result: InitializeResult = {\n            capabilities: {\n                // Tell the client that the server works in FULL text document\n                // sync mode (as opposed to incremental).\n                textDocumentSync: TextDocumentSyncKind.Full,\n                definitionProvider: { workDoneProgress: true },\n                referencesProvider: { workDoneProgress: true },\n                documentSymbolProvider: { workDoneProgress: true },\n                workspaceSymbolProvider: { workDoneProgress: true },\n                hoverProvider: { workDoneProgress: true },\n                documentHighlightProvider: { workDoneProgress: true },\n                renameProvider: { workDoneProgress: true },\n                completionProvider: {\n                    triggerCharacters: ['.', '['],\n                    resolveProvider: true,\n                    workDoneProgress: true,\n                },\n                signatureHelpProvider: {\n                    triggerCharacters: ['(', ',', ')'],\n                    workDoneProgress: true,\n                },\n                codeActionProvider: {\n                    codeActionKinds: supportedCodeActions,\n                    workDoneProgress: true,\n                },\n                executeCommandProvider: {\n                    commands: supportedCommands,\n                    workDoneProgress: true,\n                },\n                callHierarchyProvider: true,\n            },\n        };\n\n        return result;\n    }\n\n    protected createWorkspaceServiceInstance(\n        workspace: WorkspaceFolder | undefined,\n        rootPath: string\n    ): WorkspaceServiceInstance {\n        return {\n            workspaceName: workspace?.name ?? '',\n            rootPath,\n            rootUri: workspace?.uri ?? '',\n            serviceInstance: this.createAnalyzerService(workspace?.name ?? rootPath),\n            disableLanguageServices: false,\n            disableOrganizeImports: false,\n            isInitialized: createDeferred<boolean>(),\n        };\n    }\n\n    protected onAnalysisCompletedHandler(results: AnalysisResults): void {\n        // Send the computed diagnostics to the client.\n        results.diagnostics.forEach((fileDiag) => {\n            this._connection.sendDiagnostics({\n                uri: convertPathToUri(fileDiag.filePath),\n                diagnostics: this._convertDiagnostics(fileDiag.diagnostics),\n            });\n        });\n\n        if (!this._progressReporter.isEnabled(results)) {\n            // Make sure to disable progress bar if it is currently active.\n            // This can happen if a user changes typeCheckingMode in the middle\n            // of analysis.\n            // end() is noop if there is no active progress bar.\n            this._progressReporter.end();\n            return;\n        }\n\n        // Update progress.\n        if (results.filesRequiringAnalysis > 0) {\n            this._progressReporter.begin();\n\n            const progressMessage =\n                results.filesRequiringAnalysis === 1\n                    ? Localizer.CodeAction.filesToAnalyzeOne()\n                    : Localizer.CodeAction.filesToAnalyzeCount().format({\n                          count: results.filesRequiringAnalysis,\n                      });\n            this._progressReporter.report(progressMessage);\n        } else {\n            this._progressReporter.end();\n        }\n    }\n\n    async updateSettingsForWorkspace(\n        workspace: WorkspaceServiceInstance,\n        serverSettings?: ServerSettings\n    ): Promise<void> {\n        serverSettings = serverSettings ?? (await this.getSettings(workspace));\n\n        // Set logging level first.\n        (this.console as ConsoleWithLogLevel).level = serverSettings.logLevel ?? LogLevel.Info;\n\n        this.updateOptionsAndRestartService(workspace, serverSettings);\n        workspace.disableLanguageServices = !!serverSettings.disableLanguageServices;\n        workspace.disableOrganizeImports = !!serverSettings.disableOrganizeImports;\n\n        // The workspace is now open for business.\n        workspace.isInitialized.resolve(true);\n    }\n\n    updateOptionsAndRestartService(\n        workspace: WorkspaceServiceInstance,\n        serverSettings: ServerSettings,\n        typeStubTargetImportName?: string\n    ) {\n        AnalyzerServiceExecutor.runWithOptions(this.rootPath, workspace, serverSettings, typeStubTargetImportName);\n    }\n\n    protected async onCompletion(\n        params: CompletionParams,\n        token: CancellationToken\n    ): Promise<CompletionList | undefined> {\n        // We set completion incomplete for the first invocation and next consecutive call,\n        // but after that we mark it as completed so the client doesn't repeatedly call back.\n        // We mark the first one as incomplete because completion could be invoked without\n        // any meaningful character provided, such as an explicit completion invocation (ctrl+space)\n        // or a period. That might cause us to not include some items (e.g., auto-imports).\n        // The next consecutive call provides some characters to help us to pick\n        // better completion items. After that, we are not going to introduce new items,\n        // so we can let the client to do the filtering and caching.\n        const completionIncomplete =\n            this._lastTriggerKind !== CompletionTriggerKind.TriggerForIncompleteCompletions ||\n            params.context?.triggerKind !== CompletionTriggerKind.TriggerForIncompleteCompletions;\n\n        this._lastTriggerKind = params.context?.triggerKind;\n\n        const filePath = convertUriToPath(params.textDocument.uri);\n        const position: Position = {\n            line: params.position.line,\n            character: params.position.character,\n        };\n\n        const workspace = await this.getWorkspaceForFile(filePath);\n        if (workspace.disableLanguageServices) {\n            return;\n        }\n\n        const completions = await this.getWorkspaceCompletionsForPosition(\n            workspace,\n            filePath,\n            position,\n            workspace.rootPath,\n            token\n        );\n\n        if (completions && completions.completionList) {\n            completions.completionList.isIncomplete = completionIncomplete;\n        }\n\n        return completions?.completionList;\n    }\n\n    protected convertLogLevel(logLevelValue?: string): LogLevel {\n        if (!logLevelValue) {\n            return LogLevel.Info;\n        }\n\n        switch (logLevelValue.toLowerCase()) {\n            case 'error':\n                return LogLevel.Error;\n\n            case 'warning':\n                return LogLevel.Warn;\n\n            case 'information':\n                return LogLevel.Info;\n\n            case 'trace':\n                return LogLevel.Log;\n\n            default:\n                return LogLevel.Info;\n        }\n    }\n\n    private async _getProgressReporter(\n        workDoneToken: string | number | undefined,\n        clientReporter: WorkDoneProgressReporter,\n        title: string\n    ) {\n        if (workDoneToken) {\n            return { reporter: clientReporter, token: CancellationToken.None };\n        }\n\n        const serverInitiatedReporter = await this._connection.window.createWorkDoneProgress();\n        serverInitiatedReporter.begin(title, undefined, undefined, true);\n\n        return {\n            reporter: serverInitiatedReporter,\n            token: serverInitiatedReporter.token,\n        };\n    }\n\n    private _GetConnectionOptions(): ConnectionOptions {\n        return { cancellationStrategy: getCancellationStrategyFromArgv(process.argv) };\n    }\n\n    private _convertDiagnostics(diags: AnalyzerDiagnostic[]): Diagnostic[] {\n        const convertedDiags: Diagnostic[] = [];\n\n        diags.forEach((diag) => {\n            const severity = convertCategoryToSeverity(diag.category);\n\n            let source = this._serverOptions.productName;\n            const rule = diag.getRule();\n            if (rule) {\n                source = `${source} (${rule})`;\n            }\n\n            const vsDiag = Diagnostic.create(diag.range, diag.message, severity, undefined, source);\n\n            if (diag.category === DiagnosticCategory.UnusedCode) {\n                vsDiag.tags = [DiagnosticTag.Unnecessary];\n                vsDiag.severity = DiagnosticSeverity.Hint;\n\n                // If the client doesn't support \"unnecessary\" tags, don't report unused code.\n                if (!this._supportsUnnecessaryDiagnosticTag) {\n                    return;\n                }\n            }\n\n            const relatedInfo = diag.getRelatedInfo();\n            if (relatedInfo.length > 0) {\n                vsDiag.relatedInformation = relatedInfo.map((info) => {\n                    return DiagnosticRelatedInformation.create(\n                        Location.create(convertPathToUri(info.filePath), info.range),\n                        info.message\n                    );\n                });\n            }\n\n            convertedDiags.push(vsDiag);\n        });\n\n        function convertCategoryToSeverity(category: DiagnosticCategory) {\n            switch (category) {\n                case DiagnosticCategory.Error:\n                    return DiagnosticSeverity.Error;\n                case DiagnosticCategory.Warning:\n                    return DiagnosticSeverity.Warning;\n                case DiagnosticCategory.Information:\n                    return DiagnosticSeverity.Information;\n                case DiagnosticCategory.UnusedCode:\n                    return DiagnosticSeverity.Hint;\n            }\n        }\n\n        return convertedDiags;\n    }\n\n    protected recordUserInteractionTime() {\n        // Tell all of the services that the user is actively\n        // interacting with one or more editors, so they should\n        // back off from performing any work.\n        this._workspaceMap.forEach((workspace: { serviceInstance: { recordUserInteractionTime: () => void } }) => {\n            workspace.serviceInstance.recordUserInteractionTime();\n        });\n    }\n}\n","/*\n * analyzerServiceExecutor.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Runs the analyzer service of a given workspace service instance\n * with a specified set of options.\n */\n\nimport { CommandLineOptions } from '../common/commandLineOptions';\nimport { combinePaths, normalizePath } from '../common/pathUtils';\nimport { ServerSettings, WorkspaceServiceInstance } from '../languageServerBase';\n\nexport class AnalyzerServiceExecutor {\n    static runWithOptions(\n        languageServiceRootPath: string,\n        workspace: WorkspaceServiceInstance,\n        serverSettings: ServerSettings,\n        typeStubTargetImportName?: string,\n        trackFiles = true\n    ): void {\n        const commandLineOptions = getEffectiveCommandLineOptions(\n            languageServiceRootPath,\n            workspace.rootPath,\n            serverSettings,\n            trackFiles,\n            typeStubTargetImportName\n        );\n\n        // Setting options causes the analyzer service to re-analyze everything.\n        workspace.serviceInstance.setOptions(commandLineOptions, trackFiles);\n    }\n}\n\nfunction getEffectiveCommandLineOptions(\n    languageServiceRootPath: string,\n    workspaceRootPath: string,\n    serverSettings: ServerSettings,\n    trackFiles: boolean,\n    typeStubTargetImportName?: string\n) {\n    const commandLineOptions = new CommandLineOptions(workspaceRootPath, true);\n    commandLineOptions.checkOnlyOpenFiles = serverSettings.openFilesOnly;\n    commandLineOptions.useLibraryCodeForTypes = serverSettings.useLibraryCodeForTypes;\n    commandLineOptions.typeCheckingMode = serverSettings.typeCheckingMode;\n    commandLineOptions.autoImportCompletions = serverSettings.autoImportCompletions;\n    commandLineOptions.indexing = serverSettings.indexing;\n\n    if (!trackFiles) {\n        commandLineOptions.watchForSourceChanges = false;\n        commandLineOptions.watchForLibraryChanges = false;\n    } else {\n        commandLineOptions.watchForSourceChanges = serverSettings.watchForSourceChanges;\n        commandLineOptions.watchForLibraryChanges = serverSettings.watchForLibraryChanges;\n    }\n\n    if (serverSettings.venvPath) {\n        commandLineOptions.venvPath = combinePaths(\n            workspaceRootPath || languageServiceRootPath,\n            normalizePath(_expandPathVariables(languageServiceRootPath, serverSettings.venvPath))\n        );\n    }\n\n    if (serverSettings.pythonPath) {\n        // The Python VS Code extension treats the value \"python\" specially. This means\n        // the local python interpreter should be used rather than interpreting the\n        // setting value as a path to the interpreter. We'll simply ignore it in this case.\n        if (serverSettings.pythonPath.trim() !== 'python') {\n            commandLineOptions.pythonPath = combinePaths(\n                workspaceRootPath || languageServiceRootPath,\n                normalizePath(_expandPathVariables(languageServiceRootPath, serverSettings.pythonPath))\n            );\n        }\n    }\n\n    if (serverSettings.typeshedPath) {\n        // Pyright supports only one typeshed path currently, whereas the\n        // official VS Code Python extension supports multiple typeshed paths.\n        // We'll use the first one specified and ignore the rest.\n        commandLineOptions.typeshedPath = normalizePath(\n            _expandPathVariables(languageServiceRootPath, serverSettings.typeshedPath)\n        );\n    }\n\n    if (serverSettings.stubPath) {\n        commandLineOptions.stubPath = normalizePath(\n            _expandPathVariables(languageServiceRootPath, serverSettings.stubPath)\n        );\n    }\n\n    if (typeStubTargetImportName) {\n        commandLineOptions.typeStubTargetImportName = typeStubTargetImportName;\n    }\n\n    commandLineOptions.autoSearchPaths = serverSettings.autoSearchPaths;\n    commandLineOptions.extraPaths = serverSettings.extraPaths;\n    commandLineOptions.diagnosticSeverityOverrides = serverSettings.diagnosticSeverityOverrides;\n\n    return commandLineOptions;\n}\n\n// Expands certain predefined variables supported within VS Code settings.\n// Ideally, VS Code would provide an API for doing this expansion, but\n// it doesn't. We'll handle the most common variables here as a convenience.\nfunction _expandPathVariables(rootPath: string, value: string): string {\n    const regexp = /\\$\\{(.*?)\\}/g;\n    return value.replace(regexp, (match: string, name: string) => {\n        const trimmedName = name.trim();\n        if (trimmedName === 'workspaceFolder') {\n            return rootPath;\n        }\n        return match;\n    });\n}\n","/*\n * autoImporter.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n */\n\nimport { CancellationToken, CompletionItemKind, SymbolKind } from 'vscode-languageserver';\n\nimport * as AnalyzerNodeInfo from '../analyzer/analyzerNodeInfo';\nimport { DeclarationType } from '../analyzer/declaration';\nimport { ImportResolver, ModuleNameAndType } from '../analyzer/importResolver';\nimport { ImportType } from '../analyzer/importResult';\nimport {\n    getImportGroup,\n    getTextEditsForAutoImportInsertion,\n    getTextEditsForAutoImportSymbolAddition,\n    getTopLevelImports,\n    ImportGroup,\n    ImportStatements,\n} from '../analyzer/importStatementUtils';\nimport { SourceFileInfo } from '../analyzer/program';\nimport { Symbol } from '../analyzer/symbol';\nimport * as SymbolNameUtils from '../analyzer/symbolNameUtils';\nimport { throwIfCancellationRequested } from '../common/cancellationUtils';\nimport { ConfigOptions } from '../common/configOptions';\nimport { TextEditAction } from '../common/editAction';\nimport { combinePaths, getDirectoryPath, getFileName, stripFileExtension } from '../common/pathUtils';\nimport * as StringUtils from '../common/stringUtils';\nimport { Position } from '../common/textRange';\nimport { ParseNodeType } from '../parser/parseNodes';\nimport { ParseResults } from '../parser/parser';\nimport {\n    getIndexAliasData,\n    includeAliasDeclarationInIndex,\n    IndexAliasData,\n    IndexResults,\n} from './documentSymbolProvider';\n\nexport interface AutoImportSymbol {\n    readonly importAlias?: IndexAliasData;\n    readonly symbol?: Symbol;\n    readonly kind?: CompletionItemKind;\n}\n\nexport interface ModuleSymbolTable {\n    forEach(callbackfn: (symbol: AutoImportSymbol, name: string) => void): void;\n}\n\nexport type ModuleSymbolMap = Map<string, ModuleSymbolTable>;\n\n// Build a map of all modules within this program and the module-\n// level scope that contains the symbol table for the module.\nexport function buildModuleSymbolsMap(files: SourceFileInfo[], token: CancellationToken): ModuleSymbolMap {\n    const moduleSymbolMap = new Map<string, ModuleSymbolTable>();\n\n    files.forEach((file) => {\n        throwIfCancellationRequested(token);\n\n        if (file.shadows.length > 0) {\n            // There is corresponding stub file. Don't add\n            // duplicated files in the map.\n            return;\n        }\n\n        const filePath = file.sourceFile.getFilePath();\n        const symbolTable = file.sourceFile.getModuleSymbolTable();\n        if (symbolTable) {\n            const fileName = stripFileExtension(getFileName(filePath));\n\n            // Don't offer imports from files that are named with private\n            // naming semantics like \"_ast.py\".\n            if (SymbolNameUtils.isPrivateOrProtectedName(fileName)) {\n                return;\n            }\n\n            const fileInfo = AnalyzerNodeInfo.getFileInfo(file.sourceFile.getParseResults()!.parseTree);\n            moduleSymbolMap.set(filePath, {\n                forEach(callbackfn: (value: AutoImportSymbol, key: string) => void): void {\n                    symbolTable.forEach((symbol, name) => {\n                        if (symbol.isExternallyHidden()) {\n                            return;\n                        }\n\n                        const declarations = symbol.getDeclarations();\n                        if (!declarations || declarations.length === 0) {\n                            return;\n                        }\n\n                        const declaration = declarations[0];\n                        if (!declaration) {\n                            return;\n                        }\n\n                        let importAlias: IndexAliasData | undefined;\n                        if (declaration.type === DeclarationType.Alias) {\n                            if (!includeAliasDeclarationInIndex(declaration)) {\n                                return;\n                            }\n\n                            importAlias = getIndexAliasData(fileInfo?.importLookup, declaration);\n                        }\n\n                        const variableKind =\n                            declaration.type === DeclarationType.Variable &&\n                            !declaration.isConstant &&\n                            !declaration.isFinal\n                                ? CompletionItemKind.Variable\n                                : undefined;\n                        callbackfn({ importAlias, symbol, kind: variableKind }, name);\n                    });\n                },\n            });\n            return;\n        }\n\n        const indexResults = file.sourceFile.getCachedIndexResults();\n        if (indexResults && !indexResults.privateOrProtected) {\n            moduleSymbolMap.set(filePath, createModuleSymbolTableFromIndexResult(indexResults));\n            return;\n        }\n    });\n\n    return moduleSymbolMap;\n}\n\nexport interface AutoImportResult {\n    name: string;\n    symbol?: Symbol;\n    source?: string;\n    edits: TextEditAction[];\n    alias?: string;\n    kind?: CompletionItemKind;\n}\n\ninterface ImportParts {\n    importName: string;\n    symbolName?: string;\n    importFrom?: string;\n    filePath: string;\n    dotCount: number;\n    moduleNameAndType: ModuleNameAndType;\n}\n\ninterface ImportAliasData {\n    importParts: ImportParts;\n    importGroup: ImportGroup;\n    symbol?: Symbol;\n}\n\nexport class AutoImporter {\n    private _importStatements: ImportStatements;\n    private _filePath: string;\n\n    constructor(\n        private _configOptions: ConfigOptions,\n        private _importResolver: ImportResolver,\n        private _parseResults: ParseResults,\n        private _invocationPosition: Position,\n        private _excludes: string[],\n        private _moduleSymbolMap: ModuleSymbolMap,\n        private _libraryMap?: Map<string, IndexResults>\n    ) {\n        this._filePath = AnalyzerNodeInfo.getFileInfo(this._parseResults.parseTree)!.filePath;\n        this._importStatements = getTopLevelImports(this._parseResults.parseTree);\n    }\n\n    getAutoImportCandidates(\n        word: string,\n        similarityLimit: number,\n        aliasName: string | undefined,\n        token: CancellationToken\n    ) {\n        const results: AutoImportResult[] = [];\n        const importAliasMap = new Map<string, Map<string, ImportAliasData>>();\n\n        this._addImportsFromModuleMap(word, similarityLimit, aliasName, importAliasMap, results, token);\n        this._addImportsFromLibraryMap(word, similarityLimit, aliasName, importAliasMap, results, token);\n        this._addImportsFromImportAliasMap(importAliasMap, aliasName, results, token);\n        return results;\n    }\n\n    private _addImportsFromLibraryMap(\n        word: string,\n        similarityLimit: number,\n        aliasName: string | undefined,\n        aliasMap: Map<string, Map<string, ImportAliasData>>,\n        results: AutoImportResult[],\n        token: CancellationToken\n    ) {\n        this._libraryMap?.forEach((indexResults, filePath) => {\n            if (indexResults.privateOrProtected) {\n                return;\n            }\n\n            if (this._moduleSymbolMap.has(filePath)) {\n                // Module map is already taking care of this file. this can happen if the module is used by\n                // user code.\n                return;\n            }\n\n            // See if this file should be offered as an implicit import.\n            const isStubFileOrHasInit = this._isStubFileOrHasInit(this._libraryMap!, filePath);\n            this._processModuleSymbolTable(\n                createModuleSymbolTableFromIndexResult(indexResults),\n                filePath,\n                word,\n                similarityLimit,\n                isStubFileOrHasInit,\n                aliasName,\n                aliasMap,\n                results,\n                token\n            );\n        });\n    }\n\n    private _addImportsFromModuleMap(\n        word: string,\n        similarityLimit: number,\n        aliasName: string | undefined,\n        aliasMap: Map<string, Map<string, ImportAliasData>>,\n        results: AutoImportResult[],\n        token: CancellationToken\n    ) {\n        this._moduleSymbolMap.forEach((topLevelSymbols, filePath) => {\n            // See if this file should be offered as an implicit import.\n            const isStubFileOrHasInit = this._isStubFileOrHasInit(this._moduleSymbolMap!, filePath);\n            this._processModuleSymbolTable(\n                topLevelSymbols,\n                filePath,\n                word,\n                similarityLimit,\n                isStubFileOrHasInit,\n                aliasName,\n                aliasMap,\n                results,\n                token\n            );\n        });\n    }\n\n    private _isStubFileOrHasInit<T>(map: Map<string, T>, filePath: string) {\n        const fileDir = getDirectoryPath(filePath);\n        const initPathPy = combinePaths(fileDir, '__init__.py');\n        const initPathPyi = initPathPy + 'i';\n        const isStub = filePath.endsWith('.pyi');\n        const hasInit = map.has(initPathPy) || map.has(initPathPyi);\n        return { isStub, hasInit };\n    }\n\n    private _processModuleSymbolTable(\n        topLevelSymbols: ModuleSymbolTable,\n        filePath: string,\n        word: string,\n        similarityLimit: number,\n        isStubOrHasInit: { isStub: boolean; hasInit: boolean },\n        aliasName: string | undefined,\n        importAliasMap: Map<string, Map<string, ImportAliasData>>,\n        results: AutoImportResult[],\n        token: CancellationToken\n    ) {\n        throwIfCancellationRequested(token);\n\n        const [importSource, importGroup, moduleNameAndType] = this._getImportPartsForSymbols(filePath);\n        if (!importSource) {\n            return;\n        }\n\n        const dotCount = StringUtils.getCharacterCount(importSource, '.');\n        topLevelSymbols.forEach((autoImportSymbol, name) => {\n            throwIfCancellationRequested(token);\n\n            if (\n                !isStubOrHasInit.isStub &&\n                autoImportSymbol.kind === CompletionItemKind.Variable &&\n                /[a-z]/.test(name)\n            ) {\n                // If it is not a stub file and symbol is Variable, we only include it if\n                // name is all upper case.\n                return;\n            }\n\n            // For very short matching strings, we will require an exact match. Otherwise\n            // we will tend to return a list that's too long. Once we get beyond two\n            // characters, we can do a fuzzy match.\n            const isSimilar = this._isSimilar(word, name, similarityLimit);\n            if (!isSimilar) {\n                return;\n            }\n\n            const alreadyIncluded = this._containsName(name, undefined, results);\n            if (alreadyIncluded) {\n                return;\n            }\n\n            // We will collect all aliases and then process it later\n            if (autoImportSymbol.importAlias) {\n                this._addToImportAliasMap(\n                    autoImportSymbol.importAlias,\n                    {\n                        importParts: {\n                            symbolName: name,\n                            importName: name,\n                            importFrom: importSource,\n                            filePath,\n                            dotCount,\n                            moduleNameAndType,\n                        },\n                        importGroup,\n                        symbol: autoImportSymbol.symbol,\n                    },\n                    importAliasMap\n                );\n                return;\n            }\n\n            const autoImportTextEdits = this._getTextEditsForAutoImportByFilePath(\n                name,\n                filePath,\n                importSource,\n                importGroup,\n                aliasName\n            );\n\n            results.push({\n                name,\n                symbol: autoImportSymbol.symbol,\n                source: importSource,\n                edits: autoImportTextEdits,\n                alias: aliasName,\n                kind: autoImportSymbol.kind,\n            });\n        });\n\n        // If the current file is in a directory that also contains an \"__init__.py[i]\"\n        // file, we can use that directory name as an implicit import target.\n        // Or if the file is a stub file, we can use it as import target.\n        if (!isStubOrHasInit.isStub && !isStubOrHasInit.hasInit) {\n            return;\n        }\n\n        const importParts = this._getImportParts(filePath);\n        if (!importParts) {\n            return;\n        }\n\n        const isSimilar = this._isSimilar(word, importParts.importName, similarityLimit);\n        if (!isSimilar) {\n            return;\n        }\n\n        const alreadyIncluded = this._containsName(importParts.importName, importParts.importFrom, results);\n        if (alreadyIncluded) {\n            return;\n        }\n\n        this._addToImportAliasMap(\n            { modulePath: filePath, originalName: importParts.importName },\n            { importParts, importGroup },\n            importAliasMap\n        );\n    }\n\n    private _addImportsFromImportAliasMap(\n        importAliasMap: Map<string, Map<string, ImportAliasData>>,\n        aliasName: string | undefined,\n        results: AutoImportResult[],\n        token: CancellationToken\n    ) {\n        throwIfCancellationRequested(token);\n\n        importAliasMap.forEach((mapPerSymbolName, filePath) => {\n            mapPerSymbolName.forEach((importAliasData, symbolName) => {\n                throwIfCancellationRequested(token);\n\n                const autoImportTextEdits = this._getTextEditsForAutoImportByFilePath(\n                    importAliasData.importParts.symbolName,\n                    importAliasData.importParts.filePath,\n                    importAliasData.importParts.importFrom ?? importAliasData.importParts.importName,\n                    importAliasData.importGroup,\n                    aliasName\n                );\n\n                results.push({\n                    name: importAliasData.importParts.importName,\n                    alias: aliasName,\n                    symbol: importAliasData.symbol,\n                    source: importAliasData.importParts.importFrom,\n                    edits: autoImportTextEdits,\n                });\n            });\n        });\n    }\n\n    private _addToImportAliasMap(\n        alias: IndexAliasData,\n        data: ImportAliasData,\n        importAliasMap: Map<string, Map<string, ImportAliasData>>\n    ) {\n        // Since we don't resolve alias declaration using type evaluator, there is still a chance\n        // where we show multiple aliases for same symbols. but this should still reduce number of\n        // such cases.\n        if (!importAliasMap.has(alias.modulePath)) {\n            const map = new Map<string, ImportAliasData>();\n            map.set(alias.originalName, data);\n            importAliasMap.set(alias.modulePath, map);\n            return;\n        }\n\n        const map = importAliasMap.get(alias.modulePath)!;\n        if (!map.has(alias.originalName)) {\n            map.set(alias.originalName, data);\n            return;\n        }\n\n        const existingData = map.get(alias.originalName)!;\n        const comparison = this._compareImportAliasData(existingData, data);\n        if (comparison <= 0) {\n            // Existing data is better than new one.\n            return;\n        }\n\n        // Keep the new data.\n        map.set(alias.originalName, data);\n    }\n\n    private _compareImportAliasData(left: ImportAliasData, right: ImportAliasData) {\n        const groupComparison = left.importGroup - right.importGroup;\n        if (groupComparison !== 0) {\n            return groupComparison;\n        }\n\n        const dotComparison = left.importParts.dotCount - right.importParts.dotCount;\n        if (dotComparison !== 0) {\n            return dotComparison;\n        }\n\n        if (left.symbol && !right.symbol) {\n            return -1;\n        }\n\n        if (!left.symbol && right.symbol) {\n            return 1;\n        }\n\n        return StringUtils.getStringComparer()(left.importParts.importName, right.importParts.importName);\n    }\n\n    private _getImportPartsForSymbols(filePath: string): [string | undefined, ImportGroup, ModuleNameAndType] {\n        const localImport = this._importStatements.mapByFilePath.get(filePath);\n        if (localImport) {\n            return [\n                localImport.moduleName,\n                getImportGroup(localImport),\n                {\n                    importType: ImportType.Local,\n                    isLocalTypingsFile: false,\n                    moduleName: localImport.moduleName,\n                },\n            ];\n        } else {\n            const moduleNameAndType = this._getModuleNameAndTypeFromFilePath(filePath);\n            return [\n                moduleNameAndType.moduleName,\n                this._getImportGroupFromModuleNameAndType(moduleNameAndType),\n                moduleNameAndType,\n            ];\n        }\n    }\n\n    private _getImportParts(filePath: string) {\n        const name = stripFileExtension(getFileName(filePath));\n\n        // See if we can import module as \"import xxx\"\n        if (name === '__init__') {\n            return createImportParts(this._getModuleNameAndTypeFromFilePath(getDirectoryPath(filePath)));\n        }\n\n        return createImportParts(this._getModuleNameAndTypeFromFilePath(filePath));\n\n        function createImportParts(module: ModuleNameAndType): ImportParts | undefined {\n            const moduleName = module.moduleName;\n            if (!moduleName) {\n                return undefined;\n            }\n\n            const index = moduleName.lastIndexOf('.');\n            const importNamePart = index > 0 ? moduleName.substring(index + 1) : undefined;\n            const importFrom = index > 0 ? moduleName.substring(0, index) : undefined;\n            return {\n                symbolName: importNamePart,\n                importName: importNamePart ?? moduleName,\n                importFrom,\n                filePath,\n                dotCount: StringUtils.getCharacterCount(moduleName, '.'),\n                moduleNameAndType: module,\n            };\n        }\n    }\n\n    private _isSimilar(word: string, name: string, similarityLimit: number) {\n        if (similarityLimit === 1) {\n            return word === name;\n        }\n\n        return word.length > 2\n            ? StringUtils.computeCompletionSimilarity(word, name) > similarityLimit\n            : word.length > 0 && name.startsWith(word);\n    }\n\n    private _containsName(name: string, source: string | undefined, results: AutoImportResult[]) {\n        if (this._excludes.find((e) => e === name)) {\n            return true;\n        }\n\n        if (results.find((r) => r.name === name && r.source === source)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    // Given the file path of a module that we want to import,\n    // convert to a module name that can be used in an\n    // 'import from' statement.\n    private _getModuleNameAndTypeFromFilePath(filePath: string): ModuleNameAndType {\n        const execEnvironment = this._configOptions.findExecEnvironment(this._filePath);\n        return this._importResolver.getModuleNameForImport(filePath, execEnvironment);\n    }\n\n    private _getImportGroupFromModuleNameAndType(moduleNameAndType: ModuleNameAndType): ImportGroup {\n        let importGroup = ImportGroup.Local;\n        if (moduleNameAndType.isLocalTypingsFile || moduleNameAndType.importType === ImportType.ThirdParty) {\n            importGroup = ImportGroup.ThirdParty;\n        } else if (moduleNameAndType.importType === ImportType.BuiltIn) {\n            importGroup = ImportGroup.BuiltIn;\n        }\n\n        return importGroup;\n    }\n\n    private _getTextEditsForAutoImportByFilePath(\n        symbolName: string | undefined,\n        filePath: string,\n        moduleName: string,\n        importGroup: ImportGroup,\n        aliasName: string | undefined\n    ): TextEditAction[] {\n        if (symbolName) {\n            // Does an 'import from' statement already exist? If so, we'll reuse it.\n            const importStatement = this._importStatements.mapByFilePath.get(filePath);\n            if (importStatement && importStatement.node.nodeType === ParseNodeType.ImportFrom) {\n                return getTextEditsForAutoImportSymbolAddition(\n                    symbolName,\n                    importStatement,\n                    this._parseResults,\n                    aliasName\n                );\n            }\n        }\n\n        return getTextEditsForAutoImportInsertion(\n            symbolName,\n            this._importStatements,\n            moduleName,\n            importGroup,\n            this._parseResults,\n            this._invocationPosition,\n            aliasName\n        );\n    }\n}\n\nfunction createModuleSymbolTableFromIndexResult(indexResults: IndexResults): ModuleSymbolTable {\n    return {\n        forEach(callbackfn: (value: AutoImportSymbol, key: string) => void): void {\n            indexResults.symbols.forEach((data) => {\n                if (!data.externallyVisible) {\n                    return;\n                }\n\n                callbackfn(\n                    {\n                        importAlias: data.alias,\n                        kind: convertSymbolKindToCompletionItemKind(data.kind),\n                    },\n                    data.name\n                );\n            });\n        },\n    };\n}\n\nfunction convertSymbolKindToCompletionItemKind(kind: SymbolKind) {\n    switch (kind) {\n        case SymbolKind.File:\n            return CompletionItemKind.File;\n\n        case SymbolKind.Module:\n        case SymbolKind.Namespace:\n            return CompletionItemKind.Module;\n\n        case SymbolKind.Package:\n            return CompletionItemKind.Folder;\n\n        case SymbolKind.Class:\n            return CompletionItemKind.Class;\n\n        case SymbolKind.Method:\n            return CompletionItemKind.Method;\n\n        case SymbolKind.Property:\n            return CompletionItemKind.Property;\n\n        case SymbolKind.Field:\n            return CompletionItemKind.Field;\n\n        case SymbolKind.Constructor:\n            return CompletionItemKind.Constructor;\n\n        case SymbolKind.Enum:\n            return CompletionItemKind.Enum;\n\n        case SymbolKind.Interface:\n            return CompletionItemKind.Interface;\n\n        case SymbolKind.Function:\n            return CompletionItemKind.Function;\n\n        case SymbolKind.Variable:\n        case SymbolKind.Array:\n            return CompletionItemKind.Variable;\n\n        case SymbolKind.String:\n            return CompletionItemKind.Text;\n\n        case SymbolKind.Number:\n        case SymbolKind.Boolean:\n            return CompletionItemKind.Value;\n\n        case SymbolKind.Constant:\n        case SymbolKind.Null:\n            return CompletionItemKind.Constant;\n\n        case SymbolKind.Object:\n        case SymbolKind.Key:\n            return CompletionItemKind.Value;\n\n        case SymbolKind.EnumMember:\n            return CompletionItemKind.EnumMember;\n\n        case SymbolKind.Struct:\n            return CompletionItemKind.Struct;\n\n        case SymbolKind.Event:\n            return CompletionItemKind.Event;\n\n        case SymbolKind.Operator:\n            return CompletionItemKind.Operator;\n\n        case SymbolKind.TypeParameter:\n            return CompletionItemKind.TypeParameter;\n\n        default:\n            return undefined;\n    }\n}\n","/*\n * callHierarchyProvider.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Logic that provides a list of callers or callees associated with\n * a position.\n */\n\nimport { CancellationToken, SymbolKind } from 'vscode-languageserver';\nimport {\n    CallHierarchyIncomingCall,\n    CallHierarchyItem,\n    CallHierarchyOutgoingCall,\n    Range,\n} from 'vscode-languageserver-types';\n\nimport { Declaration, DeclarationType } from '../analyzer/declaration';\nimport * as DeclarationUtils from '../analyzer/declarationUtils';\nimport * as ParseTreeUtils from '../analyzer/parseTreeUtils';\nimport { ParseTreeWalker } from '../analyzer/parseTreeWalker';\nimport { TypeEvaluator } from '../analyzer/typeEvaluator';\nimport { ClassType, isClass, isObject, isTypeVar, TypeCategory } from '../analyzer/types';\nimport { specializeType } from '../analyzer/typeUtils';\nimport {\n    ClassMemberLookupFlags,\n    doForSubtypes,\n    isProperty,\n    lookUpClassMember,\n    lookUpObjectMember,\n} from '../analyzer/typeUtils';\nimport { throwIfCancellationRequested } from '../common/cancellationUtils';\nimport { getFileName } from '../common/pathUtils';\nimport { convertOffsetsToRange } from '../common/positionUtils';\nimport { rangesAreEqual } from '../common/textRange';\nimport { CallNode, MemberAccessNode, NameNode, ParseNode, ParseNodeType } from '../parser/parseNodes';\nimport { ParseResults } from '../parser/parser';\n\nexport class CallHierarchyProvider {\n    static getCallForDeclaration(\n        symbolName: string,\n        declaration: Declaration,\n        evaluator: TypeEvaluator,\n        token: CancellationToken\n    ): CallHierarchyItem | undefined {\n        throwIfCancellationRequested(token);\n\n        if (declaration.type === DeclarationType.Function || declaration.type === DeclarationType.Class) {\n            const callItem: CallHierarchyItem = {\n                name: symbolName,\n                kind: getSymbolKind(declaration, evaluator),\n                uri: declaration.path,\n                range: declaration.range,\n                selectionRange: declaration.range,\n            };\n            return callItem;\n        }\n\n        return undefined;\n    }\n\n    static getIncomingCallsForDeclaration(\n        filePath: string,\n        symbolName: string,\n        declaration: Declaration,\n        parseResults: ParseResults,\n        evaluator: TypeEvaluator,\n        token: CancellationToken\n    ): CallHierarchyIncomingCall[] | undefined {\n        throwIfCancellationRequested(token);\n\n        const callFinder = new FindIncomingCallTreeWalker(\n            filePath,\n            symbolName,\n            declaration,\n            parseResults,\n            evaluator,\n            token\n        );\n\n        const incomingCalls = callFinder.findCalls();\n\n        return incomingCalls.length > 0 ? incomingCalls : undefined;\n    }\n\n    static getOutgoingCallsForDeclaration(\n        declaration: Declaration,\n        parseResults: ParseResults,\n        evaluator: TypeEvaluator,\n        token: CancellationToken\n    ): CallHierarchyOutgoingCall[] | undefined {\n        throwIfCancellationRequested(token);\n\n        // Find the parse node root corresponding to the function or class.\n        let parseRoot: ParseNode | undefined;\n        if (declaration.type === DeclarationType.Function) {\n            parseRoot = declaration.node;\n        } else if (declaration.type === DeclarationType.Class) {\n            // Look up the __init__ method for this class.\n            const classType = evaluator.getTypeForDeclaration(declaration);\n            if (classType && isClass(classType)) {\n                // Don't perform a recursive search of parent classes in this\n                // case because we don't want to find an inherited __init__\n                // method defined in a different module.\n                const initMethodMember = lookUpClassMember(\n                    classType,\n                    '__init__',\n                    ClassMemberLookupFlags.SkipInstanceVariables |\n                        ClassMemberLookupFlags.SkipObjectBaseClass |\n                        ClassMemberLookupFlags.SkipBaseClasses\n                );\n                if (initMethodMember) {\n                    const initMethodType = evaluator.getTypeOfMember(initMethodMember);\n                    if (initMethodType && initMethodType.category === TypeCategory.Function) {\n                        const initDecls = initMethodMember.symbol.getDeclarations();\n                        if (initDecls && initDecls.length > 0) {\n                            const primaryInitDecl = initDecls[0];\n                            if (primaryInitDecl.type === DeclarationType.Function) {\n                                parseRoot = primaryInitDecl.node;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!parseRoot) {\n            return undefined;\n        }\n\n        const callFinder = new FindOutgoingCallTreeWalker(parseRoot, parseResults, evaluator, token);\n\n        const outgoingCalls = callFinder.findCalls();\n\n        return outgoingCalls.length > 0 ? outgoingCalls : undefined;\n    }\n\n    static getTargetDeclaration(declarations: Declaration[], node: ParseNode): Declaration {\n        // If there's more than one declaration, pick the target one.\n        // We'll always prefer one with a declared type, and we'll always\n        // prefer later declarations.\n        let targetDecl = declarations[0];\n        for (const decl of declarations) {\n            if (DeclarationUtils.hasTypeForDeclaration(decl) || !DeclarationUtils.hasTypeForDeclaration(targetDecl)) {\n                if (decl.type === DeclarationType.Function || decl.type === DeclarationType.Class) {\n                    targetDecl = decl;\n\n                    // If the specified node is an exact match, use this declaration\n                    // as the primary even if it's not the last.\n                    if (decl.node === node) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        return targetDecl;\n    }\n}\n\nclass FindOutgoingCallTreeWalker extends ParseTreeWalker {\n    private _outgoingCalls: CallHierarchyOutgoingCall[] = [];\n\n    constructor(\n        private _parseRoot: ParseNode,\n        private _parseResults: ParseResults,\n        private _evaluator: TypeEvaluator,\n        private _cancellationToken: CancellationToken\n    ) {\n        super();\n    }\n\n    findCalls(): CallHierarchyOutgoingCall[] {\n        this.walk(this._parseRoot);\n        return this._outgoingCalls;\n    }\n\n    visitCall(node: CallNode): boolean {\n        throwIfCancellationRequested(this._cancellationToken);\n\n        let nameNode: NameNode | undefined;\n\n        if (node.leftExpression.nodeType === ParseNodeType.Name) {\n            nameNode = node.leftExpression;\n        } else if (node.leftExpression.nodeType === ParseNodeType.MemberAccess) {\n            nameNode = node.leftExpression.memberName;\n        }\n\n        if (nameNode) {\n            const declarations = this._evaluator.getDeclarationsForNameNode(nameNode);\n\n            if (declarations) {\n                // TODO - it would be better if we could match the call to the\n                // specific declaration (e.g. a specific overload of a property\n                // setter vs getter). For now, add callees for all declarations.\n                declarations.forEach((decl) => {\n                    this._addOutgoingCallForDeclaration(nameNode!, decl);\n                });\n            }\n        }\n\n        return true;\n    }\n\n    visitMemberAccess(node: MemberAccessNode): boolean {\n        throwIfCancellationRequested(this._cancellationToken);\n\n        // Determine whether the member corresponds to a property.\n        // If so, we'll treat it as a function call for purposes of\n        // finding outgoing calls.\n        const leftHandType = this._evaluator.getType(node.leftExpression);\n        if (leftHandType) {\n            doForSubtypes(leftHandType, (subtype) => {\n                let baseType = subtype;\n\n                // This could be a bound TypeVar (e.g. used for \"self\" and \"cls\").\n                if (isTypeVar(baseType)) {\n                    baseType = specializeType(baseType, /* typeVarMap */ undefined, /* makeConcrete */ true);\n                }\n\n                if (!isObject(baseType)) {\n                    return undefined;\n                }\n\n                const memberInfo = lookUpObjectMember(baseType, node.memberName.value);\n                if (!memberInfo) {\n                    return undefined;\n                }\n\n                const memberType = this._evaluator.getTypeOfMember(memberInfo);\n                const propertyDecls = memberInfo.symbol.getDeclarations();\n\n                if (!memberType) {\n                    return undefined;\n                }\n\n                if (isObject(memberType) && ClassType.isPropertyClass(memberType.classType)) {\n                    propertyDecls.forEach((decl) => {\n                        this._addOutgoingCallForDeclaration(node.memberName, decl);\n                    });\n                }\n\n                return undefined;\n            });\n        }\n\n        return true;\n    }\n\n    private _addOutgoingCallForDeclaration(nameNode: NameNode, declaration: Declaration) {\n        const resolvedDecl = this._evaluator.resolveAliasDeclaration(declaration, /* resolveLocalNames */ true);\n        if (!resolvedDecl) {\n            return;\n        }\n\n        if (resolvedDecl.type !== DeclarationType.Function && resolvedDecl.type !== DeclarationType.Class) {\n            return;\n        }\n\n        const callDest: CallHierarchyItem = {\n            name: nameNode.value,\n            kind: getSymbolKind(resolvedDecl, this._evaluator),\n            uri: resolvedDecl.path,\n            range: resolvedDecl.range,\n            selectionRange: resolvedDecl.range,\n        };\n\n        // Is there already a call recorded for this destination? If so,\n        // we'll simply add a new range. Otherwise, we'll create a new entry.\n        let outgoingCall: CallHierarchyOutgoingCall | undefined = this._outgoingCalls.find(\n            (outgoing) => outgoing.to.uri === callDest.uri && rangesAreEqual(outgoing.to.range, callDest.range)\n        );\n\n        if (!outgoingCall) {\n            outgoingCall = {\n                to: callDest,\n                fromRanges: [],\n            };\n            this._outgoingCalls.push(outgoingCall);\n        }\n\n        const fromRange: Range = convertOffsetsToRange(\n            nameNode.start,\n            nameNode.start + nameNode.length,\n            this._parseResults.tokenizerOutput.lines\n        );\n        outgoingCall.fromRanges.push(fromRange);\n    }\n}\n\nclass FindIncomingCallTreeWalker extends ParseTreeWalker {\n    private _incomingCalls: CallHierarchyIncomingCall[] = [];\n\n    constructor(\n        private _filePath: string,\n        private _symbolName: string,\n        private _declaration: Declaration,\n        private _parseResults: ParseResults,\n        private _evaluator: TypeEvaluator,\n        private _cancellationToken: CancellationToken\n    ) {\n        super();\n    }\n\n    findCalls(): CallHierarchyIncomingCall[] {\n        this.walk(this._parseResults.parseTree);\n        return this._incomingCalls;\n    }\n\n    visitCall(node: CallNode): boolean {\n        throwIfCancellationRequested(this._cancellationToken);\n\n        let nameNode: NameNode | undefined;\n\n        if (node.leftExpression.nodeType === ParseNodeType.Name) {\n            nameNode = node.leftExpression;\n        } else if (node.leftExpression.nodeType === ParseNodeType.MemberAccess) {\n            nameNode = node.leftExpression.memberName;\n        }\n\n        // Don't bother doing any more work if the name doesn't match.\n        if (nameNode && nameNode.value === this._symbolName) {\n            const declarations = this._evaluator.getDeclarationsForNameNode(nameNode);\n\n            if (declarations) {\n                const resolvedDecls = declarations\n                    .map((decl) => {\n                        return this._evaluator.resolveAliasDeclaration(decl, /* resolveLocalNames */ true);\n                    })\n                    .filter((decl) => decl !== undefined);\n                if (resolvedDecls.some((decl) => DeclarationUtils.areDeclarationsSame(decl!, this._declaration))) {\n                    this._addIncomingCallForDeclaration(nameNode!);\n                }\n            }\n        }\n\n        return true;\n    }\n\n    visitMemberAccess(node: MemberAccessNode): boolean {\n        throwIfCancellationRequested(this._cancellationToken);\n\n        if (node.memberName.value === this._symbolName) {\n            // Determine whether the member corresponds to a property.\n            // If so, we'll treat it as a function call for purposes of\n            // finding outgoing calls.\n            const leftHandType = this._evaluator.getType(node.leftExpression);\n            if (leftHandType) {\n                doForSubtypes(leftHandType, (subtype) => {\n                    let baseType = subtype;\n\n                    // This could be a bound TypeVar (e.g. used for \"self\" and \"cls\").\n                    if (isTypeVar(baseType)) {\n                        baseType = specializeType(baseType, /* typeVarMap */ undefined, /* makeConcrete */ true);\n                    }\n\n                    if (!isObject(baseType)) {\n                        return undefined;\n                    }\n\n                    const memberInfo = lookUpObjectMember(baseType, node.memberName.value);\n                    if (!memberInfo) {\n                        return undefined;\n                    }\n\n                    const memberType = this._evaluator.getTypeOfMember(memberInfo);\n                    const propertyDecls = memberInfo.symbol.getDeclarations();\n\n                    if (!memberType) {\n                        return undefined;\n                    }\n\n                    if (propertyDecls.some((decl) => DeclarationUtils.areDeclarationsSame(decl!, this._declaration))) {\n                        this._addIncomingCallForDeclaration(node.memberName);\n                    }\n\n                    return undefined;\n                });\n            }\n        }\n\n        return true;\n    }\n\n    private _addIncomingCallForDeclaration(nameNode: NameNode) {\n        const executionNode = ParseTreeUtils.getExecutionScopeNode(nameNode);\n        if (!executionNode) {\n            return;\n        }\n\n        let callSource: CallHierarchyItem;\n        if (executionNode.nodeType === ParseNodeType.Module) {\n            const moduleRange = convertOffsetsToRange(0, 0, this._parseResults.tokenizerOutput.lines);\n            const fileName = getFileName(this._filePath);\n\n            callSource = {\n                name: `(module) ${fileName}`,\n                kind: SymbolKind.Module,\n                uri: this._filePath,\n                range: moduleRange,\n                selectionRange: moduleRange,\n            };\n        } else if (executionNode.nodeType === ParseNodeType.Lambda) {\n            const lambdaRange = convertOffsetsToRange(\n                executionNode.start,\n                executionNode.start + executionNode.length,\n                this._parseResults.tokenizerOutput.lines\n            );\n\n            callSource = {\n                name: '(lambda)',\n                kind: SymbolKind.Function,\n                uri: this._filePath,\n                range: lambdaRange,\n                selectionRange: lambdaRange,\n            };\n        } else {\n            const functionRange = convertOffsetsToRange(\n                executionNode.name.start,\n                executionNode.name.start + executionNode.name.length,\n                this._parseResults.tokenizerOutput.lines\n            );\n\n            callSource = {\n                name: executionNode.name.value,\n                kind: SymbolKind.Function,\n                uri: this._filePath,\n                range: functionRange,\n                selectionRange: functionRange,\n            };\n        }\n\n        // Is there already a call recorded for this caller? If so,\n        // we'll simply add a new range. Otherwise, we'll create a new entry.\n        let incomingCall: CallHierarchyIncomingCall | undefined = this._incomingCalls.find(\n            (incoming) => incoming.from.uri === callSource.uri && rangesAreEqual(incoming.from.range, callSource.range)\n        );\n\n        if (!incomingCall) {\n            incomingCall = {\n                from: callSource,\n                fromRanges: [],\n            };\n            this._incomingCalls.push(incomingCall);\n        }\n\n        const fromRange: Range = convertOffsetsToRange(\n            nameNode.start,\n            nameNode.start + nameNode.length,\n            this._parseResults.tokenizerOutput.lines\n        );\n        incomingCall.fromRanges.push(fromRange);\n    }\n}\n\nfunction getSymbolKind(declaration: Declaration, evaluator: TypeEvaluator): SymbolKind {\n    let symbolKind: SymbolKind;\n\n    switch (declaration.type) {\n        case DeclarationType.Class:\n        case DeclarationType.SpecialBuiltInClass:\n            symbolKind = SymbolKind.Class;\n            break;\n\n        case DeclarationType.Function:\n            if (declaration.isMethod) {\n                const declType = evaluator.getTypeForDeclaration(declaration);\n                if (declType && isProperty(declType)) {\n                    symbolKind = SymbolKind.Property;\n                } else {\n                    symbolKind = SymbolKind.Method;\n                }\n            } else {\n                symbolKind = SymbolKind.Function;\n            }\n            break;\n\n        default:\n            symbolKind = SymbolKind.Function;\n            break;\n    }\n\n    return symbolKind;\n}\n","/*\n * codeActionProvider.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n *\n * Handles 'code actions' requests from the client.\n */\n\nimport { CancellationToken, CodeAction, CodeActionKind, Command } from 'vscode-languageserver';\n\nimport { Commands } from '../commands/commands';\nimport { throwIfCancellationRequested } from '../common/cancellationUtils';\nimport { AddMissingOptionalToParamAction, CreateTypeStubFileAction } from '../common/diagnostic';\nimport { Range } from '../common/textRange';\nimport { WorkspaceServiceInstance } from '../languageServerBase';\nimport { Localizer } from '../localization/localize';\n\nexport class CodeActionProvider {\n    static async getCodeActionsForPosition(\n        workspace: WorkspaceServiceInstance,\n        filePath: string,\n        range: Range,\n        token: CancellationToken\n    ) {\n        throwIfCancellationRequested(token);\n\n        const codeActions: CodeAction[] = [];\n\n        if (!workspace.disableLanguageServices) {\n            const diags = await workspace.serviceInstance.getDiagnosticsForRange(filePath, range, token);\n            const typeStubDiag = diags.find((d) => {\n                const actions = d.getActions();\n                return actions && actions.find((a) => a.action === Commands.createTypeStub);\n            });\n\n            if (typeStubDiag) {\n                const action = typeStubDiag\n                    .getActions()!\n                    .find((a) => a.action === Commands.createTypeStub) as CreateTypeStubFileAction;\n                if (action) {\n                    const createTypeStubAction = CodeAction.create(\n                        Localizer.CodeAction.createTypeStubFor().format({ moduleName: action.moduleName }),\n                        Command.create(\n                            Localizer.CodeAction.createTypeStub(),\n                            Commands.createTypeStub,\n                            workspace.rootPath,\n                            action.moduleName,\n                            filePath\n                        ),\n                        CodeActionKind.QuickFix\n                    );\n                    codeActions.push(createTypeStubAction);\n                }\n            }\n\n            const addOptionalDiag = diags.find((d) => {\n                const actions = d.getActions();\n                return actions && actions.find((a) => a.action === Commands.addMissingOptionalToParam);\n            });\n\n            if (addOptionalDiag) {\n                const action = addOptionalDiag\n                    .getActions()!\n                    .find((a) => a.action === Commands.addMissingOptionalToParam) as AddMissingOptionalToParamAction;\n                if (action) {\n                    const addMissingOptionalAction = CodeAction.create(\n                        Localizer.CodeAction.addOptionalToAnnotation(),\n                        Command.create(\n                            Localizer.CodeAction.addOptionalToAnnotation(),\n                            Commands.addMissingOptionalToParam,\n                            action.offsetOfTypeNode\n                        ),\n                        CodeActionKind.QuickFix\n                    );\n                    codeActions.push(addMissingOptionalAction);\n                }\n            }\n        }\n\n        return codeActions;\n    }\n}\n","/*\n * completionProvider.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Logic that maps a position within a Python program file into\n * a list of zero or more text completions that apply in the context.\n */\n\nimport {\n    CancellationToken,\n    CompletionItem,\n    CompletionItemKind,\n    CompletionList,\n    MarkupKind,\n    Range,\n    TextEdit,\n} from 'vscode-languageserver';\n\nimport { ImportLookup } from '../analyzer/analyzerFileInfo';\nimport * as AnalyzerNodeInfo from '../analyzer/analyzerNodeInfo';\nimport { Declaration, DeclarationType } from '../analyzer/declaration';\nimport { convertDocStringToMarkdown } from '../analyzer/docStringToMarkdown';\nimport { ImportedModuleDescriptor, ImportResolver } from '../analyzer/importResolver';\nimport * as ParseTreeUtils from '../analyzer/parseTreeUtils';\nimport { SourceMapper } from '../analyzer/sourceMapper';\nimport { Symbol, SymbolTable } from '../analyzer/symbol';\nimport * as SymbolNameUtils from '../analyzer/symbolNameUtils';\nimport { getLastTypedDeclaredForSymbol } from '../analyzer/symbolUtils';\nimport {\n    getClassDocString,\n    getFunctionDocStringFromDeclaration,\n    getFunctionDocStringFromType,\n    getModuleDocString,\n    getOverloadedFunctionDocStrings,\n} from '../analyzer/typeDocStringUtils';\nimport { CallSignatureInfo, TypeEvaluator } from '../analyzer/typeEvaluator';\nimport {\n    ClassType,\n    FunctionType,\n    isClass,\n    isModule,\n    isNone,\n    isObject,\n    isUnbound,\n    isUnknown,\n    ObjectType,\n    Type,\n    TypeBase,\n    TypeCategory,\n    UnknownType,\n} from '../analyzer/types';\nimport {\n    doForSubtypes,\n    getDeclaringModulesForType,\n    getMembersForClass,\n    getMembersForModule,\n    isProperty,\n    makeTypeVarsConcrete,\n} from '../analyzer/typeUtils';\nimport { throwIfCancellationRequested } from '../common/cancellationUtils';\nimport { ConfigOptions } from '../common/configOptions';\nimport { TextEditAction } from '../common/editAction';\nimport { convertOffsetToPosition, convertPositionToOffset } from '../common/positionUtils';\nimport * as StringUtils from '../common/stringUtils';\nimport { comparePositions, Position } from '../common/textRange';\nimport { TextRange } from '../common/textRange';\nimport {\n    ErrorExpressionCategory,\n    ErrorNode,\n    ExpressionNode,\n    FunctionNode,\n    ImportFromNode,\n    isExpressionNode,\n    ModuleNameNode,\n    NameNode,\n    ParameterCategory,\n    ParseNode,\n    ParseNodeType,\n    StringNode,\n} from '../parser/parseNodes';\nimport { ParseResults } from '../parser/parser';\nimport { AutoImporter, ModuleSymbolMap } from './autoImporter';\nimport { IndexResults } from './documentSymbolProvider';\n\nconst _keywords: string[] = [\n    // Expression keywords\n    'True',\n    'False',\n    'None',\n    'and',\n    'or',\n    'await',\n    'not',\n    'is',\n    'lambda',\n    'yield',\n\n    // Statement keywords\n    'assert',\n    'async',\n    'break',\n    'class',\n    'continue',\n    'def',\n    'del',\n    'elif',\n    'else',\n    'except',\n    'finally',\n    'for',\n    'from',\n    'global',\n    'if',\n    'import',\n    'in',\n    'nonlocal',\n    'pass',\n    'raise',\n    'return',\n    'try',\n    'while',\n    'yield',\n];\n\nenum SortCategory {\n    // The order of the following is important. We use\n    // this to order the completion suggestions.\n\n    // A keyword that must be entered for the syntax to be correct.\n    LikelyKeyword,\n\n    // A module name recently used in an import statement.\n    RecentImportModuleName,\n\n    // A module name used in an import statement.\n    ImportModuleName,\n\n    // A literal string.\n    LiteralValue,\n\n    // A named parameter in a call expression.\n    NamedParameter,\n\n    // A keyword or symbol that was recently used for completion.\n    RecentKeywordOrSymbol,\n\n    // An auto-import symbol that was recently used for completion.\n    RecentAutoImport,\n\n    // A keyword in the python syntax.\n    Keyword,\n\n    // A normal symbol.\n    NormalSymbol,\n\n    // A symbol that starts with _ or __ (used only when there is\n    // no matching filter).\n    PrivateSymbol,\n\n    // A symbol with a dunder name (e.g. __init__).\n    DunderSymbol,\n\n    // An auto-import symbol.\n    AutoImport,\n}\n\n// Completion items can have arbitrary data hanging off them.\n// This data allows the resolve handling to disambiguate\n// which item was selected.\nexport interface CompletionItemData {\n    filePath: string;\n    workspacePath: string;\n    position: Position;\n    autoImportText?: string;\n    symbolId?: number;\n}\n\n// ModuleContext attempts to gather info for unknown types\nexport interface ModuleContext {\n    lastKnownModule?: string;\n    lastKnownMemberName?: string;\n    unknownMemberName?: string;\n}\n\nexport interface CompletionResults {\n    completionList: CompletionList | undefined;\n    moduleContext?: ModuleContext;\n}\n\ninterface RecentCompletionInfo {\n    label: string;\n    autoImportText: string;\n}\n\n// We'll use a somewhat-arbitrary cutoff value here to determine\n// whether it's sufficiently similar.\nconst similarityLimit = 0.25;\n\n// We'll remember this many completions in the MRU list.\nconst maxRecentCompletions = 128;\n\nexport class CompletionProvider {\n    private static _mostRecentCompletions: RecentCompletionInfo[] = [];\n\n    // If we're being asked to resolve a completion item, we run the\n    // original completion algorithm and look for this symbol.\n    private _itemToResolve: CompletionItem | undefined;\n\n    constructor(\n        private _workspacePath: string,\n        private _parseResults: ParseResults,\n        private _fileContents: string,\n        private _importResolver: ImportResolver,\n        private _position: Position,\n        private _filePath: string,\n        private _configOptions: ConfigOptions,\n        private _importLookup: ImportLookup,\n        private _evaluator: TypeEvaluator,\n        private _sourceMapper: SourceMapper,\n        private _libraryMap: Map<string, IndexResults> | undefined,\n        private _moduleSymbolsCallback: () => ModuleSymbolMap,\n        private _cancellationToken: CancellationToken\n    ) {}\n\n    getCompletionsForPosition(): CompletionResults | undefined {\n        const offset = convertPositionToOffset(this._position, this._parseResults.tokenizerOutput.lines);\n        if (offset === undefined) {\n            return undefined;\n        }\n\n        let node = ParseTreeUtils.findNodeByOffset(this._parseResults.parseTree, offset);\n\n        // See if we can get to a \"better\" node by backing up a few columns.\n        // A \"better\" node is defined as one that's deeper than the current\n        // node.\n        const initialNode = node;\n        const initialDepth = node ? ParseTreeUtils.getNodeDepth(node) : 0;\n\n        if (!initialNode || initialNode.nodeType !== ParseNodeType.Name) {\n            let curOffset = offset;\n            while (curOffset >= 0) {\n                curOffset--;\n\n                // Stop scanning backward if we hit certain stop characters.\n                const curChar = this._fileContents.substr(curOffset, 1);\n                if (curChar === '(' || curChar === '\\n') {\n                    break;\n                }\n\n                const curNode = ParseTreeUtils.findNodeByOffset(this._parseResults.parseTree, curOffset);\n                if (curNode && curNode !== initialNode) {\n                    if (ParseTreeUtils.getNodeDepth(curNode) > initialDepth) {\n                        node = curNode;\n                    }\n                    break;\n                }\n            }\n        }\n\n        if (node === undefined) {\n            return undefined;\n        }\n\n        // Get the text on that line prior to the insertion point.\n        const lineTextRange = this._parseResults.tokenizerOutput.lines.getItemAt(this._position.line);\n        const textOnLine = this._fileContents.substr(lineTextRange.start, lineTextRange.length);\n        const priorText = textOnLine.substr(0, this._position.character);\n        const postText = textOnLine.substr(this._position.character);\n        const priorWordIndex = priorText.search(/\\w+$/);\n        const priorWord = priorWordIndex >= 0 ? priorText.substr(priorWordIndex) : '';\n\n        // Don't offer completions if we're within a comment.\n        if (this._isWithinComment(offset, priorText)) {\n            return undefined;\n        }\n\n        // See if the node is part of an error node. If so, that takes\n        // precedence.\n        let errorNode: ParseNode | undefined = node;\n        while (errorNode) {\n            if (errorNode.nodeType === ParseNodeType.Error) {\n                break;\n            }\n\n            errorNode = errorNode.parent;\n        }\n\n        // Determine the context based on the parse node's type and\n        // that of its ancestors.\n        let curNode = errorNode || node;\n        while (true) {\n            throwIfCancellationRequested(this._cancellationToken);\n\n            if (curNode.nodeType === ParseNodeType.String) {\n                return this._getStringLiteralCompletions(curNode, priorWord, priorText, postText);\n            }\n\n            if (curNode.nodeType === ParseNodeType.StringList) {\n                return undefined;\n            }\n\n            if (curNode.nodeType === ParseNodeType.ModuleName) {\n                return this._getImportModuleCompletions(curNode);\n            }\n\n            if (curNode.nodeType === ParseNodeType.Error) {\n                return this._getExpressionErrorCompletions(curNode, priorWord, priorText, postText);\n            }\n\n            if (curNode.nodeType === ParseNodeType.MemberAccess) {\n                return this._getMemberAccessCompletions(curNode.leftExpression, priorWord);\n            }\n\n            if (curNode.nodeType === ParseNodeType.Name) {\n                // Are we within a \"from X import Y as Z\" statement and\n                // more specifically within the \"Y\"?\n                if (curNode.parent && curNode.parent.nodeType === ParseNodeType.ModuleName) {\n                    return this._getImportModuleCompletions(curNode.parent);\n                } else if (curNode.parent && curNode.parent.nodeType === ParseNodeType.ImportFromAs) {\n                    const parentNode = curNode.parent.parent;\n\n                    if (parentNode && parentNode.nodeType === ParseNodeType.ImportFrom) {\n                        if (curNode.parent.name === curNode) {\n                            return this._getImportFromCompletions(parentNode, priorWord);\n                        } else {\n                            return this._getImportFromCompletions(parentNode, '');\n                        }\n                    }\n                } else if (\n                    curNode.parent &&\n                    curNode.parent.nodeType === ParseNodeType.MemberAccess &&\n                    curNode === curNode.parent.memberName\n                ) {\n                    return this._getMemberAccessCompletions(curNode.parent.leftExpression, priorWord);\n                }\n            }\n\n            if (curNode.nodeType === ParseNodeType.ImportFrom) {\n                return this._getImportFromCompletions(curNode, priorWord);\n            }\n\n            if (isExpressionNode(curNode)) {\n                return this._getExpressionCompletions(curNode, priorWord, priorText, postText);\n            }\n\n            if (curNode.nodeType === ParseNodeType.Suite || curNode.nodeType === ParseNodeType.Module) {\n                return this._getStatementCompletions(curNode, priorWord, priorText, postText);\n            }\n\n            if (!curNode.parent) {\n                break;\n            }\n\n            curNode = curNode.parent;\n        }\n\n        return undefined;\n    }\n\n    // When the user selects a completion, this callback is invoked,\n    // allowing us to record what was selected. This allows us to\n    // build our MRU cache so we can better predict entries.\n    resolveCompletionItem(completionItem: CompletionItem) {\n        throwIfCancellationRequested(this._cancellationToken);\n\n        const completionItemData = completionItem.data as CompletionItemData;\n\n        const label = completionItem.label;\n        let autoImportText = '';\n        if (completionItemData.autoImportText) {\n            autoImportText = completionItemData.autoImportText;\n        }\n\n        const curIndex = CompletionProvider._mostRecentCompletions.findIndex(\n            (item) => item.label === label && item.autoImportText === autoImportText\n        );\n\n        if (curIndex > 0) {\n            // If there's an existing entry with the same name that's not at the\n            // beginning of the array, remove it.\n            CompletionProvider._mostRecentCompletions = CompletionProvider._mostRecentCompletions.splice(curIndex, 1);\n        }\n\n        if (curIndex !== 0) {\n            // Add to the start of the array.\n            CompletionProvider._mostRecentCompletions.unshift({ label, autoImportText });\n        }\n\n        if (CompletionProvider._mostRecentCompletions.length > maxRecentCompletions) {\n            // Prevent the MRU list from growing indefinitely.\n            CompletionProvider._mostRecentCompletions.pop();\n        }\n\n        if (completionItemData.symbolId) {\n            this._itemToResolve = completionItem;\n\n            // Rerun the completion lookup. It will fill in additional information\n            // about the item to be resolved. We'll ignore the rest of the returned\n            // list. This is a bit wasteful, but all of that information should be\n            // cached, so it's not as bad as it might seem.\n            this.getCompletionsForPosition();\n        }\n    }\n\n    private _isWithinComment(offset: number, priorText: string): boolean {\n        const tokenIndex = this._parseResults.tokenizerOutput.tokens.getItemAtPosition(offset);\n        if (tokenIndex < 0) {\n            return false;\n        }\n\n        const token = this._parseResults.tokenizerOutput.tokens.getItemAt(tokenIndex);\n\n        // If we're in the middle of a token, we're not in a comment.\n        if (offset > token.start && offset < TextRange.getEnd(token)) {\n            return false;\n        }\n\n        // See if the text that precedes the current position contains\n        // a '#' character.\n        return !!priorText.match(/#/);\n    }\n\n    private _getExpressionErrorCompletions(\n        node: ErrorNode,\n        priorWord: string,\n        priorText: string,\n        postText: string\n    ): CompletionResults | undefined {\n        // Is the error due to a missing member access name? If so,\n        // we can evaluate the left side of the member access expression\n        // to determine its type and offer suggestions based on it.\n        switch (node.category) {\n            case ErrorExpressionCategory.MissingIn: {\n                return this._createSingleKeywordCompletionList('in');\n            }\n\n            case ErrorExpressionCategory.MissingElse: {\n                return this._createSingleKeywordCompletionList('else');\n            }\n\n            case ErrorExpressionCategory.MissingExpression:\n            case ErrorExpressionCategory.MissingIndexOrSlice:\n            case ErrorExpressionCategory.MissingDecoratorCallName: {\n                return this._getExpressionCompletions(node, priorWord, priorText, postText);\n            }\n\n            case ErrorExpressionCategory.MissingMemberAccessName: {\n                if (node.child && isExpressionNode(node.child)) {\n                    return this._getMemberAccessCompletions(node.child, priorWord);\n                }\n                break;\n            }\n\n            case ErrorExpressionCategory.MissingFunctionParameterList: {\n                if (node.child && node.child.nodeType === ParseNodeType.Name) {\n                    // Determine if the partial name is a method that's overriding\n                    // a method in a base class.\n                    return this._getMethodOverrideCompletions(node.child);\n                }\n                break;\n            }\n        }\n\n        return undefined;\n    }\n\n    private _createSingleKeywordCompletionList(keyword: string): CompletionResults {\n        const completionItem = CompletionItem.create(keyword);\n        completionItem.kind = CompletionItemKind.Keyword;\n        completionItem.sortText = this._makeSortText(SortCategory.LikelyKeyword, keyword);\n        const completionList = CompletionList.create([completionItem]);\n        return { completionList };\n    }\n\n    private _getMethodOverrideCompletions(partialName: NameNode): CompletionResults | undefined {\n        const enclosingClass = ParseTreeUtils.getEnclosingClass(partialName, true);\n        if (!enclosingClass) {\n            return undefined;\n        }\n\n        const classResults = this._evaluator.getTypeOfClass(enclosingClass);\n        if (!classResults) {\n            return undefined;\n        }\n\n        // Get symbols in reverse-MRO, but leave omit the class itself.\n        const symbolTable = new Map<string, Symbol>();\n        for (let i = classResults.classType.details.mro.length - 1; i > 0; i--) {\n            const mroClass = classResults.classType.details.mro[i];\n            if (isClass(mroClass)) {\n                getMembersForClass(mroClass, symbolTable, false);\n            }\n        }\n\n        const completionList = CompletionList.create();\n\n        symbolTable.forEach((symbol, name) => {\n            const decl = getLastTypedDeclaredForSymbol(symbol);\n            if (decl && decl.type === DeclarationType.Function) {\n                const isSimilar = StringUtils.computeCompletionSimilarity(partialName.value, name) > similarityLimit;\n                if (isSimilar) {\n                    const range: Range = {\n                        start: { line: this._position.line, character: this._position.character - partialName.length },\n                        end: { line: this._position.line, character: this._position.character },\n                    };\n\n                    const methodSignature = this._printMethodSignature(decl.node) + ':';\n                    const textEdit = TextEdit.replace(range, methodSignature);\n                    this._addSymbol(name, symbol, partialName.value, completionList, undefined, textEdit);\n                }\n            }\n        });\n\n        return { completionList };\n    }\n\n    private _printMethodSignature(node: FunctionNode): string {\n        const paramList = node.parameters\n            .map((param, index) => {\n                let paramString = '';\n                if (param.category === ParameterCategory.VarArgList) {\n                    paramString += '*';\n                } else if (param.category === ParameterCategory.VarArgDictionary) {\n                    paramString += '**';\n                }\n\n                if (param.name) {\n                    paramString += param.name.value;\n                }\n\n                const paramTypeAnnotation = this._evaluator.getTypeAnnotationForParameter(node, index);\n                if (paramTypeAnnotation) {\n                    paramString += ': ' + ParseTreeUtils.printExpression(paramTypeAnnotation);\n                }\n\n                return paramString;\n            })\n            .join(', ');\n\n        let methodSignature = node.name.value + '(' + paramList + ')';\n\n        if (node.returnTypeAnnotation) {\n            methodSignature += ' -> ' + ParseTreeUtils.printExpression(node.returnTypeAnnotation);\n        } else if (node.functionAnnotationComment) {\n            methodSignature +=\n                ' -> ' + ParseTreeUtils.printExpression(node.functionAnnotationComment.returnTypeAnnotation);\n        }\n\n        return methodSignature;\n    }\n\n    private _getMemberAccessCompletions(\n        leftExprNode: ExpressionNode,\n        priorWord: string\n    ): CompletionResults | undefined {\n        const leftType = this._evaluator.getType(leftExprNode);\n        const symbolTable = new Map<string, Symbol>();\n        const completionList = CompletionList.create();\n        let lastKnownModule: ModuleContext | undefined;\n\n        if (leftType) {\n            doForSubtypes(leftType, (subtype) => {\n                const specializedSubtype = makeTypeVarsConcrete(subtype);\n\n                if (isObject(specializedSubtype)) {\n                    getMembersForClass(specializedSubtype.classType, symbolTable, /* includeInstanceVars */ true);\n                } else if (isClass(specializedSubtype)) {\n                    getMembersForClass(specializedSubtype, symbolTable, /* includeInstanceVars */ false);\n                } else if (isModule(specializedSubtype)) {\n                    getMembersForModule(specializedSubtype, symbolTable);\n                } else if (\n                    specializedSubtype.category === TypeCategory.Function ||\n                    specializedSubtype.category === TypeCategory.OverloadedFunction\n                ) {\n                    const functionClass = this._evaluator.getBuiltInType(leftExprNode, 'function');\n                    if (functionClass && isClass(functionClass)) {\n                        getMembersForClass(functionClass, symbolTable, /* includeInstanceVars */ true);\n                    }\n                } else if (isNone(subtype)) {\n                    const objectClass = this._evaluator.getBuiltInType(leftExprNode, 'object');\n                    if (objectClass && isClass(objectClass)) {\n                        getMembersForClass(objectClass, symbolTable, TypeBase.isInstance(subtype));\n                    }\n                }\n\n                return undefined;\n            });\n\n            const specializedLeftType = makeTypeVarsConcrete(leftType);\n            const objectThrough: ObjectType | undefined = isObject(specializedLeftType)\n                ? specializedLeftType\n                : undefined;\n            this._addSymbolsForSymbolTable(symbolTable, (_) => true, priorWord, objectThrough, completionList);\n\n            // If we dont know this type, look for a module we should stub\n            if (!leftType || isUnknown(leftType) || isUnbound(leftType)) {\n                lastKnownModule = this._getLastKnownModule(leftExprNode, leftType);\n            }\n        }\n\n        return { completionList, moduleContext: lastKnownModule };\n    }\n\n    private _getLastKnownModule(leftExprNode: ExpressionNode, leftType: Type | undefined): ModuleContext | undefined {\n        let curNode: ExpressionNode | undefined = leftExprNode;\n        let curType: Type | undefined = leftType;\n        let unknownMemberName: string | undefined =\n            leftExprNode.nodeType === ParseNodeType.MemberAccess ? leftExprNode?.memberName.value : undefined;\n\n        // Walk left of the expression scope till we find a known type. A.B.Unknown.<-- return B.\n        while (curNode) {\n            if (curNode.nodeType === ParseNodeType.Call || curNode.nodeType === ParseNodeType.MemberAccess) {\n                // Move left\n                curNode = curNode.leftExpression;\n\n                // First time in the loop remember the name of the unknown type.\n                if (unknownMemberName === undefined) {\n                    unknownMemberName =\n                        curNode.nodeType === ParseNodeType.MemberAccess ? curNode?.memberName.value ?? '' : '';\n                }\n            } else {\n                curNode = undefined;\n            }\n\n            if (curNode) {\n                curType = this._evaluator.getType(curNode);\n\n                // Breakout if we found a known type.\n                if (curType !== undefined && !isUnknown(curType) && !isUnbound(curType)) {\n                    break;\n                }\n            }\n        }\n\n        const context: ModuleContext = {};\n        if (curType && !isUnknown(curType) && !isUnbound(curType) && curNode) {\n            const moduleNamesForType = getDeclaringModulesForType(curType);\n\n            // For union types we only care about non 'typing' modules.\n            context.lastKnownModule = moduleNamesForType.find((n) => n !== 'typing');\n\n            if (curNode.nodeType === ParseNodeType.MemberAccess) {\n                context.lastKnownMemberName = curNode.memberName.value;\n            } else if (curNode.nodeType === ParseNodeType.Name && isClass(curType)) {\n                context.lastKnownMemberName = curType.details.name;\n            } else if (curNode.nodeType === ParseNodeType.Name && isObject(curType)) {\n                context.lastKnownMemberName = curType.classType.details.name;\n            }\n\n            context.unknownMemberName = unknownMemberName;\n        }\n\n        return context;\n    }\n\n    private _getStatementCompletions(\n        parseNode: ParseNode,\n        priorWord: string,\n        priorText: string,\n        postText: string\n    ): CompletionResults | undefined {\n        // For now, use the same logic for expressions and statements.\n        return this._getExpressionCompletions(parseNode, priorWord, priorText, postText);\n    }\n\n    private _getExpressionCompletions(\n        parseNode: ParseNode,\n        priorWord: string,\n        priorText: string,\n        postText: string\n    ): CompletionResults | undefined {\n        // If the user typed a \".\" as part of a number, don't present\n        // any completion options.\n        if (parseNode.nodeType === ParseNodeType.Number) {\n            return undefined;\n        }\n\n        const completionList = CompletionList.create();\n\n        // Add call argument completions.\n        this._addCallArgumentCompletions(parseNode, priorWord, priorText, postText, completionList);\n\n        // Add symbols that are in scope.\n        this._addSymbols(parseNode, priorWord, completionList);\n\n        // Add keywords.\n        this._findMatchingKeywords(_keywords, priorWord).map((keyword) => {\n            const completionItem = CompletionItem.create(keyword);\n            completionItem.kind = CompletionItemKind.Keyword;\n            completionList.items.push(completionItem);\n            completionItem.sortText = this._makeSortText(SortCategory.Keyword, keyword);\n        });\n\n        // Add auto-import suggestions from other modules.\n        // Ignore this check for privates, since they are not imported.\n        if (this._configOptions.autoImportCompletions && !priorWord.startsWith('_') && !this._itemToResolve) {\n            this._getAutoImportCompletions(priorWord, completionList);\n        }\n\n        // Add literal values if appropriate.\n        if (parseNode.nodeType === ParseNodeType.Error) {\n            if (parseNode.category === ErrorExpressionCategory.MissingIndexOrSlice) {\n                this._getIndexStringLiteral(parseNode, completionList);\n            } else if (parseNode.category === ErrorExpressionCategory.MissingExpression) {\n                if (parseNode.parent && parseNode.parent.nodeType === ParseNodeType.Assignment) {\n                    const declaredTypeOfTarget = this._evaluator.getDeclaredTypeForExpression(\n                        parseNode.parent.leftExpression\n                    );\n\n                    if (declaredTypeOfTarget) {\n                        this._addLiteralValuesForTargetType(declaredTypeOfTarget, priorText, postText, completionList);\n                    }\n                }\n            }\n        }\n\n        return { completionList };\n    }\n\n    private _addCallArgumentCompletions(\n        parseNode: ParseNode,\n        priorWord: string,\n        priorText: string,\n        postText: string,\n        completionList: CompletionList\n    ) {\n        // If we're within the argument list of a call, add parameter names.\n        const offset = convertPositionToOffset(this._position, this._parseResults.tokenizerOutput.lines)!;\n        const signatureInfo = this._evaluator.getCallSignatureInfo(\n            parseNode,\n            offset,\n            this._parseResults.tokenizerOutput.tokens\n        );\n\n        if (signatureInfo) {\n            // Are we past the call expression and within the argument list?\n            const callNameEnd = convertOffsetToPosition(\n                signatureInfo.callNode.leftExpression.start + signatureInfo.callNode.leftExpression.length,\n                this._parseResults.tokenizerOutput.lines\n            );\n\n            if (comparePositions(this._position, callNameEnd) > 0) {\n                this._addNamedParameters(signatureInfo, priorWord, completionList);\n\n                // Add literals that apply to this parameter.\n                this._addLiteralValuesForArgument(signatureInfo, priorText, postText, completionList);\n            }\n        }\n    }\n\n    private _addLiteralValuesForArgument(\n        signatureInfo: CallSignatureInfo,\n        priorText: string,\n        postText: string,\n        completionList: CompletionList\n    ) {\n        signatureInfo.signatures.forEach((signature) => {\n            if (!signature.activeParam) {\n                return undefined;\n            }\n\n            const type = signature.type;\n            const paramIndex = type.details.parameters.indexOf(signature.activeParam);\n\n            if (paramIndex < 0) {\n                return undefined;\n            }\n\n            const paramType = type.details.parameters[paramIndex].type;\n            this._addLiteralValuesForTargetType(paramType, priorText, postText, completionList);\n            return undefined;\n        });\n    }\n\n    private _addLiteralValuesForTargetType(\n        type: Type,\n        priorText: string,\n        postText: string,\n        completionList: CompletionList\n    ) {\n        const quoteValue = this._getQuoteValueFromPriorText(priorText);\n        doForSubtypes(type, (subtype) => {\n            if (isObject(subtype)) {\n                if (ClassType.isBuiltIn(subtype.classType, 'str')) {\n                    if (subtype.classType.literalValue !== undefined) {\n                        this._addStringLiteralToCompletionList(\n                            subtype.classType.literalValue as string,\n                            quoteValue.stringValue,\n                            postText,\n                            quoteValue.quoteCharacter,\n                            completionList\n                        );\n                    }\n                }\n            }\n\n            return undefined;\n        });\n    }\n\n    private _getStringLiteralCompletions(\n        parseNode: StringNode,\n        priorWord: string,\n        priorText: string,\n        postText: string\n    ): CompletionResults | undefined {\n        let parentNode: ParseNode | undefined = parseNode.parent;\n        if (!parentNode || parentNode.nodeType !== ParseNodeType.StringList || parentNode.strings.length > 1) {\n            return undefined;\n        }\n\n        parentNode = parentNode.parent;\n        if (!parentNode) {\n            return undefined;\n        }\n\n        const completionList = CompletionList.create();\n\n        if (parentNode.nodeType === ParseNodeType.IndexItems) {\n            parentNode = parentNode.parent;\n            if (!parentNode || parentNode.nodeType !== ParseNodeType.Index) {\n                return undefined;\n            }\n\n            const baseType = this._evaluator.getType(parentNode.baseExpression);\n            if (!baseType || !isObject(baseType)) {\n                return undefined;\n            }\n\n            // We currently handle only TypedDict objects.\n            const classType = baseType.classType;\n            if (!ClassType.isTypedDictClass(classType)) {\n                return;\n            }\n\n            const entries = this._evaluator.getTypedDictMembersForClass(classType);\n            const quoteValue = this._getQuoteValueFromPriorText(priorText);\n\n            entries.forEach((_, key) => {\n                this._addStringLiteralToCompletionList(\n                    key,\n                    quoteValue.stringValue,\n                    postText,\n                    quoteValue.quoteCharacter,\n                    completionList\n                );\n            });\n        } else if (parentNode.nodeType === ParseNodeType.Assignment) {\n            const declaredTypeOfTarget = this._evaluator.getDeclaredTypeForExpression(parentNode.leftExpression);\n\n            if (declaredTypeOfTarget) {\n                this._addLiteralValuesForTargetType(declaredTypeOfTarget, priorText, postText, completionList);\n            }\n        } else {\n            this._addCallArgumentCompletions(parseNode, priorWord, priorText, postText, completionList);\n        }\n\n        return { completionList };\n    }\n\n    // Given a string of text that precedes the current insertion point,\n    // determines which portion of it is the first part of a string literal\n    // (either starting with a single or double quote). Returns the quote\n    // type and the string literal value after the starting quote.\n    private _getQuoteValueFromPriorText(priorText: string) {\n        const lastSingleQuote = priorText.lastIndexOf(\"'\");\n        const lastDoubleQuote = priorText.lastIndexOf('\"');\n\n        let quoteCharacter = this._parseResults.tokenizerOutput.predominantSingleQuoteCharacter;\n        let stringValue = undefined;\n\n        if (lastSingleQuote > lastDoubleQuote) {\n            quoteCharacter = \"'\";\n            stringValue = priorText.substr(lastSingleQuote + 1);\n        } else if (lastDoubleQuote > lastSingleQuote) {\n            quoteCharacter = '\"';\n            stringValue = priorText.substr(lastDoubleQuote + 1);\n        }\n\n        return { stringValue, quoteCharacter };\n    }\n\n    private _getIndexStringLiteral(parseNode: ErrorNode, completionList: CompletionList) {\n        if (!parseNode.parent || parseNode.parent.nodeType !== ParseNodeType.IndexItems) {\n            return;\n        }\n\n        const parentNode = parseNode.parent;\n        if (!parentNode.parent || parentNode.parent.nodeType !== ParseNodeType.Index) {\n            return;\n        }\n\n        const baseType = this._evaluator.getType(parentNode.parent.baseExpression);\n        if (!baseType || !isObject(baseType)) {\n            return;\n        }\n\n        // We currently handle only TypedDict objects.\n        const classType = baseType.classType;\n        if (!ClassType.isTypedDictClass(classType)) {\n            return;\n        }\n\n        const entries = this._evaluator.getTypedDictMembersForClass(classType);\n        entries.forEach((_, key) => {\n            this._addStringLiteralToCompletionList(\n                key,\n                undefined,\n                undefined,\n                this._parseResults.tokenizerOutput.predominantSingleQuoteCharacter,\n                completionList\n            );\n        });\n    }\n\n    private _addStringLiteralToCompletionList(\n        value: string,\n        priorString: string | undefined,\n        postText: string | undefined,\n        quoteCharacter: string,\n        completionList: CompletionList\n    ) {\n        const isSimilar = StringUtils.computeCompletionSimilarity(priorString || '', value) > similarityLimit;\n        if (isSimilar) {\n            const valueWithQuotes = `${quoteCharacter}${value}${quoteCharacter}`;\n            const completionItem = CompletionItem.create(valueWithQuotes);\n\n            completionItem.kind = CompletionItemKind.Text;\n            completionItem.sortText = this._makeSortText(SortCategory.LiteralValue, valueWithQuotes);\n            let rangeStartCol = this._position.character;\n            if (priorString !== undefined) {\n                rangeStartCol -= priorString.length + 1;\n            }\n\n            // If the text after the insertion point is the closing quote,\n            // replace it.\n            let rangeEndCol = this._position.character;\n            if (postText !== undefined) {\n                if (postText.startsWith(quoteCharacter)) {\n                    rangeEndCol++;\n                }\n            }\n\n            const range: Range = {\n                start: { line: this._position.line, character: rangeStartCol },\n                end: { line: this._position.line, character: rangeEndCol },\n            };\n            completionItem.textEdit = TextEdit.replace(range, valueWithQuotes);\n\n            completionList.items.push(completionItem);\n        }\n    }\n\n    private _getAutoImportCompletions(priorWord: string, completionList: CompletionList) {\n        const moduleSymbolMap = this._moduleSymbolsCallback();\n        const autoImporter = new AutoImporter(\n            this._configOptions,\n            this._importResolver,\n            this._parseResults,\n            this._position,\n            completionList.items.filter((i) => !i.data?.autoImport).map((i) => i.label),\n            moduleSymbolMap,\n            this._libraryMap\n        );\n\n        for (const result of autoImporter.getAutoImportCandidates(\n            priorWord,\n            similarityLimit,\n            undefined,\n            this._cancellationToken\n        )) {\n            if (result.symbol) {\n                this._addSymbol(\n                    result.name,\n                    result.symbol,\n                    priorWord,\n                    completionList,\n                    result.source,\n                    undefined,\n                    result.edits\n                );\n            } else {\n                this._addNameToCompletionList(\n                    result.name,\n                    result.kind ?? CompletionItemKind.Module,\n                    priorWord,\n                    completionList,\n                    undefined,\n                    '',\n                    result.source\n                        ? `Auto-import\\n\\n\\`\\`\\`\\nfrom ${result.source} import ${result.name}\\n\\`\\`\\``\n                        : `Auto-import\\n\\n\\`\\`\\`\\nimport ${result.name}\\n\\`\\`\\``,\n                    undefined,\n                    result.edits\n                );\n            }\n        }\n    }\n\n    private _getImportFromCompletions(\n        importFromNode: ImportFromNode,\n        priorWord: string\n    ): CompletionResults | undefined {\n        // Don't attempt to provide completions for \"from X import *\".\n        if (importFromNode.isWildcardImport) {\n            return undefined;\n        }\n\n        // Access the imported module information, which is hanging\n        // off the ImportFromNode.\n        const importInfo = AnalyzerNodeInfo.getImportInfo(importFromNode.module);\n        if (!importInfo) {\n            return undefined;\n        }\n\n        const completionList = CompletionList.create();\n\n        const resolvedPath =\n            importInfo.resolvedPaths.length > 0 ? importInfo.resolvedPaths[importInfo.resolvedPaths.length - 1] : '';\n\n        const lookupResults = this._importLookup(resolvedPath);\n        if (lookupResults) {\n            this._addSymbolsForSymbolTable(\n                lookupResults.symbolTable,\n                (name) => {\n                    // Don't suggest symbols that have already been imported.\n                    return !importFromNode.imports.find((imp) => imp.name.value === name);\n                },\n                priorWord,\n                undefined,\n                completionList\n            );\n        }\n\n        // Add the implicit imports.\n        importInfo.implicitImports.forEach((implImport) => {\n            if (!importFromNode.imports.find((imp) => imp.name.value === implImport.name)) {\n                this._addNameToCompletionList(implImport.name, CompletionItemKind.Module, priorWord, completionList);\n            }\n        });\n\n        return { completionList };\n    }\n\n    private _findMatchingKeywords(keywordList: string[], partialMatch: string): string[] {\n        return keywordList.filter((keyword) => {\n            if (partialMatch) {\n                return StringUtils.computeCompletionSimilarity(partialMatch, keyword) > similarityLimit;\n            } else {\n                return true;\n            }\n        });\n    }\n\n    private _addNamedParameters(signatureInfo: CallSignatureInfo, priorWord: string, completionList: CompletionList) {\n        const argNameMap = new Map<string, string>();\n\n        signatureInfo.signatures.forEach((signature) => {\n            this._addNamedParametersToMap(signature.type, argNameMap);\n        });\n\n        // Remove any named parameters that are already provided.\n        signatureInfo.callNode.arguments!.forEach((arg) => {\n            if (arg.name) {\n                argNameMap.delete(arg.name.value);\n            }\n        });\n\n        // Add the remaining unique parameter names to the completion list.\n        argNameMap.forEach((argName) => {\n            const similarity = StringUtils.computeCompletionSimilarity(priorWord, argName);\n\n            if (similarity > similarityLimit) {\n                const completionItem = CompletionItem.create(argName + '=');\n                completionItem.kind = CompletionItemKind.Variable;\n\n                const completionItemData: CompletionItemData = {\n                    workspacePath: this._workspacePath,\n                    filePath: this._filePath,\n                    position: this._position,\n                };\n                completionItem.data = completionItemData;\n                completionItem.sortText = this._makeSortText(SortCategory.NamedParameter, argName);\n\n                completionList.items.push(completionItem);\n            }\n        });\n    }\n\n    private _addNamedParametersToMap(type: FunctionType, paramMap: Map<string, string>) {\n        type.details.parameters.forEach((param) => {\n            if (param.name && !param.isNameSynthesized) {\n                // Don't add private or protected names. These are assumed\n                // not to be named parameters.\n                if (!SymbolNameUtils.isPrivateOrProtectedName(param.name)) {\n                    paramMap.set(param.name, param.name);\n                }\n            }\n        });\n    }\n\n    private _addSymbols(node: ParseNode, priorWord: string, completionList: CompletionList) {\n        let curNode: ParseNode | undefined = node;\n\n        while (curNode) {\n            // Does this node have a scope associated with it?\n            let scope = AnalyzerNodeInfo.getScope(curNode);\n            if (scope) {\n                while (scope) {\n                    this._addSymbolsForSymbolTable(scope.symbolTable, () => true, priorWord, undefined, completionList);\n                    scope = scope.parent;\n                }\n\n                // If this is a class scope, add symbols from parent classes.\n                if (curNode.nodeType === ParseNodeType.Class) {\n                    const classType = this._evaluator.getTypeOfClass(curNode);\n                    if (classType && isClass(classType.classType)) {\n                        classType.classType.details.mro.forEach((baseClass, index) => {\n                            if (isClass(baseClass)) {\n                                this._addSymbolsForSymbolTable(\n                                    baseClass.details.fields,\n                                    (name) => {\n                                        const symbol = baseClass.details.fields.get(name);\n                                        if (!symbol || !symbol.isClassMember()) {\n                                            return false;\n                                        }\n\n                                        // Return only variables, not methods or classes.\n                                        return symbol\n                                            .getDeclarations()\n                                            .some((decl) => decl.type === DeclarationType.Variable);\n                                    },\n                                    priorWord,\n                                    undefined,\n                                    completionList\n                                );\n                            }\n                        });\n                    }\n                }\n                break;\n            }\n\n            curNode = curNode.parent;\n        }\n    }\n\n    private _addSymbolsForSymbolTable(\n        symbolTable: SymbolTable,\n        includeSymbolCallback: (name: string) => boolean,\n        priorWord: string,\n        objectThrough: ObjectType | undefined,\n        completionList: CompletionList\n    ) {\n        symbolTable.forEach((symbol, name) => {\n            // If there are no declarations or the symbol is not\n            // exported from this scope, don't include it in the\n            // suggestion list.\n            if (!symbol.isExternallyHidden() && includeSymbolCallback(name)) {\n                // Don't add a symbol more than once. It may have already been\n                // added from an inner scope's symbol table.\n                if (!completionList.items.some((item) => item.label === name)) {\n                    this._addSymbol(\n                        name,\n                        symbol,\n                        priorWord,\n                        completionList,\n                        undefined,\n                        undefined,\n                        undefined,\n                        objectThrough\n                    );\n                }\n            }\n        });\n    }\n\n    private _addSymbol(\n        name: string,\n        symbol: Symbol,\n        priorWord: string,\n        completionList: CompletionList,\n        autoImportSource?: string,\n        textEdit?: TextEdit,\n        additionalTextEdits?: TextEditAction[],\n        objectThrough?: ObjectType\n    ) {\n        let primaryDecl = getLastTypedDeclaredForSymbol(symbol);\n        if (!primaryDecl) {\n            const declarations = symbol.getDeclarations();\n            if (declarations.length > 0) {\n                primaryDecl = declarations[declarations.length - 1];\n            }\n        }\n\n        if (primaryDecl) {\n            let itemKind: CompletionItemKind = CompletionItemKind.Variable;\n\n            primaryDecl = this._evaluator.resolveAliasDeclaration(primaryDecl, /* resolveLocalNames */ true);\n            if (primaryDecl) {\n                itemKind = this._convertDeclarationTypeToItemKind(primaryDecl);\n\n                // Are we resolving a completion item? If so, see if this symbol\n                // is the one that we're trying to match.\n                if (this._itemToResolve) {\n                    const completionItemData = this._itemToResolve.data;\n\n                    if (completionItemData.symbolId === symbol.id) {\n                        // This call can be expensive to perform on every completion item\n                        // that we return, so we do it lazily in the \"resolve\" callback.\n                        const type = this._evaluator.getEffectiveTypeOfSymbol(symbol);\n                        if (type) {\n                            let typeDetail: string | undefined;\n                            let documentation: string | undefined;\n\n                            switch (primaryDecl.type) {\n                                case DeclarationType.Intrinsic:\n                                case DeclarationType.Variable:\n                                case DeclarationType.Parameter:\n                                    typeDetail =\n                                        name + ': ' + this._evaluator.printType(type, /* expandTypeAlias */ false);\n                                    break;\n\n                                case DeclarationType.Function: {\n                                    const functionType = objectThrough\n                                        ? this._evaluator.bindFunctionToClassOrObject(objectThrough, type, false)\n                                        : type;\n                                    if (functionType) {\n                                        if (isProperty(functionType) && objectThrough) {\n                                            const propertyType =\n                                                this._evaluator.getGetterTypeFromProperty(\n                                                    functionType.classType,\n                                                    /* inferTypeIfNeeded */ true\n                                                ) || UnknownType.create();\n                                            typeDetail =\n                                                name +\n                                                ': ' +\n                                                this._evaluator.printType(propertyType, /* expandTypeAlias */ false) +\n                                                ' (property)';\n                                        } else if (functionType.category === TypeCategory.OverloadedFunction) {\n                                            typeDetail = functionType.overloads\n                                                .map(\n                                                    (overload) =>\n                                                        name +\n                                                        this._evaluator.printType(overload, /* expandTypeAlias */ false)\n                                                )\n                                                .join('\\n');\n                                        } else {\n                                            typeDetail =\n                                                name +\n                                                ': ' +\n                                                this._evaluator.printType(functionType, /* expandTypeAlias */ false);\n                                        }\n                                    }\n                                    break;\n                                }\n                                case DeclarationType.Class:\n                                case DeclarationType.SpecialBuiltInClass: {\n                                    typeDetail = 'class ' + name + '()';\n                                    break;\n                                }\n\n                                case DeclarationType.Alias: {\n                                    typeDetail = name;\n                                    if (primaryDecl.path) {\n                                        const lookupResults = this._importLookup(primaryDecl.path);\n                                        if (lookupResults) {\n                                            documentation = lookupResults.docString;\n                                        }\n                                    }\n                                    break;\n                                }\n\n                                default: {\n                                    typeDetail = name;\n                                    break;\n                                }\n                            }\n\n                            if (isModule(type)) {\n                                documentation = getModuleDocString(type, primaryDecl, this._sourceMapper);\n                            } else if (isClass(type)) {\n                                documentation = getClassDocString(type, primaryDecl, this._sourceMapper);\n                            } else if (type.category === TypeCategory.Function) {\n                                documentation = getFunctionDocStringFromType(type, this._sourceMapper);\n                            } else if (type.category === TypeCategory.OverloadedFunction) {\n                                documentation = getOverloadedFunctionDocStrings(\n                                    type,\n                                    primaryDecl,\n                                    this._sourceMapper\n                                ).find((doc) => doc);\n                            } else if (primaryDecl.type === DeclarationType.Function) {\n                                // @property functions\n                                documentation = getFunctionDocStringFromDeclaration(primaryDecl, this._sourceMapper);\n                            }\n\n                            let markdownString = '```python\\n' + typeDetail + '\\n```\\n';\n\n                            if (documentation) {\n                                markdownString += '---\\n';\n                                markdownString += convertDocStringToMarkdown(documentation);\n                            }\n\n                            if (markdownString) {\n                                this._itemToResolve.documentation = {\n                                    kind: MarkupKind.Markdown,\n                                    value: markdownString,\n                                };\n                            }\n                        }\n                    }\n                }\n            }\n\n            let autoImportText: string | undefined;\n            if (autoImportSource) {\n                autoImportText = `Auto-import\\n\\n\\`\\`\\`\\nfrom ${autoImportSource} import ${name}\\n\\`\\`\\``;\n            }\n\n            this._addNameToCompletionList(\n                name,\n                itemKind,\n                priorWord,\n                completionList,\n                undefined,\n                undefined,\n                autoImportText,\n                textEdit,\n                additionalTextEdits,\n                symbol.id\n            );\n        } else {\n            // Does the symbol have no declaration but instead has a synthesized type?\n            const synthesizedType = symbol.getSynthesizedType();\n            if (synthesizedType) {\n                const itemKind: CompletionItemKind = CompletionItemKind.Variable;\n                this._addNameToCompletionList(\n                    name,\n                    itemKind,\n                    priorWord,\n                    completionList,\n                    undefined,\n                    undefined,\n                    undefined,\n                    textEdit,\n                    additionalTextEdits,\n                    symbol.id\n                );\n            }\n        }\n    }\n\n    private _addNameToCompletionList(\n        name: string,\n        itemKind: CompletionItemKind,\n        filter: string,\n        completionList: CompletionList,\n        typeDetail?: string,\n        documentation?: string,\n        autoImportText?: string,\n        textEdit?: TextEdit,\n        additionalTextEdits?: TextEditAction[],\n        symbolId?: number\n    ) {\n        const similarity = StringUtils.computeCompletionSimilarity(filter, name);\n\n        if (similarity > similarityLimit) {\n            const completionItem = CompletionItem.create(name);\n            completionItem.kind = itemKind;\n\n            const completionItemData: CompletionItemData = {\n                workspacePath: this._workspacePath,\n                filePath: this._filePath,\n                position: this._position,\n            };\n            completionItem.data = completionItemData;\n\n            if (autoImportText) {\n                // Force auto-import entries to the end.\n                completionItem.sortText = this._makeSortText(SortCategory.AutoImport, name, autoImportText);\n                completionItemData.autoImportText = autoImportText;\n            } else if (SymbolNameUtils.isDunderName(name)) {\n                // Force dunder-named symbols to appear after all other symbols.\n                completionItem.sortText = this._makeSortText(SortCategory.DunderSymbol, name);\n            } else if (filter === '' && SymbolNameUtils.isPrivateOrProtectedName(name)) {\n                // Distinguish between normal and private symbols only if there is\n                // currently no filter text. Once we get a single character to filter\n                // upon, we'll no longer differentiate.\n                completionItem.sortText = this._makeSortText(SortCategory.PrivateSymbol, name);\n            } else {\n                completionItem.sortText = this._makeSortText(SortCategory.NormalSymbol, name);\n            }\n\n            if (symbolId !== undefined) {\n                completionItemData.symbolId = symbolId;\n            }\n\n            let markdownString = '';\n\n            if (autoImportText) {\n                markdownString += autoImportText;\n                markdownString += '\\n\\n';\n            }\n\n            if (typeDetail) {\n                markdownString += '```python\\n' + typeDetail + '\\n```\\n';\n            }\n\n            if (documentation) {\n                markdownString += '---\\n';\n                markdownString += convertDocStringToMarkdown(documentation);\n            }\n\n            markdownString = markdownString.trimEnd();\n\n            if (markdownString) {\n                completionItem.documentation = {\n                    kind: MarkupKind.Markdown,\n                    value: markdownString,\n                };\n            }\n\n            if (textEdit) {\n                completionItem.textEdit = textEdit;\n            }\n\n            if (additionalTextEdits) {\n                completionItem.additionalTextEdits = additionalTextEdits.map((te) => {\n                    const textEdit: TextEdit = {\n                        range: {\n                            start: { line: te.range.start.line, character: te.range.start.character },\n                            end: { line: te.range.end.line, character: te.range.end.character },\n                        },\n                        newText: te.replacementText,\n                    };\n                    return textEdit;\n                });\n            }\n\n            completionList.items.push(completionItem);\n        }\n    }\n\n    private _getRecentListIndex(name: string, autoImportText: string) {\n        return CompletionProvider._mostRecentCompletions.findIndex(\n            (item) => item.label === name && item.autoImportText === autoImportText\n        );\n    }\n\n    private _makeSortText(sortCategory: SortCategory, name: string, autoImportText = ''): string {\n        const recentListIndex = this._getRecentListIndex(name, autoImportText);\n\n        // If the label is in the recent list, modify the category\n        // so it appears higher in our list.\n        if (recentListIndex >= 0) {\n            if (sortCategory === SortCategory.AutoImport) {\n                sortCategory = SortCategory.RecentAutoImport;\n            } else if (sortCategory === SortCategory.ImportModuleName) {\n                sortCategory = SortCategory.RecentImportModuleName;\n            } else if (\n                sortCategory === SortCategory.Keyword ||\n                sortCategory === SortCategory.NormalSymbol ||\n                sortCategory === SortCategory.PrivateSymbol ||\n                sortCategory === SortCategory.DunderSymbol\n            ) {\n                sortCategory = SortCategory.RecentKeywordOrSymbol;\n            }\n        }\n\n        // Generate a sort string of the format\n        //    XX.YYYY.name\n        // where XX is the sort category\n        // and YYYY is the index of the item in the MRU list\n        return this._formatInteger(sortCategory, 2) + '.' + this._formatInteger(recentListIndex, 4) + '.' + name;\n    }\n\n    private _formatInteger(val: number, digits: number): string {\n        const charCodeZero = '0'.charCodeAt(0);\n\n        let result = '';\n        for (let i = 0; i < digits; i++) {\n            // Prepend the next digit.\n            let digit = Math.floor(val % 10);\n            if (digit < 0) {\n                digit = 9;\n            }\n            result = String.fromCharCode(digit + charCodeZero) + result;\n            val = Math.floor(val / 10);\n        }\n\n        return result;\n    }\n\n    private _convertDeclarationTypeToItemKind(declaration: Declaration): CompletionItemKind {\n        const resolvedDeclaration = this._evaluator.resolveAliasDeclaration(declaration, /* resolveLocalNames */ true);\n        if (!resolvedDeclaration) {\n            return CompletionItemKind.Variable;\n        }\n\n        switch (resolvedDeclaration.type) {\n            case DeclarationType.Intrinsic:\n                return resolvedDeclaration.intrinsicType === 'class'\n                    ? CompletionItemKind.Class\n                    : CompletionItemKind.Variable;\n\n            case DeclarationType.Parameter:\n                return CompletionItemKind.Variable;\n\n            case DeclarationType.Variable:\n                return resolvedDeclaration.isConstant || resolvedDeclaration.isFinal\n                    ? CompletionItemKind.Constant\n                    : CompletionItemKind.Variable;\n\n            case DeclarationType.Function: {\n                const functionType = this._evaluator.getTypeOfFunction(resolvedDeclaration.node);\n                if (functionType && isProperty(functionType.decoratedType)) {\n                    return CompletionItemKind.Property;\n                }\n                return resolvedDeclaration.isMethod ? CompletionItemKind.Method : CompletionItemKind.Function;\n            }\n\n            case DeclarationType.Class:\n            case DeclarationType.SpecialBuiltInClass:\n                return CompletionItemKind.Class;\n\n            case DeclarationType.Alias:\n                return CompletionItemKind.Module;\n        }\n    }\n\n    private _getImportModuleCompletions(node: ModuleNameNode): CompletionResults {\n        const execEnvironment = this._configOptions.findExecEnvironment(this._filePath);\n        const moduleDescriptor: ImportedModuleDescriptor = {\n            leadingDots: node.leadingDots,\n            hasTrailingDot: node.hasTrailingDot,\n            nameParts: node.nameParts.map((part) => part.value),\n            importedSymbols: [],\n        };\n\n        const completions = this._importResolver.getCompletionSuggestions(\n            this._filePath,\n            execEnvironment,\n            moduleDescriptor,\n            similarityLimit\n        );\n\n        const completionList = CompletionList.create();\n\n        // If we're in the middle of a \"from X import Y\" statement, offer\n        // the \"import\" keyword as a completion.\n        if (\n            !node.hasTrailingDot &&\n            node.parent &&\n            node.parent.nodeType === ParseNodeType.ImportFrom &&\n            node.parent.missingImportKeyword\n        ) {\n            const keyword = 'import';\n            const completionItem = CompletionItem.create(keyword);\n            completionItem.kind = CompletionItemKind.Keyword;\n            completionList.items.push(completionItem);\n            completionItem.sortText = this._makeSortText(SortCategory.Keyword, keyword);\n        }\n\n        completions.forEach((completionName) => {\n            const completionItem = CompletionItem.create(completionName);\n            completionItem.kind = CompletionItemKind.Module;\n            completionList.items.push(completionItem);\n            completionItem.sortText = this._makeSortText(SortCategory.ImportModuleName, completionName);\n        });\n\n        return { completionList };\n    }\n}\n","/*\n * definitionProvider.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Logic that maps a position within a Python program file into\n * a \"definition\" of the item that is referred to at that position.\n * For example, if the location is within an import name, the\n * definition is the top of the resolved import file.\n */\n\nimport { CancellationToken } from 'vscode-languageserver';\n\nimport * as ParseTreeUtils from '../analyzer/parseTreeUtils';\nimport { isStubFile, SourceMapper } from '../analyzer/sourceMapper';\nimport { TypeEvaluator } from '../analyzer/typeEvaluator';\nimport { throwIfCancellationRequested } from '../common/cancellationUtils';\nimport { convertPositionToOffset } from '../common/positionUtils';\nimport { DocumentRange, Position, rangesAreEqual } from '../common/textRange';\nimport { ParseNodeType } from '../parser/parseNodes';\nimport { ParseResults } from '../parser/parser';\n\nexport class DefinitionProvider {\n    static getDefinitionsForPosition(\n        sourceMapper: SourceMapper,\n        parseResults: ParseResults,\n        position: Position,\n        evaluator: TypeEvaluator,\n        token: CancellationToken\n    ): DocumentRange[] | undefined {\n        throwIfCancellationRequested(token);\n\n        const offset = convertPositionToOffset(position, parseResults.tokenizerOutput.lines);\n        if (offset === undefined) {\n            return undefined;\n        }\n\n        const node = ParseTreeUtils.findNodeByOffset(parseResults.parseTree, offset);\n        if (node === undefined) {\n            return undefined;\n        }\n\n        const definitions: DocumentRange[] = [];\n\n        if (node.nodeType === ParseNodeType.Name) {\n            const declarations = evaluator.getDeclarationsForNameNode(node);\n            if (declarations) {\n                declarations.forEach((decl) => {\n                    const resolvedDecl = evaluator.resolveAliasDeclaration(decl, /* resolveLocalNames */ true);\n                    if (resolvedDecl && resolvedDecl.path) {\n                        this._addIfUnique(definitions, {\n                            path: resolvedDecl.path,\n                            range: resolvedDecl.range,\n                        });\n\n                        if (isStubFile(resolvedDecl.path)) {\n                            const implDecls = sourceMapper.findDeclarations(resolvedDecl);\n                            for (const implDecl of implDecls) {\n                                if (implDecl && implDecl.path) {\n                                    this._addIfUnique(definitions, {\n                                        path: implDecl.path,\n                                        range: implDecl.range,\n                                    });\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n        }\n\n        return definitions.length > 0 ? definitions : undefined;\n    }\n\n    private static _addIfUnique(definitions: DocumentRange[], itemToAdd: DocumentRange) {\n        for (const def of definitions) {\n            if (def.path === itemToAdd.path && rangesAreEqual(def.range, itemToAdd.range)) {\n                return;\n            }\n        }\n\n        definitions.push(itemToAdd);\n    }\n}\n","/*\n * documentHighlightProvider.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Logic that maps a position within a Python program file into\n * one or more highlight types.\n */\n\nimport { CancellationToken, DocumentHighlight, DocumentHighlightKind } from 'vscode-languageserver';\n\nimport { isCodeUnreachable } from '../analyzer/analyzerNodeInfo';\nimport { Declaration } from '../analyzer/declaration';\nimport { areDeclarationsSame } from '../analyzer/declarationUtils';\nimport * as ParseTreeUtils from '../analyzer/parseTreeUtils';\nimport { ParseTreeWalker } from '../analyzer/parseTreeWalker';\nimport { TypeEvaluator } from '../analyzer/typeEvaluator';\nimport { throwIfCancellationRequested } from '../common/cancellationUtils';\nimport { convertOffsetToPosition, convertPositionToOffset } from '../common/positionUtils';\nimport { Position, TextRange } from '../common/textRange';\nimport { ModuleNameNode, NameNode, ParseNode, ParseNodeType, StringNode } from '../parser/parseNodes';\nimport { ParseResults } from '../parser/parser';\n\n// This walker looks for symbols that are semantically equivalent\n// to the requested symbol.\nclass HighlightSymbolTreeWalker extends ParseTreeWalker {\n    constructor(\n        private _symbolName: string,\n        private _declarations: Declaration[],\n        private _parseResults: ParseResults,\n        private _highlightResults: DocumentHighlight[],\n        private _evaluator: TypeEvaluator,\n        private _cancellationToken: CancellationToken\n    ) {\n        super();\n    }\n\n    findHighlights() {\n        this.walk(this._parseResults.parseTree);\n    }\n\n    walk(node: ParseNode) {\n        if (!isCodeUnreachable(node)) {\n            super.walk(node);\n        }\n    }\n\n    visitModuleName(node: ModuleNameNode): boolean {\n        // Don't ever look for references within a module name.\n        return false;\n    }\n\n    visitName(node: NameNode): boolean {\n        throwIfCancellationRequested(this._cancellationToken);\n\n        // No need to do any more work if the symbol name doesn't match.\n        if (node.value !== this._symbolName) {\n            return false;\n        }\n\n        if (this._declarations.length > 0) {\n            const declarations = this._evaluator.getDeclarationsForNameNode(node);\n\n            if (declarations && declarations.length > 0) {\n                // Does this name share a declaration with the symbol of interest?\n                if (declarations.some((decl) => this._resultsContainsDeclaration(decl))) {\n                    this._addResult(node);\n                }\n            }\n        } else {\n            // There were no declarations\n            this._addResult(node);\n        }\n\n        return true;\n    }\n\n    private _addResult(node: NameNode) {\n        this._highlightResults.push({\n            kind: this._isWriteAccess(node) ? DocumentHighlightKind.Write : DocumentHighlightKind.Read,\n            range: {\n                start: convertOffsetToPosition(node.start, this._parseResults.tokenizerOutput.lines),\n                end: convertOffsetToPosition(TextRange.getEnd(node), this._parseResults.tokenizerOutput.lines),\n            },\n        });\n    }\n\n    private _isWriteAccess(node: NameNode) {\n        let prevNode: ParseNode = node;\n        let curNode: ParseNode | undefined = prevNode.parent;\n\n        while (curNode) {\n            switch (curNode.nodeType) {\n                case ParseNodeType.Assignment: {\n                    return prevNode === curNode.leftExpression;\n                }\n\n                case ParseNodeType.AugmentedAssignment: {\n                    return prevNode === curNode.leftExpression;\n                }\n\n                case ParseNodeType.AssignmentExpression: {\n                    return prevNode === curNode.name;\n                }\n\n                case ParseNodeType.Del: {\n                    return true;\n                }\n\n                case ParseNodeType.For: {\n                    return prevNode === curNode.targetExpression;\n                }\n\n                case ParseNodeType.ImportAs: {\n                    return (\n                        prevNode === curNode.alias ||\n                        (curNode.module.nameParts.length > 0 && prevNode === curNode.module.nameParts[0])\n                    );\n                }\n\n                case ParseNodeType.ImportFromAs: {\n                    return prevNode === curNode.alias || (!curNode.alias && prevNode === curNode.name);\n                }\n\n                case ParseNodeType.MemberAccess: {\n                    if (prevNode !== curNode.memberName) {\n                        return false;\n                    }\n                    break;\n                }\n\n                case ParseNodeType.Except: {\n                    return prevNode === curNode.name;\n                }\n\n                case ParseNodeType.With: {\n                    return curNode.withItems.some((item) => item === prevNode);\n                }\n\n                case ParseNodeType.ListComprehensionFor: {\n                    return prevNode === curNode.targetExpression;\n                }\n\n                case ParseNodeType.TypeAnnotation: {\n                    if (prevNode === curNode.typeAnnotation) {\n                        return false;\n                    }\n                    break;\n                }\n\n                case ParseNodeType.Function:\n                case ParseNodeType.Class:\n                case ParseNodeType.Module: {\n                    return false;\n                }\n            }\n\n            prevNode = curNode;\n            curNode = curNode.parent;\n        }\n\n        return false;\n    }\n\n    private _resultsContainsDeclaration(declaration: Declaration) {\n        // Resolve the declaration.\n        const resolvedDecl = this._evaluator.resolveAliasDeclaration(declaration, /* resolveLocalNames */ false);\n        if (!resolvedDecl) {\n            return false;\n        }\n\n        // The reference results declarations are already resolved, so we don't\n        // need to call resolveAliasDeclaration on them.\n        if (this._declarations.some((decl) => areDeclarationsSame(decl, resolvedDecl))) {\n            return true;\n        }\n\n        // We didn't find the declaration using local-only alias resolution. Attempt\n        // it again by fully resolving the alias.\n        const resolvedDeclNonlocal = this._evaluator.resolveAliasDeclaration(\n            resolvedDecl,\n            /* resolveLocalNames */ true\n        );\n        if (!resolvedDeclNonlocal || resolvedDeclNonlocal === resolvedDecl) {\n            return false;\n        }\n\n        return this._declarations.some((decl) => areDeclarationsSame(decl, resolvedDeclNonlocal));\n    }\n}\n\n// This walker looks for strings that are equivalent\n// to the requested string.\nclass HighlightStringTreeWalker extends ParseTreeWalker {\n    constructor(\n        private _stringValue: string,\n        private _parseResults: ParseResults,\n        private _highlightResults: DocumentHighlight[],\n        private _cancellationToken: CancellationToken\n    ) {\n        super();\n    }\n\n    findHighlights() {\n        this.walk(this._parseResults.parseTree);\n    }\n\n    walk(node: ParseNode) {\n        if (!isCodeUnreachable(node)) {\n            super.walk(node);\n        }\n    }\n\n    visitString(node: StringNode): boolean {\n        throwIfCancellationRequested(this._cancellationToken);\n\n        // Compare the unescaped values.\n        if (node.value !== this._stringValue) {\n            return false;\n        }\n\n        this._highlightResults.push({\n            kind: DocumentHighlightKind.Text,\n            range: {\n                start: convertOffsetToPosition(node.start, this._parseResults.tokenizerOutput.lines),\n                end: convertOffsetToPosition(TextRange.getEnd(node), this._parseResults.tokenizerOutput.lines),\n            },\n        });\n\n        return true;\n    }\n}\n\nexport class DocumentHighlightProvider {\n    static getDocumentHighlight(\n        parseResults: ParseResults,\n        position: Position,\n        evaluator: TypeEvaluator,\n        token: CancellationToken\n    ): DocumentHighlight[] | undefined {\n        throwIfCancellationRequested(token);\n\n        const offset = convertPositionToOffset(position, parseResults.tokenizerOutput.lines);\n        if (offset === undefined) {\n            return undefined;\n        }\n\n        const node = ParseTreeUtils.findNodeByOffset(parseResults.parseTree, offset);\n        if (node === undefined) {\n            return undefined;\n        }\n\n        const results: DocumentHighlight[] = [];\n\n        if (node.nodeType === ParseNodeType.Name) {\n            const declarations = evaluator.getDeclarationsForNameNode(node) || [];\n\n            const resolvedDeclarations: Declaration[] = [];\n            declarations.forEach((decl) => {\n                const resolvedDecl = evaluator.resolveAliasDeclaration(decl, true);\n                if (resolvedDecl) {\n                    resolvedDeclarations.push(resolvedDecl);\n                }\n            });\n\n            const walker = new HighlightSymbolTreeWalker(\n                node.value,\n                resolvedDeclarations,\n                parseResults,\n                results,\n                evaluator,\n                token\n            );\n            walker.findHighlights();\n        } else if (node.nodeType === ParseNodeType.String) {\n            const walker = new HighlightStringTreeWalker(node.value, parseResults, results, token);\n            walker.findHighlights();\n        }\n\n        return results.length > 0 ? results : undefined;\n    }\n}\n","/*\n * documentSymbolProvider.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Logic that enumerates all of the symbols within a specified\n * source file document.\n */\n\nimport { CancellationToken, DocumentSymbol, Location, SymbolInformation, SymbolKind } from 'vscode-languageserver';\nimport { URI } from 'vscode-uri';\n\nimport { resolveAliasDeclaration } from '../analyzer/aliasDeclarationUtils';\nimport { ImportLookup } from '../analyzer/analyzerFileInfo';\nimport * as AnalyzerNodeInfo from '../analyzer/analyzerNodeInfo';\nimport { AliasDeclaration, Declaration, DeclarationType } from '../analyzer/declaration';\nimport { getNameFromDeclaration } from '../analyzer/declarationUtils';\nimport { getLastTypedDeclaredForSymbol, getNamesInDunderAll } from '../analyzer/symbolUtils';\nimport { TypeEvaluator } from '../analyzer/typeEvaluator';\nimport { isProperty } from '../analyzer/typeUtils';\nimport { throwIfCancellationRequested } from '../common/cancellationUtils';\nimport { convertOffsetsToRange } from '../common/positionUtils';\nimport * as StringUtils from '../common/stringUtils';\nimport { Range } from '../common/textRange';\nimport { ParseResults } from '../parser/parser';\n\nexport interface IndexAliasData {\n    readonly originalName: string;\n    readonly modulePath: string;\n}\n\nexport interface IndexSymbolData {\n    readonly name: string;\n    readonly alias: IndexAliasData | undefined;\n    readonly externallyVisible: boolean;\n    readonly kind: SymbolKind;\n    readonly range: Range;\n    readonly selectionRange: Range;\n    readonly children: IndexSymbolData[];\n}\n\nexport interface IndexResults {\n    readonly privateOrProtected: boolean;\n    readonly symbols: IndexSymbolData[];\n}\n\nexport function includeAliasDeclarationInIndex(declaration: AliasDeclaration): boolean {\n    return declaration.usesLocalName && !!declaration.symbolName && declaration.path.length > 0;\n}\n\nexport function getIndexAliasData(\n    importLookup: ImportLookup | undefined,\n    declaration: AliasDeclaration\n): IndexAliasData | undefined {\n    if (!declaration.symbolName) {\n        return undefined;\n    }\n\n    const aliasData = { originalName: declaration.symbolName!, modulePath: declaration.path };\n    if (!importLookup) {\n        return aliasData;\n    }\n\n    const resolved = resolveAliasDeclaration(importLookup, declaration, true);\n    const nameValue = resolved ? getNameFromDeclaration(resolved) : undefined;\n    if (!nameValue || resolved!.path.length <= 0) {\n        return aliasData;\n    }\n\n    return { originalName: nameValue, modulePath: resolved!.path };\n}\n\n// We'll use a somewhat-arbitrary cutoff value here to determine\n// whether it's sufficiently similar.\nconst similarityLimit = 0.5;\n\nexport class DocumentSymbolProvider {\n    static addSymbolsForDocument(\n        indexResults: IndexResults | undefined,\n        parseResults: ParseResults | undefined,\n        filePath: string,\n        query: string,\n        symbolList: SymbolInformation[],\n        token: CancellationToken\n    ) {\n        if (!indexResults && !parseResults) {\n            return;\n        }\n\n        const indexSymbolData =\n            indexResults?.symbols ?? DocumentSymbolProvider.indexSymbols(parseResults!, false, token);\n        appendWorkspaceSymbolsRecursive(indexSymbolData, filePath, query, '', symbolList, token);\n    }\n\n    static addHierarchicalSymbolsForDocument(\n        indexResults: IndexResults | undefined,\n        parseResults: ParseResults | undefined,\n        symbolList: DocumentSymbol[],\n        token: CancellationToken\n    ) {\n        if (!indexResults && !parseResults) {\n            return;\n        }\n\n        const indexSymbolData =\n            indexResults?.symbols ?? DocumentSymbolProvider.indexSymbols(parseResults!, false, token);\n        appendDocumentSymbolsRecursive(indexSymbolData, symbolList, token);\n    }\n\n    static indexSymbols(\n        parseResults: ParseResults,\n        importSymbolsOnly: boolean,\n        token: CancellationToken\n    ): IndexSymbolData[] {\n        const indexSymbolData: IndexSymbolData[] = [];\n        collectSymbolIndexData(parseResults, parseResults.parseTree, importSymbolsOnly, indexSymbolData, token);\n\n        return indexSymbolData;\n    }\n}\n\nfunction getSymbolKind(name: string, declaration: Declaration, evaluator?: TypeEvaluator): SymbolKind | undefined {\n    let symbolKind: SymbolKind;\n    switch (declaration.type) {\n        case DeclarationType.Class:\n        case DeclarationType.SpecialBuiltInClass:\n            symbolKind = SymbolKind.Class;\n            break;\n\n        case DeclarationType.Function:\n            if (declaration.isMethod) {\n                const declType = evaluator?.getTypeForDeclaration(declaration);\n                if (declType && isProperty(declType)) {\n                    symbolKind = SymbolKind.Property;\n                } else {\n                    symbolKind = SymbolKind.Method;\n                }\n            } else {\n                symbolKind = SymbolKind.Function;\n            }\n            break;\n\n        case DeclarationType.Alias:\n            symbolKind = SymbolKind.Module;\n            break;\n\n        case DeclarationType.Parameter:\n            if (name === 'self' || name === 'cls' || name === '_') {\n                return;\n            }\n            symbolKind = SymbolKind.Variable;\n            break;\n\n        case DeclarationType.Variable:\n            if (name === '_') {\n                return;\n            }\n            symbolKind = declaration.isConstant || declaration.isFinal ? SymbolKind.Constant : SymbolKind.Variable;\n            break;\n\n        default:\n            symbolKind = SymbolKind.Variable;\n            break;\n    }\n\n    return symbolKind;\n}\n\nfunction appendWorkspaceSymbolsRecursive(\n    indexSymbolData: IndexSymbolData[],\n    filePath: string,\n    query: string,\n    container: string,\n    symbolList: SymbolInformation[],\n    token: CancellationToken\n) {\n    throwIfCancellationRequested(token);\n\n    for (const symbolData of indexSymbolData) {\n        if (symbolData.alias) {\n            continue;\n        }\n\n        const similarity = StringUtils.computeCompletionSimilarity(query, symbolData.name);\n        if (similarity >= similarityLimit) {\n            const location: Location = {\n                uri: URI.file(filePath).toString(),\n                range: symbolData.selectionRange,\n            };\n\n            const symbolInfo: SymbolInformation = {\n                name: symbolData.name,\n                kind: symbolData.kind,\n                containerName: container.length > 0 ? container : undefined,\n                location,\n            };\n\n            symbolList.push(symbolInfo);\n        }\n\n        appendWorkspaceSymbolsRecursive(\n            symbolData.children,\n            filePath,\n            query,\n            getContainerName(container, symbolData.name),\n            symbolList,\n            token\n        );\n    }\n\n    function getContainerName(container: string, name: string) {\n        if (container.length > 0) {\n            return `${container}.${name}`;\n        }\n\n        return name;\n    }\n}\n\nfunction appendDocumentSymbolsRecursive(\n    indexSymbolData: IndexSymbolData[],\n    symbolList: DocumentSymbol[],\n    token: CancellationToken\n) {\n    throwIfCancellationRequested(token);\n\n    for (const symbolData of indexSymbolData) {\n        if (symbolData.alias) {\n            continue;\n        }\n\n        const children: DocumentSymbol[] = [];\n        appendDocumentSymbolsRecursive(symbolData.children, children, token);\n\n        const symbolInfo: DocumentSymbol = {\n            name: symbolData.name,\n            kind: symbolData.kind,\n            range: symbolData.range,\n            selectionRange: symbolData.selectionRange,\n            children: children,\n        };\n\n        symbolList.push(symbolInfo);\n    }\n}\n\nfunction collectSymbolIndexData(\n    parseResults: ParseResults,\n    node: AnalyzerNodeInfo.ScopedNode,\n    autoImportMode: boolean,\n    indexSymbolData: IndexSymbolData[],\n    token: CancellationToken\n) {\n    throwIfCancellationRequested(token);\n\n    const scope = AnalyzerNodeInfo.getScope(node);\n    if (!scope) {\n        return;\n    }\n\n    // Build __all__ map for regular python file to reduce candidate in autoImportMode.\n    const file = AnalyzerNodeInfo.getFileInfo(parseResults.parseTree);\n    let allNameTable: Set<string> | undefined;\n    if (autoImportMode && !file?.isStubFile) {\n        allNameTable = new Set<string>(getNamesInDunderAll(scope.symbolTable) ?? []);\n    }\n\n    const symbolTable = scope.symbolTable;\n    symbolTable.forEach((symbol, name) => {\n        if (symbol.isIgnoredForProtocolMatch()) {\n            return;\n        }\n\n        if (allNameTable && !allNameTable.has(name)) {\n            // if allNameTable exists, then name must exist in the table.\n            return;\n        }\n\n        // Prefer declarations with a defined type.\n        let declaration = getLastTypedDeclaredForSymbol(symbol);\n\n        // Fall back to declarations without a type.\n        if (!declaration && symbol.hasDeclarations()) {\n            declaration = symbol.getDeclarations()[0];\n        }\n\n        if (!declaration) {\n            return;\n        }\n\n        if (DeclarationType.Alias === declaration.type) {\n            if (declaration.path.length <= 0) {\n                return;\n            }\n\n            if (!allNameTable && !includeAliasDeclarationInIndex(declaration)) {\n                // For import alias, we only put the alias in the index if it is the form of\n                // \"from x import y as z\" or the alias is explicitly listed in __all__\n                return;\n            }\n        }\n\n        collectSymbolIndexDataForName(\n            parseResults,\n            declaration,\n            autoImportMode,\n            !symbol.isExternallyHidden(),\n            name,\n            indexSymbolData,\n            token\n        );\n    });\n}\n\nfunction collectSymbolIndexDataForName(\n    parseResults: ParseResults,\n    declaration: Declaration,\n    autoImportMode: boolean,\n    externallyVisible: boolean,\n    name: string,\n    indexSymbolData: IndexSymbolData[],\n    token: CancellationToken\n) {\n    if (autoImportMode && !externallyVisible) {\n        return;\n    }\n\n    const symbolKind = getSymbolKind(name, declaration);\n    if (symbolKind === undefined) {\n        return;\n    }\n\n    const selectionRange = declaration.range;\n    let range = selectionRange;\n    const children: IndexSymbolData[] = [];\n\n    if (declaration.type === DeclarationType.Class || declaration.type === DeclarationType.Function) {\n        if (!autoImportMode) {\n            collectSymbolIndexData(parseResults, declaration.node, false, children, token);\n        }\n\n        const nameRange = convertOffsetsToRange(\n            declaration.node.start,\n            declaration.node.name.start + declaration.node.length,\n            parseResults.tokenizerOutput.lines\n        );\n        range = nameRange;\n    }\n\n    const data: IndexSymbolData = {\n        name,\n        alias:\n            DeclarationType.Alias === declaration.type\n                ? getIndexAliasData(AnalyzerNodeInfo.getFileInfo(parseResults.parseTree)?.importLookup, declaration)\n                : undefined,\n        externallyVisible,\n        kind: symbolKind,\n        range,\n        selectionRange,\n        children,\n    };\n\n    indexSymbolData.push(data);\n}\n","/*\n * hoverProvider.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Logic that maps a position within a Python program file into\n * markdown text that is displayed when the user hovers over that\n * position within a smart editor.\n */\n\nimport { CancellationToken, Hover, MarkupKind } from 'vscode-languageserver';\n\nimport { Declaration, DeclarationBase, DeclarationType, FunctionDeclaration } from '../analyzer/declaration';\nimport { convertDocStringToMarkdown } from '../analyzer/docStringToMarkdown';\nimport * as ParseTreeUtils from '../analyzer/parseTreeUtils';\nimport { SourceMapper } from '../analyzer/sourceMapper';\nimport {\n    getClassDocString,\n    getFunctionDocStringFromDeclaration,\n    getFunctionDocStringFromType,\n    getModuleDocString,\n    getOverloadedFunctionDocStrings,\n} from '../analyzer/typeDocStringUtils';\nimport { TypeEvaluator } from '../analyzer/typeEvaluator';\nimport { isClass, isModule, isObject, Type, TypeCategory, UnknownType } from '../analyzer/types';\nimport { ClassMemberLookupFlags, isProperty, lookUpClassMember } from '../analyzer/typeUtils';\nimport { throwIfCancellationRequested } from '../common/cancellationUtils';\nimport { convertOffsetToPosition, convertPositionToOffset } from '../common/positionUtils';\nimport { Position, Range } from '../common/textRange';\nimport { TextRange } from '../common/textRange';\nimport { NameNode, ParseNode, ParseNodeType } from '../parser/parseNodes';\nimport { ParseResults } from '../parser/parser';\n\nexport interface HoverTextPart {\n    python?: boolean;\n    text: string;\n}\n\nexport interface HoverResults {\n    parts: HoverTextPart[];\n    range: Range;\n}\n\nexport class HoverProvider {\n    static getHoverForPosition(\n        sourceMapper: SourceMapper,\n        parseResults: ParseResults,\n        position: Position,\n        evaluator: TypeEvaluator,\n        token: CancellationToken\n    ): HoverResults | undefined {\n        throwIfCancellationRequested(token);\n\n        const offset = convertPositionToOffset(position, parseResults.tokenizerOutput.lines);\n        if (offset === undefined) {\n            return undefined;\n        }\n\n        const node = ParseTreeUtils.findNodeByOffset(parseResults.parseTree, offset);\n        if (node === undefined) {\n            return undefined;\n        }\n\n        const results: HoverResults = {\n            parts: [],\n            range: {\n                start: convertOffsetToPosition(node.start, parseResults.tokenizerOutput.lines),\n                end: convertOffsetToPosition(TextRange.getEnd(node), parseResults.tokenizerOutput.lines),\n            },\n        };\n\n        if (node.nodeType === ParseNodeType.Name) {\n            const declarations = evaluator.getDeclarationsForNameNode(node);\n            if (declarations && declarations.length > 0) {\n                this._addResultsForDeclaration(sourceMapper, results.parts, declarations[0], node, evaluator);\n            } else if (!node.parent || node.parent.nodeType !== ParseNodeType.ModuleName) {\n                // If we had no declaration, see if we can provide a minimal tooltip. We'll skip\n                // this if it's part of a module name, since a module name part with no declaration\n                // is a directory (a namespace package), and we don't want to provide any hover\n                // information in that case.\n                if (results.parts.length === 0) {\n                    const type = evaluator.getType(node) || UnknownType.create();\n\n                    let typeText = '';\n                    if (isModule(type)) {\n                        // Handle modules specially because submodules aren't associated with\n                        // declarations, but we want them to be presented in the same way as\n                        // the top-level module, which does have a declaration.\n                        typeText = '(module) ' + node.value;\n                    } else {\n                        typeText = node.value + ': ' + evaluator.printType(type, /* expandTypeAlias */ false);\n                    }\n\n                    this._addResultsPart(results.parts, typeText, true);\n                    this._addDocumentationPart(sourceMapper, results.parts, node, evaluator, undefined);\n                }\n            }\n        }\n\n        return results.parts.length > 0 ? results : undefined;\n    }\n\n    private static _addResultsForDeclaration(\n        sourceMapper: SourceMapper,\n        parts: HoverTextPart[],\n        declaration: Declaration,\n        node: NameNode,\n        evaluator: TypeEvaluator\n    ): void {\n        const resolvedDecl = evaluator.resolveAliasDeclaration(declaration, /* resolveLocalNames */ true);\n        if (!resolvedDecl) {\n            this._addResultsPart(parts, `(import) ` + node.value + this._getTypeText(node, evaluator), true);\n            return;\n        }\n\n        switch (resolvedDecl.type) {\n            case DeclarationType.Intrinsic: {\n                this._addResultsPart(parts, node.value + this._getTypeText(node, evaluator), true);\n                this._addDocumentationPart(sourceMapper, parts, node, evaluator, resolvedDecl);\n                break;\n            }\n\n            case DeclarationType.Variable: {\n                let label = resolvedDecl.isConstant || resolvedDecl.isFinal ? 'constant' : 'variable';\n\n                // If the named node is an aliased import symbol, we can't call\n                // getType on the original name because it's not in the symbol\n                // table. Instead, use the node from the resolved alias.\n                let typeNode = node;\n                if (\n                    declaration.node.nodeType === ParseNodeType.ImportAs ||\n                    declaration.node.nodeType === ParseNodeType.ImportFromAs\n                ) {\n                    if (declaration.node.alias && node !== declaration.node.alias) {\n                        if (resolvedDecl.node.nodeType === ParseNodeType.Name) {\n                            typeNode = resolvedDecl.node;\n                        }\n                    }\n                } else if (node.parent?.nodeType === ParseNodeType.Argument && node.parent.name === node) {\n                    // If this is a named argument, we would normally have received a Parameter declaration\n                    // rather than a variable declaration, but we can get here in the case of a dataclass.\n                    // Replace the typeNode with the node of the variable declaration.\n                    if (declaration.node.nodeType === ParseNodeType.Name) {\n                        typeNode = declaration.node;\n                    }\n                }\n\n                // Determine if this identifier is a type alias. If so, expand\n                // the type alias when printing the type information.\n                const type = evaluator.getType(typeNode);\n                let expandTypeAlias = false;\n                if (type?.typeAliasInfo && node.value === type.typeAliasInfo.aliasName) {\n                    if (type.typeAliasInfo.aliasName === typeNode.value) {\n                        expandTypeAlias = true;\n                    }\n\n                    label = 'type alias';\n                }\n\n                this._addResultsPart(\n                    parts,\n                    `(${label}) ` + node.value + this._getTypeText(typeNode, evaluator, expandTypeAlias),\n                    true\n                );\n                this._addDocumentationPart(sourceMapper, parts, node, evaluator, resolvedDecl);\n                break;\n            }\n\n            case DeclarationType.Parameter: {\n                this._addResultsPart(parts, '(parameter) ' + node.value + this._getTypeText(node, evaluator), true);\n                this._addDocumentationPart(sourceMapper, parts, node, evaluator, resolvedDecl);\n                break;\n            }\n\n            case DeclarationType.Class:\n            case DeclarationType.SpecialBuiltInClass: {\n                if (this._addInitMethodInsteadIfCallNode(node, evaluator, parts, sourceMapper, resolvedDecl)) {\n                    return;\n                }\n\n                this._addResultsPart(parts, '(class) ' + node.value, true);\n                this._addDocumentationPart(sourceMapper, parts, node, evaluator, resolvedDecl);\n                break;\n            }\n\n            case DeclarationType.Function: {\n                let label = 'function';\n                if (resolvedDecl.isMethod) {\n                    const declaredType = evaluator.getTypeForDeclaration(resolvedDecl);\n                    label = declaredType && isProperty(declaredType) ? 'property' : 'method';\n                }\n\n                this._addResultsPart(parts, `(${label}) ` + node.value + this._getTypeText(node, evaluator), true);\n                this._addDocumentationPart(sourceMapper, parts, node, evaluator, resolvedDecl);\n                break;\n            }\n\n            case DeclarationType.Alias: {\n                this._addResultsPart(parts, '(module) ' + node.value, true);\n                this._addDocumentationPart(sourceMapper, parts, node, evaluator, resolvedDecl);\n                break;\n            }\n        }\n    }\n\n    private static _addInitMethodInsteadIfCallNode(\n        node: NameNode,\n        evaluator: TypeEvaluator,\n        parts: HoverTextPart[],\n        sourceMapper: SourceMapper,\n        declaration: Declaration\n    ) {\n        // If the class is used as part of a call (i.e. it is being\n        // instantiated), include the constructor arguments within the\n        // hover text.\n        let callLeftNode: ParseNode | undefined = node;\n\n        // Allow the left to be a member access chain (e.g. a.b.c) if the\n        // node in question is the last item in the chain.\n        if (\n            callLeftNode.parent &&\n            callLeftNode.parent.nodeType === ParseNodeType.MemberAccess &&\n            node === callLeftNode.parent.memberName\n        ) {\n            callLeftNode = node.parent;\n        }\n\n        if (\n            !callLeftNode ||\n            !callLeftNode.parent ||\n            callLeftNode.parent.nodeType !== ParseNodeType.Call ||\n            callLeftNode.parent.leftExpression !== callLeftNode\n        ) {\n            return false;\n        }\n\n        // Get the init method for this class.\n        const classType = evaluator.getType(node);\n        if (!classType || !isClass(classType)) {\n            return false;\n        }\n\n        const initMethodMember = lookUpClassMember(\n            classType,\n            '__init__',\n            ClassMemberLookupFlags.SkipInstanceVariables | ClassMemberLookupFlags.SkipObjectBaseClass\n        );\n\n        if (!initMethodMember) {\n            return false;\n        }\n\n        const instanceType = evaluator.getType(callLeftNode.parent);\n        const functionType = evaluator.getTypeOfMember(initMethodMember);\n\n        if (!instanceType || !functionType || !isObject(instanceType)) {\n            return false;\n        }\n\n        const initMethodType = evaluator.bindFunctionToClassOrObject(instanceType, functionType, false);\n\n        if (!initMethodType || initMethodType.category !== TypeCategory.Function) {\n            return false;\n        }\n\n        const functionParts = evaluator.printFunctionParts(initMethodType);\n        const classText = `${node.value}(${functionParts[0].join(', ')})`;\n\n        this._addResultsPart(parts, '(class) ' + classText, true);\n        this._addDocumentationPartForType(sourceMapper, parts, initMethodType, declaration);\n        return true;\n    }\n\n    private static _getTypeText(node: NameNode, evaluator: TypeEvaluator, expandTypeAlias = false): string {\n        const type = evaluator.getType(node) || UnknownType.create();\n        return ': ' + evaluator.printType(type, expandTypeAlias);\n    }\n\n    private static _addDocumentationPart(\n        sourceMapper: SourceMapper,\n        parts: HoverTextPart[],\n        node: NameNode,\n        evaluator: TypeEvaluator,\n        resolvedDecl: DeclarationBase | undefined\n    ) {\n        const type = evaluator.getType(node);\n        if (type) {\n            this._addDocumentationPartForType(sourceMapper, parts, type, resolvedDecl);\n        }\n    }\n\n    private static _addDocumentationPartForType(\n        sourceMapper: SourceMapper,\n        parts: HoverTextPart[],\n        type: Type,\n        resolvedDecl: DeclarationBase | undefined\n    ) {\n        const docStrings: (string | undefined)[] = [];\n\n        if (isModule(type)) {\n            docStrings.push(getModuleDocString(type, resolvedDecl, sourceMapper));\n        } else if (isClass(type)) {\n            docStrings.push(getClassDocString(type, resolvedDecl, sourceMapper));\n        } else if (type.category === TypeCategory.Function) {\n            docStrings.push(getFunctionDocStringFromType(type, sourceMapper));\n        } else if (type.category === TypeCategory.OverloadedFunction) {\n            docStrings.push(...getOverloadedFunctionDocStrings(type, resolvedDecl, sourceMapper));\n        } else if (resolvedDecl?.type === DeclarationType.Function) {\n            // @property functions\n            docStrings.push(getFunctionDocStringFromDeclaration(resolvedDecl as FunctionDeclaration, sourceMapper));\n        }\n\n        for (const docString of docStrings) {\n            if (docString) {\n                this._addDocumentationResultsPart(parts, docString);\n            }\n        }\n    }\n\n    private static _addDocumentationResultsPart(parts: HoverTextPart[], docString?: string) {\n        if (docString) {\n            this._addResultsPart(parts, convertDocStringToMarkdown(docString));\n        }\n    }\n\n    private static _addResultsPart(parts: HoverTextPart[], text: string, python = false) {\n        parts.push({\n            python,\n            text,\n        });\n    }\n}\n\nexport function convertHoverResults(hoverResults: HoverResults | undefined): Hover | undefined {\n    if (!hoverResults) {\n        return undefined;\n    }\n\n    const markupString = hoverResults.parts\n        .map((part) => {\n            if (part.python) {\n                return '```python\\n' + part.text + '\\n```\\n';\n            }\n            return part.text;\n        })\n        .join('');\n\n    return {\n        contents: {\n            kind: MarkupKind.Markdown,\n            value: markupString,\n        },\n        range: hoverResults.range,\n    };\n}\n","/*\n * importSorter.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Provides code that sorts and formats import statements within a\n * python source file.\n */\n\nimport { CancellationToken } from 'vscode-languageserver';\n\nimport {\n    compareImportStatements,\n    getImportGroup,\n    getTopLevelImports,\n    ImportStatement,\n} from '../analyzer/importStatementUtils';\nimport { throwIfCancellationRequested } from '../common/cancellationUtils';\nimport { TextEditAction } from '../common/editAction';\nimport { convertOffsetToPosition } from '../common/positionUtils';\nimport { Range } from '../common/textRange';\nimport { TextRange } from '../common/textRange';\nimport { ImportAsNode, ImportFromAsNode, ImportFromNode, ParseNodeType } from '../parser/parseNodes';\nimport { ParseResults } from '../parser/parser';\n\n// We choose a line length that matches the default for the popular\n// \"black\" formatter used in many Python projects.\nconst _maxLineLength = 88;\n\nexport class ImportSorter {\n    constructor(private _parseResults: ParseResults, private _cancellationToken: CancellationToken) {}\n\n    sort(): TextEditAction[] {\n        throwIfCancellationRequested(this._cancellationToken);\n\n        const actions: TextEditAction[] = [];\n        const importStatements = getTopLevelImports(this._parseResults.parseTree);\n\n        const sortedStatements = importStatements.orderedImports\n            .map((s) => s)\n            .sort((a, b) => {\n                return compareImportStatements(a, b);\n            });\n\n        if (sortedStatements.length === 0) {\n            // Nothing to do.\n            return [];\n        }\n\n        const primaryRange = this._getPrimaryReplacementRange(importStatements.orderedImports);\n\n        actions.push({\n            range: primaryRange,\n            replacementText: this._generateSortedImportText(sortedStatements),\n        });\n\n        this._addSecondaryReplacementRanges(importStatements.orderedImports, actions);\n\n        return actions;\n    }\n\n    // Determines the text range for the existing primary block of import statements.\n    // If there are other blocks of import statements separated by other statements,\n    // we'll ignore these other blocks for now.\n    private _getPrimaryReplacementRange(statements: ImportStatement[]): Range {\n        let statementLimit = statements.findIndex((s) => s.followsNonImportStatement);\n        if (statementLimit < 0) {\n            statementLimit = statements.length;\n        }\n\n        const lastStatement = statements[statementLimit - 1].node;\n        return {\n            start: convertOffsetToPosition(statements[0].node.start, this._parseResults.tokenizerOutput.lines),\n            end: convertOffsetToPosition(TextRange.getEnd(lastStatement), this._parseResults.tokenizerOutput.lines),\n        };\n    }\n\n    // If import statements are separated by other statements, we will remove the old\n    // secondary blocks.\n    private _addSecondaryReplacementRanges(statements: ImportStatement[], actions: TextEditAction[]) {\n        let secondaryBlockStart = statements.findIndex((s) => s.followsNonImportStatement);\n        if (secondaryBlockStart < 0) {\n            return;\n        }\n\n        while (true) {\n            let secondaryBlockLimit = statements.findIndex(\n                (s, index) => index > secondaryBlockStart && s.followsNonImportStatement\n            );\n            if (secondaryBlockLimit < 0) {\n                secondaryBlockLimit = statements.length;\n            }\n\n            actions.push({\n                range: {\n                    start: convertOffsetToPosition(\n                        statements[secondaryBlockStart].node.start,\n                        this._parseResults.tokenizerOutput.lines\n                    ),\n                    end: convertOffsetToPosition(\n                        TextRange.getEnd(statements[secondaryBlockLimit - 1].node),\n                        this._parseResults.tokenizerOutput.lines\n                    ),\n                },\n                replacementText: '',\n            });\n\n            secondaryBlockStart = secondaryBlockLimit;\n            if (secondaryBlockStart >= statements.length) {\n                break;\n            }\n        }\n    }\n\n    private _generateSortedImportText(sortedStatements: ImportStatement[]): string {\n        let importText = '';\n        let prevImportGroup = getImportGroup(sortedStatements[0]);\n\n        for (const statement of sortedStatements) {\n            // Insert a blank space between import type groups.\n            const curImportType = getImportGroup(statement);\n            if (prevImportGroup !== curImportType) {\n                importText += this._parseResults.tokenizerOutput.predominantEndOfLineSequence;\n                prevImportGroup = curImportType;\n            }\n\n            let importLine: string;\n            if (statement.node.nodeType === ParseNodeType.Import) {\n                importLine = this._formatImportNode(statement.subnode!, statement.moduleName);\n            } else {\n                importLine = this._formatImportFromNode(statement.node, statement.moduleName);\n            }\n\n            // If this isn't the last statement, add a newline.\n            if (statement !== sortedStatements[sortedStatements.length - 1]) {\n                importLine += this._parseResults.tokenizerOutput.predominantEndOfLineSequence;\n            }\n\n            importText += importLine;\n        }\n\n        return importText;\n    }\n\n    private _formatImportNode(subnode: ImportAsNode, moduleName: string): string {\n        let importText = `import ${moduleName}`;\n        if (subnode.alias) {\n            importText += ` as ${subnode.alias.value}`;\n        }\n\n        return importText;\n    }\n\n    private _formatImportFromNode(node: ImportFromNode, moduleName: string): string {\n        const symbols = node.imports\n            .sort((a, b) => this._compareSymbols(a, b))\n            .map((symbol) => {\n                let symbolText = symbol.name.value;\n                if (symbol.alias) {\n                    symbolText += ` as ${symbol.alias.value}`;\n                }\n\n                return symbolText;\n            });\n\n        let cumulativeText = `from ${moduleName} import `;\n        if (node.isWildcardImport) {\n            return cumulativeText + '*';\n        }\n\n        const symbolText = symbols.join(', ');\n        if (cumulativeText.length + symbolText.length <= _maxLineLength) {\n            return cumulativeText + symbolText;\n        }\n\n        // We need to split across multiple lines with parens.\n        cumulativeText += '(' + this._parseResults.tokenizerOutput.predominantEndOfLineSequence;\n\n        for (const symbol of symbols) {\n            cumulativeText +=\n                this._parseResults.tokenizerOutput.predominantTabSequence +\n                symbol +\n                ',' +\n                this._parseResults.tokenizerOutput.predominantEndOfLineSequence;\n        }\n\n        cumulativeText += ')';\n\n        return cumulativeText;\n    }\n\n    private _compareSymbols(a: ImportFromAsNode, b: ImportFromAsNode) {\n        return a.name.value < b.name.value ? -1 : 1;\n    }\n}\n","/*\n * quickActions.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Provides support for miscellaneous quick actions.\n */\n\nimport { CancellationToken } from 'vscode-languageserver';\n\nimport {\n    getTextEditsForAutoImportInsertion,\n    getTextEditsForAutoImportSymbolAddition,\n    getTopLevelImports,\n    ImportGroup,\n} from '../analyzer/importStatementUtils';\nimport * as ParseTreeUtils from '../analyzer/parseTreeUtils';\nimport { Commands } from '../commands/commands';\nimport { throwIfCancellationRequested } from '../common/cancellationUtils';\nimport { TextEditAction } from '../common/editAction';\nimport { convertOffsetToPosition } from '../common/positionUtils';\nimport { TextRange } from '../common/textRange';\nimport { ParseNode, ParseNodeType } from '../parser/parseNodes';\nimport { ParseResults } from '../parser/parser';\nimport { ImportSorter } from './importSorter';\n\nexport function performQuickAction(command: string, args: any[], parseResults: ParseResults, token: CancellationToken) {\n    if (command === Commands.orderImports) {\n        const importSorter = new ImportSorter(parseResults, token);\n        return importSorter.sort();\n    } else if (command === Commands.addMissingOptionalToParam) {\n        if (args.length >= 1) {\n            const nodeOffset = parseInt(args[0], 10);\n            return _addMissingOptionalToParam(parseResults, nodeOffset, token);\n        }\n    }\n\n    return [];\n}\n\n// Inserts text into the document to wrap an existing type annotation\n// with \"Optional[X]\".\nfunction _addMissingOptionalToParam(\n    parseResults: ParseResults,\n    offset: number,\n    token: CancellationToken\n): TextEditAction[] {\n    throwIfCancellationRequested(token);\n\n    let node: ParseNode | undefined = ParseTreeUtils.findNodeByOffset(parseResults.parseTree, offset);\n    while (node) {\n        if (node.nodeType === ParseNodeType.Parameter) {\n            break;\n        }\n\n        node = node.parent;\n    }\n\n    if (!node) {\n        return [];\n    }\n\n    const typeAnnotation = node.typeAnnotation || node.typeAnnotationComment;\n    if (!typeAnnotation) {\n        return [];\n    }\n\n    const editActions: TextEditAction[] = [];\n\n    const startPos = convertOffsetToPosition(typeAnnotation.start, parseResults.tokenizerOutput.lines);\n    const endPos = convertOffsetToPosition(TextRange.getEnd(typeAnnotation), parseResults.tokenizerOutput.lines);\n\n    editActions.push({\n        range: { start: startPos, end: startPos },\n        replacementText: 'Optional[',\n    });\n    editActions.push({\n        range: { start: endPos, end: endPos },\n        replacementText: ']',\n    });\n\n    // Add the import statement if necessary.\n    const importStatements = getTopLevelImports(parseResults.parseTree);\n    const importStatement = importStatements.orderedImports.find((imp) => imp.moduleName === 'typing');\n\n    // If there's an existing import statement, insert into it.\n    if (importStatement && importStatement.node.nodeType === ParseNodeType.ImportFrom) {\n        const additionalEditActions = getTextEditsForAutoImportSymbolAddition(\n            'Optional',\n            importStatement,\n            parseResults\n        );\n        editActions.push(...additionalEditActions);\n    } else {\n        const additionalEditActions = getTextEditsForAutoImportInsertion(\n            'Optional',\n            importStatements,\n            'typing',\n            ImportGroup.BuiltIn,\n            parseResults,\n            startPos\n        );\n        editActions.push(...additionalEditActions);\n    }\n\n    return editActions;\n}\n","/*\n * referencesProvider.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Logic that finds all of the references to a symbol specified\n * by a location within a file.\n */\n\nimport { CancellationToken } from 'vscode-languageserver';\n\nimport * as AnalyzerNodeInfo from '../analyzer/analyzerNodeInfo';\nimport { Declaration } from '../analyzer/declaration';\nimport * as DeclarationUtils from '../analyzer/declarationUtils';\nimport * as ParseTreeUtils from '../analyzer/parseTreeUtils';\nimport { ParseTreeWalker } from '../analyzer/parseTreeWalker';\nimport { isStubFile, SourceMapper } from '../analyzer/sourceMapper';\nimport { TypeEvaluator } from '../analyzer/typeEvaluator';\nimport { throwIfCancellationRequested } from '../common/cancellationUtils';\nimport { convertOffsetToPosition, convertPositionToOffset } from '../common/positionUtils';\nimport { DocumentRange, Position } from '../common/textRange';\nimport { TextRange } from '../common/textRange';\nimport { ModuleNameNode, NameNode, ParseNode, ParseNodeType } from '../parser/parseNodes';\nimport { ParseResults } from '../parser/parser';\n\nexport interface ReferencesResult {\n    requiresGlobalSearch: boolean;\n    nodeAtOffset: ParseNode;\n    symbolName: string;\n    declarations: Declaration[];\n    locations: DocumentRange[];\n}\n\nclass FindReferencesTreeWalker extends ParseTreeWalker {\n    constructor(\n        private _parseResults: ParseResults,\n        private _filePath: string,\n        private _referencesResult: ReferencesResult,\n        private _includeDeclaration: boolean,\n        private _evaluator: TypeEvaluator,\n        private _cancellationToken: CancellationToken\n    ) {\n        super();\n    }\n\n    findReferences() {\n        this.walk(this._parseResults.parseTree);\n    }\n\n    walk(node: ParseNode) {\n        if (!AnalyzerNodeInfo.isCodeUnreachable(node)) {\n            super.walk(node);\n        }\n    }\n\n    visitModuleName(node: ModuleNameNode): boolean {\n        // Don't ever look for references within a module name.\n        return false;\n    }\n\n    visitName(node: NameNode): boolean {\n        throwIfCancellationRequested(this._cancellationToken);\n\n        // No need to do any more work if the symbol name doesn't match.\n        if (node.value !== this._referencesResult.symbolName) {\n            return false;\n        }\n\n        const declarations = this._evaluator.getDeclarationsForNameNode(node);\n\n        if (declarations && declarations.length > 0) {\n            // Does this name share a declaration with the symbol of interest?\n            if (declarations.some((decl) => this._resultsContainsDeclaration(decl))) {\n                // Is it the same symbol?\n                if (this._includeDeclaration || node !== this._referencesResult.nodeAtOffset) {\n                    this._referencesResult.locations.push({\n                        path: this._filePath,\n                        range: {\n                            start: convertOffsetToPosition(node.start, this._parseResults.tokenizerOutput.lines),\n                            end: convertOffsetToPosition(\n                                TextRange.getEnd(node),\n                                this._parseResults.tokenizerOutput.lines\n                            ),\n                        },\n                    });\n                }\n            }\n        }\n\n        return true;\n    }\n\n    private _resultsContainsDeclaration(declaration: Declaration) {\n        // Resolve the declaration.\n        const resolvedDecl = this._evaluator.resolveAliasDeclaration(declaration, /* resolveLocalNames */ false);\n        if (!resolvedDecl) {\n            return false;\n        }\n\n        // The reference results declarations are already resolved, so we don't\n        // need to call resolveAliasDeclaration on them.\n        if (\n            this._referencesResult.declarations.some((decl) => DeclarationUtils.areDeclarationsSame(decl, resolvedDecl))\n        ) {\n            return true;\n        }\n\n        // We didn't find the declaration using local-only alias resolution. Attempt\n        // it again by fully resolving the alias.\n        const resolvedDeclNonlocal = this._evaluator.resolveAliasDeclaration(\n            resolvedDecl,\n            /* resolveLocalNames */ true\n        );\n        if (!resolvedDeclNonlocal || resolvedDeclNonlocal === resolvedDecl) {\n            return false;\n        }\n\n        return this._referencesResult.declarations.some((decl) =>\n            DeclarationUtils.areDeclarationsSame(decl, resolvedDeclNonlocal)\n        );\n    }\n}\n\nexport class ReferencesProvider {\n    static getDeclarationForPosition(\n        sourceMapper: SourceMapper,\n        parseResults: ParseResults,\n        filePath: string,\n        position: Position,\n        evaluator: TypeEvaluator,\n        token: CancellationToken\n    ): ReferencesResult | undefined {\n        throwIfCancellationRequested(token);\n\n        const offset = convertPositionToOffset(position, parseResults.tokenizerOutput.lines);\n        if (offset === undefined) {\n            return undefined;\n        }\n\n        const node = ParseTreeUtils.findNodeByOffset(parseResults.parseTree, offset);\n        if (node === undefined) {\n            return undefined;\n        }\n\n        // If this isn't a name node, there are no references to be found.\n        if (node.nodeType !== ParseNodeType.Name) {\n            return undefined;\n        }\n\n        // Special case module names, which don't have references.\n        if (node.parent?.nodeType === ParseNodeType.ModuleName) {\n            return undefined;\n        }\n\n        const declarations = evaluator.getDeclarationsForNameNode(node);\n        if (!declarations) {\n            return undefined;\n        }\n\n        const resolvedDeclarations: Declaration[] = [];\n        declarations.forEach((decl) => {\n            const resolvedDecl = evaluator.resolveAliasDeclaration(decl, /* resolveLocalNames */ false);\n            if (resolvedDecl) {\n                resolvedDeclarations.push(resolvedDecl);\n\n                if (isStubFile(resolvedDecl.path)) {\n                    const implDecls = sourceMapper.findDeclarations(resolvedDecl);\n                    for (const implDecl of implDecls) {\n                        if (implDecl && implDecl.path) {\n                            this._addIfUnique(resolvedDeclarations, implDecl);\n                        }\n                    }\n                }\n            }\n        });\n\n        if (resolvedDeclarations.length === 0) {\n            return undefined;\n        }\n\n        // Does this symbol require search beyond the current file? Determine whether\n        // the symbol is declared within an evaluation scope that is within the current\n        // file and cannot be imported directly from other modules.\n        const requiresGlobalSearch = resolvedDeclarations.some((decl) => {\n            // If the declaration is outside of this file, a global search is needed.\n            if (decl.path !== filePath) {\n                return true;\n            }\n\n            const evalScope = ParseTreeUtils.getEvaluationScopeNode(decl.node);\n\n            // If the declaration is at the module level or a class level, it can be seen\n            // outside of the current module, so a global search is needed.\n            if (evalScope.nodeType === ParseNodeType.Module || evalScope.nodeType === ParseNodeType.Class) {\n                return true;\n            }\n\n            // If the name node is a member variable, we need to do a global search.\n            if (\n                decl.node?.parent?.nodeType === ParseNodeType.MemberAccess &&\n                decl.node === decl.node.parent.memberName\n            ) {\n                return true;\n            }\n\n            return false;\n        });\n\n        return {\n            requiresGlobalSearch,\n            nodeAtOffset: node,\n            symbolName: node.value,\n            declarations: resolvedDeclarations,\n            locations: [],\n        };\n    }\n\n    private static _addIfUnique(declarations: Declaration[], itemToAdd: Declaration) {\n        for (const def of declarations) {\n            if (DeclarationUtils.areDeclarationsSame(def, itemToAdd)) {\n                return;\n            }\n        }\n\n        declarations.push(itemToAdd);\n    }\n\n    static addReferences(\n        parseResults: ParseResults,\n        filePath: string,\n        referencesResult: ReferencesResult,\n        includeDeclaration: boolean,\n        evaluator: TypeEvaluator,\n        token: CancellationToken\n    ): void {\n        const refTreeWalker = new FindReferencesTreeWalker(\n            parseResults,\n            filePath,\n            referencesResult,\n            includeDeclaration,\n            evaluator,\n            token\n        );\n        refTreeWalker.findReferences();\n    }\n}\n","/*\n * signatureHelpProvider.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Logic that maps a position within a Python call node into info\n * that can be presented to the developer to help fill in the remaining\n * arguments for the call.\n */\n\nimport { CancellationToken } from 'vscode-languageserver';\n\nimport { extractParameterDocumentation } from '../analyzer/docStringUtils';\nimport * as ParseTreeUtils from '../analyzer/parseTreeUtils';\nimport { CallSignature, TypeEvaluator } from '../analyzer/typeEvaluator';\nimport { throwIfCancellationRequested } from '../common/cancellationUtils';\nimport { convertPositionToOffset } from '../common/positionUtils';\nimport { Position } from '../common/textRange';\nimport { ParseResults } from '../parser/parser';\n\nexport interface ParamInfo {\n    startOffset: number;\n    endOffset: number;\n    text: string;\n    documentation?: string;\n}\n\nexport interface SignatureInfo {\n    label: string;\n    documentation?: string;\n    parameters?: ParamInfo[];\n    activeParameter?: number;\n}\n\nexport interface SignatureHelpResults {\n    signatures: SignatureInfo[];\n    callHasParameters: boolean;\n}\n\nexport class SignatureHelpProvider {\n    static getSignatureHelpForPosition(\n        parseResults: ParseResults,\n        position: Position,\n        evaluator: TypeEvaluator,\n        token: CancellationToken\n    ): SignatureHelpResults | undefined {\n        throwIfCancellationRequested(token);\n\n        const offset = convertPositionToOffset(position, parseResults.tokenizerOutput.lines);\n        if (offset === undefined) {\n            return undefined;\n        }\n\n        let node = ParseTreeUtils.findNodeByOffset(parseResults.parseTree, offset);\n\n        // See if we can get to a \"better\" node by backing up a few columns.\n        // A \"better\" node is defined as one that's deeper than the current\n        // node.\n        const initialNode = node;\n        const initialDepth = node ? ParseTreeUtils.getNodeDepth(node) : 0;\n        let curOffset = offset;\n        while (curOffset >= 0) {\n            curOffset--;\n            const curNode = ParseTreeUtils.findNodeByOffset(parseResults.parseTree, curOffset);\n            if (curNode && curNode !== initialNode) {\n                if (ParseTreeUtils.getNodeDepth(curNode) > initialDepth) {\n                    node = curNode;\n                }\n                break;\n            }\n        }\n\n        if (node === undefined) {\n            return undefined;\n        }\n\n        const callSignatureInfo = evaluator.getCallSignatureInfo(node, offset, parseResults.tokenizerOutput.tokens);\n        if (!callSignatureInfo) {\n            return undefined;\n        }\n\n        const signatures = callSignatureInfo.signatures.map((sig) => this._makeSignature(sig, evaluator));\n        const callHasParameters = !!callSignatureInfo.callNode.arguments?.length;\n\n        return {\n            signatures,\n            callHasParameters,\n        };\n    }\n\n    private static _makeSignature(signature: CallSignature, evaluator: TypeEvaluator): SignatureInfo {\n        const functionType = signature.type;\n        const stringParts = evaluator.printFunctionParts(functionType);\n        const parameters: ParamInfo[] = [];\n        const functionDocString = functionType.details.docString;\n        let label = '(';\n\n        stringParts[0].forEach((paramString: string, paramIndex) => {\n            const paramName = functionType.details.parameters[paramIndex].name || '';\n            parameters.push({\n                startOffset: label.length,\n                endOffset: label.length + paramString.length,\n                text: paramString,\n                documentation: extractParameterDocumentation(functionDocString || '', paramName),\n            });\n\n            label += paramString;\n            if (paramIndex < stringParts[0].length - 1) {\n                label += ', ';\n            }\n        });\n\n        label += ') -> ' + stringParts[1];\n\n        let activeParameter: number | undefined;\n        if (signature.activeParam) {\n            activeParameter = functionType.details.parameters.indexOf(signature.activeParam);\n            if (activeParameter === -1) {\n                activeParameter = undefined;\n            }\n        }\n\n        const sigInfo: SignatureInfo = {\n            label,\n            parameters,\n            documentation: functionDocString,\n            activeParameter,\n        };\n\n        return sigInfo;\n    }\n}\n","/*\n * localize.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Code that localizes user-visible strings.\n */\n\nimport { fail } from '../common/debug';\n\nimport enUsStrings = require('./package.nls.en-us.json');\nimport deStrings = require('./package.nls.de.json');\nimport esStrings = require('./package.nls.es.json');\nimport frStrings = require('./package.nls.fr.json');\nimport jaStrings = require('./package.nls.ja.json');\nimport ruStrings = require('./package.nls.ru.json');\nimport zhCnStrings = require('./package.nls.zh-cn.json');\nimport zhTwStrings = require('./package.nls.zh-tw.json');\n\nexport class ParameterizedString<T extends {}> {\n    constructor(private _formatString: string) {}\n\n    format(params: T): string {\n        let str = this._formatString;\n        Object.keys(params).forEach((key) => {\n            str = str.replace(`{${key}}`, (params as any)[key].toString());\n        });\n        return str;\n    }\n\n    getFormatString() {\n        return this._formatString;\n    }\n}\n\nconst defaultLocale = 'en-us';\nconst stringMapsByLocale: { [locale: string]: any } = {\n    de: deStrings,\n    'en-us': enUsStrings,\n    es: esStrings,\n    fr: frStrings,\n    ja: jaStrings,\n    ru: ruStrings,\n    'zh-cn': zhCnStrings,\n    'zh-tw': zhTwStrings,\n};\n\ntype StringLookupMap = { [key: string]: string | StringLookupMap };\nlet localizedStrings: StringLookupMap | undefined = undefined;\nlet defaultStrings: StringLookupMap = {};\n\nfunction getRawString(key: string): string {\n    if (localizedStrings === undefined) {\n        localizedStrings = initialize();\n    }\n\n    const keyParts = key.split('.');\n\n    const str = getRawStringFromMap(localizedStrings, keyParts) || getRawStringFromMap(defaultStrings, keyParts);\n    if (str) {\n        return str;\n    }\n\n    fail(`Missing localized string for key \"${key}\"`);\n}\n\nfunction getRawStringFromMap(map: StringLookupMap, keyParts: string[]): string | undefined {\n    let curObj: any = map;\n\n    for (const keyPart of keyParts) {\n        if (!curObj[keyPart]) {\n            return undefined;\n        }\n\n        curObj = curObj[keyPart];\n    }\n\n    return curObj as string;\n}\n\nfunction initialize(): StringLookupMap {\n    defaultStrings = loadDefaultStrings();\n    const currentLocale = getLocaleFromEnv();\n    return loadStringsForLocale(currentLocale);\n}\n\nfunction getLocaleFromEnv() {\n    const env = process.env;\n\n    // Start with the VSCode environment variables.\n    const vscodeConfigString = env.VSCODE_NLS_CONFIG;\n    if (vscodeConfigString) {\n        try {\n            return JSON.parse(vscodeConfigString).locale;\n        } catch {\n            // Fall through\n        }\n    }\n\n    // See if there is a language env variable.\n    const localeString = env.LC_ALL || env.LC_MESSAGES || env.LANG || env.LANGUAGE;\n    if (localeString) {\n        // This string may contain a local followed by an encoding (e.g. \"en-us.UTF-8\").\n        const localeStringSplit = localeString.split('.');\n        if (localeStringSplit.length > 0 && localeStringSplit[0]) {\n            return localeStringSplit[0];\n        }\n    }\n\n    // Fall back to the default locale.\n    return defaultLocale;\n}\n\nfunction loadDefaultStrings(): StringLookupMap {\n    const defaultStrings = loadStringsFromJsonFile(defaultLocale);\n    if (defaultStrings) {\n        return defaultStrings;\n    }\n    console.error('Could not load default strings');\n    return {};\n}\n\nfunction loadStringsForLocale(locale: string): StringLookupMap {\n    if (locale === defaultLocale) {\n        // No need to load override if we're using the default.\n        return {};\n    }\n\n    let override = loadStringsFromJsonFile(locale);\n    if (override !== undefined) {\n        return override;\n    }\n\n    // If we couldn't find the requested locale, try to fall back on a more\n    // general version.\n    const localeSplit = locale.split('-');\n    if (localeSplit.length > 0 && localeSplit[0]) {\n        override = loadStringsFromJsonFile(localeSplit[0]);\n        if (override !== undefined) {\n            return override;\n        }\n    }\n\n    return {};\n}\n\nfunction loadStringsFromJsonFile(locale: string): StringLookupMap | undefined {\n    return stringMapsByLocale[locale];\n}\n\nexport namespace Localizer {\n    export namespace Diagnostic {\n        export const annotatedParamCountMismatch = () =>\n            new ParameterizedString<{ expected: number; received: number }>(\n                getRawString('Diagnostic.annotatedParamCountMismatch')\n            );\n        export const annotatedTypeArgMissing = () => getRawString('Diagnostic.annotatedTypeArgMissing');\n        export const annotationFormatString = () => getRawString('Diagnostic.annotationFormatString');\n        export const annotationNotSupported = () => getRawString('Diagnostic.annotationNotSupported');\n        export const annotationSpansStrings = () => getRawString('Diagnostic.annotationSpansStrings');\n        export const annotationStringEscape = () => getRawString('Diagnostic.annotationStringEscape');\n        export const annotationTripleQuote = () => getRawString('Diagnostic.annotationTripleQuote');\n        export const argAssignment = () =>\n            new ParameterizedString<{ argType: string; paramType: string }>(getRawString('Diagnostic.argAssignment'));\n        export const argAssignmentFunction = () =>\n            new ParameterizedString<{ argType: string; paramType: string; functionName: string }>(\n                getRawString('Diagnostic.argAssignmentFunction')\n            );\n        export const argAssignmentParam = () =>\n            new ParameterizedString<{ argType: string; paramType: string; paramName: string }>(\n                getRawString('Diagnostic.argAssignmentParam')\n            );\n        export const argAssignmentParamFunction = () =>\n            new ParameterizedString<{ argType: string; paramType: string; paramName: string; functionName: string }>(\n                getRawString('Diagnostic.argAssignmentParamFunction')\n            );\n        export const argMissingForParam = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.argMissingForParam'));\n        export const argMissingForParams = () =>\n            new ParameterizedString<{ names: string }>(getRawString('Diagnostic.argMissingForParams'));\n        export const argPositional = () => getRawString('Diagnostic.argPositional');\n        export const argPositionalExpectedCount = () =>\n            new ParameterizedString<{ expected: number }>(getRawString('Diagnostic.argPositionalExpectedCount'));\n        export const argPositionalExpectedOne = () => getRawString('Diagnostic.argPositionalExpectedOne');\n        export const argTypePartiallyUnknown = () => getRawString('Diagnostic.argTypePartiallyUnknown');\n        export const argTypeUnknown = () => getRawString('Diagnostic.argTypeUnknown');\n        export const assertAlwaysTrue = () => getRawString('Diagnostic.assertAlwaysTrue');\n        export const assignmentExprContext = () => getRawString('Diagnostic.assignmentExprContext');\n        export const assignmentExprComprehension = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.assignmentExprComprehension'));\n        export const assignmentInProtocol = () => getRawString('Diagnostic.assignmentInProtocol');\n        export const assignmentTargetExpr = () => getRawString('Diagnostic.assignmentTargetExpr');\n        export const awaitIllegal = () => getRawString('Diagnostic.awaitIllegal');\n        export const awaitNotInAsync = () => getRawString('Diagnostic.awaitNotInAsync');\n        export const backticksIllegal = () => getRawString('Diagnostic.backticksIllegal');\n        export const baseClassCircular = () => getRawString('Diagnostic.baseClassCircular');\n        export const baseClassInvalid = () => getRawString('Diagnostic.baseClassInvalid');\n        export const baseClassFinal = () =>\n            new ParameterizedString<{ type: string }>(getRawString('Diagnostic.baseClassFinal'));\n        export const baseClassUnknown = () => getRawString('Diagnostic.baseClassUnknown');\n        export const bindTypeMismatch = () =>\n            new ParameterizedString<{ type: string; methodName: string; paramName: string }>(\n                getRawString('Diagnostic.bindTypeMismatch')\n            );\n        export const breakOutsideLoop = () => getRawString('Diagnostic.breakOutsideLoop');\n        export const callableExtraArgs = () => getRawString('Diagnostic.callableExtraArgs');\n        export const callableFirstArg = () => getRawString('Diagnostic.callableFirstArg');\n        export const classMethodClsParam = () => getRawString('Diagnostic.classMethodClsParam');\n        export const classNotRuntimeSubscriptable = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.classNotRuntimeSubscriptable'));\n        export const classDecoratorTypeUnknown = () => getRawString('Diagnostic.classDecoratorTypeUnknown');\n        export const classGetItemClsParam = () => getRawString('Diagnostic.classGetItemClsParam');\n        export const classVarFirstArgMissing = () => getRawString('Diagnostic.classVarFirstArgMissing');\n        export const classVarTooManyArgs = () => getRawString('Diagnostic.classVarTooManyArgs');\n        export const comprehensionInDict = () => getRawString('Diagnostic.comprehensionInDict');\n        export const comprehensionInSet = () => getRawString('Diagnostic.comprehensionInSet');\n        export const concatenateParamSpecMissing = () => getRawString('Diagnostic.concatenateParamSpecMissing');\n        export const concatenateTypeArgsMissing = () => getRawString('Diagnostic.concatenateTypeArgsMissing');\n        export const constantRedefinition = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.constantRedefinition'));\n        export const constructorNoArgs = () =>\n            new ParameterizedString<{ type: string }>(getRawString('Diagnostic.constructorNoArgs'));\n        export const continueInFinally = () => getRawString('Diagnostic.continueInFinally');\n        export const continueOutsideLoop = () => getRawString('Diagnostic.continueOutsideLoop');\n        export const dataClassFieldWithDefault = () => getRawString('Diagnostic.dataClassFieldWithDefault');\n        export const declaredReturnTypePartiallyUnknown = () =>\n            new ParameterizedString<{ returnType: string }>(\n                getRawString('Diagnostic.declaredReturnTypePartiallyUnknown')\n            );\n        export const declaredReturnTypeUnknown = () => getRawString('Diagnostic.declaredReturnTypeUnknown');\n        export const defaultValueContainsCall = () => getRawString('Diagnostic.defaultValueContainsCall');\n        export const defaultValueNotAllowed = () => getRawString('Diagnostic.defaultValueNotAllowed');\n        export const defaultValueNotEllipsis = () => getRawString('Diagnostic.defaultValueNotEllipsis');\n        export const dictInAnnotation = () => getRawString('Diagnostic.dictInAnnotation');\n        export const dictKeyValuePairs = () => getRawString('Diagnostic.dictKeyValuePairs');\n        export const delTargetExpr = () => getRawString('Diagnostic.delTargetExpr');\n        export const dictExpandIllegalInComprehension = () =>\n            getRawString('Diagnostic.dictExpandIllegalInComprehension');\n        export const duplicateArgsParam = () => getRawString('Diagnostic.duplicateArgsParam');\n        export const duplicateBaseClass = () => getRawString('Diagnostic.duplicateBaseClass');\n        export const duplicateCatchAll = () => getRawString('Diagnostic.duplicateCatchAll');\n        export const duplicateImport = () =>\n            new ParameterizedString<{ importName: string }>(getRawString('Diagnostic.duplicateImport'));\n        export const duplicateKwargsParam = () => getRawString('Diagnostic.duplicateKwargsParam');\n        export const duplicateNameOnly = () => getRawString('Diagnostic.duplicateNameOnly');\n        export const duplicateParam = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.duplicateParam'));\n        export const duplicatePositionOnly = () => getRawString('Diagnostic.duplicatePositionOnly');\n        export const duplicateUnpack = () => getRawString('Diagnostic.duplicateUnpack');\n        export const ellipsisContext = () => getRawString('Diagnostic.ellipsisContext');\n        export const ellipsisSecondArg = () => getRawString('Diagnostic.ellipsisSecondArg');\n        export const enumFirstArg = () => getRawString('Diagnostic.enumFirstArg');\n        export const enumSecondArg = () => getRawString('Diagnostic.enumSecondArg');\n        export const exceptionTypeIncorrect = () =>\n            new ParameterizedString<{ type: string }>(getRawString('Diagnostic.exceptionTypeIncorrect'));\n        export const exceptionTypeNotClass = () =>\n            new ParameterizedString<{ type: string }>(getRawString('Diagnostic.exceptionTypeNotClass'));\n        export const exceptionTypeNotInstantiable = () =>\n            new ParameterizedString<{ type: string }>(getRawString('Diagnostic.exceptionTypeNotInstantiable'));\n        export const expectedAfterDecorator = () => getRawString('Diagnostic.expectedAfterDecorator');\n        export const expectedArrow = () => getRawString('Diagnostic.expectedArrow');\n        export const expectedAsAfterException = () => getRawString('Diagnostic.expectedAsAfterException');\n        export const expectedAssignRightHandExpr = () => getRawString('Diagnostic.expectedAssignRightHandExpr');\n        export const expectedBinaryRightHandExpr = () => getRawString('Diagnostic.expectedBinaryRightHandExpr');\n        export const expectedBoolLiteral = () => getRawString('Diagnostic.expectedBoolLiteral');\n        export const expectedClassName = () => getRawString('Diagnostic.expectedClassName');\n        export const expectedCloseBracket = () => getRawString('Diagnostic.expectedCloseBracket');\n        export const expectedCloseBrace = () => getRawString('Diagnostic.expectedCloseBrace');\n        export const expectedCloseParen = () => getRawString('Diagnostic.expectedCloseParen');\n        export const expectedColon = () => getRawString('Diagnostic.expectedColon');\n        export const expectedDecoratorName = () => getRawString('Diagnostic.expectedDecoratorName');\n        export const expectedDecoratorNewline = () => getRawString('Diagnostic.expectedDecoratorNewline');\n        export const expectedDelExpr = () => getRawString('Diagnostic.expectedDelExpr');\n        export const expectedElse = () => getRawString('Diagnostic.expectedElse');\n        export const expectedExceptionClass = () => getRawString('Diagnostic.expectedExceptionClass');\n        export const expectedExceptionObj = () => getRawString('Diagnostic.expectedExceptionObj');\n        export const expectedExpr = () => getRawString('Diagnostic.expectedExpr');\n        export const expectedImport = () => getRawString('Diagnostic.expectedImport');\n        export const expectedImportAlias = () => getRawString('Diagnostic.expectedImportAlias');\n        export const expectedImportSymbols = () => getRawString('Diagnostic.expectedImportSymbols');\n        export const expectedIdentifier = () => getRawString('Diagnostic.expectedIdentifier');\n        export const expectedIndentedBlock = () => getRawString('Diagnostic.expectedIndentedBlock');\n        export const expectedIn = () => getRawString('Diagnostic.expectedIn');\n        export const expectedInExpr = () => getRawString('Diagnostic.expectedInExpr');\n        export const expectedFunctionAfterAsync = () => getRawString('Diagnostic.expectedFunctionAfterAsync');\n        export const expectedFunctionName = () => getRawString('Diagnostic.expectedFunctionName');\n        export const expectedMemberName = () => getRawString('Diagnostic.expectedMemberName');\n        export const expectedModuleName = () => getRawString('Diagnostic.expectedModuleName');\n        export const expectedNameAfterAs = () => getRawString('Diagnostic.expectedNameAfterAs');\n        export const expectedNamedArgument = () => getRawString('Diagnostic.expectedNamedArgument');\n        export const expectedNewlineOrSemicolon = () => getRawString('Diagnostic.expectedNewlineOrSemicolon');\n        export const expectedOpenParen = () => getRawString('Diagnostic.expectedOpenParen');\n        export const expectedParamName = () => getRawString('Diagnostic.expectedParamName');\n        export const expectedReturnExpr = () => getRawString('Diagnostic.expectedReturnExpr');\n        export const expectedSliceIndex = () => getRawString('Diagnostic.expectedSliceIndex');\n        export const expectedTypeNotString = () => getRawString('Diagnostic.expectedTypeNotString');\n        export const expectedYieldExpr = () => getRawString('Diagnostic.expectedYieldExpr');\n        export const finalContext = () => getRawString('Diagnostic.finalContext');\n        export const finalMethodOverride = () =>\n            new ParameterizedString<{ name: string; className: string }>(\n                getRawString('Diagnostic.finalMethodOverride')\n            );\n        export const finalReassigned = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.finalReassigned'));\n        export const finalRedeclaration = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.finalRedeclaration'));\n        export const finalRedeclarationBySubclass = () =>\n            new ParameterizedString<{ name: string; className: string }>(\n                getRawString('Diagnostic.finalRedeclarationBySubclass')\n            );\n        export const finalTooManyArgs = () => getRawString('Diagnostic.finalTooManyArgs');\n        export const finalUnassigned = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.finalUnassigned'));\n        export const formatStringBrace = () => getRawString('Diagnostic.formatStringBrace');\n        export const formatStringBytes = () => getRawString('Diagnostic.formatStringBytes');\n        export const formatStringEscape = () => getRawString('Diagnostic.formatStringEscape');\n        export const formatStringIllegal = () => getRawString('Diagnostic.formatStringIllegal');\n        export const formatStringUnicode = () => getRawString('Diagnostic.formatStringUnicode');\n        export const formatStringUnterminated = () => getRawString('Diagnostic.formatStringUnterminated');\n        export const functionDecoratorTypeUnknown = () => getRawString('Diagnostic.functionDecoratorTypeUnknown');\n        export const genericClassAssigned = () => getRawString('Diagnostic.genericClassAssigned');\n        export const genericClassDeleted = () => getRawString('Diagnostic.genericClassDeleted');\n        export const genericNotAllowed = () => getRawString('Diagnostic.genericNotAllowed');\n        export const genericTypeArgMissing = () => getRawString('Diagnostic.genericTypeArgMissing');\n        export const genericTypeArgTypeVar = () => getRawString('Diagnostic.genericTypeArgTypeVar');\n        export const genericTypeArgUnique = () => getRawString('Diagnostic.genericTypeArgUnique');\n        export const globalReassignment = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.globalReassignment'));\n        export const globalRedefinition = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.globalRedefinition'));\n        export const implicitStringConcat = () => getRawString('Diagnostic.implicitStringConcat');\n        export const importCycleDetected = () => getRawString('Diagnostic.importCycleDetected');\n        export const importDepthExceeded = () =>\n            new ParameterizedString<{ depth: number }>(getRawString('Diagnostic.importDepthExceeded'));\n        export const importResolveFailure = () =>\n            new ParameterizedString<{ importName: string }>(getRawString('Diagnostic.importResolveFailure'));\n        export const importSourceResolveFailure = () =>\n            new ParameterizedString<{ importName: string }>(getRawString('Diagnostic.importSourceResolveFailure'));\n        export const importSymbolUnknown = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.importSymbolUnknown'));\n        export const incompatibleMethodOverride = () =>\n            new ParameterizedString<{ name: string; className: string }>(\n                getRawString('Diagnostic.incompatibleMethodOverride')\n            );\n        export const inconsistentIndent = () => getRawString('Diagnostic.inconsistentIndent');\n        export const inconsistentTabs = () => getRawString('Diagnostic.inconsistentTabs');\n        export const initSubclassClsParam = () => getRawString('Diagnostic.initSubclassClsParam');\n        export const instanceMethodSelfParam = () => getRawString('Diagnostic.instanceMethodSelfParam');\n        export const internalBindError = () =>\n            new ParameterizedString<{ file: string; message: string }>(getRawString('Diagnostic.internalBindError'));\n        export const internalParseError = () =>\n            new ParameterizedString<{ file: string; message: string }>(getRawString('Diagnostic.internalParseError'));\n        export const internalTypeCheckingError = () =>\n            new ParameterizedString<{ file: string; message: string }>(\n                getRawString('Diagnostic.internalTypeCheckingError')\n            );\n        export const invalidIdentifierChar = () => getRawString('Diagnostic.invalidIdentifierChar');\n        export const invalidStubStatement = () => getRawString('Diagnostic.invalidStubStatement');\n        export const invalidTokenChars = () =>\n            new ParameterizedString<{ text: string }>(getRawString('Diagnostic.invalidTokenChars'));\n        export const isInstanceInvalidType = () =>\n            new ParameterizedString<{ type: string }>(getRawString('Diagnostic.isInstanceInvalidType'));\n        export const isSubclassInvalidType = () =>\n            new ParameterizedString<{ type: string }>(getRawString('Diagnostic.isSubclassInvalidType'));\n        export const keyRequiredDeleted = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.keyRequiredDeleted'));\n        export const keyValueInSet = () => getRawString('Diagnostic.keyValueInSet');\n        export const lambdaReturnTypeUnknown = () => getRawString('Diagnostic.lambdaReturnTypeUnknown');\n        export const lambdaReturnTypePartiallyUnknown = () =>\n            new ParameterizedString<{ returnType: string }>(\n                getRawString('Diagnostic.lambdaReturnTypePartiallyUnknown')\n            );\n        export const listInAnnotation = () => getRawString('Diagnostic.listInAnnotation');\n        export const literalUnsupportedType = () => getRawString('Diagnostic.literalUnsupportedType');\n        export const literalEmptyArgs = () => getRawString('Diagnostic.literalEmptyArgs');\n        export const memberAccess = () =>\n            new ParameterizedString<{ name: string; type: string }>(getRawString('Diagnostic.memberAccess'));\n        export const memberDelete = () =>\n            new ParameterizedString<{ name: string; type: string }>(getRawString('Diagnostic.memberDelete'));\n        export const memberSet = () =>\n            new ParameterizedString<{ name: string; type: string }>(getRawString('Diagnostic.memberSet'));\n        export const metaclassConflict = () => getRawString('Diagnostic.metaclassConflict');\n        export const metaclassDuplicate = () => getRawString('Diagnostic.metaclassDuplicate');\n        export const methodNotDefined = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.methodNotDefined'));\n        export const methodNotDefinedOnType = () =>\n            new ParameterizedString<{ name: string; type: string }>(getRawString('Diagnostic.methodNotDefinedOnType'));\n        export const methodOrdering = () => getRawString('Diagnostic.methodOrdering');\n        export const methodOverridden = () =>\n            new ParameterizedString<{ name: string; className: string }>(getRawString('Diagnostic.methodOverridden'));\n        export const methodReturnsNonObject = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.methodReturnsNonObject'));\n        export const moduleContext = () => getRawString('Diagnostic.moduleContext');\n        export const moduleUnknownMember = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.moduleUnknownMember'));\n        export const namedExceptAfterCatchAll = () => getRawString('Diagnostic.namedExceptAfterCatchAll');\n        export const namedTupleEmptyName = () => getRawString('Diagnostic.namedTupleEmptyName');\n        export const namedTupleFirstArg = () => getRawString('Diagnostic.namedTupleFirstArg');\n        export const namedTupleNameString = () => getRawString('Diagnostic.namedTupleNameString');\n        export const namedTupleNameType = () => getRawString('Diagnostic.namedTupleNameType');\n        export const namedTupleNameUnique = () => getRawString('Diagnostic.namedTupleNameUnique');\n        export const namedTupleNoTypes = () => getRawString('Diagnostic.namedTupleNoTypes');\n        export const namedTupleSecondArg = () => getRawString('Diagnostic.namedTupleSecondArg');\n        export const newClsParam = () => getRawString('Diagnostic.newClsParam');\n        export const nonDefaultAfterDefault = () => getRawString('Diagnostic.nonDefaultAfterDefault');\n        export const noneNotCallable = () => getRawString('Diagnostic.noneNotCallable');\n        export const noneNotIterable = () => getRawString('Diagnostic.noneNotIterable');\n        export const noneNotSubscriptable = () => getRawString('Diagnostic.noneNotSubscriptable');\n        export const noneNotUsableWith = () => getRawString('Diagnostic.noneNotUsableWith');\n        export const noneOperator = () =>\n            new ParameterizedString<{ operator: string }>(getRawString('Diagnostic.noneOperator'));\n        export const noneUnknownMember = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.noneUnknownMember'));\n        export const nonLocalNoBinding = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.nonLocalNoBinding'));\n        export const nonLocalReassignment = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.nonLocalReassignment'));\n        export const nonLocalRedefinition = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.nonLocalRedefinition'));\n        export const nonLocalInModule = () => getRawString('Diagnostic.nonLocalInModule');\n        export const noOverload = () =>\n            new ParameterizedString<{ expression: string }>(getRawString('Diagnostic.noOverload'));\n        export const noReturnContainsReturn = () => getRawString('Diagnostic.noReturnContainsReturn');\n        export const noReturnContainsYield = () => getRawString('Diagnostic.noReturnContainsYield');\n        export const noReturnReturnsNone = () => getRawString('Diagnostic.noReturnReturnsNone');\n        export const objectNotCallable = () =>\n            new ParameterizedString<{ type: string }>(getRawString('Diagnostic.objectNotCallable'));\n        export const obscuredClassDeclaration = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.obscuredClassDeclaration'));\n        export const obscuredFunctionDeclaration = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.obscuredFunctionDeclaration'));\n        export const obscuredParameterDeclaration = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.obscuredParameterDeclaration'));\n        export const obscuredVariableDeclaration = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.obscuredVariableDeclaration'));\n        export const operatorLessOrGreaterDeprecated = () => getRawString('Diagnostic.operatorLessOrGreaterDeprecated');\n        export const optionalExtraArgs = () => getRawString('Diagnostic.optionalExtraArgs');\n        export const overlappingOverload = () =>\n            new ParameterizedString<{ name: string; obscured: number; obscuredBy: number }>(\n                getRawString('Diagnostic.overlappingOverload')\n            );\n        export const overloadAbstractMismatch = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.overloadAbstractMismatch'));\n        export const overloadReturnTypeMismatch = () =>\n            new ParameterizedString<{ name: string; newIndex: number; prevIndex: number }>(\n                getRawString('Diagnostic.overloadReturnTypeMismatch')\n            );\n        export const paramAfterKwargsParam = () => getRawString('Diagnostic.paramAfterKwargsParam');\n        export const paramAlreadyAssigned = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.paramAlreadyAssigned'));\n        export const paramNameMissing = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.paramNameMissing'));\n        export const paramSpecAssignedName = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.paramSpecAssignedName'));\n        export const paramSpecContext = () => getRawString('Diagnostic.paramSpecContext');\n        export const paramSpecIllegal = () => getRawString('Diagnostic.paramSpecIllegal');\n        export const paramSpecFirstArg = () => getRawString('Diagnostic.paramSpecFirstArg');\n        export const paramSpecUnknownArg = () => getRawString('Diagnostic.paramSpecUnknownArg');\n        export const paramSpecUnknownMember = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.paramSpecUnknownMember'));\n        export const paramSpecUnknownParam = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.paramSpecUnknownParam'));\n        export const paramTypeUnknown = () =>\n            new ParameterizedString<{ paramName: string }>(getRawString('Diagnostic.paramTypeUnknown'));\n        export const paramAssignmentMismatch = () =>\n            new ParameterizedString<{ sourceType: string; paramType: string }>(\n                getRawString('Diagnostic.paramAssignmentMismatch')\n            );\n        export const paramTypePartiallyUnknown = () =>\n            new ParameterizedString<{ paramName: string }>(getRawString('Diagnostic.paramTypePartiallyUnknown'));\n        export const positionArgAfterNamedArg = () => getRawString('Diagnostic.positionArgAfterNamedArg');\n        export const positionOnlyAfterNameOnly = () => getRawString('Diagnostic.positionOnlyAfterNameOnly');\n        export const positionOnlyIncompatible = () => getRawString('Diagnostic.positionOnlyIncompatible');\n        export const privateUsedOutsideOfClass = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.privateUsedOutsideOfClass'));\n        export const privateUsedOutsideOfModule = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.privateUsedOutsideOfModule'));\n        export const protectedUsedOutsideOfClass = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.protectedUsedOutsideOfClass'));\n        export const protocolIllegal = () => getRawString('Diagnostic.protocolIllegal');\n        export const protocolUsedInCall = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.protocolUsedInCall'));\n        export const raiseParams = () => getRawString('Diagnostic.raiseParams');\n        export const relativeImportNotAllowed = () => getRawString('Diagnostic.relativeImportNotAllowed');\n        export const returnMissing = () =>\n            new ParameterizedString<{ returnType: string }>(getRawString('Diagnostic.returnMissing'));\n        export const returnOutsideFunction = () => getRawString('Diagnostic.returnOutsideFunction');\n        export const returnTypeMismatch = () =>\n            new ParameterizedString<{ exprType: string; returnType: string }>(\n                getRawString('Diagnostic.returnTypeMismatch')\n            );\n        export const returnTypeUnknown = () => getRawString('Diagnostic.returnTypeUnknown');\n        export const returnTypePartiallyUnknown = () =>\n            new ParameterizedString<{ returnType: string }>(getRawString('Diagnostic.returnTypePartiallyUnknown'));\n        export const setterGetterTypeMismatch = () => getRawString('Diagnostic.setterGetterTypeMismatch');\n        export const singleOverload = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.singleOverload'));\n        export const staticClsSelfParam = () => getRawString('Diagnostic.staticClsSelfParam');\n        export const stringNonAsciiBytes = () => getRawString('Diagnostic.stringNonAsciiBytes');\n        export const stringUnsupportedEscape = () => getRawString('Diagnostic.stringUnsupportedEscape');\n        export const stringUnterminated = () => getRawString('Diagnostic.stringUnterminated');\n        export const stubFileMissing = () =>\n            new ParameterizedString<{ importName: string }>(getRawString('Diagnostic.stubFileMissing'));\n        export const stubUsesGetAttr = () => getRawString('Diagnostic.stubUsesGetAttr');\n        export const sublistParamsIncompatible = () => getRawString('Diagnostic.sublistParamsIncompatible');\n        export const superCallArgCount = () => getRawString('Diagnostic.superCallArgCount');\n        export const superCallFirstArg = () =>\n            new ParameterizedString<{ type: string }>(getRawString('Diagnostic.superCallFirstArg'));\n        export const superCallSecondArg = () =>\n            new ParameterizedString<{ type: string }>(getRawString('Diagnostic.superCallSecondArg'));\n        export const superCallZeroArgForm = () => getRawString('Diagnostic.superCallZeroArgForm');\n        export const symbolIsUnbound = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.symbolIsUnbound'));\n        export const symbolIsUndefined = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.symbolIsUndefined'));\n        export const symbolIsPossiblyUnbound = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.symbolIsPossiblyUnbound'));\n        export const symbolOverridden = () =>\n            new ParameterizedString<{ name: string; className: string }>(getRawString('Diagnostic.symbolOverridden'));\n        export const tupleInAnnotation = () => getRawString('Diagnostic.tupleInAnnotation');\n        export const tupleSizeMismatch = () =>\n            new ParameterizedString<{ expected: number; received: number }>(\n                getRawString('Diagnostic.tupleSizeMismatch')\n            );\n        export const typeAbstract = () =>\n            new ParameterizedString<{ type: string }>(getRawString('Diagnostic.typeAbstract'));\n        export const typeAliasIsRecursive = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.typeAliasIsRecursive'));\n        export const typeAliasNotInModule = () => getRawString('Diagnostic.typeAliasNotInModule');\n        export const typeAliasRedeclared = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.typeAliasRedeclared'));\n        export const typeArgsExpectingNone = () => getRawString('Diagnostic.typeArgsExpectingNone');\n        export const typeArgsMismatchOne = () =>\n            new ParameterizedString<{ received: number }>(getRawString('Diagnostic.typeArgsMismatchOne'));\n        export const typeArgsMissingForAlias = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.typeArgsMissingForAlias'));\n        export const typeArgsMissingForClass = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.typeArgsMissingForClass'));\n        export const typeArgsTooFew = () =>\n            new ParameterizedString<{ name: string; expected: number; received: number }>(\n                getRawString('Diagnostic.typeArgsTooFew')\n            );\n        export const typeArgsTooMany = () =>\n            new ParameterizedString<{ name: string; expected: number; received: number }>(\n                getRawString('Diagnostic.typeArgsTooMany')\n            );\n        export const typeAssignmentMismatch = () =>\n            new ParameterizedString<{ sourceType: string; destType: string }>(\n                getRawString('Diagnostic.typeAssignmentMismatch')\n            );\n        export const typeCallNotAllowed = () => getRawString('Diagnostic.typeCallNotAllowed');\n        export const typedDictAccess = () => getRawString('Diagnostic.typedDictAccess');\n        export const typedDictBadVar = () => getRawString('Diagnostic.typedDictBadVar');\n        export const typedDictBaseClass = () => getRawString('Diagnostic.typedDictBaseClass');\n        export const typedDictDelete = () => getRawString('Diagnostic.typedDictDelete');\n        export const typedDictEmptyName = () => getRawString('Diagnostic.typedDictEmptyName');\n        export const typedDictEntryName = () => getRawString('Diagnostic.typedDictEntryName');\n        export const typedDictEntryUnique = () => getRawString('Diagnostic.typedDictEntryUnique');\n        export const typedDictExtraArgs = () => getRawString('Diagnostic.typedDictExtraArgs');\n        export const typedDictFirstArg = () => getRawString('Diagnostic.typedDictFirstArg');\n        export const typedDictSecondArgDict = () => getRawString('Diagnostic.typedDictSecondArgDict');\n        export const typedDictSecondArgDictEntry = () => getRawString('Diagnostic.typedDictSecondArgDictEntry');\n        export const typedDictSet = () => getRawString('Diagnostic.typedDictSet');\n        export const typedDictTotalParam = () => getRawString('Diagnostic.typedDictTotalParam');\n        export const typeExpectedClass = () =>\n            new ParameterizedString<{ type: string }>(getRawString('Diagnostic.typeExpectedClass'));\n        export const typeNotAwaitable = () =>\n            new ParameterizedString<{ type: string }>(getRawString('Diagnostic.typeNotAwaitable'));\n        export const typeNotCallable = () =>\n            new ParameterizedString<{ expression: string; type: string }>(getRawString('Diagnostic.typeNotCallable'));\n        export const typeNotIntantiable = () =>\n            new ParameterizedString<{ type: string }>(getRawString('Diagnostic.typeNotIntantiable'));\n        export const typeNotIterable = () =>\n            new ParameterizedString<{ type: string }>(getRawString('Diagnostic.typeNotIterable'));\n        export const typeNotSpecializable = () =>\n            new ParameterizedString<{ type: string }>(getRawString('Diagnostic.typeNotSpecializable'));\n        export const typeNotSubscriptable = () =>\n            new ParameterizedString<{ type: string }>(getRawString('Diagnostic.typeNotSubscriptable'));\n        export const typeNotUsableWith = () =>\n            new ParameterizedString<{ type: string; method: string }>(getRawString('Diagnostic.typeNotUsableWith'));\n        export const typeNotSupportBinaryOperator = () =>\n            new ParameterizedString<{ leftType: string; rightType: string; operator: string }>(\n                getRawString('Diagnostic.typeNotSupportBinaryOperator')\n            );\n        export const typeNotSupportUnaryOperator = () =>\n            new ParameterizedString<{ type: string; operator: string }>(\n                getRawString('Diagnostic.typeNotSupportUnaryOperator')\n            );\n        export const typePartiallyUnknown = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.typePartiallyUnknown'));\n        export const typeUnknown = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.typeUnknown'));\n        export const typeVarAssignedName = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.typeVarAssignedName'));\n        export const typeVarAssignmentMismatch = () =>\n            new ParameterizedString<{ type: string; name: string }>(\n                getRawString('Diagnostic.typeVarAssignmentMismatch')\n            );\n        export const typeVarBoundAndConstrained = () => getRawString('Diagnostic.typeVarBoundAndConstrained');\n        export const typeVarFirstArg = () => getRawString('Diagnostic.typeVarFirstArg');\n        export const typeVarGeneric = () => getRawString('Diagnostic.typeVarGeneric');\n        export const typeVarNotUsedByOuterScope = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.typeVarNotUsedByOuterScope'));\n        export const typeVarSingleConstraint = () => getRawString('Diagnostic.typeVarSingleConstraint');\n        export const typeVarUnknownParam = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.typeVarUnknownParam'));\n        export const typeVarUsedByOuterScope = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.typeVarUsedByOuterScope'));\n        export const typeVarVariance = () => getRawString('Diagnostic.typeVarVariance');\n        export const unaccessedClass = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.unaccessedClass'));\n        export const unaccessedFunction = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.unaccessedFunction'));\n        export const unaccessedImport = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.unaccessedImport'));\n        export const unaccessedSymbol = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.unaccessedSymbol'));\n        export const unaccessedVariable = () =>\n            new ParameterizedString<{ name: string }>(getRawString('Diagnostic.unaccessedVariable'));\n        export const unexpectedAsyncToken = () => getRawString('Diagnostic.unexpectedAsyncToken');\n        export const unexpectedExprToken = () => getRawString('Diagnostic.unexpectedExprToken');\n        export const unexpectedIndent = () => getRawString('Diagnostic.unexpectedIndent');\n        export const unexpectedUnindent = () => getRawString('Diagnostic.unexpectedUnindent');\n        export const unionSyntaxIllegal = () => getRawString('Diagnostic.unionSyntaxIllegal');\n        export const unnecessaryCast = () =>\n            new ParameterizedString<{ type: string }>(getRawString('Diagnostic.unnecessaryCast'));\n        export const unnecessaryIsInstanceNever = () =>\n            new ParameterizedString<{ testType: string; classType: string }>(\n                getRawString('Diagnostic.unnecessaryIsInstanceNever')\n            );\n        export const unnecessaryIsInstanceAlways = () =>\n            new ParameterizedString<{ testType: string; classType: string }>(\n                getRawString('Diagnostic.unnecessaryIsInstanceAlways')\n            );\n        export const unnecessaryIsSubclassAlways = () =>\n            new ParameterizedString<{ testType: string; classType: string }>(\n                getRawString('Diagnostic.unnecessaryIsSubclassAlways')\n            );\n        export const unnecessaryIsSubclassNever = () =>\n            new ParameterizedString<{ testType: string; classType: string }>(\n                getRawString('Diagnostic.unnecessaryIsSubclassNever')\n            );\n        export const unpackIllegalInComprehension = () => getRawString('Diagnostic.unpackIllegalInComprehension');\n        export const unpackInDict = () => getRawString('Diagnostic.unpackInDict');\n        export const unpackInSet = () => getRawString('Diagnostic.unpackInSet');\n        export const unpackTuplesIllegal = () => getRawString('Diagnostic.unpackTuplesIllegal');\n        export const unreachableCode = () => getRawString('Diagnostic.unreachableCode');\n        export const varAnnotationIllegal = () => getRawString('Diagnostic.varAnnotationIllegal');\n        export const walrusIllegal = () => getRawString('Diagnostic.walrusIllegal');\n        export const walrusNotAllowed = () => getRawString('Diagnostic.walrusNotAllowed');\n        export const wildcardInFunction = () => getRawString('Diagnostic.wildcardInFunction');\n        export const wildcardLibraryImport = () => getRawString('Diagnostic.wildcardLibraryImport');\n        export const yieldFromIllegal = () => getRawString('Diagnostic.yieldFromIllegal');\n        export const yieldFromOutsideAsync = () => getRawString('Diagnostic.yieldFromOutsideAsync');\n        export const yieldOutsideFunction = () => getRawString('Diagnostic.yieldOutsideFunction');\n        export const yieldTypeMismatch = () =>\n            new ParameterizedString<{ exprType: string; yieldType: string }>(\n                getRawString('Diagnostic.yieldTypeMismatch')\n            );\n    }\n\n    export namespace DiagnosticAddendum {\n        export const argParam = () =>\n            new ParameterizedString<{ paramName: string }>(getRawString('DiagnosticAddendum.argParam'));\n        export const argParamFunction = () =>\n            new ParameterizedString<{ paramName: string; functionName: string }>(\n                getRawString('DiagnosticAddendum.argParamFunction')\n            );\n        export const argsParamMissing = () =>\n            new ParameterizedString<{ paramName: string }>(getRawString('DiagnosticAddendum.argsParamMissing'));\n        export const argumentType = () =>\n            new ParameterizedString<{ type: string }>(getRawString('DiagnosticAddendum.argumentType'));\n        export const argumentTypes = () =>\n            new ParameterizedString<{ types: string }>(getRawString('DiagnosticAddendum.argumentTypes'));\n        export const assignToNone = () => getRawString('DiagnosticAddendum.assignToNone');\n        export const asyncHelp = () => getRawString('DiagnosticAddendum.asyncHelp');\n        export const finalMethod = () => getRawString('DiagnosticAddendum.finalMethod');\n        export const functionReturnTypeMismatch = () =>\n            new ParameterizedString<{ sourceType: string; destType: string }>(\n                getRawString('DiagnosticAddendum.functionReturnTypeMismatch')\n            );\n        export const functionTooFewParams = () =>\n            new ParameterizedString<{ expected: number; received: number }>(\n                getRawString('DiagnosticAddendum.functionTooFewParams')\n            );\n        export const functionTooManyParams = () =>\n            new ParameterizedString<{ expected: number; received: number }>(\n                getRawString('DiagnosticAddendum.functionTooManyParams')\n            );\n        export const keyUndefined = () =>\n            new ParameterizedString<{ name: string; type: string }>(getRawString('DiagnosticAddendum.keyUndefined'));\n        export const literalAssignmentMismatch = () =>\n            new ParameterizedString<{ sourceType: string; destType: string }>(\n                getRawString('DiagnosticAddendum.literalAssignmentMismatch')\n            );\n        export const memberAssignment = () =>\n            new ParameterizedString<{ type: string; name: string; classType: string }>(\n                getRawString('DiagnosticAddendum.memberAssignment')\n            );\n        export const memberIsAbstract = () =>\n            new ParameterizedString<{ type: string; name: string }>(\n                getRawString('DiagnosticAddendum.memberIsAbstract')\n            );\n        export const memberIsAbstractMore = () =>\n            new ParameterizedString<{ count: number }>(getRawString('DiagnosticAddendum.memberIsAbstractMore'));\n        export const memberSetClassVar = () =>\n            new ParameterizedString<{ name: string }>(getRawString('DiagnosticAddendum.memberSetClassVar'));\n        export const memberTypeMismatch = () =>\n            new ParameterizedString<{ name: string }>(getRawString('DiagnosticAddendum.memberTypeMismatch'));\n        export const memberUnknown = () =>\n            new ParameterizedString<{ name: string }>(getRawString('DiagnosticAddendum.memberUnknown'));\n        export const namedParamMissingInDest = () =>\n            new ParameterizedString<{ name: string }>(getRawString('DiagnosticAddendum.namedParamMissingInDest'));\n        export const namedParamMissingInSource = () =>\n            new ParameterizedString<{ name: string }>(getRawString('DiagnosticAddendum.namedParamMissingInSource'));\n        export const namedParamTypeMismatch = () =>\n            new ParameterizedString<{ name: string; sourceType: string; destType: string }>(\n                getRawString('DiagnosticAddendum.namedParamTypeMismatch')\n            );\n        export const noOverloadAssignable = () =>\n            new ParameterizedString<{ type: string }>(getRawString('DiagnosticAddendum.noOverloadAssignable'));\n        export const overloadCallName = () =>\n            new ParameterizedString<{ name: string }>(getRawString('DiagnosticAddendum.overloadCallName'));\n        export const overloadNotAssignable = () =>\n            new ParameterizedString<{ name: string }>(getRawString('DiagnosticAddendum.overloadNotAssignable'));\n        export const overriddenMethod = () => getRawString('DiagnosticAddendum.overriddenMethod');\n        export const overriddenSymbol = () => getRawString('DiagnosticAddendum.overriddenSymbol');\n        export const overrideParamCount = () =>\n            new ParameterizedString<{ baseCount: number; overrideCount: number }>(\n                getRawString('DiagnosticAddendum.overrideParamCount')\n            );\n        export const overrideParamName = () =>\n            new ParameterizedString<{ index: number; baseName: string; overrideName: string }>(\n                getRawString('DiagnosticAddendum.overrideParamName')\n            );\n        export const overrideParamType = () =>\n            new ParameterizedString<{ index: number; baseType: string; overrideType: string }>(\n                getRawString('DiagnosticAddendum.overrideParamType')\n            );\n        export const overrideReturnType = () =>\n            new ParameterizedString<{ baseType: string; overrideType: string }>(\n                getRawString('DiagnosticAddendum.overrideReturnType')\n            );\n        export const overrideType = () =>\n            new ParameterizedString<{ type: string }>(getRawString('DiagnosticAddendum.overrideType'));\n        export const paramAssignment = () =>\n            new ParameterizedString<{ index: number; sourceType: string; destType: string }>(\n                getRawString('DiagnosticAddendum.paramAssignment')\n            );\n        export const paramType = () =>\n            new ParameterizedString<{ paramType: string }>(getRawString('DiagnosticAddendum.paramType'));\n        export const propertyMissingDeleter = () =>\n            new ParameterizedString<{ name: string }>(getRawString('DiagnosticAddendum.propertyMissingDeleter'));\n        export const propertyMissingSetter = () =>\n            new ParameterizedString<{ name: string }>(getRawString('DiagnosticAddendum.propertyMissingSetter'));\n        export const protocolMemberClassVar = () =>\n            new ParameterizedString<{ name: string }>(getRawString('DiagnosticAddendum.protocolMemberClassVar'));\n        export const protocolMemberMissing = () =>\n            new ParameterizedString<{ name: string }>(getRawString('DiagnosticAddendum.protocolMemberMissing'));\n        export const seeDeclaration = () => getRawString('DiagnosticAddendum.seeDeclaration');\n        export const seeClassDeclaration = () => getRawString('DiagnosticAddendum.seeClassDeclaration');\n        export const seeFunctionDeclaration = () => getRawString('DiagnosticAddendum.seeFunctionDeclaration');\n        export const seeMethodDeclaration = () => getRawString('DiagnosticAddendum.seeMethodDeclaration');\n        export const seeParameterDeclaration = () => getRawString('DiagnosticAddendum.seeParameterDeclaration');\n        export const seeVariableDeclaration = () => getRawString('DiagnosticAddendum.seeVariableDeclaration');\n        export const tupleEntryTypeMismatch = () =>\n            new ParameterizedString<{ entry: number }>(getRawString('DiagnosticAddendum.tupleEntryTypeMismatch'));\n        export const tupleSizeMismatch = () =>\n            new ParameterizedString<{ expected: number; received: number }>(\n                getRawString('DiagnosticAddendum.tupleSizeMismatch')\n            );\n        export const typeAssignmentMismatch = () =>\n            new ParameterizedString<{ sourceType: string; destType: string }>(\n                getRawString('DiagnosticAddendum.typeAssignmentMismatch')\n            );\n        export const typeBound = () =>\n            new ParameterizedString<{ sourceType: string; destType: string; name: string }>(\n                getRawString('DiagnosticAddendum.typeBound')\n            );\n        export const typeConstrainedTypeVar = () =>\n            new ParameterizedString<{ type: string; name: string }>(\n                getRawString('DiagnosticAddendum.typeConstrainedTypeVar')\n            );\n        export const typeConstraint = () =>\n            new ParameterizedString<{ type: string; name: string }>(getRawString('DiagnosticAddendum.typeConstraint'));\n        export const typedDictFieldMissing = () =>\n            new ParameterizedString<{ name: string; type: string }>(\n                getRawString('DiagnosticAddendum.typedDictFieldMissing')\n            );\n        export const typedDictFieldNotRequired = () =>\n            new ParameterizedString<{ name: string; type: string }>(\n                getRawString('DiagnosticAddendum.typedDictFieldNotRequired')\n            );\n        export const typedDictFieldRequired = () =>\n            new ParameterizedString<{ name: string; type: string }>(\n                getRawString('DiagnosticAddendum.typedDictFieldRequired')\n            );\n        export const typedDictFieldTypeMismatch = () =>\n            new ParameterizedString<{ name: string; type: string }>(\n                getRawString('DiagnosticAddendum.typedDictFieldTypeMismatch')\n            );\n        export const typedDictFieldUndefined = () =>\n            new ParameterizedString<{ name: string; type: string }>(\n                getRawString('DiagnosticAddendum.typedDictFieldUndefined')\n            );\n        export const typeIncompatible = () =>\n            new ParameterizedString<{ sourceType: string; destType: string }>(\n                getRawString('DiagnosticAddendum.typeIncompatible')\n            );\n        export const typeNotClass = () =>\n            new ParameterizedString<{ type: string }>(getRawString('DiagnosticAddendum.typeNotClass'));\n        export const typeParamSpec = () =>\n            new ParameterizedString<{ type: string; name: string }>(getRawString('DiagnosticAddendum.typeParamSpec'));\n        export const typeNotStringLiteral = () =>\n            new ParameterizedString<{ type: string }>(getRawString('DiagnosticAddendum.typeNotStringLiteral'));\n        export const typeOfSymbol = () =>\n            new ParameterizedString<{ name: string; type: string }>(getRawString('DiagnosticAddendum.typeOfSymbol'));\n        export const typeUnsupported = () =>\n            new ParameterizedString<{ type: string }>(getRawString('DiagnosticAddendum.typeUnsupported'));\n        export const typeVarIsContravariant = () =>\n            new ParameterizedString<{ name: string }>(getRawString('DiagnosticAddendum.typeVarIsContravariant'));\n        export const typeVarIsCovariant = () =>\n            new ParameterizedString<{ name: string }>(getRawString('DiagnosticAddendum.typeVarIsCovariant'));\n        export const typeVarIsInvariant = () =>\n            new ParameterizedString<{ name: string }>(getRawString('DiagnosticAddendum.typeVarIsInvariant'));\n        export const typeVarNotAllowed = () => getRawString('DiagnosticAddendum.typeVarNotAllowed');\n        export const useDictInstead = () => getRawString('DiagnosticAddendum.useDictInstead');\n        export const useListInstead = () => getRawString('DiagnosticAddendum.useListInstead');\n        export const useTupleInstead = () => getRawString('DiagnosticAddendum.useTupleInstead');\n        export const useTypeInstead = () => getRawString('DiagnosticAddendum.useTypeInstead');\n    }\n\n    export namespace CodeAction {\n        export const addOptionalToAnnotation = () => getRawString('CodeAction.addOptionalToAnnotation');\n        export const createTypeStub = () => getRawString('CodeAction.createTypeStub');\n        export const createTypeStubFor = () =>\n            new ParameterizedString<{ moduleName: string }>(getRawString('CodeAction.createTypeStubFor'));\n        export const executingCommand = () => getRawString('CodeAction.executingCommand');\n        export const filesToAnalyzeOne = () => getRawString('CodeAction.filesToAnalyzeOne');\n        export const filesToAnalyzeCount = () =>\n            new ParameterizedString<{ count: number }>(getRawString('CodeAction.filesToAnalyzeCount'));\n        export const findingReferences = () => getRawString('CodeAction.findingReferences');\n        export const organizeImports = () => getRawString('CodeAction.organizeImports');\n    }\n}\n","/*\n * characterStream.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Based on code from vscode-python repository:\n *  https://github.com/Microsoft/vscode-python\n *\n * Class that represents a stream of characters.\n */\n\nimport Char from 'typescript-char';\n\nimport { isLineBreak, isWhiteSpace } from './characters';\n\nexport class CharacterStream {\n    private _text: string;\n    private _position: number;\n    private _currentChar: number;\n    private _isEndOfStream: boolean;\n\n    constructor(text: string) {\n        this._text = text;\n        this._position = 0;\n        this._currentChar = text.length > 0 ? text.charCodeAt(0) : 0;\n        this._isEndOfStream = text.length === 0;\n    }\n\n    getText(): string {\n        return this._text;\n    }\n\n    get position(): number {\n        return this._position;\n    }\n\n    set position(value: number) {\n        this._position = value;\n        this._checkBounds();\n    }\n\n    get currentChar(): number {\n        return this._currentChar;\n    }\n\n    // We also expose a (non-property) method that is\n    // the equivalent of currentChar above. This allows\n    // us to work around assumptions in the TypeScript\n    // compiler that method calls (e.g. moveNext()) don't\n    // modify properties.\n    getCurrentChar(): number {\n        return this._currentChar;\n    }\n\n    get nextChar(): number {\n        return this.position + 1 < this._text.length ? this._text.charCodeAt(this.position + 1) : 0;\n    }\n\n    get prevChar(): number {\n        return this.position - 1 >= 0 ? this._text.charCodeAt(this.position - 1) : 0;\n    }\n\n    isEndOfStream(): boolean {\n        return this._isEndOfStream;\n    }\n\n    lookAhead(offset: number): number {\n        const pos = this._position + offset;\n        return pos < 0 || pos >= this._text.length ? 0 : this._text.charCodeAt(pos);\n    }\n\n    advance(offset: number) {\n        this.position += offset;\n    }\n\n    moveNext(): boolean {\n        if (this._position < this._text.length - 1) {\n            // Most common case, no need to check bounds extensively\n            this._position += 1;\n            this._currentChar = this._text.charCodeAt(this._position);\n            return true;\n        }\n        this.advance(1);\n        return !this.isEndOfStream();\n    }\n\n    isAtWhiteSpace(): boolean {\n        return isWhiteSpace(this.currentChar);\n    }\n\n    isAtLineBreak(): boolean {\n        return isLineBreak(this.currentChar);\n    }\n\n    skipLineBreak(): void {\n        if (this._currentChar === Char.CarriageReturn) {\n            this.moveNext();\n            if (this.currentChar === Char.LineFeed) {\n                this.moveNext();\n            }\n        } else if (this._currentChar === Char.LineFeed) {\n            this.moveNext();\n        }\n    }\n\n    skipWhitespace(): void {\n        while (!this.isEndOfStream() && this.isAtWhiteSpace()) {\n            this.moveNext();\n        }\n    }\n\n    skipToEol(): void {\n        while (!this.isEndOfStream() && !this.isAtLineBreak()) {\n            this.moveNext();\n        }\n    }\n\n    skipToWhitespace(): void {\n        while (!this.isEndOfStream() && !this.isAtWhiteSpace()) {\n            this.moveNext();\n        }\n    }\n\n    charCodeAt(index: number): number {\n        return this._text.charCodeAt(index);\n    }\n\n    get length(): number {\n        return this._text.length;\n    }\n\n    private _checkBounds(): void {\n        if (this._position < 0) {\n            this._position = 0;\n        }\n\n        this._isEndOfStream = this._position >= this._text.length;\n        if (this._isEndOfStream) {\n            this._position = this._text.length;\n        }\n\n        this._currentChar = this._isEndOfStream ? 0 : this._text.charCodeAt(this._position);\n    }\n}\n","/*\n * characters.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Based on code from vscode-python repository:\n *  https://github.com/Microsoft/vscode-python\n *\n * Utility routines used by tokenizer.\n */\n\nimport Char from 'typescript-char';\n\nimport * as unicode from './unicode';\n\nenum CharCategory {\n    // Character cannot appear in identifier\n    NotIdentifierChar = 0,\n\n    // Character can appear at beginning or within identifier\n    StartIdentifierChar = 1,\n\n    // Character can appear only within identifier, not at beginning\n    IdentifierChar = 2,\n}\n\n// Table of first 256 character codes (the most common cases).\nconst _identifierCharFastTableSize = 256;\nconst _identifierCharFastTable: CharCategory[] = new Array(_identifierCharFastTableSize);\n\n// Map of remaining characters that can appear within identifier.\nconst _identifierCharMap: { [code: number]: CharCategory } = {};\n\n// We do lazy initialization of this map because it's rarely used.\nlet _identifierCharMapInitialized = false;\n\nexport function isIdentifierStartChar(ch: number) {\n    if (ch < _identifierCharFastTableSize) {\n        return _identifierCharFastTable[ch] === CharCategory.StartIdentifierChar;\n    }\n\n    // Lazy initialize the char map. We'll rarely get here.\n    if (!_identifierCharMapInitialized) {\n        _buildIdentifierLookupTable(false);\n        _identifierCharMapInitialized = true;\n    }\n\n    return _identifierCharMap[ch] === CharCategory.StartIdentifierChar;\n}\n\nexport function isIdentifierChar(ch: number) {\n    if (ch < _identifierCharFastTableSize) {\n        return (\n            _identifierCharFastTable[ch] === CharCategory.StartIdentifierChar ||\n            _identifierCharFastTable[ch] === CharCategory.IdentifierChar\n        );\n    }\n\n    return (\n        _identifierCharMap[ch] === CharCategory.StartIdentifierChar ||\n        _identifierCharMap[ch] === CharCategory.IdentifierChar\n    );\n}\n\nexport function isWhiteSpace(ch: number): boolean {\n    return ch === Char.Space || ch === Char.Tab || ch === Char.FormFeed;\n}\n\nexport function isLineBreak(ch: number): boolean {\n    return ch === Char.CarriageReturn || ch === Char.LineFeed;\n}\n\nexport function isNumber(ch: number): boolean {\n    return (ch >= Char._0 && ch <= Char._9) || ch === Char.Underscore;\n}\n\nexport function isDecimal(ch: number): boolean {\n    return (ch >= Char._0 && ch <= Char._9) || ch === Char.Underscore;\n}\n\nexport function isHex(ch: number): boolean {\n    return isDecimal(ch) || (ch >= Char.a && ch <= Char.f) || (ch >= Char.A && ch <= Char.F) || ch === Char.Underscore;\n}\n\nexport function isOctal(ch: number): boolean {\n    return (ch >= Char._0 && ch <= Char._7) || ch === Char.Underscore;\n}\n\nexport function isBinary(ch: number): boolean {\n    return ch === Char._0 || ch === Char._1 || ch === Char.Underscore;\n}\n\n// Underscore is explicitly allowed to start an identifier.\n// Characters with the Other_ID_Start property.\nconst _specialStartIdentifierChars: unicode.UnicodeRangeTable = [\n    Char.Underscore,\n    0x1885,\n    0x1886,\n    0x2118,\n    0x212e,\n    0x309b,\n    0x309c,\n];\n\nconst _startIdentifierCharRanges = [\n    _specialStartIdentifierChars,\n    unicode.unicodeLu,\n    unicode.unicodeLl,\n    unicode.unicodeLt,\n    unicode.unicodeLo,\n    unicode.unicodeLm,\n    unicode.unicodeNl,\n];\n\n// Characters with the Other_ID_Start property.\nconst _specialIdentifierChars: unicode.UnicodeRangeTable = [\n    0x00b7,\n    0x0387,\n    0x1369,\n    0x136a,\n    0x136b,\n    0x136c,\n    0x136d,\n    0x136e,\n    0x136f,\n    0x1370,\n    0x1371,\n    0x19da,\n];\n\nconst _identifierCharRanges = [\n    _specialIdentifierChars,\n    unicode.unicodeMn,\n    unicode.unicodeMc,\n    unicode.unicodeNd,\n    unicode.unicodePc,\n];\n\nfunction _buildIdentifierLookupTableFromUnicodeRangeTable(\n    table: unicode.UnicodeRangeTable,\n    category: CharCategory,\n    fastTableOnly: boolean\n) {\n    for (let entryIndex = 0; entryIndex < table.length; entryIndex++) {\n        const entry = table[entryIndex];\n        let rangeStart: number;\n        let rangeEnd: number;\n\n        if (Array.isArray(entry)) {\n            rangeStart = entry[0];\n            rangeEnd = entry[1];\n        } else {\n            rangeStart = rangeEnd = entry;\n        }\n\n        for (let i = rangeStart; i <= rangeEnd; i++) {\n            if (i < _identifierCharFastTableSize) {\n                _identifierCharFastTable[i] = category;\n            } else {\n                _identifierCharMap[i] = category;\n            }\n        }\n\n        if (fastTableOnly && rangeStart >= _identifierCharFastTableSize) {\n            break;\n        }\n    }\n}\n\n// Build a lookup table for to speed up tokenization of identifiers.\nfunction _buildIdentifierLookupTable(fastTableOnly: boolean) {\n    _identifierCharFastTable.fill(CharCategory.NotIdentifierChar);\n\n    _identifierCharRanges.forEach((table) => {\n        _buildIdentifierLookupTableFromUnicodeRangeTable(table, CharCategory.IdentifierChar, fastTableOnly);\n    });\n\n    _startIdentifierCharRanges.forEach((table) => {\n        _buildIdentifierLookupTableFromUnicodeRangeTable(table, CharCategory.StartIdentifierChar, fastTableOnly);\n    });\n}\n\n_buildIdentifierLookupTable(true);\n","/*\n * parseNodes.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Definition of parse nodes that make up the Python abstract\n * syntax tree (AST).\n */\n\nimport { TextRange } from '../common/textRange';\nimport {\n    IdentifierToken,\n    KeywordToken,\n    KeywordType,\n    NumberToken,\n    OperatorType,\n    StringToken,\n    Token,\n    TokenType,\n} from './tokenizerTypes';\n\nexport const enum ParseNodeType {\n    Error, // 0\n\n    Argument,\n    Assert,\n    Assignment,\n    AssignmentExpression,\n    AugmentedAssignment,\n    Await,\n    BinaryOperation,\n    Break,\n    Call,\n\n    Class, // 10\n    Constant,\n    Continue,\n    Decorator,\n    Del,\n    Dictionary,\n    DictionaryExpandEntry,\n    DictionaryKeyEntry,\n    Ellipsis,\n    If,\n\n    Import, // 20\n    ImportAs,\n    ImportFrom,\n    ImportFromAs,\n    Index,\n    IndexItems,\n    Except,\n    For,\n    FormatString,\n    Function,\n\n    Global, // 30\n    Lambda,\n    List,\n    ListComprehension,\n    ListComprehensionFor,\n    ListComprehensionIf,\n    MemberAccess,\n    Module,\n    ModuleName,\n    Name,\n\n    Nonlocal, // 40\n    Number,\n    Parameter,\n    Pass,\n    Raise,\n    Return,\n    Set,\n    Slice,\n    StatementList,\n    StringList,\n\n    String, // 50\n    Suite,\n    Ternary,\n    Tuple,\n    Try,\n    TypeAnnotation,\n    UnaryOperation,\n    Unpack,\n    While,\n    With,\n\n    WithItem, // 60\n    Yield,\n    YieldFrom,\n    FunctionAnnotation,\n}\n\nexport const enum ErrorExpressionCategory {\n    MissingIn,\n    MissingElse,\n    MissingExpression,\n    MissingIndexOrSlice,\n    MissingDecoratorCallName,\n    MissingCallCloseParen,\n    MissingIndexCloseBracket,\n    MissingMemberAccessName,\n    MissingTupleCloseParen,\n    MissingListCloseBracket,\n    MissingFunctionParameterList,\n}\n\nexport interface ParseNodeBase extends TextRange {\n    readonly nodeType: ParseNodeType;\n\n    // A unique ID given to each parse node.\n    id: number;\n\n    parent?: ParseNode;\n}\n\nlet _nextNodeId = 1;\nexport function getNextNodeId() {\n    return _nextNodeId++;\n}\n\nexport function extendRange(node: ParseNodeBase, newRange: TextRange) {\n    if (newRange.start < node.start) {\n        node.length += node.start - newRange.start;\n        node.start = newRange.start;\n    }\n\n    if (TextRange.getEnd(newRange) > TextRange.getEnd(node)) {\n        node.length = TextRange.getEnd(newRange) - node.start;\n    }\n}\n\nexport type ParseNodeArray = (ParseNode | undefined)[];\n\nexport interface ModuleNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.Module;\n    statements: StatementNode[];\n}\n\nexport namespace ModuleNode {\n    export function create(range: TextRange) {\n        const node: ModuleNode = {\n            start: range.start,\n            length: range.length,\n            nodeType: ParseNodeType.Module,\n            id: _nextNodeId++,\n            statements: [],\n        };\n\n        return node;\n    }\n}\n\nexport interface SuiteNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.Suite;\n    statements: StatementNode[];\n}\n\nexport namespace SuiteNode {\n    export function create(range: TextRange) {\n        const node: SuiteNode = {\n            start: range.start,\n            length: range.length,\n            nodeType: ParseNodeType.Suite,\n            id: _nextNodeId++,\n            statements: [],\n        };\n\n        return node;\n    }\n}\n\nexport interface IfNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.If;\n    testExpression: ExpressionNode;\n    ifSuite: SuiteNode;\n    elseSuite?: SuiteNode | IfNode;\n}\n\nexport namespace IfNode {\n    export function create(\n        ifOrElifToken: Token,\n        testExpression: ExpressionNode,\n        ifSuite: SuiteNode,\n        elseSuite?: SuiteNode\n    ) {\n        const node: IfNode = {\n            start: ifOrElifToken.start,\n            length: ifOrElifToken.length,\n            nodeType: ParseNodeType.If,\n            id: _nextNodeId++,\n            testExpression,\n            ifSuite,\n            elseSuite,\n        };\n\n        testExpression.parent = node;\n        ifSuite.parent = node;\n\n        extendRange(node, testExpression);\n        extendRange(node, ifSuite);\n        if (elseSuite) {\n            extendRange(node, elseSuite);\n            elseSuite.parent = node;\n        }\n\n        return node;\n    }\n}\n\nexport interface WhileNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.While;\n    testExpression: ExpressionNode;\n    whileSuite: SuiteNode;\n    elseSuite?: SuiteNode;\n}\n\nexport namespace WhileNode {\n    export function create(whileToken: Token, testExpression: ExpressionNode, whileSuite: SuiteNode) {\n        const node: WhileNode = {\n            start: whileToken.start,\n            length: whileToken.length,\n            nodeType: ParseNodeType.While,\n            id: _nextNodeId++,\n            testExpression,\n            whileSuite,\n        };\n\n        testExpression.parent = node;\n        whileSuite.parent = node;\n\n        extendRange(node, whileSuite);\n\n        return node;\n    }\n}\n\nexport interface ForNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.For;\n    isAsync?: boolean;\n    targetExpression: ExpressionNode;\n    iterableExpression: ExpressionNode;\n    forSuite: SuiteNode;\n    elseSuite?: SuiteNode;\n}\n\nexport namespace ForNode {\n    export function create(\n        forToken: Token,\n        targetExpression: ExpressionNode,\n        iterableExpression: ExpressionNode,\n        forSuite: SuiteNode\n    ) {\n        const node: ForNode = {\n            start: forToken.start,\n            length: forToken.length,\n            nodeType: ParseNodeType.For,\n            id: _nextNodeId++,\n            targetExpression,\n            iterableExpression,\n            forSuite,\n        };\n\n        targetExpression.parent = node;\n        iterableExpression.parent = node;\n        forSuite.parent = node;\n\n        extendRange(node, forSuite);\n\n        return node;\n    }\n}\n\nexport type ListComprehensionIterNode = ListComprehensionForNode | ListComprehensionIfNode;\n\nexport interface ListComprehensionForNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.ListComprehensionFor;\n    isAsync?: boolean;\n    targetExpression: ExpressionNode;\n    iterableExpression: ExpressionNode;\n}\n\nexport namespace ListComprehensionForNode {\n    export function create(startToken: Token, targetExpression: ExpressionNode, iterableExpression: ExpressionNode) {\n        const node: ListComprehensionForNode = {\n            start: startToken.start,\n            length: startToken.length,\n            nodeType: ParseNodeType.ListComprehensionFor,\n            id: _nextNodeId++,\n            targetExpression,\n            iterableExpression,\n        };\n\n        targetExpression.parent = node;\n        iterableExpression.parent = node;\n\n        extendRange(node, targetExpression);\n        extendRange(node, iterableExpression);\n\n        return node;\n    }\n}\n\nexport interface ListComprehensionIfNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.ListComprehensionIf;\n    testExpression: ExpressionNode;\n}\n\nexport namespace ListComprehensionIfNode {\n    export function create(ifToken: Token, testExpression: ExpressionNode) {\n        const node: ListComprehensionIfNode = {\n            start: ifToken.start,\n            length: ifToken.length,\n            nodeType: ParseNodeType.ListComprehensionIf,\n            id: _nextNodeId++,\n            testExpression,\n        };\n\n        testExpression.parent = node;\n\n        extendRange(node, testExpression);\n\n        return node;\n    }\n}\n\nexport interface TryNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.Try;\n    trySuite: SuiteNode;\n    exceptClauses: ExceptNode[];\n    elseSuite?: SuiteNode;\n    finallySuite?: SuiteNode;\n}\n\nexport namespace TryNode {\n    export function create(tryToken: Token, trySuite: SuiteNode) {\n        const node: TryNode = {\n            start: tryToken.start,\n            length: tryToken.length,\n            nodeType: ParseNodeType.Try,\n            id: _nextNodeId++,\n            trySuite,\n            exceptClauses: [],\n        };\n\n        trySuite.parent = node;\n\n        extendRange(node, trySuite);\n\n        return node;\n    }\n}\n\nexport interface ExceptNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.Except;\n    typeExpression?: ExpressionNode;\n    name?: NameNode;\n    exceptSuite: SuiteNode;\n}\n\nexport namespace ExceptNode {\n    export function create(exceptToken: Token, exceptSuite: SuiteNode) {\n        const node: ExceptNode = {\n            start: exceptToken.start,\n            length: exceptToken.length,\n            nodeType: ParseNodeType.Except,\n            id: _nextNodeId++,\n            exceptSuite,\n        };\n\n        exceptSuite.parent = node;\n\n        extendRange(node, exceptSuite);\n\n        return node;\n    }\n}\n\nexport interface FunctionNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.Function;\n    decorators: DecoratorNode[];\n    isAsync?: boolean;\n    name: NameNode;\n    parameters: ParameterNode[];\n    returnTypeAnnotation?: ExpressionNode;\n    functionAnnotationComment?: FunctionAnnotationNode;\n    suite: SuiteNode;\n}\n\nexport namespace FunctionNode {\n    export function create(defToken: Token, name: NameNode, suite: SuiteNode) {\n        const node: FunctionNode = {\n            start: defToken.start,\n            length: defToken.length,\n            nodeType: ParseNodeType.Function,\n            id: _nextNodeId++,\n            decorators: [],\n            name,\n            parameters: [],\n            suite,\n        };\n\n        name.parent = node;\n        suite.parent = node;\n\n        extendRange(node, suite);\n\n        return node;\n    }\n}\n\nexport const enum ParameterCategory {\n    Simple,\n    VarArgList,\n    VarArgDictionary,\n}\n\nexport interface ParameterNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.Parameter;\n    category: ParameterCategory;\n    name?: NameNode;\n    typeAnnotation?: ExpressionNode;\n    typeAnnotationComment?: ExpressionNode;\n    defaultValue?: ExpressionNode;\n}\n\nexport namespace ParameterNode {\n    export function create(startToken: Token, paramCategory: ParameterCategory) {\n        const node: ParameterNode = {\n            start: startToken.start,\n            length: startToken.length,\n            nodeType: ParseNodeType.Parameter,\n            id: _nextNodeId++,\n            category: paramCategory,\n        };\n\n        return node;\n    }\n}\n\nexport interface ClassNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.Class;\n    decorators: DecoratorNode[];\n    name: NameNode;\n    arguments: ArgumentNode[];\n    suite: SuiteNode;\n}\n\nexport namespace ClassNode {\n    export function create(classToken: Token, name: NameNode, suite: SuiteNode) {\n        const node: ClassNode = {\n            start: classToken.start,\n            length: classToken.length,\n            nodeType: ParseNodeType.Class,\n            id: _nextNodeId++,\n            decorators: [],\n            name,\n            arguments: [],\n            suite,\n        };\n\n        name.parent = node;\n        suite.parent = node;\n\n        extendRange(node, suite);\n\n        return node;\n    }\n\n    // This variant is used to create a dummy class\n    // when the parser encounters decorators with no\n    // function or class declaration.\n    export function createDummyForDecorators(decorators: DecoratorNode[]) {\n        const node: ClassNode = {\n            start: 0,\n            length: 0,\n            nodeType: ParseNodeType.Class,\n            id: _nextNodeId++,\n            decorators,\n            name: {\n                start: 0,\n                length: 0,\n                id: 0,\n                nodeType: ParseNodeType.Name,\n                token: {\n                    type: TokenType.Identifier,\n                    start: 0,\n                    length: 0,\n                    comments: [],\n                    value: '',\n                },\n                value: '',\n            },\n            arguments: [],\n            suite: {\n                start: 0,\n                length: 0,\n                id: 0,\n                nodeType: ParseNodeType.Suite,\n                statements: [],\n            },\n        };\n\n        decorators.forEach((decorator) => {\n            decorator.parent = node;\n            extendRange(node, decorator);\n        });\n\n        node.name.parent = node;\n        node.suite.parent = node;\n\n        return node;\n    }\n}\n\nexport interface WithNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.With;\n    isAsync?: boolean;\n    withItems: WithItemNode[];\n    suite: SuiteNode;\n}\n\nexport namespace WithNode {\n    export function create(withToken: Token, suite: SuiteNode) {\n        const node: WithNode = {\n            start: withToken.start,\n            length: withToken.length,\n            nodeType: ParseNodeType.With,\n            id: _nextNodeId++,\n            withItems: [],\n            suite,\n        };\n\n        suite.parent = node;\n\n        extendRange(node, suite);\n\n        return node;\n    }\n}\n\nexport interface WithItemNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.WithItem;\n    expression: ExpressionNode;\n    target?: ExpressionNode;\n}\n\nexport namespace WithItemNode {\n    export function create(expression: ExpressionNode) {\n        const node: WithItemNode = {\n            start: expression.start,\n            length: expression.length,\n            nodeType: ParseNodeType.WithItem,\n            id: _nextNodeId++,\n            expression,\n        };\n\n        expression.parent = node;\n\n        return node;\n    }\n}\n\nexport interface DecoratorNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.Decorator;\n    leftExpression: ExpressionNode;\n    arguments: ArgumentNode[] | undefined;\n}\n\nexport namespace DecoratorNode {\n    export function create(atToken: Token, leftExpression: ExpressionNode) {\n        const node: DecoratorNode = {\n            start: atToken.start,\n            length: atToken.length,\n            nodeType: ParseNodeType.Decorator,\n            id: _nextNodeId++,\n            leftExpression,\n            arguments: undefined,\n        };\n\n        leftExpression.parent = node;\n\n        extendRange(node, leftExpression);\n\n        return node;\n    }\n}\n\nexport interface StatementListNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.StatementList;\n    statements: ParseNode[];\n}\n\nexport namespace StatementListNode {\n    export function create(atToken: Token) {\n        const node: StatementListNode = {\n            start: atToken.start,\n            length: atToken.length,\n            nodeType: ParseNodeType.StatementList,\n            id: _nextNodeId++,\n            statements: [],\n        };\n\n        return node;\n    }\n}\n\nexport type StatementNode =\n    | IfNode\n    | WhileNode\n    | ForNode\n    | TryNode\n    | FunctionNode\n    | ClassNode\n    | WithNode\n    | StatementListNode\n    | ErrorNode;\n\nexport type SmallStatementNode =\n    | ExpressionNode\n    | DelNode\n    | PassNode\n    | ImportNode\n    | GlobalNode\n    | NonlocalNode\n    | AssertNode;\n\nexport type ExpressionNode =\n    | ErrorNode\n    | UnaryOperationNode\n    | BinaryOperationNode\n    | AssignmentNode\n    | TypeAnnotationNode\n    | AssignmentExpressionNode\n    | AugmentedAssignmentNode\n    | AwaitNode\n    | TernaryNode\n    | UnpackNode\n    | TupleNode\n    | CallNode\n    | ListComprehensionNode\n    | IndexNode\n    | SliceNode\n    | YieldNode\n    | YieldFromNode\n    | MemberAccessNode\n    | LambdaNode\n    | NameNode\n    | ConstantNode\n    | EllipsisNode\n    | NumberNode\n    | StringNode\n    | FormatStringNode\n    | StringListNode\n    | DictionaryNode\n    | DictionaryExpandEntryNode\n    | ListNode\n    | SetNode\n    | DecoratorNode\n    | FunctionAnnotationNode;\n\nexport function isExpressionNode(node: ParseNode): node is ExpressionNode {\n    switch (node.nodeType) {\n        case ParseNodeType.Error:\n        case ParseNodeType.UnaryOperation:\n        case ParseNodeType.BinaryOperation:\n        case ParseNodeType.AssignmentExpression:\n        case ParseNodeType.TypeAnnotation:\n        case ParseNodeType.Await:\n        case ParseNodeType.Ternary:\n        case ParseNodeType.Unpack:\n        case ParseNodeType.Tuple:\n        case ParseNodeType.Call:\n        case ParseNodeType.ListComprehension:\n        case ParseNodeType.Index:\n        case ParseNodeType.Slice:\n        case ParseNodeType.Yield:\n        case ParseNodeType.YieldFrom:\n        case ParseNodeType.MemberAccess:\n        case ParseNodeType.Lambda:\n        case ParseNodeType.Name:\n        case ParseNodeType.Constant:\n        case ParseNodeType.Ellipsis:\n        case ParseNodeType.Number:\n        case ParseNodeType.String:\n        case ParseNodeType.FormatString:\n        case ParseNodeType.StringList:\n        case ParseNodeType.Dictionary:\n        case ParseNodeType.DictionaryExpandEntry:\n        case ParseNodeType.List:\n        case ParseNodeType.Set:\n            return true;\n\n        default:\n            return false;\n    }\n}\n\nexport interface ErrorNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.Error;\n    readonly category: ErrorExpressionCategory;\n    readonly child?: ExpressionNode;\n}\n\nexport namespace ErrorNode {\n    export function create(initialRange: TextRange, category: ErrorExpressionCategory, child?: ExpressionNode) {\n        const node: ErrorNode = {\n            start: initialRange.start,\n            length: initialRange.length,\n            nodeType: ParseNodeType.Error,\n            id: _nextNodeId++,\n            category,\n            child,\n        };\n\n        if (child) {\n            child.parent = node;\n            extendRange(node, child);\n        }\n\n        return node;\n    }\n}\n\nexport interface UnaryOperationNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.UnaryOperation;\n    expression: ExpressionNode;\n    operatorToken: Token;\n    operator: OperatorType;\n}\n\nexport namespace UnaryOperationNode {\n    export function create(operatorToken: Token, expression: ExpressionNode, operator: OperatorType) {\n        const node: UnaryOperationNode = {\n            start: operatorToken.start,\n            length: operatorToken.length,\n            nodeType: ParseNodeType.UnaryOperation,\n            id: _nextNodeId++,\n            operator,\n            operatorToken,\n            expression,\n        };\n\n        expression.parent = node;\n\n        extendRange(node, expression);\n\n        return node;\n    }\n}\n\nexport interface BinaryOperationNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.BinaryOperation;\n    leftExpression: ExpressionNode;\n    operatorToken: Token;\n    operator: OperatorType;\n    rightExpression: ExpressionNode;\n    parenthesized?: boolean;\n}\n\nexport namespace BinaryOperationNode {\n    export function create(\n        leftExpression: ExpressionNode,\n        rightExpression: ExpressionNode,\n        operatorToken: Token,\n        operator: OperatorType\n    ) {\n        const node: BinaryOperationNode = {\n            start: leftExpression.start,\n            length: leftExpression.length,\n            nodeType: ParseNodeType.BinaryOperation,\n            id: _nextNodeId++,\n            leftExpression,\n            operatorToken,\n            operator,\n            rightExpression,\n        };\n\n        leftExpression.parent = node;\n        rightExpression.parent = node;\n\n        extendRange(node, rightExpression);\n\n        return node;\n    }\n}\n\nexport interface AssignmentExpressionNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.AssignmentExpression;\n    name: NameNode;\n    rightExpression: ExpressionNode;\n}\n\nexport namespace AssignmentExpressionNode {\n    export function create(name: NameNode, rightExpression: ExpressionNode) {\n        const node: AssignmentExpressionNode = {\n            start: name.start,\n            length: name.length,\n            nodeType: ParseNodeType.AssignmentExpression,\n            id: _nextNodeId++,\n            name,\n            rightExpression,\n        };\n\n        name.parent = node;\n        rightExpression.parent = node;\n\n        extendRange(node, rightExpression);\n\n        return node;\n    }\n}\n\nexport interface AssignmentNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.Assignment;\n    leftExpression: ExpressionNode;\n    rightExpression: ExpressionNode;\n    typeAnnotationComment?: ExpressionNode;\n}\n\nexport namespace AssignmentNode {\n    export function create(leftExpression: ExpressionNode, rightExpression: ExpressionNode) {\n        const node: AssignmentNode = {\n            start: leftExpression.start,\n            length: leftExpression.length,\n            nodeType: ParseNodeType.Assignment,\n            id: _nextNodeId++,\n            leftExpression,\n            rightExpression,\n        };\n\n        leftExpression.parent = node;\n        rightExpression.parent = node;\n\n        extendRange(node, rightExpression);\n\n        return node;\n    }\n}\n\nexport interface TypeAnnotationNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.TypeAnnotation;\n    valueExpression: ExpressionNode;\n    typeAnnotation: ExpressionNode;\n}\n\nexport namespace TypeAnnotationNode {\n    export function create(valueExpression: ExpressionNode, typeAnnotation: ExpressionNode) {\n        const node: TypeAnnotationNode = {\n            start: valueExpression.start,\n            length: valueExpression.length,\n            nodeType: ParseNodeType.TypeAnnotation,\n            id: _nextNodeId++,\n            valueExpression,\n            typeAnnotation,\n        };\n\n        valueExpression.parent = node;\n        typeAnnotation.parent = node;\n\n        extendRange(node, typeAnnotation);\n\n        return node;\n    }\n}\n\nexport interface FunctionAnnotationNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.FunctionAnnotation;\n    isParamListEllipsis: boolean;\n    paramTypeAnnotations: ExpressionNode[];\n    returnTypeAnnotation: ExpressionNode;\n}\n\nexport namespace FunctionAnnotationNode {\n    export function create(\n        openParenToken: Token,\n        isParamListEllipsis: boolean,\n        paramTypeAnnotations: ExpressionNode[],\n        returnTypeAnnotation: ExpressionNode\n    ) {\n        const node: FunctionAnnotationNode = {\n            start: openParenToken.start,\n            length: openParenToken.length,\n            nodeType: ParseNodeType.FunctionAnnotation,\n            id: _nextNodeId++,\n            isParamListEllipsis,\n            paramTypeAnnotations,\n            returnTypeAnnotation,\n        };\n\n        paramTypeAnnotations.forEach((p) => {\n            p.parent = node;\n        });\n        returnTypeAnnotation.parent = node;\n\n        extendRange(node, returnTypeAnnotation);\n\n        return node;\n    }\n}\n\nexport interface AugmentedAssignmentNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.AugmentedAssignment;\n    leftExpression: ExpressionNode;\n    operator: OperatorType;\n    rightExpression: ExpressionNode;\n\n    // The destExpression is a copy of the leftExpression\n    // node. We use it as a place to hang the result type,\n    // as opposed to the source type.\n    destExpression: ExpressionNode;\n}\n\nexport namespace AugmentedAssignmentNode {\n    export function create(\n        leftExpression: ExpressionNode,\n        rightExpression: ExpressionNode,\n        operator: OperatorType,\n        destExpression: ExpressionNode\n    ) {\n        const node: AugmentedAssignmentNode = {\n            start: leftExpression.start,\n            length: leftExpression.length,\n            nodeType: ParseNodeType.AugmentedAssignment,\n            id: _nextNodeId++,\n            leftExpression,\n            operator,\n            rightExpression,\n            destExpression,\n        };\n\n        leftExpression.parent = node;\n        rightExpression.parent = node;\n        destExpression.parent = node;\n\n        extendRange(node, rightExpression);\n\n        return node;\n    }\n}\n\nexport interface AwaitNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.Await;\n    expression: ExpressionNode;\n}\n\nexport namespace AwaitNode {\n    export function create(awaitToken: Token, expression: ExpressionNode) {\n        const node: AwaitNode = {\n            start: awaitToken.start,\n            length: awaitToken.length,\n            nodeType: ParseNodeType.Await,\n            id: _nextNodeId++,\n            expression,\n        };\n\n        expression.parent = node;\n\n        extendRange(node, expression);\n\n        return node;\n    }\n}\n\nexport interface TernaryNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.Ternary;\n    ifExpression: ExpressionNode;\n    testExpression: ExpressionNode;\n    elseExpression: ExpressionNode;\n}\n\nexport namespace TernaryNode {\n    export function create(\n        ifExpression: ExpressionNode,\n        testExpression: ExpressionNode,\n        elseExpression: ExpressionNode\n    ) {\n        const node: TernaryNode = {\n            start: ifExpression.start,\n            length: ifExpression.length,\n            nodeType: ParseNodeType.Ternary,\n            id: _nextNodeId++,\n            ifExpression,\n            testExpression,\n            elseExpression,\n        };\n\n        ifExpression.parent = node;\n        testExpression.parent = node;\n        elseExpression.parent = node;\n\n        extendRange(node, elseExpression);\n\n        return node;\n    }\n}\n\nexport interface UnpackNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.Unpack;\n    expression: ExpressionNode;\n}\n\nexport namespace UnpackNode {\n    export function create(starToken: Token, expression: ExpressionNode) {\n        const node: UnpackNode = {\n            start: starToken.start,\n            length: starToken.length,\n            nodeType: ParseNodeType.Unpack,\n            id: _nextNodeId++,\n            expression,\n        };\n\n        expression.parent = node;\n\n        extendRange(node, expression);\n\n        return node;\n    }\n}\n\nexport interface TupleNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.Tuple;\n    expressions: ExpressionNode[];\n    enclosedInParens: boolean;\n}\n\nexport namespace TupleNode {\n    export function create(range: TextRange, enclosedInParens: boolean) {\n        const node: TupleNode = {\n            start: range.start,\n            length: range.length,\n            nodeType: ParseNodeType.Tuple,\n            id: _nextNodeId++,\n            expressions: [],\n            enclosedInParens,\n        };\n\n        return node;\n    }\n}\n\nexport interface CallNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.Call;\n    leftExpression: ExpressionNode;\n    arguments: ArgumentNode[];\n}\n\nexport namespace CallNode {\n    export function create(leftExpression: ExpressionNode) {\n        const node: CallNode = {\n            start: leftExpression.start,\n            length: leftExpression.length,\n            nodeType: ParseNodeType.Call,\n            id: _nextNodeId++,\n            leftExpression,\n            arguments: [],\n        };\n\n        leftExpression.parent = node;\n\n        return node;\n    }\n}\n\nexport interface ListComprehensionNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.ListComprehension;\n    expression: ParseNode;\n    comprehensions: ListComprehensionIterNode[];\n}\n\nexport namespace ListComprehensionNode {\n    export function create(expression: ParseNode) {\n        const node: ListComprehensionNode = {\n            start: expression.start,\n            length: expression.length,\n            nodeType: ParseNodeType.ListComprehension,\n            id: _nextNodeId++,\n            expression,\n            comprehensions: [],\n        };\n\n        expression.parent = node;\n\n        return node;\n    }\n}\n\nexport interface IndexItemsNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.IndexItems;\n    items: ExpressionNode[];\n}\n\nexport namespace IndexItemsNode {\n    export function create(openBracketToken: Token, closeBracketToken: Token, items: ExpressionNode[]) {\n        const node: IndexItemsNode = {\n            start: openBracketToken.start,\n            length: openBracketToken.length,\n            nodeType: ParseNodeType.IndexItems,\n            id: _nextNodeId++,\n            items,\n        };\n\n        items.forEach((item) => {\n            item.parent = node;\n        });\n\n        extendRange(node, closeBracketToken);\n\n        return node;\n    }\n}\n\nexport interface IndexNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.Index;\n    baseExpression: ExpressionNode;\n    items: IndexItemsNode;\n}\n\nexport namespace IndexNode {\n    export function create(baseExpression: ExpressionNode, items: IndexItemsNode) {\n        const node: IndexNode = {\n            start: baseExpression.start,\n            length: baseExpression.length,\n            nodeType: ParseNodeType.Index,\n            id: _nextNodeId++,\n            baseExpression,\n            items,\n        };\n\n        baseExpression.parent = node;\n        items.parent = node;\n\n        extendRange(node, items);\n\n        return node;\n    }\n}\n\nexport interface SliceNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.Slice;\n    startValue?: ExpressionNode;\n    endValue?: ExpressionNode;\n    stepValue?: ExpressionNode;\n}\n\nexport namespace SliceNode {\n    export function create(range: TextRange) {\n        const node: SliceNode = {\n            start: range.start,\n            length: range.length,\n            nodeType: ParseNodeType.Slice,\n            id: _nextNodeId++,\n        };\n\n        return node;\n    }\n}\n\nexport interface YieldNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.Yield;\n    expression?: ExpressionNode;\n}\n\nexport namespace YieldNode {\n    export function create(yieldToken: Token, expression?: ExpressionNode) {\n        const node: YieldNode = {\n            start: yieldToken.start,\n            length: yieldToken.length,\n            nodeType: ParseNodeType.Yield,\n            id: _nextNodeId++,\n            expression,\n        };\n\n        if (expression) {\n            expression.parent = node;\n            extendRange(node, expression);\n        }\n\n        return node;\n    }\n}\n\nexport interface YieldFromNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.YieldFrom;\n    expression: ExpressionNode;\n}\n\nexport namespace YieldFromNode {\n    export function create(yieldToken: Token, expression: ExpressionNode) {\n        const node: YieldFromNode = {\n            start: yieldToken.start,\n            length: yieldToken.length,\n            nodeType: ParseNodeType.YieldFrom,\n            id: _nextNodeId++,\n            expression,\n        };\n\n        expression.parent = node;\n\n        extendRange(node, expression);\n\n        return node;\n    }\n}\n\nexport interface MemberAccessNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.MemberAccess;\n    leftExpression: ExpressionNode;\n    memberName: NameNode;\n}\n\nexport namespace MemberAccessNode {\n    export function create(leftExpression: ExpressionNode, memberName: NameNode) {\n        const node: MemberAccessNode = {\n            start: leftExpression.start,\n            length: leftExpression.length,\n            nodeType: ParseNodeType.MemberAccess,\n            id: _nextNodeId++,\n            leftExpression,\n            memberName,\n        };\n\n        leftExpression.parent = node;\n        memberName.parent = node;\n\n        extendRange(node, memberName);\n\n        return node;\n    }\n}\n\nexport interface LambdaNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.Lambda;\n    parameters: ParameterNode[];\n    expression: ExpressionNode;\n}\n\nexport namespace LambdaNode {\n    export function create(lambdaToken: Token, expression: ExpressionNode) {\n        const node: LambdaNode = {\n            start: lambdaToken.start,\n            length: lambdaToken.length,\n            nodeType: ParseNodeType.Lambda,\n            id: _nextNodeId++,\n            parameters: [],\n            expression,\n        };\n\n        expression.parent = node;\n\n        extendRange(node, expression);\n\n        return node;\n    }\n}\n\nexport interface NameNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.Name;\n    token: IdentifierToken;\n    value: string;\n}\n\nexport namespace NameNode {\n    export function create(nameToken: IdentifierToken) {\n        const node: NameNode = {\n            start: nameToken.start,\n            length: nameToken.length,\n            nodeType: ParseNodeType.Name,\n            id: _nextNodeId++,\n            token: nameToken,\n            value: nameToken.value,\n        };\n\n        return node;\n    }\n}\n\nexport interface ConstantNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.Constant;\n    constType: KeywordType;\n}\n\nexport namespace ConstantNode {\n    export function create(token: KeywordToken) {\n        const node: ConstantNode = {\n            start: token.start,\n            length: token.length,\n            nodeType: ParseNodeType.Constant,\n            id: _nextNodeId++,\n            constType: token.keywordType,\n        };\n\n        return node;\n    }\n}\n\nexport interface EllipsisNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.Ellipsis;\n}\n\nexport namespace EllipsisNode {\n    export function create(range: TextRange) {\n        const node: EllipsisNode = {\n            start: range.start,\n            length: range.length,\n            nodeType: ParseNodeType.Ellipsis,\n            id: _nextNodeId++,\n        };\n\n        return node;\n    }\n}\n\nexport interface NumberNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.Number;\n    value: number;\n    isInteger: boolean;\n    isImaginary: boolean;\n}\n\nexport namespace NumberNode {\n    export function create(token: NumberToken) {\n        const node: NumberNode = {\n            start: token.start,\n            length: token.length,\n            nodeType: ParseNodeType.Number,\n            id: _nextNodeId++,\n            value: token.value,\n            isInteger: token.isInteger,\n            isImaginary: token.isImaginary,\n        };\n\n        return node;\n    }\n}\n\nexport interface StringNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.String;\n    token: StringToken;\n    value: string;\n    hasUnescapeErrors: boolean;\n}\n\nexport namespace StringNode {\n    export function create(token: StringToken, unescapedValue: string, hasUnescapeErrors: boolean) {\n        const node: StringNode = {\n            start: token.start,\n            length: token.length,\n            nodeType: ParseNodeType.String,\n            id: _nextNodeId++,\n            token,\n            value: unescapedValue,\n            hasUnescapeErrors,\n        };\n\n        return node;\n    }\n}\n\nexport interface FormatStringNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.FormatString;\n    token: StringToken;\n    value: string;\n    hasUnescapeErrors: boolean;\n    expressions: ExpressionNode[];\n}\n\nexport namespace FormatStringNode {\n    export function create(\n        token: StringToken,\n        unescapedValue: string,\n        hasUnescapeErrors: boolean,\n        expressions: ExpressionNode[]\n    ) {\n        const node: FormatStringNode = {\n            start: token.start,\n            length: token.length,\n            nodeType: ParseNodeType.FormatString,\n            id: _nextNodeId++,\n            token,\n            value: unescapedValue,\n            hasUnescapeErrors,\n            expressions,\n        };\n\n        expressions.forEach((expr) => {\n            expr.parent = node;\n        });\n\n        return node;\n    }\n}\n\nexport interface StringListNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.StringList;\n    strings: (StringNode | FormatStringNode)[];\n\n    // If strings are found within the context of\n    // a type annotation, they are further parsed\n    // into an expression.\n    typeAnnotation?: ExpressionNode;\n}\n\nexport namespace StringListNode {\n    export function create(strings: (StringNode | FormatStringNode)[]) {\n        const node: StringListNode = {\n            start: strings[0].start,\n            length: strings[0].length,\n            nodeType: ParseNodeType.StringList,\n            id: _nextNodeId++,\n            strings,\n        };\n\n        if (strings.length > 0) {\n            strings.forEach((str) => {\n                str.parent = node;\n            });\n            extendRange(node, strings[strings.length - 1]);\n        }\n\n        return node;\n    }\n}\n\nexport interface DictionaryNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.Dictionary;\n    entries: DictionaryEntryNode[];\n}\n\nexport namespace DictionaryNode {\n    export function create(range: TextRange) {\n        const node: DictionaryNode = {\n            start: range.start,\n            length: range.length,\n            nodeType: ParseNodeType.Dictionary,\n            id: _nextNodeId++,\n            entries: [],\n        };\n\n        return node;\n    }\n}\n\nexport interface DictionaryKeyEntryNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.DictionaryKeyEntry;\n    keyExpression: ExpressionNode;\n    valueExpression: ExpressionNode;\n}\n\nexport namespace DictionaryKeyEntryNode {\n    export function create(keyExpression: ExpressionNode, valueExpression: ExpressionNode) {\n        const node: DictionaryKeyEntryNode = {\n            start: keyExpression.start,\n            length: keyExpression.length,\n            nodeType: ParseNodeType.DictionaryKeyEntry,\n            id: _nextNodeId++,\n            keyExpression,\n            valueExpression,\n        };\n\n        keyExpression.parent = node;\n        valueExpression.parent = node;\n\n        extendRange(node, valueExpression);\n\n        return node;\n    }\n}\n\nexport interface DictionaryExpandEntryNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.DictionaryExpandEntry;\n    expandExpression: ExpressionNode;\n}\n\nexport namespace DictionaryExpandEntryNode {\n    export function create(expandExpression: ExpressionNode) {\n        const node: DictionaryExpandEntryNode = {\n            start: expandExpression.start,\n            length: expandExpression.length,\n            nodeType: ParseNodeType.DictionaryExpandEntry,\n            id: _nextNodeId++,\n            expandExpression,\n        };\n\n        expandExpression.parent = node;\n\n        return node;\n    }\n}\n\nexport type DictionaryEntryNode = DictionaryKeyEntryNode | DictionaryExpandEntryNode | ListComprehensionNode;\n\nexport interface SetNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.Set;\n    entries: ExpressionNode[];\n}\n\nexport namespace SetNode {\n    export function create(range: TextRange) {\n        const node: SetNode = {\n            start: range.start,\n            length: range.length,\n            nodeType: ParseNodeType.Set,\n            id: _nextNodeId++,\n            entries: [],\n        };\n\n        return node;\n    }\n}\n\nexport interface ListNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.List;\n    entries: ExpressionNode[];\n}\n\nexport namespace ListNode {\n    export function create(range: TextRange) {\n        const node: ListNode = {\n            start: range.start,\n            length: range.length,\n            nodeType: ParseNodeType.List,\n            id: _nextNodeId++,\n            entries: [],\n        };\n\n        return node;\n    }\n}\n\nexport const enum ArgumentCategory {\n    Simple,\n    UnpackedList,\n    UnpackedDictionary,\n}\n\nexport interface ArgumentNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.Argument;\n    argumentCategory: ArgumentCategory;\n    name?: NameNode;\n    valueExpression: ExpressionNode;\n}\n\nexport namespace ArgumentNode {\n    export function create(startToken: Token, valueExpression: ExpressionNode, argCategory: ArgumentCategory) {\n        const node: ArgumentNode = {\n            start: startToken.start,\n            length: startToken.length,\n            nodeType: ParseNodeType.Argument,\n            id: _nextNodeId++,\n            valueExpression,\n            argumentCategory: argCategory,\n        };\n\n        valueExpression.parent = node;\n\n        extendRange(node, valueExpression);\n\n        return node;\n    }\n}\n\nexport interface DelNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.Del;\n    expressions: ExpressionNode[];\n}\n\nexport namespace DelNode {\n    export function create(delToken: Token) {\n        const node: DelNode = {\n            start: delToken.start,\n            length: delToken.length,\n            nodeType: ParseNodeType.Del,\n            id: _nextNodeId++,\n            expressions: [],\n        };\n\n        return node;\n    }\n}\n\nexport interface PassNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.Pass;\n}\n\nexport namespace PassNode {\n    export function create(passToken: TextRange) {\n        const node: PassNode = {\n            start: passToken.start,\n            length: passToken.length,\n            nodeType: ParseNodeType.Pass,\n            id: _nextNodeId++,\n        };\n\n        return node;\n    }\n}\n\nexport interface ImportNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.Import;\n    list: ImportAsNode[];\n}\n\nexport namespace ImportNode {\n    export function create(passToken: TextRange) {\n        const node: ImportNode = {\n            start: passToken.start,\n            length: passToken.length,\n            nodeType: ParseNodeType.Import,\n            id: _nextNodeId++,\n            list: [],\n        };\n\n        return node;\n    }\n}\n\nexport interface ModuleNameNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.ModuleName;\n    leadingDots: number;\n    nameParts: NameNode[];\n\n    // This is an error condition used only for type completion.\n    hasTrailingDot?: boolean;\n}\n\nexport namespace ModuleNameNode {\n    export function create(range: TextRange) {\n        const node: ModuleNameNode = {\n            start: range.start,\n            length: range.length,\n            nodeType: ParseNodeType.ModuleName,\n            id: _nextNodeId++,\n            leadingDots: 0,\n            nameParts: [],\n        };\n\n        return node;\n    }\n}\n\nexport interface ImportAsNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.ImportAs;\n    module: ModuleNameNode;\n    alias?: NameNode;\n}\n\nexport namespace ImportAsNode {\n    export function create(module: ModuleNameNode) {\n        const node: ImportAsNode = {\n            start: module.start,\n            length: module.length,\n            nodeType: ParseNodeType.ImportAs,\n            id: _nextNodeId++,\n            module,\n        };\n\n        module.parent = node;\n\n        return node;\n    }\n}\n\nexport interface ImportFromNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.ImportFrom;\n    module: ModuleNameNode;\n    imports: ImportFromAsNode[];\n    isWildcardImport: boolean;\n    usesParens: boolean;\n    wildcardToken?: Token;\n    missingImportKeyword?: boolean;\n}\n\nexport namespace ImportFromNode {\n    export function create(fromToken: Token, module: ModuleNameNode) {\n        const node: ImportFromNode = {\n            start: fromToken.start,\n            length: fromToken.length,\n            nodeType: ParseNodeType.ImportFrom,\n            id: _nextNodeId++,\n            module,\n            imports: [],\n            isWildcardImport: false,\n            usesParens: false,\n        };\n\n        module.parent = node;\n\n        extendRange(node, module);\n\n        return node;\n    }\n}\n\nexport interface ImportFromAsNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.ImportFromAs;\n    name: NameNode;\n    alias?: NameNode;\n}\n\nexport namespace ImportFromAsNode {\n    export function create(name: NameNode) {\n        const node: ImportFromAsNode = {\n            start: name.start,\n            length: name.length,\n            nodeType: ParseNodeType.ImportFromAs,\n            id: _nextNodeId++,\n            name,\n        };\n\n        name.parent = node;\n\n        return node;\n    }\n}\n\nexport interface GlobalNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.Global;\n    nameList: NameNode[];\n}\n\nexport namespace GlobalNode {\n    export function create(range: TextRange) {\n        const node: GlobalNode = {\n            start: range.start,\n            length: range.length,\n            nodeType: ParseNodeType.Global,\n            id: _nextNodeId++,\n            nameList: [],\n        };\n\n        return node;\n    }\n}\n\nexport interface NonlocalNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.Nonlocal;\n    nameList: NameNode[];\n}\n\nexport namespace NonlocalNode {\n    export function create(range: TextRange) {\n        const node: NonlocalNode = {\n            start: range.start,\n            length: range.length,\n            nodeType: ParseNodeType.Nonlocal,\n            id: _nextNodeId++,\n            nameList: [],\n        };\n\n        return node;\n    }\n}\n\nexport interface AssertNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.Assert;\n    testExpression: ExpressionNode;\n    exceptionExpression?: ExpressionNode;\n}\n\nexport namespace AssertNode {\n    export function create(assertToken: Token, testExpression: ExpressionNode) {\n        const node: AssertNode = {\n            start: assertToken.start,\n            length: assertToken.length,\n            nodeType: ParseNodeType.Assert,\n            id: _nextNodeId++,\n            testExpression,\n        };\n\n        testExpression.parent = node;\n\n        extendRange(node, testExpression);\n\n        return node;\n    }\n}\n\nexport interface BreakNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.Break;\n}\n\nexport namespace BreakNode {\n    export function create(range: TextRange) {\n        const node: BreakNode = {\n            start: range.start,\n            length: range.length,\n            nodeType: ParseNodeType.Break,\n            id: _nextNodeId++,\n        };\n\n        return node;\n    }\n}\n\nexport interface ContinueNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.Continue;\n}\n\nexport namespace ContinueNode {\n    export function create(range: TextRange) {\n        const node: ContinueNode = {\n            start: range.start,\n            length: range.length,\n            nodeType: ParseNodeType.Continue,\n            id: _nextNodeId++,\n        };\n\n        return node;\n    }\n}\n\nexport interface ReturnNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.Return;\n    returnExpression?: ExpressionNode;\n}\n\nexport namespace ReturnNode {\n    export function create(range: TextRange) {\n        const node: ReturnNode = {\n            start: range.start,\n            length: range.length,\n            nodeType: ParseNodeType.Return,\n            id: _nextNodeId++,\n        };\n\n        return node;\n    }\n}\n\nexport interface RaiseNode extends ParseNodeBase {\n    readonly nodeType: ParseNodeType.Raise;\n    typeExpression?: ExpressionNode;\n    valueExpression?: ExpressionNode;\n    tracebackExpression?: ExpressionNode;\n}\n\nexport namespace RaiseNode {\n    export function create(range: TextRange) {\n        const node: RaiseNode = {\n            start: range.start,\n            length: range.length,\n            nodeType: ParseNodeType.Raise,\n            id: _nextNodeId++,\n        };\n\n        return node;\n    }\n}\n\nexport type ParseNode =\n    | ErrorNode\n    | ArgumentNode\n    | AssertNode\n    | AssignmentExpressionNode\n    | AssignmentNode\n    | AugmentedAssignmentNode\n    | AwaitNode\n    | BinaryOperationNode\n    | BreakNode\n    | CallNode\n    | ClassNode\n    | ConstantNode\n    | ContinueNode\n    | DecoratorNode\n    | DelNode\n    | DictionaryNode\n    | DictionaryEntryNode\n    | DictionaryExpandEntryNode\n    | DictionaryKeyEntryNode\n    | EllipsisNode\n    | IfNode\n    | ImportNode\n    | ImportAsNode\n    | ImportFromNode\n    | ImportFromAsNode\n    | IndexNode\n    | IndexItemsNode\n    | ExceptNode\n    | ForNode\n    | FormatStringNode\n    | FunctionNode\n    | FunctionAnnotationNode\n    | GlobalNode\n    | LambdaNode\n    | ListNode\n    | ListComprehensionNode\n    | ListComprehensionForNode\n    | ListComprehensionIfNode\n    | MemberAccessNode\n    | ModuleNameNode\n    | ModuleNode\n    | NameNode\n    | NonlocalNode\n    | NumberNode\n    | ParameterNode\n    | PassNode\n    | RaiseNode\n    | ReturnNode\n    | SetNode\n    | SliceNode\n    | StatementListNode\n    | StringListNode\n    | StringNode\n    | SuiteNode\n    | TernaryNode\n    | TupleNode\n    | TryNode\n    | TypeAnnotationNode\n    | UnaryOperationNode\n    | UnpackNode\n    | WhileNode\n    | WithNode\n    | WithItemNode\n    | YieldNode\n    | YieldFromNode;\n\nexport type EvaluationScopeNode = LambdaNode | FunctionNode | ModuleNode | ClassNode | ListComprehensionNode;\nexport type ExecutionScopeNode = LambdaNode | FunctionNode | ModuleNode;\n","/*\n * parser.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Based on code from python-language-server repository:\n *  https://github.com/Microsoft/python-language-server\n *\n * Parser for the Python language. Converts a stream of tokens\n * into an abstract syntax tree (AST).\n */\n\nimport Char from 'typescript-char';\n\nimport { assert } from '../common/debug';\nimport { Diagnostic, DiagnosticAddendum } from '../common/diagnostic';\nimport { DiagnosticSink } from '../common/diagnosticSink';\nimport { convertOffsetsToRange, convertPositionToOffset } from '../common/positionUtils';\nimport { latestStablePythonVersion, PythonVersion } from '../common/pythonVersion';\nimport { TextRange } from '../common/textRange';\nimport { TextRangeCollection } from '../common/textRangeCollection';\nimport { timingStats } from '../common/timing';\nimport { Localizer } from '../localization/localize';\nimport {\n    ArgumentCategory,\n    ArgumentNode,\n    AssertNode,\n    AssignmentExpressionNode,\n    AssignmentNode,\n    AugmentedAssignmentNode,\n    AwaitNode,\n    BinaryOperationNode,\n    BreakNode,\n    CallNode,\n    ClassNode,\n    ConstantNode,\n    ContinueNode,\n    DecoratorNode,\n    DelNode,\n    DictionaryEntryNode,\n    DictionaryExpandEntryNode,\n    DictionaryKeyEntryNode,\n    DictionaryNode,\n    EllipsisNode,\n    ErrorExpressionCategory,\n    ErrorNode,\n    ExceptNode,\n    ExpressionNode,\n    extendRange,\n    FormatStringNode,\n    ForNode,\n    FunctionAnnotationNode,\n    FunctionNode,\n    getNextNodeId,\n    GlobalNode,\n    IfNode,\n    ImportAsNode,\n    ImportFromAsNode,\n    ImportFromNode,\n    ImportNode,\n    IndexItemsNode,\n    IndexNode,\n    LambdaNode,\n    ListComprehensionForNode,\n    ListComprehensionIfNode,\n    ListComprehensionIterNode,\n    ListComprehensionNode,\n    ListNode,\n    MemberAccessNode,\n    ModuleNameNode,\n    ModuleNode,\n    NameNode,\n    NonlocalNode,\n    NumberNode,\n    ParameterCategory,\n    ParameterNode,\n    ParseNode,\n    ParseNodeType,\n    PassNode,\n    RaiseNode,\n    ReturnNode,\n    SetNode,\n    SliceNode,\n    StatementListNode,\n    StatementNode,\n    StringListNode,\n    StringNode,\n    SuiteNode,\n    TernaryNode,\n    TryNode,\n    TupleNode,\n    TypeAnnotationNode,\n    UnaryOperationNode,\n    UnpackNode,\n    WhileNode,\n    WithItemNode,\n    WithNode,\n    YieldFromNode,\n    YieldNode,\n} from './parseNodes';\nimport * as StringTokenUtils from './stringTokenUtils';\nimport { Tokenizer, TokenizerOutput } from './tokenizer';\nimport {\n    DedentToken,\n    IdentifierToken,\n    IndentToken,\n    KeywordToken,\n    KeywordType,\n    NumberToken,\n    OperatorToken,\n    OperatorType,\n    StringToken,\n    StringTokenFlags,\n    Token,\n    TokenType,\n} from './tokenizerTypes';\n\ninterface ExpressionListResult {\n    list: ExpressionNode[];\n    trailingComma: boolean;\n    parseError?: ErrorNode;\n}\n\nexport class ParseOptions {\n    constructor() {\n        this.isStubFile = false;\n        this.pythonVersion = latestStablePythonVersion;\n        this.reportInvalidStringEscapeSequence = false;\n    }\n\n    isStubFile: boolean;\n    pythonVersion: PythonVersion;\n    reportInvalidStringEscapeSequence: boolean;\n}\n\nexport interface ParseResults {\n    text: string;\n    parseTree: ModuleNode;\n    importedModules: ModuleImport[];\n    futureImports: Map<string, boolean>;\n    tokenizerOutput: TokenizerOutput;\n    containsWildcardImport: boolean;\n}\n\nexport interface ParseExpressionTextResults {\n    parseTree?: ExpressionNode;\n    lines: TextRangeCollection<TextRange>;\n    diagnostics: Diagnostic[];\n}\n\nexport interface ModuleImport {\n    nameNode: ModuleNameNode;\n    leadingDots: number;\n    nameParts: string[];\n\n    // Used for \"from X import Y\" pattern. An empty\n    // array implies \"from X import *\".\n    importedSymbols: string[] | undefined;\n}\n\nconst enum ParseTextMode {\n    Expression,\n    VariableAnnotation,\n    FunctionAnnotation,\n}\n\nexport class Parser {\n    private _fileContents?: string;\n    private _tokenizerOutput?: TokenizerOutput;\n    private _tokenIndex = 0;\n    private _parseOptions: ParseOptions = new ParseOptions();\n    private _diagSink: DiagnosticSink = new DiagnosticSink();\n    private _isInLoop = false;\n    private _isInFunction = false;\n    private _isInFinally = false;\n    private _isParsingTypeAnnotation = false;\n    private _isParsingIndexTrailer = false;\n    private _futureImportMap = new Map<string, boolean>();\n    private _importedModules: ModuleImport[] = [];\n    private _containsWildcardImport = false;\n    private _assignmentExpressionsAllowed = true;\n    private _typingImportAliases: string[] = [];\n    private _typingSymbolAliases: Map<string, string> = new Map<string, string>();\n\n    parseSourceFile(fileContents: string, parseOptions: ParseOptions, diagSink: DiagnosticSink): ParseResults {\n        timingStats.tokenizeFileTime.timeOperation(() => {\n            this._startNewParse(fileContents, 0, fileContents.length, parseOptions, diagSink);\n        });\n\n        const moduleNode = ModuleNode.create({ start: 0, length: fileContents.length });\n\n        timingStats.parseFileTime.timeOperation(() => {\n            while (!this._atEof()) {\n                if (!this._consumeTokenIfType(TokenType.NewLine)) {\n                    // Handle a common error case and try to recover.\n                    const nextToken = this._peekToken();\n                    if (nextToken.type === TokenType.Indent) {\n                        this._getNextToken();\n                        const indentToken = nextToken as IndentToken;\n                        if (indentToken.isIndentAmbiguous) {\n                            this._addError(Localizer.Diagnostic.inconsistentTabs(), indentToken);\n                        } else {\n                            this._addError(Localizer.Diagnostic.unexpectedIndent(), nextToken);\n                        }\n                    }\n\n                    const statement = this._parseStatement();\n                    if (!statement) {\n                        // Perform basic error recovery to get to the next line.\n                        this._consumeTokensUntilType([TokenType.NewLine]);\n                    } else {\n                        statement.parent = moduleNode;\n                        moduleNode.statements.push(statement);\n                    }\n                }\n            }\n        });\n\n        assert(this._tokenizerOutput !== undefined);\n        return {\n            text: fileContents,\n            parseTree: moduleNode,\n            importedModules: this._importedModules,\n            futureImports: this._futureImportMap,\n            tokenizerOutput: this._tokenizerOutput!,\n            containsWildcardImport: this._containsWildcardImport,\n        };\n    }\n\n    parseTextExpression(\n        fileContents: string,\n        textOffset: number,\n        textLength: number,\n        parseOptions: ParseOptions,\n        parseTextMode = ParseTextMode.Expression,\n        initialParenDepth = 0\n    ): ParseExpressionTextResults {\n        const diagSink = new DiagnosticSink();\n        this._startNewParse(fileContents, textOffset, textLength, parseOptions, diagSink, initialParenDepth);\n\n        let parseTree: ExpressionNode | undefined;\n        if (parseTextMode === ParseTextMode.VariableAnnotation) {\n            parseTree = this._parseTypeAnnotation(/* allowUnionNotation */ false);\n        } else if (parseTextMode === ParseTextMode.FunctionAnnotation) {\n            parseTree = this._parseFunctionTypeAnnotation();\n        } else {\n            parseTree = this._parseTestExpression(false);\n        }\n\n        if (this._peekTokenType() === TokenType.NewLine) {\n            this._getNextToken();\n        }\n\n        if (!this._atEof()) {\n            this._addError(Localizer.Diagnostic.unexpectedExprToken(), this._peekToken());\n        }\n\n        return {\n            parseTree,\n            lines: this._tokenizerOutput!.lines,\n            diagnostics: diagSink.fetchAndClear(),\n        };\n    }\n\n    private _startNewParse(\n        fileContents: string,\n        textOffset: number,\n        textLength: number,\n        parseOptions: ParseOptions,\n        diagSink: DiagnosticSink,\n        initialParenDepth = 0\n    ) {\n        this._fileContents = fileContents;\n        this._parseOptions = parseOptions;\n        this._diagSink = diagSink;\n\n        // Tokenize the file contents.\n        const tokenizer = new Tokenizer();\n        this._tokenizerOutput = tokenizer.tokenize(fileContents, textOffset, textLength, initialParenDepth);\n        this._tokenIndex = 0;\n    }\n\n    // stmt: simple_stmt | compound_stmt\n    // compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt | with_stmt\n    //   | funcdef | classdef | decorated | async_stmt\n    private _parseStatement(): StatementNode | ErrorNode | undefined {\n        // Handle the errant condition of a dedent token here to provide\n        // better recovery.\n        if (this._consumeTokenIfType(TokenType.Dedent)) {\n            this._addError(Localizer.Diagnostic.unexpectedUnindent(), this._peekToken());\n        }\n\n        switch (this._peekKeywordType()) {\n            case KeywordType.If:\n                return this._parseIfStatement();\n\n            case KeywordType.While:\n                return this._parseWhileStatement();\n\n            case KeywordType.For:\n                return this._parseForStatement();\n\n            case KeywordType.Try:\n                return this._parseTryStatement();\n\n            case KeywordType.With:\n                return this._parseWithStatement();\n\n            case KeywordType.Def:\n                return this._parseFunctionDef();\n\n            case KeywordType.Class:\n                return this._parseClassDef();\n\n            case KeywordType.Async:\n                return this._parseAsyncStatement();\n        }\n\n        if (this._peekOperatorType() === OperatorType.MatrixMultiply) {\n            return this._parseDecorated();\n        }\n\n        return this._parseSimpleStatement();\n    }\n\n    // async_stmt: 'async' (funcdef | with_stmt | for_stmt)\n    private _parseAsyncStatement(): StatementNode | undefined {\n        const asyncToken = this._getKeywordToken(KeywordType.Async);\n\n        switch (this._peekKeywordType()) {\n            case KeywordType.Def:\n                return this._parseFunctionDef(asyncToken);\n\n            case KeywordType.With:\n                return this._parseWithStatement(asyncToken);\n\n            case KeywordType.For:\n                return this._parseForStatement(asyncToken);\n        }\n\n        this._addError(Localizer.Diagnostic.unexpectedAsyncToken(), asyncToken);\n\n        return undefined;\n    }\n\n    // if_stmt: 'if' test_suite ('elif' test_suite)* ['else' suite]\n    // test_suite: test suite\n    // test: or_test ['if' or_test 'else' test] | lambdef\n    private _parseIfStatement(keywordType: KeywordType.If | KeywordType.Elif = KeywordType.If): IfNode {\n        const ifOrElifToken = this._getKeywordToken(keywordType);\n\n        const test = this._parseTestExpression(true);\n        const suite = this._parseSuite(this._isInFunction);\n        const ifNode = IfNode.create(ifOrElifToken, test, suite);\n\n        if (this._consumeTokenIfKeyword(KeywordType.Else)) {\n            ifNode.elseSuite = this._parseSuite(this._isInFunction);\n            ifNode.elseSuite.parent = ifNode;\n            extendRange(ifNode, ifNode.elseSuite);\n        } else if (this._peekKeywordType() === KeywordType.Elif) {\n            // Recursively handle an \"elif\" statement.\n            ifNode.elseSuite = this._parseIfStatement(KeywordType.Elif);\n            ifNode.elseSuite.parent = ifNode;\n            extendRange(ifNode, ifNode.elseSuite);\n        }\n\n        return ifNode;\n    }\n\n    private _parseLoopSuite(): SuiteNode {\n        const wasInLoop = this._isInLoop;\n        const wasInFinally = this._isInFinally;\n        this._isInLoop = true;\n        this._isInFinally = false;\n\n        const suite = this._parseSuite(this._isInFunction);\n\n        this._isInLoop = wasInLoop;\n        this._isInFinally = wasInFinally;\n\n        return suite;\n    }\n\n    // suite: ':' (simple_stmt | NEWLINE INDENT stmt+ DEDENT)\n    private _parseSuite(isFunction = false, postColonCallback?: () => void): SuiteNode {\n        const nextToken = this._peekToken();\n        const suite = SuiteNode.create(nextToken);\n\n        if (!this._consumeTokenIfType(TokenType.Colon)) {\n            this._addError(Localizer.Diagnostic.expectedColon(), nextToken);\n\n            // Try to perform parse recovery by consuming tokens until\n            // we find the end of the line.\n            if (this._consumeTokensUntilType([TokenType.NewLine, TokenType.Colon])) {\n                this._getNextToken();\n            }\n        }\n\n        if (postColonCallback) {\n            postColonCallback();\n        }\n\n        const wasFunction = this._isInFunction;\n        this._isInFunction = isFunction;\n\n        if (this._consumeTokenIfType(TokenType.NewLine)) {\n            if (postColonCallback) {\n                postColonCallback();\n            }\n\n            const possibleIndent = this._peekToken();\n            if (!this._consumeTokenIfType(TokenType.Indent)) {\n                this._addError(Localizer.Diagnostic.expectedIndentedBlock(), this._peekToken());\n            } else {\n                const indentToken = possibleIndent as IndentToken;\n                if (indentToken.isIndentAmbiguous) {\n                    this._addError(Localizer.Diagnostic.inconsistentTabs(), indentToken);\n                }\n            }\n\n            while (true) {\n                // Handle a common error here and see if we can recover.\n                const nextToken = this._peekToken();\n                if (nextToken.type === TokenType.Indent) {\n                    this._getNextToken();\n                    const indentToken = nextToken as IndentToken;\n                    if (indentToken.isIndentAmbiguous) {\n                        this._addError(Localizer.Diagnostic.inconsistentTabs(), indentToken);\n                    } else {\n                        this._addError(Localizer.Diagnostic.unexpectedIndent(), nextToken);\n                    }\n                }\n\n                const statement = this._parseStatement();\n                if (!statement) {\n                    // Perform basic error recovery to get to the next line.\n                    this._consumeTokensUntilType([TokenType.NewLine]);\n                } else {\n                    statement.parent = suite;\n                    suite.statements.push(statement);\n                }\n\n                const dedentToken = this._peekToken() as DedentToken;\n                if (this._consumeTokenIfType(TokenType.Dedent)) {\n                    if (!dedentToken.matchesIndent) {\n                        this._addError(Localizer.Diagnostic.inconsistentIndent(), dedentToken);\n                    }\n                    break;\n                }\n\n                if (this._peekTokenType() === TokenType.EndOfStream) {\n                    break;\n                }\n            }\n        } else {\n            const simpleStatement = this._parseSimpleStatement();\n            suite.statements.push(simpleStatement);\n            simpleStatement.parent = suite;\n        }\n\n        if (suite.statements.length > 0) {\n            extendRange(suite, suite.statements[suite.statements.length - 1]);\n        }\n\n        this._isInFunction = wasFunction;\n\n        return suite;\n    }\n\n    // for_stmt: [async] 'for' exprlist 'in' testlist suite ['else' suite]\n    private _parseForStatement(asyncToken?: KeywordToken): ForNode {\n        const forToken = this._getKeywordToken(KeywordType.For);\n\n        const exprListResult = this._parseExpressionList(true);\n        const targetExpr = this._makeExpressionOrTuple(exprListResult, /* enclosedInParens */ false);\n        let seqExpr: ExpressionNode;\n        let forSuite: SuiteNode;\n        let elseSuite: SuiteNode | undefined;\n\n        if (!this._consumeTokenIfKeyword(KeywordType.In)) {\n            seqExpr = this._handleExpressionParseError(\n                ErrorExpressionCategory.MissingIn,\n                Localizer.Diagnostic.expectedIn()\n            );\n            forSuite = SuiteNode.create(this._peekToken());\n        } else {\n            seqExpr = this._parseTestListAsExpression(\n                ErrorExpressionCategory.MissingExpression,\n                Localizer.Diagnostic.expectedInExpr()\n            );\n            forSuite = this._parseLoopSuite();\n\n            if (this._consumeTokenIfKeyword(KeywordType.Else)) {\n                elseSuite = this._parseSuite(this._isInFunction);\n            }\n        }\n\n        const forNode = ForNode.create(forToken, targetExpr, seqExpr, forSuite);\n        forNode.elseSuite = elseSuite;\n        if (elseSuite) {\n            extendRange(forNode, elseSuite);\n            elseSuite.parent = forNode;\n        }\n\n        if (asyncToken) {\n            forNode.isAsync = true;\n            extendRange(forNode, asyncToken);\n        }\n\n        return forNode;\n    }\n\n    // comp_iter: comp_for | comp_if\n    private _tryParseListComprehension(target: ParseNode): ListComprehensionNode | undefined {\n        const compFor = this._tryParseCompForStatement();\n\n        if (!compFor) {\n            return undefined;\n        }\n\n        if (target.nodeType === ParseNodeType.Unpack) {\n            this._addError(Localizer.Diagnostic.unpackIllegalInComprehension(), target);\n        } else if (target.nodeType === ParseNodeType.DictionaryExpandEntry) {\n            this._addError(Localizer.Diagnostic.dictExpandIllegalInComprehension(), target);\n        }\n\n        const listCompNode = ListComprehensionNode.create(target);\n\n        const compList: ListComprehensionIterNode[] = [compFor];\n        while (true) {\n            const compIter = this._tryParseCompForStatement() || this._tryParseCompIfStatement();\n            if (!compIter) {\n                break;\n            }\n            compIter.parent = listCompNode;\n            compList.push(compIter);\n        }\n\n        listCompNode.comprehensions = compList;\n        if (compList.length > 0) {\n            compList.forEach((comp) => {\n                comp.parent = listCompNode;\n            });\n            extendRange(listCompNode, compList[compList.length - 1]);\n        }\n        return listCompNode;\n    }\n\n    // comp_for: ['async'] 'for' exprlist 'in' or_test [comp_iter]\n    private _tryParseCompForStatement(): ListComprehensionForNode | undefined {\n        const startTokenKeywordType = this._peekKeywordType();\n\n        if (startTokenKeywordType === KeywordType.Async) {\n            const nextToken = this._peekToken(1) as KeywordToken;\n            if (nextToken.type !== TokenType.Keyword || nextToken.keywordType !== KeywordType.For) {\n                return undefined;\n            }\n        } else if (startTokenKeywordType !== KeywordType.For) {\n            return undefined;\n        }\n\n        let asyncToken: KeywordToken | undefined;\n        if (this._peekKeywordType() === KeywordType.Async) {\n            asyncToken = this._getKeywordToken(KeywordType.Async);\n        }\n\n        const forToken = this._getKeywordToken(KeywordType.For);\n\n        const exprListResult = this._parseExpressionList(true);\n        const targetExpr = this._makeExpressionOrTuple(exprListResult, /* enclosedInParens */ false);\n        let seqExpr: ExpressionNode | undefined;\n\n        if (!this._consumeTokenIfKeyword(KeywordType.In)) {\n            seqExpr = this._handleExpressionParseError(\n                ErrorExpressionCategory.MissingIn,\n                Localizer.Diagnostic.expectedIn()\n            );\n        } else {\n            this._disallowAssignmentExpression(() => {\n                seqExpr = this._parseOrTest();\n            });\n        }\n\n        const compForNode = ListComprehensionForNode.create(asyncToken || forToken, targetExpr, seqExpr!);\n\n        if (asyncToken) {\n            compForNode.isAsync = true;\n        }\n\n        return compForNode;\n    }\n\n    // comp_if: 'if' test_nocond [comp_iter]\n    // comp_iter: comp_for | comp_if\n    private _tryParseCompIfStatement(): ListComprehensionIfNode | undefined {\n        if (this._peekKeywordType() !== KeywordType.If) {\n            return undefined;\n        }\n\n        const ifToken = this._getKeywordToken(KeywordType.If);\n        const ifExpr = this._tryParseLambdaExpression() || this._parseAssignmentExpression();\n\n        const compIfNode = ListComprehensionIfNode.create(ifToken, ifExpr);\n\n        return compIfNode;\n    }\n\n    // while_stmt: 'while' test suite ['else' suite]\n    private _parseWhileStatement(): WhileNode {\n        const whileToken = this._getKeywordToken(KeywordType.While);\n\n        const whileNode = WhileNode.create(whileToken, this._parseTestExpression(true), this._parseLoopSuite());\n\n        if (this._consumeTokenIfKeyword(KeywordType.Else)) {\n            whileNode.elseSuite = this._parseSuite(this._isInFunction);\n            whileNode.elseSuite.parent = whileNode;\n            extendRange(whileNode, whileNode.elseSuite);\n        }\n\n        return whileNode;\n    }\n\n    // try_stmt: ('try' suite\n    //         ((except_clause suite)+\n    //             ['else' suite]\n    //             ['finally' suite] |\n    //         'finally' suite))\n    // except_clause: 'except' [test ['as' NAME]]\n    private _parseTryStatement(): TryNode {\n        const tryToken = this._getKeywordToken(KeywordType.Try);\n        const trySuite = this._parseSuite(this._isInFunction);\n        const tryNode = TryNode.create(tryToken, trySuite);\n        let sawCatchAllExcept = false;\n\n        while (true) {\n            const exceptToken = this._peekToken();\n            if (!this._consumeTokenIfKeyword(KeywordType.Except)) {\n                break;\n            }\n\n            let typeExpr: ExpressionNode | undefined;\n            let symbolName: IdentifierToken | undefined;\n            if (this._peekTokenType() !== TokenType.Colon) {\n                typeExpr = this._parseTestExpression(true);\n\n                if (this._consumeTokenIfKeyword(KeywordType.As)) {\n                    symbolName = this._getTokenIfIdentifier();\n                    if (!symbolName) {\n                        this._addError(Localizer.Diagnostic.expectedNameAfterAs(), this._peekToken());\n                    }\n                } else {\n                    // Handle the python 2.x syntax in a graceful manner.\n                    const peekToken = this._peekToken();\n                    if (this._consumeTokenIfType(TokenType.Comma)) {\n                        this._addError(Localizer.Diagnostic.expectedAsAfterException(), peekToken);\n\n                        // Parse the expression expected in python 2.x, but discard it.\n                        this._parseTestExpression(false);\n                    }\n                }\n            }\n\n            if (!typeExpr) {\n                if (sawCatchAllExcept) {\n                    this._addError(Localizer.Diagnostic.duplicateCatchAll(), exceptToken);\n                }\n                sawCatchAllExcept = true;\n            } else {\n                if (sawCatchAllExcept) {\n                    this._addError(Localizer.Diagnostic.namedExceptAfterCatchAll(), typeExpr);\n                }\n            }\n\n            const exceptSuite = this._parseSuite(this._isInFunction);\n            const exceptNode = ExceptNode.create(exceptToken, exceptSuite);\n            if (typeExpr) {\n                exceptNode.typeExpression = typeExpr;\n                exceptNode.typeExpression.parent = exceptNode;\n            }\n\n            if (symbolName) {\n                exceptNode.name = NameNode.create(symbolName);\n                exceptNode.name.parent = exceptNode;\n            }\n\n            tryNode.exceptClauses.push(exceptNode);\n            exceptNode.parent = tryNode;\n        }\n\n        if (tryNode.exceptClauses.length > 0) {\n            extendRange(tryNode, tryNode.exceptClauses[tryNode.exceptClauses.length - 1]);\n\n            if (this._consumeTokenIfKeyword(KeywordType.Else)) {\n                tryNode.elseSuite = this._parseSuite(this._isInFunction);\n                tryNode.elseSuite.parent = tryNode;\n                extendRange(tryNode, tryNode.elseSuite);\n            }\n        }\n\n        if (this._consumeTokenIfKeyword(KeywordType.Finally)) {\n            tryNode.finallySuite = this._parseSuite(this._isInFunction);\n            tryNode.finallySuite.parent = tryNode;\n            extendRange(tryNode, tryNode.finallySuite);\n        }\n\n        return tryNode;\n    }\n\n    // funcdef: 'def' NAME parameters ['->' test] ':' suite\n    // parameters: '(' [typedargslist] ')'\n    private _parseFunctionDef(asyncToken?: KeywordToken, decorators?: DecoratorNode[]): FunctionNode | ErrorNode {\n        const defToken = this._getKeywordToken(KeywordType.Def);\n\n        const nameToken = this._getTokenIfIdentifier();\n        if (!nameToken) {\n            this._addError(Localizer.Diagnostic.expectedFunctionName(), defToken);\n            return ErrorNode.create(defToken, ErrorExpressionCategory.MissingFunctionParameterList);\n        }\n\n        if (!this._consumeTokenIfType(TokenType.OpenParenthesis)) {\n            this._addError(Localizer.Diagnostic.expectedOpenParen(), this._peekToken());\n            return ErrorNode.create(\n                nameToken,\n                ErrorExpressionCategory.MissingFunctionParameterList,\n                NameNode.create(nameToken)\n            );\n        }\n\n        const paramList = this._parseVarArgsList(TokenType.CloseParenthesis, /* allowAnnotations */ true);\n\n        if (!this._consumeTokenIfType(TokenType.CloseParenthesis)) {\n            this._addError(Localizer.Diagnostic.expectedCloseParen(), this._peekToken());\n            this._consumeTokensUntilType([TokenType.Colon]);\n        }\n\n        let returnType: ExpressionNode | undefined;\n        if (this._consumeTokenIfType(TokenType.Arrow)) {\n            returnType = this._parseTypeAnnotation();\n        }\n\n        let functionTypeAnnotationToken: StringToken | undefined;\n        const suite = this._parseSuite(/* isFunction */ true, () => {\n            if (!functionTypeAnnotationToken) {\n                functionTypeAnnotationToken = this._getTypeAnnotationCommentText();\n            }\n        });\n\n        const functionNode = FunctionNode.create(defToken, NameNode.create(nameToken), suite);\n        if (asyncToken) {\n            functionNode.isAsync = true;\n            extendRange(functionNode, asyncToken);\n        }\n\n        functionNode.parameters = paramList;\n        paramList.forEach((param) => {\n            param.parent = functionNode;\n        });\n\n        if (decorators) {\n            functionNode.decorators = decorators;\n            decorators.forEach((decorator) => {\n                decorator.parent = functionNode;\n            });\n\n            if (decorators.length > 0) {\n                extendRange(functionNode, decorators[0]);\n            }\n        }\n\n        if (returnType) {\n            functionNode.returnTypeAnnotation = returnType;\n            functionNode.returnTypeAnnotation.parent = functionNode;\n            extendRange(functionNode, returnType);\n        }\n\n        // If there was a type annotation comment for the function,\n        // parse it now.\n        if (functionTypeAnnotationToken) {\n            this._parseFunctionTypeAnnotationComment(functionTypeAnnotationToken, functionNode);\n        }\n\n        return functionNode;\n    }\n\n    // typedargslist: (\n    //   tfpdef ['=' test] (',' tfpdef ['=' test])*\n    //      [ ','\n    //          [\n    //              '*' [tfpdef] (',' tfpdef ['=' test])* [',' ['**' tfpdef [',']]]\n    //              | '**' tfpdef [',']\n    //          ]\n    //      ]\n    //   | '*' [tfpdef] (',' tfpdef ['=' test])* [',' ['**' tfpdef [',']]]\n    //   | '**' tfpdef [','])\n    // tfpdef: NAME [':' test]\n    // vfpdef: NAME;\n    private _parseVarArgsList(terminator: TokenType, allowAnnotations: boolean): ParameterNode[] {\n        const paramMap = new Map<string, string>();\n        const paramList: ParameterNode[] = [];\n        let sawDefaultParam = false;\n        let reportedNonDefaultParamErr = false;\n        let sawKwSeparator = false;\n        let sawPositionOnlySeparator = false;\n        let sawVarArgs = false;\n        let sawKwArgs = false;\n\n        while (true) {\n            if (this._peekTokenType() === terminator) {\n                break;\n            }\n\n            const param = this._parseParameter(allowAnnotations);\n            if (!param) {\n                this._consumeTokensUntilType([terminator]);\n                break;\n            }\n\n            if (param.name) {\n                const name = param.name.value;\n                if (paramMap.has(name)) {\n                    this._addError(Localizer.Diagnostic.duplicateParam().format({ name }), param.name);\n                } else {\n                    paramMap.set(name, name);\n                }\n            }\n\n            if (param.category === ParameterCategory.Simple) {\n                if (!param.name) {\n                    if (sawPositionOnlySeparator) {\n                        this._addError(Localizer.Diagnostic.duplicatePositionOnly(), param);\n                    } else if (sawKwSeparator) {\n                        this._addError(Localizer.Diagnostic.positionOnlyAfterNameOnly(), param);\n                    }\n                    sawPositionOnlySeparator = true;\n                } else {\n                    if (param.defaultValue) {\n                        sawDefaultParam = true;\n                    } else if (sawDefaultParam && !sawKwSeparator && !sawVarArgs) {\n                        // Report this error only once.\n                        if (!reportedNonDefaultParamErr) {\n                            this._addError(Localizer.Diagnostic.nonDefaultAfterDefault(), param);\n                            reportedNonDefaultParamErr = true;\n                        }\n                    }\n                }\n            }\n\n            paramList.push(param);\n\n            if (param.category === ParameterCategory.VarArgList) {\n                if (!param.name) {\n                    if (sawKwSeparator) {\n                        this._addError(Localizer.Diagnostic.duplicateNameOnly(), param);\n                    }\n                    sawKwSeparator = true;\n                } else {\n                    if (sawVarArgs) {\n                        this._addError(Localizer.Diagnostic.duplicateArgsParam(), param);\n                    }\n                    sawVarArgs = true;\n                }\n            }\n\n            if (param.category === ParameterCategory.VarArgDictionary) {\n                if (sawKwArgs) {\n                    this._addError(Localizer.Diagnostic.duplicateKwargsParam(), param);\n                }\n                sawKwArgs = true;\n            } else if (sawKwArgs) {\n                this._addError(Localizer.Diagnostic.paramAfterKwargsParam(), param);\n            }\n\n            const foundComma = this._consumeTokenIfType(TokenType.Comma);\n\n            if (allowAnnotations && !param.typeAnnotation) {\n                // Look for a type annotation comment at the end of the line.\n                const typeAnnotationComment = this._parseVariableTypeAnnotationComment();\n                if (typeAnnotationComment) {\n                    param.typeAnnotationComment = typeAnnotationComment;\n                    param.typeAnnotationComment.parent = param;\n                    extendRange(param, param.typeAnnotationComment);\n                }\n            }\n\n            if (!foundComma) {\n                break;\n            }\n        }\n\n        if (paramList.length > 0) {\n            const lastParam = paramList[paramList.length - 1];\n            if (lastParam.category === ParameterCategory.VarArgList && !lastParam.name) {\n                this._addError(Localizer.Diagnostic.expectedNamedArgument(), lastParam);\n            }\n        }\n\n        return paramList;\n    }\n\n    private _parseParameter(allowAnnotations: boolean): ParameterNode {\n        let starCount = 0;\n        let slashCount = 0;\n        const firstToken = this._peekToken();\n\n        if (this._consumeTokenIfOperator(OperatorType.Multiply)) {\n            starCount = 1;\n        } else if (this._consumeTokenIfOperator(OperatorType.Power)) {\n            starCount = 2;\n        } else if (this._consumeTokenIfOperator(OperatorType.Divide)) {\n            if (this._getLanguageVersion() < PythonVersion.V3_8) {\n                this._addError(Localizer.Diagnostic.positionOnlyIncompatible(), firstToken);\n            }\n            slashCount = 1;\n        }\n\n        const paramName = this._getTokenIfIdentifier();\n        if (!paramName) {\n            if (starCount === 1) {\n                const paramNode = ParameterNode.create(firstToken, ParameterCategory.VarArgList);\n                return paramNode;\n            } else if (slashCount === 1) {\n                const paramNode = ParameterNode.create(firstToken, ParameterCategory.Simple);\n                return paramNode;\n            }\n\n            // Check for the Python 2.x parameter sublist syntax and handle it gracefully.\n            if (this._peekTokenType() === TokenType.OpenParenthesis) {\n                const sublistStart = this._getNextToken();\n                if (this._consumeTokensUntilType([TokenType.CloseParenthesis])) {\n                    this._getNextToken();\n                }\n                this._addError(Localizer.Diagnostic.sublistParamsIncompatible(), sublistStart);\n            } else {\n                this._addError(Localizer.Diagnostic.expectedParamName(), this._peekToken());\n            }\n        }\n\n        let paramType = ParameterCategory.Simple;\n        if (starCount === 1) {\n            paramType = ParameterCategory.VarArgList;\n        } else if (starCount === 2) {\n            paramType = ParameterCategory.VarArgDictionary;\n        }\n        const paramNode = ParameterNode.create(firstToken, paramType);\n        if (paramName) {\n            paramNode.name = NameNode.create(paramName);\n            paramNode.name.parent = paramNode;\n            extendRange(paramNode, paramName);\n        }\n\n        if (allowAnnotations && this._consumeTokenIfType(TokenType.Colon)) {\n            paramNode.typeAnnotation = this._parseTypeAnnotation();\n            paramNode.typeAnnotation.parent = paramNode;\n            extendRange(paramNode, paramNode.typeAnnotation);\n        }\n\n        if (this._consumeTokenIfOperator(OperatorType.Assign)) {\n            paramNode.defaultValue = this._parseTestExpression(false);\n            paramNode.defaultValue.parent = paramNode;\n            extendRange(paramNode, paramNode.defaultValue);\n\n            if (starCount > 0) {\n                this._addError(Localizer.Diagnostic.defaultValueNotAllowed(), paramNode.defaultValue);\n            }\n        }\n\n        return paramNode;\n    }\n\n    // with_stmt: 'with' with_item (',' with_item)*  ':' suite\n    private _parseWithStatement(asyncToken?: KeywordToken): WithNode {\n        const withToken = this._getKeywordToken(KeywordType.With);\n        const withItemList: WithItemNode[] = [];\n\n        while (true) {\n            withItemList.push(this._parseWithItem());\n\n            if (!this._consumeTokenIfType(TokenType.Comma)) {\n                break;\n            }\n        }\n\n        const withSuite = this._parseSuite(this._isInFunction);\n        const withNode = WithNode.create(withToken, withSuite);\n        if (asyncToken) {\n            withNode.isAsync = true;\n            extendRange(withNode, asyncToken);\n        }\n\n        withNode.withItems = withItemList;\n        withItemList.forEach((withItem) => {\n            withItem.parent = withNode;\n        });\n\n        return withNode;\n    }\n\n    // with_item: test ['as' expr]\n    private _parseWithItem(): WithItemNode {\n        const expr = this._parseTestExpression(true);\n        const itemNode = WithItemNode.create(expr);\n\n        if (this._consumeTokenIfKeyword(KeywordType.As)) {\n            itemNode.target = this._parseExpression(false);\n            itemNode.target.parent = itemNode;\n            extendRange(itemNode, itemNode.target);\n        }\n\n        return itemNode;\n    }\n\n    // decorators: decorator+\n    // decorated: decorators (classdef | funcdef | async_funcdef)\n    private _parseDecorated(): StatementNode | undefined {\n        const decoratorList: DecoratorNode[] = [];\n\n        while (true) {\n            if (this._peekOperatorType() === OperatorType.MatrixMultiply) {\n                decoratorList.push(this._parseDecorator());\n            } else {\n                break;\n            }\n        }\n\n        const nextToken = this._peekToken() as KeywordToken;\n        if (nextToken.type === TokenType.Keyword) {\n            if (nextToken.keywordType === KeywordType.Async) {\n                this._getNextToken();\n\n                if (this._peekKeywordType() !== KeywordType.Def) {\n                    this._addError(Localizer.Diagnostic.expectedFunctionAfterAsync(), this._peekToken());\n                } else {\n                    return this._parseFunctionDef(nextToken, decoratorList);\n                }\n            } else if (nextToken.keywordType === KeywordType.Def) {\n                return this._parseFunctionDef(undefined, decoratorList);\n            } else if (nextToken.keywordType === KeywordType.Class) {\n                return this._parseClassDef(decoratorList);\n            }\n        }\n\n        this._addError(Localizer.Diagnostic.expectedAfterDecorator(), this._peekToken());\n\n        // Return a dummy class declaration so the completion provider has\n        // some parse nodes to work with.\n        return ClassNode.createDummyForDecorators(decoratorList);\n    }\n\n    // decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE\n    private _parseDecorator(): DecoratorNode {\n        const atOperator = this._getNextToken() as OperatorToken;\n        assert(atOperator.operatorType === OperatorType.MatrixMultiply);\n\n        let callNameExpr: ExpressionNode | undefined;\n        while (true) {\n            const namePart = this._getTokenIfIdentifier();\n            if (!namePart) {\n                this._addError(Localizer.Diagnostic.expectedDecoratorName(), this._peekToken());\n                if (callNameExpr) {\n                    callNameExpr = ErrorNode.create(\n                        this._peekToken(),\n                        ErrorExpressionCategory.MissingMemberAccessName,\n                        callNameExpr\n                    );\n                } else {\n                    callNameExpr = ErrorNode.create(\n                        this._peekToken(),\n                        ErrorExpressionCategory.MissingDecoratorCallName\n                    );\n                }\n                break;\n            }\n\n            const namePartNode = NameNode.create(namePart);\n\n            if (!callNameExpr) {\n                callNameExpr = namePartNode;\n            } else {\n                callNameExpr = MemberAccessNode.create(callNameExpr, namePartNode);\n            }\n\n            if (!this._consumeTokenIfType(TokenType.Dot)) {\n                break;\n            }\n        }\n\n        const decoratorNode = DecoratorNode.create(atOperator, callNameExpr);\n\n        if (this._consumeTokenIfType(TokenType.OpenParenthesis)) {\n            decoratorNode.arguments = this._parseArgList();\n            decoratorNode.arguments.forEach((arg) => {\n                arg.parent = decoratorNode;\n                extendRange(decoratorNode, arg);\n            });\n\n            const nextToken = this._peekToken();\n            if (!this._consumeTokenIfType(TokenType.CloseParenthesis)) {\n                this._addError(Localizer.Diagnostic.expectedCloseParen(), this._peekToken());\n            } else {\n                extendRange(decoratorNode, nextToken);\n            }\n        }\n\n        if (!this._consumeTokenIfType(TokenType.NewLine)) {\n            this._addError(Localizer.Diagnostic.expectedDecoratorNewline(), this._peekToken());\n            this._consumeTokensUntilType([TokenType.NewLine]);\n        }\n\n        return decoratorNode;\n    }\n\n    // classdef: 'class' NAME ['(' [arglist] ')'] suite\n    private _parseClassDef(decorators?: DecoratorNode[]): ClassNode {\n        const classToken = this._getKeywordToken(KeywordType.Class);\n\n        let nameToken = this._getTokenIfIdentifier();\n        if (!nameToken) {\n            this._addError(Localizer.Diagnostic.expectedClassName(), this._peekToken());\n            nameToken = IdentifierToken.create(0, 0, '', undefined);\n        }\n\n        let argList: ArgumentNode[] = [];\n        if (this._consumeTokenIfType(TokenType.OpenParenthesis)) {\n            argList = this._parseArgList();\n\n            if (!this._consumeTokenIfType(TokenType.CloseParenthesis)) {\n                this._addError(Localizer.Diagnostic.expectedCloseParen(), this._peekToken());\n            }\n        }\n\n        const suite = this._parseSuite(false);\n\n        const classNode = ClassNode.create(classToken, NameNode.create(nameToken), suite);\n        classNode.arguments = argList;\n        argList.forEach((arg) => {\n            arg.parent = classNode;\n        });\n\n        if (decorators) {\n            classNode.decorators = decorators;\n            if (decorators.length > 0) {\n                decorators.forEach((decorator) => {\n                    decorator.parent = classNode;\n                });\n                extendRange(classNode, decorators[0]);\n            }\n        }\n\n        return classNode;\n    }\n\n    private _parsePassStatement(): PassNode {\n        return PassNode.create(this._getKeywordToken(KeywordType.Pass));\n    }\n\n    private _parseBreakStatement(): BreakNode {\n        const breakToken = this._getKeywordToken(KeywordType.Break);\n\n        if (!this._isInLoop) {\n            this._addError(Localizer.Diagnostic.breakOutsideLoop(), breakToken);\n        }\n\n        return BreakNode.create(breakToken);\n    }\n\n    private _parseContinueStatement(): ContinueNode {\n        const continueToken = this._getKeywordToken(KeywordType.Continue);\n\n        if (!this._isInLoop) {\n            this._addError(Localizer.Diagnostic.continueOutsideLoop(), continueToken);\n        } else if (this._isInFinally) {\n            this._addError(Localizer.Diagnostic.continueInFinally(), continueToken);\n        }\n\n        return ContinueNode.create(continueToken);\n    }\n\n    // return_stmt: 'return' [testlist]\n    private _parseReturnStatement(): ReturnNode {\n        const returnToken = this._getKeywordToken(KeywordType.Return);\n\n        const returnNode = ReturnNode.create(returnToken);\n\n        if (!this._isInFunction) {\n            this._addError(Localizer.Diagnostic.returnOutsideFunction(), returnToken);\n        }\n\n        if (!this._isNextTokenNeverExpression()) {\n            const returnExpr = this._parseTestOrStarListAsExpression(\n                /* allowAssignmentExpression */ true,\n                ErrorExpressionCategory.MissingExpression,\n                Localizer.Diagnostic.expectedReturnExpr()\n            );\n            this._reportConditionalErrorForStarTupleElement(returnExpr);\n            returnNode.returnExpression = returnExpr;\n            returnNode.returnExpression.parent = returnNode;\n            extendRange(returnNode, returnExpr);\n        }\n\n        return returnNode;\n    }\n\n    // import_from: ('from' (('.' | '...')* dotted_name | ('.' | '...')+)\n    //             'import' ('*' | '(' import_as_names ')' | import_as_names))\n    // import_as_names: import_as_name (',' import_as_name)* [',']\n    // import_as_name: NAME ['as' NAME]\n    private _parseFromStatement(): ImportFromNode {\n        const fromToken = this._getKeywordToken(KeywordType.From);\n\n        const modName = this._parseDottedModuleName(true);\n        const importFromNode = ImportFromNode.create(fromToken, modName);\n\n        // Handle imports from __future__ specially because they can\n        // change the way we interpret the rest of the file.\n        const isFutureImport =\n            modName.leadingDots === 0 && modName.nameParts.length === 1 && modName.nameParts[0].value === '__future__';\n\n        const possibleInputToken = this._peekToken();\n        if (!this._consumeTokenIfKeyword(KeywordType.Import)) {\n            this._addError(Localizer.Diagnostic.expectedImport(), this._peekToken());\n            if (!modName.hasTrailingDot) {\n                importFromNode.missingImportKeyword = true;\n            }\n        } else {\n            extendRange(importFromNode, possibleInputToken);\n\n            // Look for \"*\" token.\n            const possibleStarToken = this._peekToken();\n            if (this._consumeTokenIfOperator(OperatorType.Multiply)) {\n                extendRange(importFromNode, possibleStarToken);\n                importFromNode.isWildcardImport = true;\n                importFromNode.wildcardToken = possibleStarToken;\n                this._containsWildcardImport = true;\n            } else {\n                const inParen = this._consumeTokenIfType(TokenType.OpenParenthesis);\n\n                while (true) {\n                    const importName = this._getTokenIfIdentifier();\n                    if (!importName) {\n                        break;\n                    }\n\n                    const importFromAsNode = ImportFromAsNode.create(NameNode.create(importName));\n\n                    if (this._consumeTokenIfKeyword(KeywordType.As)) {\n                        const aliasName = this._getTokenIfIdentifier();\n                        if (!aliasName) {\n                            this._addError(Localizer.Diagnostic.expectedImportAlias(), this._peekToken());\n                        } else {\n                            importFromAsNode.alias = NameNode.create(aliasName);\n                            importFromAsNode.alias.parent = importFromAsNode;\n                            extendRange(importFromAsNode, aliasName);\n                        }\n                    }\n\n                    importFromNode.imports.push(importFromAsNode);\n                    importFromAsNode.parent = importFromNode;\n                    extendRange(importFromNode, importFromAsNode);\n\n                    if (isFutureImport) {\n                        // Add the future import to the map.\n                        this._futureImportMap.set(importName.value, true);\n                    }\n\n                    if (!this._consumeTokenIfType(TokenType.Comma)) {\n                        break;\n                    }\n                }\n\n                if (importFromNode.imports.length === 0) {\n                    this._addError(Localizer.Diagnostic.expectedImportSymbols(), this._peekToken());\n                }\n\n                if (inParen) {\n                    importFromNode.usesParens = true;\n\n                    const nextToken = this._peekToken();\n                    if (!this._consumeTokenIfType(TokenType.CloseParenthesis)) {\n                        this._addError(Localizer.Diagnostic.expectedCloseParen(), this._peekToken());\n                    } else {\n                        extendRange(importFromNode, nextToken);\n                    }\n                }\n            }\n        }\n\n        this._importedModules.push({\n            nameNode: importFromNode.module,\n            leadingDots: importFromNode.module.leadingDots,\n            nameParts: importFromNode.module.nameParts.map((p) => p.value),\n            importedSymbols: importFromNode.imports.map((imp) => imp.name.value),\n        });\n\n        let isTypingImport = false;\n        if (importFromNode.module.nameParts.length === 1) {\n            const firstNamePartValue = importFromNode.module.nameParts[0].value;\n            if (firstNamePartValue === 'typing' || firstNamePartValue === 'typing_extensions') {\n                isTypingImport = true;\n            }\n        }\n\n        if (isTypingImport) {\n            const typingSymbolsOfInterest = ['Literal', 'TypeAlias'];\n\n            if (importFromNode.isWildcardImport) {\n                typingSymbolsOfInterest.forEach((s) => {\n                    this._typingSymbolAliases.set(s, s);\n                });\n            } else {\n                importFromNode.imports.forEach((imp) => {\n                    if (typingSymbolsOfInterest.some((s) => s === imp.name.value)) {\n                        this._typingSymbolAliases.set(imp.alias?.value || imp.name.value, imp.name.value);\n                    }\n                });\n            }\n        }\n\n        return importFromNode;\n    }\n\n    // import_name: 'import' dotted_as_names\n    // dotted_as_names: dotted_as_name (',' dotted_as_name)*\n    // dotted_as_name: dotted_name ['as' NAME]\n    private _parseImportStatement(): ImportNode {\n        const importToken = this._getKeywordToken(KeywordType.Import);\n\n        const importNode = ImportNode.create(importToken);\n\n        while (true) {\n            const modName = this._parseDottedModuleName();\n\n            const importAsNode = ImportAsNode.create(modName);\n\n            if (this._consumeTokenIfKeyword(KeywordType.As)) {\n                const aliasToken = this._getTokenIfIdentifier();\n                if (aliasToken) {\n                    importAsNode.alias = NameNode.create(aliasToken);\n                    importAsNode.alias.parent = importAsNode;\n                    extendRange(importAsNode, importAsNode.alias);\n                } else {\n                    this._addError(Localizer.Diagnostic.expectedImportAlias(), this._peekToken());\n                }\n            }\n\n            if (importAsNode.module.leadingDots > 0) {\n                this._addError(Localizer.Diagnostic.relativeImportNotAllowed(), importAsNode.module);\n            }\n\n            importNode.list.push(importAsNode);\n            importAsNode.parent = importNode;\n\n            this._importedModules.push({\n                nameNode: importAsNode.module,\n                leadingDots: importAsNode.module.leadingDots,\n                nameParts: importAsNode.module.nameParts.map((p) => p.value),\n                importedSymbols: undefined,\n            });\n\n            if (modName.nameParts.length === 1) {\n                const firstNamePartValue = modName.nameParts[0].value;\n                if (firstNamePartValue === 'typing' || firstNamePartValue === 'typing_extensions') {\n                    this._typingImportAliases.push(importAsNode.alias?.value || firstNamePartValue);\n                }\n            }\n\n            if (!this._consumeTokenIfType(TokenType.Comma)) {\n                break;\n            }\n        }\n\n        if (importNode.list.length > 0) {\n            extendRange(importNode, importNode.list[importNode.list.length - 1]);\n        }\n\n        return importNode;\n    }\n\n    // ('.' | '...')* dotted_name | ('.' | '...')+\n    // dotted_name: NAME ('.' NAME)*\n    private _parseDottedModuleName(allowJustDots = false): ModuleNameNode {\n        const moduleNameNode = ModuleNameNode.create(this._peekToken());\n\n        while (true) {\n            if (this._consumeTokenIfType(TokenType.Ellipsis)) {\n                moduleNameNode.leadingDots += 3;\n            } else if (this._consumeTokenIfType(TokenType.Dot)) {\n                moduleNameNode.leadingDots++;\n            } else {\n                break;\n            }\n        }\n\n        while (true) {\n            const identifier = this._getTokenIfIdentifier([KeywordType.Import]);\n            if (!identifier) {\n                if (!allowJustDots || moduleNameNode.leadingDots === 0) {\n                    this._addError(Localizer.Diagnostic.expectedModuleName(), this._peekToken());\n                    moduleNameNode.hasTrailingDot = true;\n                }\n                break;\n            }\n\n            const namePart = NameNode.create(identifier);\n            moduleNameNode.nameParts.push(namePart);\n            namePart.parent = moduleNameNode;\n            extendRange(moduleNameNode, namePart);\n\n            const nextToken = this._peekToken();\n            if (!this._consumeTokenIfType(TokenType.Dot)) {\n                break;\n            }\n\n            // Extend the module name to include the dot.\n            extendRange(moduleNameNode, nextToken);\n        }\n\n        return moduleNameNode;\n    }\n\n    private _parseGlobalStatement(): GlobalNode {\n        const globalToken = this._getKeywordToken(KeywordType.Global);\n\n        const globalNode = GlobalNode.create(globalToken);\n        globalNode.nameList = this._parseNameList();\n        if (globalNode.nameList.length > 0) {\n            globalNode.nameList.forEach((name) => {\n                name.parent = globalNode;\n            });\n            extendRange(globalNode, globalNode.nameList[globalNode.nameList.length - 1]);\n        }\n        return globalNode;\n    }\n\n    private _parseNonlocalStatement(): NonlocalNode {\n        const nonlocalToken = this._getKeywordToken(KeywordType.Nonlocal);\n\n        const nonlocalNode = NonlocalNode.create(nonlocalToken);\n        nonlocalNode.nameList = this._parseNameList();\n        if (nonlocalNode.nameList.length > 0) {\n            nonlocalNode.nameList.forEach((name) => {\n                name.parent = nonlocalNode;\n            });\n            extendRange(nonlocalNode, nonlocalNode.nameList[nonlocalNode.nameList.length - 1]);\n        }\n        return nonlocalNode;\n    }\n\n    private _parseNameList(): NameNode[] {\n        const nameList: NameNode[] = [];\n\n        while (true) {\n            const name = this._getTokenIfIdentifier();\n            if (!name) {\n                this._addError(Localizer.Diagnostic.expectedIdentifier(), this._peekToken());\n                break;\n            }\n\n            nameList.push(NameNode.create(name));\n\n            if (!this._consumeTokenIfType(TokenType.Comma)) {\n                break;\n            }\n        }\n\n        return nameList;\n    }\n\n    // raise_stmt: 'raise' [test ['from' test]]\n    // (old) raise_stmt: 'raise' [test [',' test [',' test]]]\n    private _parseRaiseStatement(): RaiseNode {\n        const raiseToken = this._getKeywordToken(KeywordType.Raise);\n\n        const raiseNode = RaiseNode.create(raiseToken);\n        if (!this._isNextTokenNeverExpression()) {\n            raiseNode.typeExpression = this._parseTestExpression(true);\n            raiseNode.typeExpression.parent = raiseNode;\n            extendRange(raiseNode, raiseNode.typeExpression);\n\n            if (this._consumeTokenIfKeyword(KeywordType.From)) {\n                raiseNode.valueExpression = this._parseTestExpression(true);\n                raiseNode.valueExpression.parent = raiseNode;\n                extendRange(raiseNode, raiseNode.valueExpression);\n            } else {\n                if (this._consumeTokenIfType(TokenType.Comma)) {\n                    // Handle the Python 2.x variant\n                    raiseNode.valueExpression = this._parseTestExpression(true);\n                    raiseNode.valueExpression.parent = raiseNode;\n                    extendRange(raiseNode, raiseNode.valueExpression);\n\n                    if (this._consumeTokenIfType(TokenType.Comma)) {\n                        raiseNode.tracebackExpression = this._parseTestExpression(true);\n                        raiseNode.tracebackExpression.parent = raiseNode;\n                        extendRange(raiseNode, raiseNode.tracebackExpression);\n                    }\n                }\n            }\n        }\n\n        return raiseNode;\n    }\n\n    // assert_stmt: 'assert' test [',' test]\n    private _parseAssertStatement(): AssertNode {\n        const assertToken = this._getKeywordToken(KeywordType.Assert);\n\n        const expr = this._parseTestExpression(true);\n        const assertNode = AssertNode.create(assertToken, expr);\n\n        if (this._consumeTokenIfType(TokenType.Comma)) {\n            const exceptionExpr = this._parseTestExpression(true);\n            assertNode.exceptionExpression = exceptionExpr;\n            assertNode.exceptionExpression.parent = assertNode;\n            extendRange(assertNode, exceptionExpr);\n        }\n\n        return assertNode;\n    }\n\n    // del_stmt: 'del' exprlist\n    private _parseDelStatement(): DelNode {\n        const delToken = this._getKeywordToken(KeywordType.Del);\n\n        const exprListResult = this._parseExpressionList(true);\n        if (!exprListResult.parseError && exprListResult.list.length === 0) {\n            this._addError(Localizer.Diagnostic.expectedDelExpr(), this._peekToken());\n        }\n        const delNode = DelNode.create(delToken);\n        delNode.expressions = exprListResult.list;\n        if (delNode.expressions.length > 0) {\n            delNode.expressions.forEach((expr) => {\n                expr.parent = delNode;\n            });\n            extendRange(delNode, delNode.expressions[delNode.expressions.length - 1]);\n        }\n        return delNode;\n    }\n\n    // yield_expr: 'yield' [yield_arg]\n    // yield_arg: 'from' test | testlist\n    private _parseYieldExpression(): YieldNode | YieldFromNode {\n        const yieldToken = this._getKeywordToken(KeywordType.Yield);\n\n        const nextToken = this._peekToken();\n        if (this._consumeTokenIfKeyword(KeywordType.From)) {\n            if (this._getLanguageVersion() < PythonVersion.V3_3) {\n                this._addError(Localizer.Diagnostic.yieldFromIllegal(), nextToken);\n            }\n            return YieldFromNode.create(yieldToken, this._parseTestExpression(true));\n        }\n\n        let exprList: ExpressionNode | undefined;\n        if (!this._isNextTokenNeverExpression()) {\n            exprList = this._parseTestOrStarListAsExpression(\n                /* allowAssignmentExpression */ true,\n                ErrorExpressionCategory.MissingExpression,\n                Localizer.Diagnostic.expectedYieldExpr()\n            );\n            this._reportConditionalErrorForStarTupleElement(exprList);\n        }\n\n        return YieldNode.create(yieldToken, exprList);\n    }\n\n    private _tryParseYieldExpression(): YieldNode | YieldFromNode | undefined {\n        if (this._peekKeywordType() !== KeywordType.Yield) {\n            return undefined;\n        }\n\n        return this._parseYieldExpression();\n    }\n\n    // simple_stmt: small_stmt (';' small_stmt)* [';'] NEWLINE\n    private _parseSimpleStatement(): StatementListNode {\n        const statement = StatementListNode.create(this._peekToken());\n\n        while (true) {\n            // Swallow invalid tokens to make sure we make forward progress.\n            if (this._peekTokenType() === TokenType.Invalid) {\n                const invalidToken = this._getNextToken();\n                const text = this._fileContents!.substr(invalidToken.start, invalidToken.length);\n\n                // Remove any non-printable characters.\n                const cleanedText = text.replace(/[\\S\\W]/g, '');\n                this._addError(Localizer.Diagnostic.invalidTokenChars().format({ text: cleanedText }), invalidToken);\n                this._consumeTokensUntilType([TokenType.NewLine]);\n                break;\n            }\n\n            const smallStatement = this._parseSmallStatement();\n            statement.statements.push(smallStatement);\n            smallStatement.parent = statement;\n            extendRange(statement, smallStatement);\n\n            if (smallStatement.nodeType === ParseNodeType.Error) {\n                // No need to log an error here. We assume that\n                // it was already logged by _parseSmallStatement.\n                break;\n            }\n\n            // Consume the semicolon if present.\n            if (!this._consumeTokenIfType(TokenType.Semicolon)) {\n                break;\n            }\n\n            const nextTokenType = this._peekTokenType();\n            if (nextTokenType === TokenType.NewLine || nextTokenType === TokenType.EndOfStream) {\n                break;\n            }\n        }\n\n        if (!this._consumeTokenIfType(TokenType.NewLine)) {\n            this._addError(Localizer.Diagnostic.expectedNewlineOrSemicolon(), this._peekToken());\n        }\n\n        return statement;\n    }\n\n    // small_stmt: (expr_stmt | del_stmt | pass_stmt | flow_stmt |\n    //             import_stmt | global_stmt | nonlocal_stmt | assert_stmt)\n    // flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt | yield_stmt\n    // import_stmt: import_name | import_from\n    private _parseSmallStatement(): ParseNode {\n        switch (this._peekKeywordType()) {\n            case KeywordType.Pass:\n                return this._parsePassStatement();\n\n            case KeywordType.Break:\n                return this._parseBreakStatement();\n\n            case KeywordType.Continue:\n                return this._parseContinueStatement();\n\n            case KeywordType.Return:\n                return this._parseReturnStatement();\n\n            case KeywordType.From:\n                return this._parseFromStatement();\n\n            case KeywordType.Import:\n                return this._parseImportStatement();\n\n            case KeywordType.Global:\n                return this._parseGlobalStatement();\n\n            case KeywordType.Nonlocal:\n                return this._parseNonlocalStatement();\n\n            case KeywordType.Raise:\n                return this._parseRaiseStatement();\n\n            case KeywordType.Assert:\n                return this._parseAssertStatement();\n\n            case KeywordType.Del:\n                return this._parseDelStatement();\n\n            case KeywordType.Yield:\n                return this._parseYieldExpression();\n        }\n\n        return this._parseExpressionStatement();\n    }\n\n    private _makeExpressionOrTuple(exprListResult: ExpressionListResult, enclosedInParens: boolean): ExpressionNode {\n        // A single-element tuple with no trailing comma is simply an expression\n        // that's surrounded by parens.\n        if (exprListResult.list.length === 1 && !exprListResult.trailingComma) {\n            return exprListResult.list[0];\n        }\n\n        // To accommodate empty tuples (\"()\"), we will reach back to get\n        // the opening parenthesis as the opening token.\n\n        const tupleStartRange: TextRange =\n            exprListResult.list.length > 0 ? exprListResult.list[0] : this._peekToken(-1);\n\n        const tupleNode = TupleNode.create(tupleStartRange, enclosedInParens);\n        tupleNode.expressions = exprListResult.list;\n        if (exprListResult.list.length > 0) {\n            exprListResult.list.forEach((expr) => {\n                expr.parent = tupleNode;\n            });\n            extendRange(tupleNode, exprListResult.list[exprListResult.list.length - 1]);\n        }\n\n        return tupleNode;\n    }\n\n    private _parseTestListAsExpression(errorCategory: ErrorExpressionCategory, errorString: string): ExpressionNode {\n        if (this._isNextTokenNeverExpression()) {\n            return this._handleExpressionParseError(errorCategory, errorString);\n        }\n\n        const exprListResult = this._parseTestExpressionList();\n        if (exprListResult.parseError) {\n            return exprListResult.parseError;\n        }\n        return this._makeExpressionOrTuple(exprListResult, /* enclosedInParens */ false);\n    }\n\n    private _parseTestOrStarListAsExpression(\n        allowAssignmentExpression: boolean,\n        errorCategory: ErrorExpressionCategory,\n        errorString: string\n    ): ExpressionNode {\n        if (this._isNextTokenNeverExpression()) {\n            return this._handleExpressionParseError(errorCategory, errorString);\n        }\n\n        const exprListResult = this._parseTestOrStarExpressionList(allowAssignmentExpression);\n        if (exprListResult.parseError) {\n            return exprListResult.parseError;\n        }\n        return this._makeExpressionOrTuple(exprListResult, /* enclosedInParens */ false);\n    }\n\n    private _parseExpressionList(allowStar: boolean): ExpressionListResult {\n        return this._parseExpressionListGeneric(() => this._parseExpression(allowStar));\n    }\n\n    // testlist: test (',' test)* [',']\n    private _parseTestExpressionList(): ExpressionListResult {\n        return this._parseExpressionListGeneric(() => this._parseTestExpression(false));\n    }\n\n    private _parseTestOrStarExpressionList(allowAssignmentExpression: boolean): ExpressionListResult {\n        const exprListResult = this._parseExpressionListGeneric(() =>\n            this._parseTestOrStarExpression(allowAssignmentExpression)\n        );\n\n        if (!exprListResult.parseError) {\n            // Make sure that we don't have more than one star expression in the list.\n            let sawStar = false;\n            for (const expr of exprListResult.list) {\n                if (expr.nodeType === ParseNodeType.Unpack) {\n                    if (sawStar) {\n                        this._addError(Localizer.Diagnostic.duplicateUnpack(), expr);\n                        break;\n                    }\n                    sawStar = true;\n                }\n            }\n        }\n\n        return exprListResult;\n    }\n\n    // exp_or_star: expr | star_expr\n    // expr: xor_expr ('|' xor_expr)*\n    // star_expr: '*' expr\n    private _parseExpression(allowUnpack: boolean): ExpressionNode {\n        const startToken = this._peekToken();\n\n        if (allowUnpack && this._consumeTokenIfOperator(OperatorType.Multiply)) {\n            return UnpackNode.create(startToken, this._parseExpression(false));\n        }\n\n        return this._parseBitwiseOrExpression();\n    }\n\n    // test_or_star: test | star_expr\n    private _parseTestOrStarExpression(allowAssignmentExpression: boolean): ExpressionNode {\n        if (this._peekOperatorType() === OperatorType.Multiply) {\n            return this._parseExpression(true);\n        }\n\n        return this._parseTestExpression(allowAssignmentExpression);\n    }\n\n    // test: or_test ['if' or_test 'else' test] | lambdef\n    private _parseTestExpression(allowAssignmentExpression: boolean): ExpressionNode {\n        if (this._peekKeywordType() === KeywordType.Lambda) {\n            return this._parseLambdaExpression();\n        }\n\n        const ifExpr = allowAssignmentExpression ? this._parseAssignmentExpression() : this._parseOrTest();\n        if (ifExpr.nodeType === ParseNodeType.Error) {\n            return ifExpr;\n        }\n\n        if (!this._consumeTokenIfKeyword(KeywordType.If)) {\n            return ifExpr;\n        }\n\n        const testExpr = this._parseAssignmentExpression();\n        if (testExpr.nodeType === ParseNodeType.Error) {\n            return testExpr;\n        }\n\n        if (!this._consumeTokenIfKeyword(KeywordType.Else)) {\n            return this._handleExpressionParseError(\n                ErrorExpressionCategory.MissingElse,\n                Localizer.Diagnostic.expectedElse()\n            );\n        }\n\n        const elseExpr = this._parseTestExpression(true);\n        if (elseExpr.nodeType === ParseNodeType.Error) {\n            return elseExpr;\n        }\n\n        return TernaryNode.create(ifExpr, testExpr, elseExpr);\n    }\n\n    // assign_expr: NAME := test\n    private _parseAssignmentExpression() {\n        const leftExpr = this._parseOrTest();\n        if (leftExpr.nodeType === ParseNodeType.Error) {\n            return leftExpr;\n        }\n\n        if (leftExpr.nodeType !== ParseNodeType.Name) {\n            return leftExpr;\n        }\n\n        const walrusToken = this._peekToken();\n        if (!this._consumeTokenIfOperator(OperatorType.Walrus)) {\n            return leftExpr;\n        }\n\n        if (!this._assignmentExpressionsAllowed) {\n            this._addError(Localizer.Diagnostic.walrusNotAllowed(), walrusToken);\n        }\n\n        if (this._getLanguageVersion() < PythonVersion.V3_8) {\n            this._addError(Localizer.Diagnostic.walrusIllegal(), walrusToken);\n        }\n\n        const rightExpr = this._parseTestExpression(/* allowAssignmentExpression */ false);\n\n        return AssignmentExpressionNode.create(leftExpr, rightExpr);\n    }\n\n    // or_test: and_test ('or' and_test)*\n    private _parseOrTest(): ExpressionNode {\n        let leftExpr = this._parseAndTest();\n        if (leftExpr.nodeType === ParseNodeType.Error) {\n            return leftExpr;\n        }\n\n        while (true) {\n            const peekToken = this._peekToken();\n            if (!this._consumeTokenIfKeyword(KeywordType.Or)) {\n                break;\n            }\n            const rightExpr = this._parseAndTest();\n            leftExpr = BinaryOperationNode.create(leftExpr, rightExpr, peekToken, OperatorType.Or);\n        }\n\n        return leftExpr;\n    }\n\n    // and_test: not_test ('and' not_test)*\n    private _parseAndTest(): ExpressionNode {\n        let leftExpr = this._parseNotTest();\n        if (leftExpr.nodeType === ParseNodeType.Error) {\n            return leftExpr;\n        }\n\n        while (true) {\n            const peekToken = this._peekToken();\n            if (!this._consumeTokenIfKeyword(KeywordType.And)) {\n                break;\n            }\n            const rightExpr = this._parseNotTest();\n            leftExpr = BinaryOperationNode.create(leftExpr, rightExpr, peekToken, OperatorType.And);\n        }\n\n        return leftExpr;\n    }\n\n    // not_test: 'not' not_test | comparison\n    private _parseNotTest(): ExpressionNode {\n        const notToken = this._peekToken();\n        if (this._consumeTokenIfKeyword(KeywordType.Not)) {\n            const notExpr = this._parseNotTest();\n            return UnaryOperationNode.create(notToken, notExpr, OperatorType.Not);\n        }\n\n        return this._parseComparison();\n    }\n\n    // comparison: expr (comp_op expr)*\n    // comp_op: '<'|'>'|'=='|'>='|'<='|'<>'|'!='|'in'|'not' 'in'|'is'|'is' 'not'\n    private _parseComparison(): ExpressionNode {\n        let leftExpr = this._parseBitwiseOrExpression();\n        if (leftExpr.nodeType === ParseNodeType.Error) {\n            return leftExpr;\n        }\n\n        while (true) {\n            let comparisonOperator: OperatorType | undefined;\n            const peekToken = this._peekToken();\n\n            if (Tokenizer.isOperatorComparison(this._peekOperatorType())) {\n                comparisonOperator = this._peekOperatorType();\n                if (comparisonOperator === OperatorType.LessOrGreaterThan) {\n                    this._addError(Localizer.Diagnostic.operatorLessOrGreaterDeprecated(), peekToken);\n                    comparisonOperator = OperatorType.NotEquals;\n                }\n                this._getNextToken();\n            } else if (this._consumeTokenIfKeyword(KeywordType.In)) {\n                comparisonOperator = OperatorType.In;\n            } else if (this._consumeTokenIfKeyword(KeywordType.Is)) {\n                if (this._consumeTokenIfKeyword(KeywordType.Not)) {\n                    comparisonOperator = OperatorType.IsNot;\n                } else {\n                    comparisonOperator = OperatorType.Is;\n                }\n            } else if (this._peekKeywordType() === KeywordType.Not) {\n                const tokenAfterNot = this._peekToken(1);\n                if (\n                    tokenAfterNot.type === TokenType.Keyword &&\n                    (tokenAfterNot as KeywordToken).keywordType === KeywordType.In\n                ) {\n                    this._getNextToken();\n                    this._getNextToken();\n                    comparisonOperator = OperatorType.NotIn;\n                }\n            }\n\n            if (comparisonOperator === undefined) {\n                break;\n            }\n\n            const rightExpr = this._parseBitwiseOrExpression();\n            leftExpr = BinaryOperationNode.create(leftExpr, rightExpr, peekToken, comparisonOperator);\n        }\n\n        return leftExpr;\n    }\n\n    // expr: xor_expr ('|' xor_expr)*\n    private _parseBitwiseOrExpression(): ExpressionNode {\n        let leftExpr = this._parseBitwiseXorExpression();\n        if (leftExpr.nodeType === ParseNodeType.Error) {\n            return leftExpr;\n        }\n\n        while (true) {\n            const peekToken = this._peekToken();\n            if (!this._consumeTokenIfOperator(OperatorType.BitwiseOr)) {\n                break;\n            }\n            const rightExpr = this._parseBitwiseXorExpression();\n            leftExpr = BinaryOperationNode.create(leftExpr, rightExpr, peekToken, OperatorType.BitwiseOr);\n        }\n\n        return leftExpr;\n    }\n\n    // xor_expr: and_expr ('^' and_expr)*\n    private _parseBitwiseXorExpression(): ExpressionNode {\n        let leftExpr = this._parseBitwiseAndExpression();\n        if (leftExpr.nodeType === ParseNodeType.Error) {\n            return leftExpr;\n        }\n\n        while (true) {\n            const peekToken = this._peekToken();\n            if (!this._consumeTokenIfOperator(OperatorType.BitwiseXor)) {\n                break;\n            }\n            const rightExpr = this._parseBitwiseAndExpression();\n            leftExpr = BinaryOperationNode.create(leftExpr, rightExpr, peekToken, OperatorType.BitwiseXor);\n        }\n\n        return leftExpr;\n    }\n\n    // and_expr: shift_expr ('&' shift_expr)*\n    private _parseBitwiseAndExpression(): ExpressionNode {\n        let leftExpr = this._parseShiftExpression();\n        if (leftExpr.nodeType === ParseNodeType.Error) {\n            return leftExpr;\n        }\n\n        while (true) {\n            const peekToken = this._peekToken();\n            if (!this._consumeTokenIfOperator(OperatorType.BitwiseAnd)) {\n                break;\n            }\n            const rightExpr = this._parseShiftExpression();\n            leftExpr = BinaryOperationNode.create(leftExpr, rightExpr, peekToken, OperatorType.BitwiseAnd);\n        }\n\n        return leftExpr;\n    }\n\n    // shift_expr: arith_expr (('<<'|'>>') arith_expr)*\n    private _parseShiftExpression(): ExpressionNode {\n        let leftExpr = this._parseArithmeticExpression();\n        if (leftExpr.nodeType === ParseNodeType.Error) {\n            return leftExpr;\n        }\n\n        let peekToken = this._peekToken();\n        let nextOperator = this._peekOperatorType();\n        while (nextOperator === OperatorType.LeftShift || nextOperator === OperatorType.RightShift) {\n            this._getNextToken();\n            const rightExpr = this._parseArithmeticExpression();\n            leftExpr = BinaryOperationNode.create(leftExpr, rightExpr, peekToken, nextOperator);\n            peekToken = this._peekToken();\n            nextOperator = this._peekOperatorType();\n        }\n\n        return leftExpr;\n    }\n\n    // arith_expr: term (('+'|'-') term)*\n    private _parseArithmeticExpression(): ExpressionNode {\n        let leftExpr = this._parseArithmeticTerm();\n        if (leftExpr.nodeType === ParseNodeType.Error) {\n            return leftExpr;\n        }\n\n        let peekToken = this._peekToken();\n        let nextOperator = this._peekOperatorType();\n        while (nextOperator === OperatorType.Add || nextOperator === OperatorType.Subtract) {\n            this._getNextToken();\n            const rightExpr = this._parseArithmeticTerm();\n            if (rightExpr.nodeType === ParseNodeType.Error) {\n                return rightExpr;\n            }\n\n            leftExpr = BinaryOperationNode.create(leftExpr, rightExpr, peekToken, nextOperator);\n            peekToken = this._peekToken();\n            nextOperator = this._peekOperatorType();\n        }\n\n        return leftExpr;\n    }\n\n    // term: factor (('*'|'@'|'/'|'%'|'//') factor)*\n    private _parseArithmeticTerm(): ExpressionNode {\n        let leftExpr = this._parseArithmeticFactor();\n        if (leftExpr.nodeType === ParseNodeType.Error) {\n            return leftExpr;\n        }\n\n        let peekToken = this._peekToken();\n        let nextOperator = this._peekOperatorType();\n        while (\n            nextOperator === OperatorType.Multiply ||\n            nextOperator === OperatorType.MatrixMultiply ||\n            nextOperator === OperatorType.Divide ||\n            nextOperator === OperatorType.Mod ||\n            nextOperator === OperatorType.FloorDivide\n        ) {\n            this._getNextToken();\n            const rightExpr = this._parseArithmeticFactor();\n            leftExpr = BinaryOperationNode.create(leftExpr, rightExpr, peekToken, nextOperator);\n            peekToken = this._peekToken();\n            nextOperator = this._peekOperatorType();\n        }\n\n        return leftExpr;\n    }\n\n    // factor: ('+'|'-'|'~') factor | power\n    // power: atom_expr ['**' factor]\n    private _parseArithmeticFactor(): ExpressionNode {\n        const nextToken = this._peekToken();\n        const nextOperator = this._peekOperatorType();\n        if (\n            nextOperator === OperatorType.Add ||\n            nextOperator === OperatorType.Subtract ||\n            nextOperator === OperatorType.BitwiseInvert\n        ) {\n            this._getNextToken();\n            const expression = this._parseArithmeticFactor();\n            return UnaryOperationNode.create(nextToken, expression, nextOperator);\n        }\n\n        const leftExpr = this._parseAtomExpression();\n        if (leftExpr.nodeType === ParseNodeType.Error) {\n            return leftExpr;\n        }\n\n        const peekToken = this._peekToken();\n        if (this._consumeTokenIfOperator(OperatorType.Power)) {\n            const rightExpr = this._parseArithmeticFactor();\n            return BinaryOperationNode.create(leftExpr, rightExpr, peekToken, OperatorType.Power);\n        }\n\n        return leftExpr;\n    }\n\n    // Determines whether the expression refers to a type exported by the typing\n    // or typing_extensions modules. We can directly evaluate the types at binding\n    // time. We assume here that the code isn't making use of some custom type alias\n    // to refer to the typing types.\n    private _isTypingAnnotation(typeAnnotation: ExpressionNode, name: string): boolean {\n        if (typeAnnotation.nodeType === ParseNodeType.Name) {\n            const alias = this._typingSymbolAliases.get(typeAnnotation.value);\n            if (alias === name) {\n                return true;\n            }\n        } else if (typeAnnotation.nodeType === ParseNodeType.MemberAccess) {\n            if (\n                typeAnnotation.leftExpression.nodeType === ParseNodeType.Name &&\n                typeAnnotation.memberName.value === name\n            ) {\n                const baseName = typeAnnotation.leftExpression.value;\n                return this._typingImportAliases.some((alias) => alias === baseName);\n            }\n        }\n\n        return false;\n    }\n\n    // atom_expr: ['await'] atom trailer*\n    // trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME\n    private _parseAtomExpression(): ExpressionNode {\n        let awaitToken: KeywordToken | undefined;\n        if (this._peekKeywordType() === KeywordType.Await && !this._isParsingTypeAnnotation) {\n            awaitToken = this._getKeywordToken(KeywordType.Await);\n            if (this._getLanguageVersion() < PythonVersion.V3_5) {\n                this._addError(Localizer.Diagnostic.awaitIllegal(), awaitToken);\n            }\n        }\n\n        let atomExpression = this._parseAtom();\n        if (atomExpression.nodeType === ParseNodeType.Error) {\n            return atomExpression;\n        }\n\n        // Consume trailers.\n        while (true) {\n            const nextToken = this._peekToken();\n\n            // Is it a function call?\n            if (this._consumeTokenIfType(TokenType.OpenParenthesis)) {\n                // Generally, function calls are not allowed within type annotations,\n                // but they are permitted in \"Annotated\" annotations.\n                const wasParsingTypeAnnotation = this._isParsingTypeAnnotation;\n                this._isParsingTypeAnnotation = false;\n\n                const argList = this._parseArgList();\n                const callNode = CallNode.create(atomExpression);\n                callNode.arguments = argList;\n                if (argList.length > 0) {\n                    argList.forEach((arg) => {\n                        arg.parent = callNode;\n                    });\n                    extendRange(callNode, argList[argList.length - 1]);\n                }\n\n                const nextToken = this._peekToken();\n                let isArgListTerminated = false;\n                if (!this._consumeTokenIfType(TokenType.CloseParenthesis)) {\n                    this._addError(Localizer.Diagnostic.expectedCloseParen(), this._peekToken());\n\n                    // Consume the remainder of tokens on the line for error\n                    // recovery.\n                    this._consumeTokensUntilType([TokenType.NewLine]);\n\n                    // Extend the node's range to include the rest of the line.\n                    // This helps the signatureHelpProvider.\n                    extendRange(callNode, this._peekToken());\n                } else {\n                    extendRange(callNode, nextToken);\n                    isArgListTerminated = true;\n                }\n\n                this._isParsingTypeAnnotation = wasParsingTypeAnnotation;\n\n                if (this._isParsingTypeAnnotation) {\n                    const diag = new DiagnosticAddendum();\n                    if (atomExpression.nodeType === ParseNodeType.Name && atomExpression.value === 'type') {\n                        diag.addMessage(Localizer.DiagnosticAddendum.useTypeInstead());\n                        this._addError(Localizer.Diagnostic.typeCallNotAllowed() + diag.getString(), callNode);\n                    }\n                }\n\n                atomExpression = callNode;\n\n                // If the argument list wasn't terminated, break out of the loop\n                if (!isArgListTerminated) {\n                    break;\n                }\n            } else if (this._consumeTokenIfType(TokenType.OpenBracket)) {\n                // Is it an index operator?\n\n                // This is an unfortunate hack that's necessary to accommodate 'Literal'\n                // type annotations properly. We need to suspend treating strings as\n                // type annotations within a Literal subscript. Note that the code previously\n                // looked for \"typing.Literal\", but someone submitted a bug report because\n                // they were using an aliased version of 'typing'.\n                const isLiteralSubscript = this._isTypingAnnotation(atomExpression, 'Literal');\n                const wasParsingIndexTrailer = this._isParsingIndexTrailer;\n                const wasParsingTypeAnnotation = this._isParsingTypeAnnotation;\n                if (isLiteralSubscript) {\n                    this._isParsingTypeAnnotation = false;\n                }\n                this._isParsingIndexTrailer = true;\n                const indexExpressions = this._parseSubscriptList();\n                this._isParsingTypeAnnotation = wasParsingTypeAnnotation;\n                this._isParsingIndexTrailer = wasParsingIndexTrailer;\n\n                const closingToken = this._peekToken();\n                const indexItemsNode = IndexItemsNode.create(nextToken, closingToken, indexExpressions);\n                const indexNode = IndexNode.create(atomExpression, indexItemsNode);\n                extendRange(indexNode, indexNode);\n\n                if (!this._consumeTokenIfType(TokenType.CloseBracket)) {\n                    // Handle the error case, but don't use the error node in this\n                    // case because it creates problems for the completion provider.\n                    this._handleExpressionParseError(\n                        ErrorExpressionCategory.MissingIndexCloseBracket,\n                        Localizer.Diagnostic.expectedCloseBracket(),\n                        indexNode\n                    );\n                }\n\n                atomExpression = indexNode;\n            } else if (this._consumeTokenIfType(TokenType.Dot)) {\n                // Is it a member access?\n                const memberName = this._getTokenIfIdentifier();\n                if (!memberName) {\n                    return this._handleExpressionParseError(\n                        ErrorExpressionCategory.MissingMemberAccessName,\n                        Localizer.Diagnostic.expectedMemberName(),\n                        atomExpression\n                    );\n                }\n                atomExpression = MemberAccessNode.create(atomExpression, NameNode.create(memberName));\n            } else {\n                break;\n            }\n        }\n\n        if (awaitToken) {\n            return AwaitNode.create(awaitToken, atomExpression);\n        }\n\n        return atomExpression;\n    }\n\n    // subscriptlist: subscript (',' subscript)* [',']\n    private _parseSubscriptList(): ExpressionNode[] {\n        const listResult = this._parseExpressionListGeneric(\n            () => this._parseSubscript(),\n            () => {\n                // Override the normal terminal check to exclude colons,\n                // which are a valid way to start subscription expressions.\n                if (this._peekTokenType() === TokenType.Colon) {\n                    return false;\n                }\n                return this._isNextTokenNeverExpression();\n            }\n        );\n\n        if (listResult.parseError) {\n            return [listResult.parseError];\n        }\n\n        if (listResult.list.length === 0) {\n            return [\n                this._handleExpressionParseError(\n                    ErrorExpressionCategory.MissingIndexOrSlice,\n                    Localizer.Diagnostic.expectedSliceIndex()\n                ),\n            ];\n        }\n\n        return listResult.list;\n    }\n\n    // subscript: test | [test] ':' [test] [sliceop]\n    // sliceop: ':' [test]\n    private _parseSubscript(): ExpressionNode {\n        const firstToken = this._peekToken();\n        const sliceExpressions: (ExpressionNode | undefined)[] = [undefined, undefined, undefined];\n        let sliceIndex = 0;\n        let sawColon = false;\n\n        while (true) {\n            const nextTokenType = this._peekTokenType();\n            if (nextTokenType === TokenType.CloseBracket || nextTokenType === TokenType.Comma) {\n                break;\n            }\n\n            if (nextTokenType !== TokenType.Colon) {\n                sliceExpressions[sliceIndex] = this._parseTestExpression(false);\n            }\n            sliceIndex++;\n\n            if (sliceIndex >= 3 || !this._consumeTokenIfType(TokenType.Colon)) {\n                break;\n            }\n            sawColon = true;\n        }\n\n        // If this was a simple expression with no colons return it.\n        if (!sawColon) {\n            return sliceExpressions[0]!;\n        }\n\n        const sliceNode = SliceNode.create(firstToken);\n        sliceNode.startValue = sliceExpressions[0];\n        if (sliceNode.startValue) {\n            sliceNode.startValue.parent = sliceNode;\n        }\n        sliceNode.endValue = sliceExpressions[1];\n        if (sliceNode.endValue) {\n            sliceNode.endValue.parent = sliceNode;\n        }\n        sliceNode.stepValue = sliceExpressions[2];\n        if (sliceNode.stepValue) {\n            sliceNode.stepValue.parent = sliceNode;\n        }\n        const extension = sliceExpressions[2] || sliceExpressions[1] || sliceExpressions[0];\n        if (extension) {\n            extendRange(sliceNode, extension);\n        }\n\n        return sliceNode;\n    }\n\n    // arglist: argument (',' argument)*  [',']\n    private _parseArgList(): ArgumentNode[] {\n        const argList: ArgumentNode[] = [];\n        let sawKeywordArg = false;\n\n        while (true) {\n            const nextTokenType = this._peekTokenType();\n            if (\n                nextTokenType === TokenType.CloseParenthesis ||\n                nextTokenType === TokenType.NewLine ||\n                nextTokenType === TokenType.EndOfStream\n            ) {\n                break;\n            }\n\n            const arg = this._parseArgument();\n            if (arg.name) {\n                sawKeywordArg = true;\n            } else if (sawKeywordArg && arg.argumentCategory === ArgumentCategory.Simple) {\n                this._addError(Localizer.Diagnostic.positionArgAfterNamedArg(), arg);\n            }\n            argList.push(arg);\n\n            if (!this._consumeTokenIfType(TokenType.Comma)) {\n                break;\n            }\n        }\n\n        return argList;\n    }\n\n    // argument: ( test [comp_for] |\n    //             test '=' test |\n    //             '**' test |\n    //             '*' test )\n    private _parseArgument(): ArgumentNode {\n        const firstToken = this._peekToken();\n\n        let argType = ArgumentCategory.Simple;\n        if (this._consumeTokenIfOperator(OperatorType.Multiply)) {\n            argType = ArgumentCategory.UnpackedList;\n        } else if (this._consumeTokenIfOperator(OperatorType.Power)) {\n            argType = ArgumentCategory.UnpackedDictionary;\n        }\n\n        let valueExpr = this._parseTestExpression(true);\n        let nameIdentifier: IdentifierToken | undefined;\n\n        if (argType === ArgumentCategory.Simple) {\n            if (this._consumeTokenIfOperator(OperatorType.Assign)) {\n                const nameExpr = valueExpr;\n                valueExpr = this._parseTestExpression(false);\n\n                if (nameExpr.nodeType === ParseNodeType.Name) {\n                    nameIdentifier = nameExpr.token;\n                } else {\n                    this._addError(Localizer.Diagnostic.expectedParamName(), nameExpr);\n                }\n            } else {\n                const listComp = this._tryParseListComprehension(valueExpr);\n                if (listComp) {\n                    valueExpr = listComp;\n                }\n            }\n        }\n\n        const argNode = ArgumentNode.create(firstToken, valueExpr, argType);\n        if (nameIdentifier) {\n            argNode.name = NameNode.create(nameIdentifier);\n            argNode.name.parent = argNode;\n        }\n\n        return argNode;\n    }\n\n    // atom: ('(' [yield_expr | testlist_comp] ')' |\n    //     '[' [testlist_comp] ']' |\n    //     '{' [dictorsetmaker] '}' |\n    //     NAME | NUMBER | STRING+ | '...' | 'None' | 'True' | 'False' | '__debug__')\n    private _parseAtom(): ExpressionNode {\n        const nextToken = this._peekToken();\n\n        if (nextToken.type === TokenType.Ellipsis) {\n            return EllipsisNode.create(this._getNextToken());\n        }\n\n        if (nextToken.type === TokenType.Number) {\n            return NumberNode.create(this._getNextToken() as NumberToken);\n        }\n\n        if (nextToken.type === TokenType.Identifier) {\n            return NameNode.create(this._getNextToken() as IdentifierToken);\n        }\n\n        if (nextToken.type === TokenType.String) {\n            return this._parseStringList();\n        }\n\n        if (nextToken.type === TokenType.Backtick) {\n            this._getNextToken();\n\n            // Atoms with backticks are no longer allowed in Python 3.x, but they\n            // were a thing in Python 2.x. We'll parse them to improve parse recovery\n            // and emit an error.\n            this._addError(Localizer.Diagnostic.backticksIllegal(), nextToken);\n\n            const expressionNode = this._parseTestListAsExpression(\n                ErrorExpressionCategory.MissingExpression,\n                Localizer.Diagnostic.expectedExpr()\n            );\n\n            this._consumeTokenIfType(TokenType.Backtick);\n            return expressionNode;\n        }\n\n        if (nextToken.type === TokenType.OpenParenthesis) {\n            const possibleTupleNode = this._parseTupleAtom();\n            if (\n                possibleTupleNode.nodeType === ParseNodeType.Tuple &&\n                this._isParsingTypeAnnotation &&\n                !this._isParsingIndexTrailer\n            ) {\n                // This is allowed inside of an index trailer, specifically\n                // to support Tuple[()], which is the documented way to annotate\n                // a zero-length tuple.\n                const diag = new DiagnosticAddendum();\n                diag.addMessage(Localizer.DiagnosticAddendum.useTupleInstead());\n                this._addError(Localizer.Diagnostic.tupleInAnnotation() + diag.getString(), possibleTupleNode);\n            }\n\n            if (possibleTupleNode.nodeType === ParseNodeType.BinaryOperation) {\n                // Mark the binary expression as parenthesized so we don't attempt\n                // to use comparison chaining, which isn't appropriate when the\n                // expression is parenthesized.\n                possibleTupleNode.parenthesized = true;\n            }\n            return possibleTupleNode;\n        } else if (nextToken.type === TokenType.OpenBracket) {\n            const listNode = this._parseListAtom();\n            if (this._isParsingTypeAnnotation && !this._isParsingIndexTrailer) {\n                const diag = new DiagnosticAddendum();\n                diag.addMessage(Localizer.DiagnosticAddendum.useListInstead());\n                this._addError(Localizer.Diagnostic.listInAnnotation() + diag.getString(), listNode);\n            }\n            return listNode;\n        } else if (nextToken.type === TokenType.OpenCurlyBrace) {\n            const dictNode = this._parseDictionaryOrSetAtom();\n            if (this._isParsingTypeAnnotation) {\n                const diag = new DiagnosticAddendum();\n                diag.addMessage(Localizer.DiagnosticAddendum.useDictInstead());\n                this._addError(Localizer.Diagnostic.dictInAnnotation() + diag.getString(), dictNode);\n            }\n            return dictNode;\n        }\n\n        if (nextToken.type === TokenType.Keyword) {\n            const keywordToken = nextToken as KeywordToken;\n            if (\n                keywordToken.keywordType === KeywordType.False ||\n                keywordToken.keywordType === KeywordType.True ||\n                keywordToken.keywordType === KeywordType.Debug ||\n                keywordToken.keywordType === KeywordType.None\n            ) {\n                return ConstantNode.create(this._getNextToken() as KeywordToken);\n            }\n\n            // Make an identifier out of the keyword.\n            const keywordAsIdentifier = this._getTokenIfIdentifier();\n            if (keywordAsIdentifier) {\n                return NameNode.create(keywordAsIdentifier);\n            }\n        }\n\n        return this._handleExpressionParseError(\n            ErrorExpressionCategory.MissingExpression,\n            Localizer.Diagnostic.expectedExpr()\n        );\n    }\n\n    // Allocates a dummy \"error expression\" and consumes the remainder\n    // of the tokens on the line for error recovery. A partially-completed\n    // child node can be passed to help the completion provider determine\n    // what to do.\n    private _handleExpressionParseError(\n        category: ErrorExpressionCategory,\n        errorMsg: string,\n        childNode?: ExpressionNode\n    ): ErrorNode {\n        this._addError(errorMsg, this._peekToken());\n        const expr = ErrorNode.create(this._peekToken(), category, childNode);\n        this._consumeTokensUntilType([TokenType.NewLine]);\n        return expr;\n    }\n\n    // lambdef: 'lambda' [varargslist] ':' test\n    private _parseLambdaExpression(allowConditional = true): LambdaNode {\n        const lambdaToken = this._getKeywordToken(KeywordType.Lambda);\n\n        const argList = this._parseVarArgsList(TokenType.Colon, /* allowAnnotations */ false);\n\n        if (!this._consumeTokenIfType(TokenType.Colon)) {\n            this._addError(Localizer.Diagnostic.expectedColon(), this._peekToken());\n        }\n\n        let testExpr: ExpressionNode;\n        if (allowConditional) {\n            testExpr = this._parseTestExpression(false);\n        } else {\n            testExpr = this._tryParseLambdaExpression(false) || this._parseOrTest();\n        }\n\n        const lambdaNode = LambdaNode.create(lambdaToken, testExpr);\n        lambdaNode.parameters = argList;\n        argList.forEach((arg) => {\n            arg.parent = lambdaNode;\n        });\n        return lambdaNode;\n    }\n\n    private _tryParseLambdaExpression(allowConditional = true): LambdaNode | undefined {\n        if (this._peekKeywordType() !== KeywordType.Lambda) {\n            return undefined;\n        }\n\n        return this._parseLambdaExpression(allowConditional);\n    }\n\n    // ('(' [yield_expr | testlist_comp] ')'\n    // testlist_comp: (test | star_expr) (comp_for | (',' (test | star_expr))* [','])\n    private _parseTupleAtom(): ExpressionNode {\n        const startParen = this._getNextToken();\n        assert(startParen.type === TokenType.OpenParenthesis);\n\n        const yieldExpr = this._tryParseYieldExpression();\n        if (yieldExpr) {\n            if (this._peekTokenType() !== TokenType.CloseParenthesis) {\n                return this._handleExpressionParseError(\n                    ErrorExpressionCategory.MissingTupleCloseParen,\n                    Localizer.Diagnostic.expectedCloseParen()\n                );\n            } else {\n                extendRange(yieldExpr, this._getNextToken());\n            }\n\n            return yieldExpr;\n        }\n\n        const exprListResult = this._parseTestListWithComprehension();\n        const tupleOrExpression = this._makeExpressionOrTuple(exprListResult, /* enclosedInParens */ true);\n\n        if (this._peekTokenType() !== TokenType.CloseParenthesis) {\n            return this._handleExpressionParseError(\n                ErrorExpressionCategory.MissingTupleCloseParen,\n                Localizer.Diagnostic.expectedCloseParen()\n            );\n        } else {\n            extendRange(tupleOrExpression, this._getNextToken());\n        }\n\n        return tupleOrExpression;\n    }\n\n    // '[' [testlist_comp] ']'\n    // testlist_comp: (test | star_expr) (comp_for | (',' (test | star_expr))* [','])\n    private _parseListAtom(): ListNode | ErrorNode {\n        const startBracket = this._getNextToken();\n        assert(startBracket.type === TokenType.OpenBracket);\n\n        const exprListResult = this._parseTestListWithComprehension();\n        const closeBracket: Token | undefined = this._peekToken();\n        if (!this._consumeTokenIfType(TokenType.CloseBracket)) {\n            return this._handleExpressionParseError(\n                ErrorExpressionCategory.MissingListCloseBracket,\n                Localizer.Diagnostic.expectedCloseBracket()\n            );\n        }\n\n        const listAtom = ListNode.create(startBracket);\n        extendRange(listAtom, closeBracket);\n        if (exprListResult.list.length > 0) {\n            exprListResult.list.forEach((expr) => {\n                expr.parent = listAtom;\n            });\n            extendRange(listAtom, exprListResult.list[exprListResult.list.length - 1]);\n        }\n        listAtom.entries = exprListResult.list;\n        return listAtom;\n    }\n\n    private _parseTestListWithComprehension(): ExpressionListResult {\n        let sawComprehension = false;\n\n        return this._parseExpressionListGeneric(\n            () => {\n                let expr = this._parseTestOrStarExpression(true);\n                const listComp = this._tryParseListComprehension(expr);\n                if (listComp) {\n                    expr = listComp;\n                    sawComprehension = true;\n                }\n                return expr;\n            },\n            () => this._isNextTokenNeverExpression(),\n            () => sawComprehension\n        );\n    }\n\n    // '{' [dictorsetmaker] '}'\n    // dictorsetmaker: (\n    //    (dictentry (comp_for | (',' dictentry)* [',']))\n    //    | (setentry (comp_for | (',' setentry)* [',']))\n    // )\n    // dictentry: (test ':' test | '**' expr)\n    // setentry: test | star_expr\n    private _parseDictionaryOrSetAtom(): DictionaryNode | SetNode {\n        const startBrace = this._getNextToken();\n        assert(startBrace.type === TokenType.OpenCurlyBrace);\n\n        const dictionaryEntries: DictionaryEntryNode[] = [];\n        const setEntries: ExpressionNode[] = [];\n        let isDictionary = false;\n        let isSet = false;\n        let sawListComprehension = false;\n        let isFirstEntry = true;\n\n        while (true) {\n            if (this._peekTokenType() === TokenType.CloseCurlyBrace) {\n                break;\n            }\n\n            let doubleStarExpression: ExpressionNode | undefined;\n            let keyExpression: ExpressionNode | undefined;\n            let valueExpression: ExpressionNode | undefined;\n            const doubleStar = this._peekToken();\n\n            if (this._consumeTokenIfOperator(OperatorType.Power)) {\n                doubleStarExpression = this._parseExpression(false);\n            } else {\n                keyExpression = this._parseTestOrStarExpression(true);\n\n                if (this._consumeTokenIfType(TokenType.Colon)) {\n                    valueExpression = this._parseTestExpression(false);\n                }\n            }\n\n            if (keyExpression && valueExpression) {\n                if (keyExpression.nodeType === ParseNodeType.Unpack) {\n                    this._addError(Localizer.Diagnostic.unpackInDict(), keyExpression);\n                }\n\n                if (isSet) {\n                    this._addError(Localizer.Diagnostic.keyValueInSet(), valueExpression);\n                } else {\n                    const keyEntryNode = DictionaryKeyEntryNode.create(keyExpression, valueExpression);\n                    let dictEntry: DictionaryEntryNode = keyEntryNode;\n                    const listComp = this._tryParseListComprehension(keyEntryNode);\n                    if (listComp) {\n                        dictEntry = listComp;\n                        sawListComprehension = true;\n\n                        if (!isFirstEntry) {\n                            this._addError(Localizer.Diagnostic.comprehensionInDict(), dictEntry);\n                        }\n                    }\n                    dictionaryEntries.push(dictEntry);\n                    isDictionary = true;\n                }\n            } else if (doubleStarExpression) {\n                if (isSet) {\n                    this._addError(Localizer.Diagnostic.unpackInSet(), doubleStarExpression);\n                } else {\n                    const listEntryNode = DictionaryExpandEntryNode.create(doubleStarExpression);\n                    extendRange(listEntryNode, doubleStar);\n                    let expandEntryNode: DictionaryEntryNode = listEntryNode;\n                    const listComp = this._tryParseListComprehension(listEntryNode);\n                    if (listComp) {\n                        expandEntryNode = listComp;\n                        sawListComprehension = true;\n\n                        if (!isFirstEntry) {\n                            this._addError(Localizer.Diagnostic.comprehensionInDict(), doubleStarExpression);\n                        }\n                    }\n                    dictionaryEntries.push(expandEntryNode);\n                    isDictionary = true;\n                }\n            } else {\n                assert(keyExpression !== undefined);\n                if (keyExpression) {\n                    if (isDictionary) {\n                        this._addError(Localizer.Diagnostic.dictKeyValuePairs(), keyExpression);\n                    } else {\n                        const listComp = this._tryParseListComprehension(keyExpression);\n                        if (listComp) {\n                            keyExpression = listComp;\n                            sawListComprehension = true;\n\n                            if (!isFirstEntry) {\n                                this._addError(Localizer.Diagnostic.comprehensionInSet(), keyExpression);\n                            }\n                        }\n                        setEntries.push(keyExpression);\n                        isSet = true;\n                    }\n                }\n            }\n\n            // List comprehension statements always end the list.\n            if (sawListComprehension) {\n                break;\n            }\n\n            if (!this._consumeTokenIfType(TokenType.Comma)) {\n                break;\n            }\n\n            isFirstEntry = false;\n        }\n\n        let closeCurlyBrace: Token | undefined = this._peekToken();\n        if (!this._consumeTokenIfType(TokenType.CloseCurlyBrace)) {\n            this._addError(Localizer.Diagnostic.expectedCloseBrace(), this._peekToken());\n            closeCurlyBrace = undefined;\n        }\n\n        if (isSet) {\n            const setAtom = SetNode.create(startBrace);\n            if (closeCurlyBrace) {\n                extendRange(setAtom, closeCurlyBrace);\n            }\n            if (setEntries.length > 0) {\n                extendRange(setAtom, setEntries[setEntries.length - 1]);\n            }\n            setEntries.forEach((entry) => {\n                entry.parent = setAtom;\n            });\n            setAtom.entries = setEntries;\n            return setAtom;\n        }\n\n        const dictionaryAtom = DictionaryNode.create(startBrace);\n        if (closeCurlyBrace) {\n            extendRange(dictionaryAtom, closeCurlyBrace);\n        }\n        if (dictionaryEntries.length > 0) {\n            dictionaryEntries.forEach((entry) => {\n                entry.parent = dictionaryAtom;\n            });\n            extendRange(dictionaryAtom, dictionaryEntries[dictionaryEntries.length - 1]);\n        }\n        dictionaryAtom.entries = dictionaryEntries;\n        return dictionaryAtom;\n    }\n\n    private _parseExpressionListGeneric(\n        parser: () => ExpressionNode,\n        terminalCheck: () => boolean = () => this._isNextTokenNeverExpression(),\n        finalEntryCheck: () => boolean = () => false\n    ): ExpressionListResult {\n        let trailingComma = false;\n        const list: ExpressionNode[] = [];\n        let parseError: ErrorNode | undefined;\n\n        while (true) {\n            if (terminalCheck()) {\n                break;\n            }\n\n            const expr = parser();\n            if (expr.nodeType === ParseNodeType.Error) {\n                parseError = expr;\n                break;\n            }\n            list.push(expr);\n\n            // Should we stop without checking for a trailing comma?\n            if (finalEntryCheck()) {\n                break;\n            }\n\n            if (!this._consumeTokenIfType(TokenType.Comma)) {\n                trailingComma = false;\n                break;\n            }\n\n            trailingComma = true;\n        }\n\n        return { trailingComma, list, parseError };\n    }\n\n    // expr_stmt: testlist_star_expr (annassign | augassign (yield_expr | testlist) |\n    //                     ('=' (yield_expr | testlist_star_expr))*)\n    // testlist_star_expr: (test|star_expr) (',' (test|star_expr))* [',']\n    // annassign: ':' test ['=' test]\n    // augassign: ('+=' | '-=' | '*=' | '@=' | '/=' | '%=' | '&=' | '|=' | '^=' |\n    //             '<<=' | '>>=' | '**=' | '//=')\n    private _parseExpressionStatement(): ExpressionNode {\n        let leftExpr = this._parseTestOrStarListAsExpression(\n            /* allowAssignmentExpression */ false,\n            ErrorExpressionCategory.MissingExpression,\n            Localizer.Diagnostic.expectedExpr()\n        );\n        let annotationExpr: ExpressionNode | undefined;\n\n        if (leftExpr.nodeType === ParseNodeType.Error) {\n            return leftExpr;\n        }\n\n        // Is this a type annotation assignment?\n        if (this._consumeTokenIfType(TokenType.Colon)) {\n            annotationExpr = this._parseTypeAnnotation();\n            leftExpr = TypeAnnotationNode.create(leftExpr, annotationExpr);\n\n            if (!this._parseOptions.isStubFile && this._getLanguageVersion() < PythonVersion.V3_6) {\n                this._addError(Localizer.Diagnostic.varAnnotationIllegal(), annotationExpr);\n            }\n\n            if (!this._consumeTokenIfOperator(OperatorType.Assign)) {\n                return leftExpr;\n            }\n\n            // This is an unfortunate hack that's necessary to accommodate 'TypeAlias'\n            // declarations properly. We need to treat this assignment differently than\n            // most because the expression on the right side is treated like a type\n            // annotation and therefore allows string-literal forward declarations.\n            const isTypeAliasDeclaration = this._isTypingAnnotation(annotationExpr, 'TypeAlias');\n\n            const wasParsingTypeAnnotation = this._isParsingTypeAnnotation;\n            if (isTypeAliasDeclaration) {\n                this._isParsingTypeAnnotation = true;\n            }\n\n            const rightExpr = this._parseTestExpression(false);\n\n            this._isParsingTypeAnnotation = wasParsingTypeAnnotation;\n\n            return AssignmentNode.create(leftExpr, rightExpr);\n        }\n\n        // Is this a simple assignment?\n        if (this._consumeTokenIfOperator(OperatorType.Assign)) {\n            return this._parseChainAssignments(leftExpr);\n        }\n\n        if (!annotationExpr && Tokenizer.isOperatorAssignment(this._peekOperatorType())) {\n            const operatorToken = this._getNextToken() as OperatorToken;\n\n            const rightExpr =\n                this._tryParseYieldExpression() ||\n                this._parseTestListAsExpression(\n                    ErrorExpressionCategory.MissingExpression,\n                    Localizer.Diagnostic.expectedBinaryRightHandExpr()\n                );\n\n            // Make a shallow copy of the dest expression but give it a new ID.\n            const destExpr = Object.assign({}, leftExpr);\n            destExpr.id = getNextNodeId();\n\n            return AugmentedAssignmentNode.create(leftExpr, rightExpr, operatorToken.operatorType, destExpr);\n        }\n\n        return leftExpr;\n    }\n\n    private _parseChainAssignments(leftExpr: ExpressionNode): ExpressionNode {\n        let rightExpr: ExpressionNode | undefined;\n        rightExpr = this._tryParseYieldExpression();\n        if (!rightExpr) {\n            rightExpr = this._parseTestOrStarListAsExpression(\n                /* allowAssignmentExpression */ false,\n                ErrorExpressionCategory.MissingExpression,\n                Localizer.Diagnostic.expectedAssignRightHandExpr()\n            );\n        }\n\n        if (rightExpr.nodeType === ParseNodeType.Error) {\n            return AssignmentNode.create(leftExpr, rightExpr);\n        }\n\n        // Recur until we've consumed the entire chain.\n        if (this._consumeTokenIfOperator(OperatorType.Assign)) {\n            rightExpr = this._parseChainAssignments(rightExpr);\n            if (rightExpr.nodeType === ParseNodeType.Error) {\n                return rightExpr;\n            }\n        }\n\n        const assignmentNode = AssignmentNode.create(leftExpr, rightExpr);\n\n        // Look for a type annotation comment at the end of the line.\n        const typeAnnotationComment = this._parseVariableTypeAnnotationComment();\n        if (typeAnnotationComment) {\n            assignmentNode.typeAnnotationComment = typeAnnotationComment;\n            assignmentNode.typeAnnotationComment.parent = assignmentNode;\n            extendRange(assignmentNode, assignmentNode.typeAnnotationComment);\n        }\n\n        return assignmentNode;\n    }\n\n    private _parseFunctionTypeAnnotation(): FunctionAnnotationNode | undefined {\n        const openParenToken = this._peekToken();\n        if (!this._consumeTokenIfType(TokenType.OpenParenthesis)) {\n            this._addError(Localizer.Diagnostic.expectedOpenParen(), this._peekToken());\n            return undefined;\n        }\n\n        let paramAnnotations: ExpressionNode[] = [];\n\n        while (true) {\n            const nextTokenType = this._peekTokenType();\n            if (\n                nextTokenType === TokenType.CloseParenthesis ||\n                nextTokenType === TokenType.NewLine ||\n                nextTokenType === TokenType.EndOfStream\n            ) {\n                break;\n            }\n\n            const paramAnnotation = this._parseTypeAnnotation();\n            paramAnnotations.push(paramAnnotation);\n\n            if (!this._consumeTokenIfType(TokenType.Comma)) {\n                break;\n            }\n        }\n\n        if (!this._consumeTokenIfType(TokenType.CloseParenthesis)) {\n            this._addError(Localizer.Diagnostic.expectedCloseParen(), this._peekToken());\n            this._consumeTokensUntilType([TokenType.Colon]);\n        }\n\n        if (!this._consumeTokenIfType(TokenType.Arrow)) {\n            this._addError(Localizer.Diagnostic.expectedArrow(), this._peekToken());\n            return undefined;\n        }\n\n        const returnType = this._parseTypeAnnotation();\n\n        let isParamListEllipsis = false;\n        if (paramAnnotations.length === 1 && paramAnnotations[0].nodeType === ParseNodeType.Ellipsis) {\n            paramAnnotations = [];\n            isParamListEllipsis = true;\n        }\n\n        return FunctionAnnotationNode.create(openParenToken, isParamListEllipsis, paramAnnotations, returnType);\n    }\n\n    private _parseTypeAnnotation(allowUnionNotation = true): ExpressionNode {\n        // Temporary set a flag that indicates we're parsing a type annotation.\n        const wasParsingTypeAnnotation = this._isParsingTypeAnnotation;\n        this._isParsingTypeAnnotation = true;\n\n        const result = this._parseTestExpression(/* allowAssignmentExpression */ false);\n\n        this._isParsingTypeAnnotation = wasParsingTypeAnnotation;\n\n        return result;\n    }\n\n    private _reportStringTokenErrors(stringToken: StringToken, unescapedResult: StringTokenUtils.UnescapedString) {\n        if (stringToken.flags & StringTokenFlags.Unterminated) {\n            this._addError(Localizer.Diagnostic.stringUnterminated(), stringToken);\n        }\n\n        if (unescapedResult.nonAsciiInBytes) {\n            this._addError(Localizer.Diagnostic.stringNonAsciiBytes(), stringToken);\n        }\n\n        if (stringToken.flags & StringTokenFlags.Format) {\n            if (this._getLanguageVersion() < PythonVersion.V3_6) {\n                this._addError(Localizer.Diagnostic.formatStringIllegal(), stringToken);\n            }\n\n            if (stringToken.flags & StringTokenFlags.Bytes) {\n                this._addError(Localizer.Diagnostic.formatStringBytes(), stringToken);\n            }\n\n            if (stringToken.flags & StringTokenFlags.Unicode) {\n                this._addError(Localizer.Diagnostic.formatStringUnicode(), stringToken);\n            }\n        }\n    }\n\n    private _makeStringNode(stringToken: StringToken): StringNode {\n        const unescapedResult = StringTokenUtils.getUnescapedString(stringToken);\n        this._reportStringTokenErrors(stringToken, unescapedResult);\n        return StringNode.create(stringToken, unescapedResult.value, unescapedResult.unescapeErrors.length > 0);\n    }\n\n    private _getTypeAnnotationCommentText(): StringToken | undefined {\n        if (this._tokenIndex === 0) {\n            return undefined;\n        }\n\n        const curToken = this._tokenizerOutput!.tokens.getItemAt(this._tokenIndex - 1);\n        const nextToken = this._tokenizerOutput!.tokens.getItemAt(this._tokenIndex);\n\n        if (curToken.start + curToken.length === nextToken.start) {\n            return undefined;\n        }\n\n        const interTokenContents = this._fileContents!.substring(curToken.start + curToken.length, nextToken.start);\n        const commentRegEx = /^(\\s*#\\s*type:\\s*)([^\\r\\n]*)/;\n        const match = interTokenContents.match(commentRegEx);\n        if (!match) {\n            return undefined;\n        }\n\n        // Synthesize a string token and StringNode.\n        const typeString = match[2];\n\n        // Ignore all \"ignore\" comments. Include \"[\" in the regular\n        // expression because mypy supports ignore comments of the\n        // form ignore[errorCode, ...]. We'll treat these as regular\n        // ignore statements (as though no errorCodes were included).\n        if (typeString.trim().match(/^ignore(\\s|\\[|$)/)) {\n            return undefined;\n        }\n\n        const tokenOffset = curToken.start + curToken.length + match[1].length;\n        return StringToken.create(tokenOffset, typeString.length, StringTokenFlags.None, typeString, 0, undefined);\n    }\n\n    private _parseVariableTypeAnnotationComment(): ExpressionNode | undefined {\n        const stringToken = this._getTypeAnnotationCommentText();\n        if (!stringToken) {\n            return undefined;\n        }\n\n        const stringNode = this._makeStringNode(stringToken);\n        const stringListNode = StringListNode.create([stringNode]);\n        const parser = new Parser();\n        const parseResults = parser.parseTextExpression(\n            this._fileContents!,\n            stringToken.start,\n            stringToken.length,\n            this._parseOptions,\n            ParseTextMode.VariableAnnotation\n        );\n\n        parseResults.diagnostics.forEach((diag) => {\n            this._addError(diag.message, stringListNode);\n        });\n\n        if (!parseResults.parseTree) {\n            return undefined;\n        }\n\n        return parseResults.parseTree;\n    }\n\n    private _parseFunctionTypeAnnotationComment(stringToken: StringToken, functionNode: FunctionNode): void {\n        const stringNode = this._makeStringNode(stringToken);\n        const stringListNode = StringListNode.create([stringNode]);\n        const parser = new Parser();\n        const parseResults = parser.parseTextExpression(\n            this._fileContents!,\n            stringToken.start,\n            stringToken.length,\n            this._parseOptions,\n            ParseTextMode.FunctionAnnotation\n        );\n\n        parseResults.diagnostics.forEach((diag) => {\n            this._addError(diag.message, stringListNode);\n        });\n\n        if (!parseResults.parseTree || parseResults.parseTree.nodeType !== ParseNodeType.FunctionAnnotation) {\n            return;\n        }\n\n        const functionAnnotation = parseResults.parseTree;\n\n        functionNode.functionAnnotationComment = functionAnnotation;\n        functionAnnotation.parent = functionNode;\n        extendRange(functionNode, functionAnnotation);\n    }\n\n    private _parseFormatStringSegment(\n        stringToken: StringToken,\n        segment: StringTokenUtils.FormatStringSegment,\n        segmentOffset: number,\n        segmentLength: number\n    ) {\n        assert(segment.isExpression);\n        const parser = new Parser();\n        const parseResults = parser.parseTextExpression(\n            this._fileContents!,\n            stringToken.start + stringToken.prefixLength + stringToken.quoteMarkLength + segment.offset + segmentOffset,\n            segmentLength,\n            this._parseOptions,\n            ParseTextMode.Expression,\n            /* initialParenDepth */ 1\n        );\n\n        parseResults.diagnostics.forEach((diag) => {\n            const textRangeStart =\n                (diag.range ? convertPositionToOffset(diag.range.start, parseResults.lines) : stringToken.start) ||\n                stringToken.start;\n            const textRangeEnd =\n                (diag.range\n                    ? (convertPositionToOffset(diag.range.end, parseResults.lines) || 0) + 1\n                    : stringToken.start + stringToken.length) || stringToken.start + stringToken.length;\n            const textRange = { start: textRangeStart, length: textRangeEnd - textRangeStart };\n            this._addError(diag.message, textRange);\n        });\n\n        return parseResults.parseTree;\n    }\n\n    private _parseFormatString(stringToken: StringToken): FormatStringNode {\n        const unescapedResult = StringTokenUtils.getUnescapedString(stringToken);\n        this._reportStringTokenErrors(stringToken, unescapedResult);\n\n        const formatExpressions: ExpressionNode[] = [];\n\n        for (const segment of unescapedResult.formatStringSegments) {\n            if (segment.isExpression) {\n                // Determine if we need to truncate the expression because it\n                // contains formatting directives that start with a ! or :.\n                const segmentExprLength = this._getFormatStringExpressionLength(segment.value.trimEnd());\n                const parseTree = this._parseFormatStringSegment(stringToken, segment, 0, segmentExprLength);\n                if (parseTree) {\n                    formatExpressions.push(parseTree);\n                }\n\n                // Look for additional expressions within the format directive.\n                const formatDirective = segment.value.substr(segmentExprLength);\n                let braceDepth = 0;\n                let startOfExprOffset = 0;\n                for (let i = 0; i < formatDirective.length; i++) {\n                    if (formatDirective.charCodeAt(i) === Char.OpenBrace) {\n                        if (braceDepth === 0) {\n                            startOfExprOffset = i + 1;\n                        }\n                        braceDepth++;\n                    } else if (formatDirective.charCodeAt(i) === Char.CloseBrace) {\n                        if (braceDepth > 0) {\n                            braceDepth--;\n                            if (braceDepth === 0) {\n                                const parseTree = this._parseFormatStringSegment(\n                                    stringToken,\n                                    segment,\n                                    segmentExprLength + startOfExprOffset,\n                                    i - startOfExprOffset\n                                );\n                                if (parseTree) {\n                                    formatExpressions.push(parseTree);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return FormatStringNode.create(\n            stringToken,\n            unescapedResult.value,\n            unescapedResult.unescapeErrors.length > 0,\n            formatExpressions\n        );\n    }\n\n    private _getFormatStringExpressionLength(segmentValue: string): number {\n        let segmentExprLength = 0;\n\n        // PEP 498 says: Expressions cannot contain ':' or '!' outside of\n        // strings or parentheses, brackets, or braces. The exception is\n        // that the '!=' operator is allowed as a special case.\n        const quoteStack: string[] = [];\n        let braceCount = 0;\n        let parenCount = 0;\n        let bracketCount = 0;\n        let prevCharWasEqual = false;\n\n        while (segmentExprLength < segmentValue.length) {\n            const curChar = segmentValue[segmentExprLength];\n            const ignoreSeparator = quoteStack.length > 0 || braceCount > 0 || parenCount > 0 || bracketCount > 0;\n            const inString = quoteStack.length > 0;\n\n            if (curChar === '=') {\n                prevCharWasEqual = true;\n            } else {\n                if (curChar === ':') {\n                    if (!ignoreSeparator) {\n                        break;\n                    }\n                } else if (curChar === '!') {\n                    if (!ignoreSeparator) {\n                        // Allow !=, as per PEP 498\n                        if (\n                            segmentExprLength === segmentValue.length - 1 ||\n                            segmentValue[segmentExprLength + 1] !== '='\n                        ) {\n                            break;\n                        }\n                    }\n                } else if (curChar === \"'\" || curChar === '\"') {\n                    let quoteSequence = curChar;\n                    if (\n                        segmentExprLength + 2 < segmentValue.length &&\n                        segmentValue[segmentExprLength + 1] === curChar &&\n                        segmentValue[segmentExprLength + 2] === curChar\n                    ) {\n                        quoteSequence = curChar + curChar + curChar;\n                        segmentExprLength += 2;\n                    }\n\n                    if (quoteStack.length > 0 && quoteStack[quoteStack.length - 1] === quoteSequence) {\n                        quoteStack.pop();\n                    } else {\n                        quoteStack.push(quoteSequence);\n                    }\n                } else if (curChar === '(') {\n                    if (!inString) {\n                        parenCount++;\n                    }\n                } else if (curChar === ')') {\n                    if (!inString && parenCount > 0) {\n                        parenCount--;\n                    }\n                } else if (curChar === '{') {\n                    if (!inString) {\n                        braceCount++;\n                    }\n                } else if (curChar === '}') {\n                    if (!inString && braceCount > 0) {\n                        braceCount--;\n                    }\n                } else if (curChar === '[') {\n                    if (!inString) {\n                        bracketCount++;\n                    }\n                } else if (curChar === ']') {\n                    if (!inString && bracketCount > 0) {\n                        bracketCount--;\n                    }\n                }\n\n                prevCharWasEqual = false;\n            }\n\n            segmentExprLength++;\n        }\n\n        // Handle Python 3.8 f-string formatting expressions that\n        // end in an \"=\".\n        if (this._parseOptions.pythonVersion >= PythonVersion.V3_8 && prevCharWasEqual) {\n            segmentExprLength--;\n        }\n\n        return segmentExprLength;\n    }\n\n    private _parseStringList(): StringListNode {\n        const stringList: (StringNode | FormatStringNode)[] = [];\n\n        while (this._peekTokenType() === TokenType.String) {\n            const stringToken = this._getNextToken() as StringToken;\n            if (stringToken.flags & StringTokenFlags.Format) {\n                stringList.push(this._parseFormatString(stringToken));\n            } else {\n                stringList.push(this._makeStringNode(stringToken));\n            }\n        }\n\n        const stringNode = StringListNode.create(stringList);\n\n        // If we're parsing a type annotation, parse the contents of the string.\n        if (this._isParsingTypeAnnotation) {\n            // Don't allow multiple strings because we have no way of reporting\n            // parse errors that span strings.\n            if (stringNode.strings.length > 1) {\n                this._addError(Localizer.Diagnostic.annotationSpansStrings(), stringNode);\n            } else if (stringNode.strings[0].token.flags & StringTokenFlags.Triplicate) {\n                this._addError(Localizer.Diagnostic.annotationTripleQuote(), stringNode);\n            } else if (stringNode.strings[0].token.flags & StringTokenFlags.Format) {\n                this._addError(Localizer.Diagnostic.annotationFormatString(), stringNode);\n            } else {\n                const stringToken = stringNode.strings[0].token;\n                const stringValue = StringTokenUtils.getUnescapedString(stringNode.strings[0].token);\n                const unescapedString = stringValue.value;\n                const tokenOffset = stringToken.start;\n                const prefixLength = stringToken.prefixLength + stringToken.quoteMarkLength;\n\n                // Don't allow escape characters because we have no way of mapping\n                // error ranges back to the escaped text.\n                if (unescapedString.length !== stringToken.length - prefixLength - stringToken.quoteMarkLength) {\n                    this._addError(Localizer.Diagnostic.annotationStringEscape(), stringNode);\n                } else {\n                    const parser = new Parser();\n                    const parseResults = parser.parseTextExpression(\n                        this._fileContents!,\n                        tokenOffset + prefixLength,\n                        unescapedString.length,\n                        this._parseOptions,\n                        ParseTextMode.VariableAnnotation\n                    );\n\n                    parseResults.diagnostics.forEach((diag) => {\n                        this._addError(diag.message, stringNode);\n                    });\n\n                    if (parseResults.parseTree) {\n                        stringNode.typeAnnotation = parseResults.parseTree;\n                        stringNode.typeAnnotation.parent = stringNode;\n                    }\n                }\n            }\n        }\n\n        return stringNode;\n    }\n\n    // Python 3.8 added support for star (unpack) expressions in tuples\n    // following a return or yield statement in cases where the tuple\n    // wasn't surrounded in parentheses.\n    private _reportConditionalErrorForStarTupleElement(possibleTupleExpr: ExpressionNode) {\n        if (possibleTupleExpr.nodeType !== ParseNodeType.Tuple) {\n            return;\n        }\n\n        if (possibleTupleExpr.enclosedInParens) {\n            return;\n        }\n\n        if (this._parseOptions.pythonVersion >= PythonVersion.V3_8) {\n            return;\n        }\n\n        for (const expr of possibleTupleExpr.expressions) {\n            if (expr.nodeType === ParseNodeType.Unpack) {\n                this._addError(Localizer.Diagnostic.unpackTuplesIllegal(), expr);\n                return;\n            }\n        }\n    }\n\n    // Peeks at the next token and returns true if it can never\n    // represent the start of an expression.\n    private _isNextTokenNeverExpression(): boolean {\n        const nextToken = this._peekToken();\n        switch (nextToken.type) {\n            case TokenType.Keyword: {\n                switch (this._peekKeywordType()) {\n                    case KeywordType.For:\n                    case KeywordType.In:\n                    case KeywordType.If:\n                        return true;\n                }\n                break;\n            }\n\n            case TokenType.Operator: {\n                switch (this._peekOperatorType()) {\n                    case OperatorType.AddEqual:\n                    case OperatorType.SubtractEqual:\n                    case OperatorType.MultiplyEqual:\n                    case OperatorType.DivideEqual:\n                    case OperatorType.ModEqual:\n                    case OperatorType.BitwiseAndEqual:\n                    case OperatorType.BitwiseOrEqual:\n                    case OperatorType.BitwiseXorEqual:\n                    case OperatorType.LeftShiftEqual:\n                    case OperatorType.RightShiftEqual:\n                    case OperatorType.PowerEqual:\n                    case OperatorType.FloorDivideEqual:\n                    case OperatorType.Assign:\n                        return true;\n                }\n                break;\n            }\n\n            case TokenType.Indent:\n            case TokenType.Dedent:\n            case TokenType.NewLine:\n            case TokenType.EndOfStream:\n            case TokenType.Semicolon:\n            case TokenType.CloseParenthesis:\n            case TokenType.CloseBracket:\n            case TokenType.CloseCurlyBrace:\n            case TokenType.Comma:\n            case TokenType.Colon:\n                return true;\n        }\n\n        return false;\n    }\n\n    private _disallowAssignmentExpression(callback: () => void) {\n        const wasAllowed = this._assignmentExpressionsAllowed;\n        this._assignmentExpressionsAllowed = false;\n\n        callback();\n\n        this._assignmentExpressionsAllowed = wasAllowed;\n    }\n\n    private _getNextToken(): Token {\n        const token = this._tokenizerOutput!.tokens.getItemAt(this._tokenIndex);\n        if (!this._atEof()) {\n            this._tokenIndex++;\n        }\n\n        return token;\n    }\n\n    private _atEof(): boolean {\n        // Are we pointing at the last token in the stream (which is\n        // assumed to be an end-of-stream token)?\n        return this._tokenIndex >= this._tokenizerOutput!.tokens.count - 1;\n    }\n\n    private _peekToken(count = 0): Token {\n        if (this._tokenIndex + count < 0) {\n            this._tokenizerOutput!.tokens.getItemAt(0);\n        }\n\n        if (this._tokenIndex + count >= this._tokenizerOutput!.tokens.count) {\n            return this._tokenizerOutput!.tokens.getItemAt(this._tokenizerOutput!.tokens.count - 1);\n        }\n\n        return this._tokenizerOutput!.tokens.getItemAt(this._tokenIndex + count);\n    }\n\n    private _peekTokenType(): TokenType {\n        return this._peekToken().type;\n    }\n\n    private _peekKeywordType(): KeywordType | undefined {\n        const nextToken = this._peekToken();\n        if (nextToken.type !== TokenType.Keyword) {\n            return undefined;\n        }\n\n        return (nextToken as KeywordToken).keywordType;\n    }\n\n    private _peekOperatorType(): OperatorType | undefined {\n        const nextToken = this._peekToken();\n        if (nextToken.type !== TokenType.Operator) {\n            return undefined;\n        }\n\n        return (nextToken as OperatorToken).operatorType;\n    }\n\n    private _getTokenIfIdentifier(disallowedKeywords: KeywordType[] = []): IdentifierToken | undefined {\n        const nextToken = this._peekToken();\n        if (nextToken.type === TokenType.Identifier) {\n            return this._getNextToken() as IdentifierToken;\n        }\n\n        // If the next token is invalid, treat it as an identifier.\n        if (nextToken.type === TokenType.Invalid) {\n            this._getNextToken();\n            this._addError(Localizer.Diagnostic.invalidIdentifierChar(), nextToken);\n            return IdentifierToken.create(nextToken.start, nextToken.length, '', nextToken.comments);\n        }\n\n        // If keywords are allowed in this context, convert the keyword\n        // to an identifier token.\n        if (nextToken.type === TokenType.Keyword) {\n            const keywordType = this._peekKeywordType();\n            if (!disallowedKeywords.find((type) => type === keywordType)) {\n                const keywordText = this._fileContents!.substr(nextToken.start, nextToken.length);\n                this._getNextToken();\n                return IdentifierToken.create(nextToken.start, nextToken.length, keywordText, nextToken.comments);\n            }\n        }\n\n        return undefined;\n    }\n\n    // Consumes tokens until the next one in the stream is\n    // either a specified terminator or the end-of-stream\n    // token.\n    private _consumeTokensUntilType(terminators: TokenType[]): boolean {\n        while (true) {\n            const token = this._peekToken();\n            if (terminators.some((term) => term === token.type)) {\n                return true;\n            }\n\n            if (token.type === TokenType.EndOfStream) {\n                return false;\n            }\n\n            this._getNextToken();\n        }\n    }\n\n    private _consumeTokenIfType(tokenType: TokenType): boolean {\n        if (this._peekTokenType() === tokenType) {\n            this._getNextToken();\n            return true;\n        }\n\n        return false;\n    }\n\n    private _consumeTokenIfKeyword(keywordType: KeywordType): boolean {\n        if (this._peekKeywordType() === keywordType) {\n            this._getNextToken();\n            return true;\n        }\n\n        return false;\n    }\n\n    private _consumeTokenIfOperator(operatorType: OperatorType): boolean {\n        if (this._peekOperatorType() === operatorType) {\n            this._getNextToken();\n            return true;\n        }\n\n        return false;\n    }\n\n    private _getKeywordToken(keywordType: KeywordType): KeywordToken {\n        const keywordToken = this._getNextToken() as KeywordToken;\n        assert(keywordToken.type === TokenType.Keyword);\n        assert(keywordToken.keywordType === keywordType);\n        return keywordToken;\n    }\n\n    private _getLanguageVersion() {\n        return this._parseOptions.pythonVersion;\n    }\n\n    private _addError(message: string, range: TextRange) {\n        assert(range !== undefined);\n        this._diagSink.addError(\n            message,\n            convertOffsetsToRange(range.start, range.start + range.length, this._tokenizerOutput!.lines)\n        );\n    }\n}\n","/*\n * stringTokenUtils.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Methods that handle unescaping of escaped string token\n * literal values.\n */\n\nimport Char from 'typescript-char';\n\nimport { StringToken, StringTokenFlags } from './tokenizerTypes';\n\nexport interface FormatStringSegment {\n    // Offset within the unescaped string where\n    // this format string segment begins.\n    offset: number;\n\n    // Length of unescaped string corresponding\n    // to this segment.\n    length: number;\n\n    // Unescaped value of segment (without brackets).\n    value: string;\n\n    // Indicates whether this segment should be parsed\n    // as an expression.\n    isExpression: boolean;\n}\n\nexport const enum UnescapeErrorType {\n    InvalidEscapeSequence,\n    EscapeWithinFormatExpression,\n    SingleCloseBraceWithinFormatLiteral,\n    UnterminatedFormatExpression,\n}\n\nexport interface UnescapeError {\n    // Offset within the unescaped string where\n    // this error begins.\n    offset: number;\n\n    // Length of section associated with error.\n    length: number;\n\n    // Type of error.\n    errorType: UnescapeErrorType;\n}\n\nexport interface UnescapedString {\n    value: string;\n    unescapeErrors: UnescapeError[];\n    nonAsciiInBytes: boolean;\n    formatStringSegments: FormatStringSegment[];\n}\n\nexport function getUnescapedString(stringToken: StringToken): UnescapedString {\n    const escapedString = stringToken.escapedValue;\n    const isRaw = (stringToken.flags & StringTokenFlags.Raw) !== 0;\n    const isBytes = (stringToken.flags & StringTokenFlags.Bytes) !== 0;\n    const isFormat = (stringToken.flags & StringTokenFlags.Format) !== 0;\n    let formatExpressionNestCount = 0;\n    let formatSegment: FormatStringSegment = {\n        offset: 0,\n        length: 0,\n        value: '',\n        isExpression: false,\n    };\n    let strOffset = 0;\n    const output: UnescapedString = {\n        value: '',\n        unescapeErrors: [],\n        nonAsciiInBytes: false,\n        formatStringSegments: [],\n    };\n\n    const addInvalidEscapeOffset = () => {\n        // Invalid escapes are not reported for raw strings.\n        if (!isRaw) {\n            output.unescapeErrors.push({\n                offset: strOffset - 1,\n                length: 2,\n                errorType: UnescapeErrorType.InvalidEscapeSequence,\n            });\n        }\n    };\n\n    const getEscapedCharacter = (offset = 0) => {\n        if (strOffset + offset >= escapedString.length) {\n            return Char.EndOfText;\n        }\n\n        return escapedString.charCodeAt(strOffset + offset);\n    };\n\n    const scanHexEscape = (digitCount: number) => {\n        let foundIllegalHexDigit = false;\n        let hexValue = 0;\n        let localValue = '';\n\n        for (let i = 0; i < digitCount; i++) {\n            const charCode = getEscapedCharacter(1 + i);\n            if (!_isHexCharCode(charCode)) {\n                foundIllegalHexDigit = true;\n                break;\n            }\n            hexValue = 16 * hexValue + _getHexDigitValue(charCode);\n        }\n\n        if (foundIllegalHexDigit) {\n            addInvalidEscapeOffset();\n            localValue = '\\\\' + String.fromCharCode(getEscapedCharacter());\n            strOffset++;\n        } else {\n            localValue = String.fromCharCode(hexValue);\n            strOffset += 1 + digitCount;\n        }\n\n        return localValue;\n    };\n\n    const appendOutputChar = (charCode: number) => {\n        const char = String.fromCharCode(charCode);\n        output.value += char;\n        formatSegment.value += char;\n    };\n\n    while (true) {\n        let curChar = getEscapedCharacter();\n        if (curChar === Char.EndOfText) {\n            if (isFormat) {\n                if (formatSegment.isExpression) {\n                    // The last format segment was an unterminated expression.\n                    output.unescapeErrors.push({\n                        offset: formatSegment.offset,\n                        length: strOffset - formatSegment.offset,\n                        errorType: UnescapeErrorType.UnterminatedFormatExpression,\n                    });\n                }\n\n                // Push the last segment.\n                if (strOffset !== formatSegment.offset) {\n                    formatSegment.length = strOffset - formatSegment.offset;\n                    output.formatStringSegments.push(formatSegment);\n                }\n            }\n            return output;\n        }\n\n        if (curChar === Char.Backslash) {\n            if (isFormat && formatSegment.isExpression) {\n                // Backslashes aren't allowed within format string expressions.\n                output.unescapeErrors.push({\n                    offset: strOffset,\n                    length: 1,\n                    errorType: UnescapeErrorType.EscapeWithinFormatExpression,\n                });\n            }\n\n            // Move past the escape (backslash) character.\n            strOffset++;\n            curChar = getEscapedCharacter();\n            let localValue = '';\n\n            if (curChar === Char.CarriageReturn || curChar === Char.LineFeed) {\n                if (curChar === Char.CarriageReturn && getEscapedCharacter(1) === Char.LineFeed) {\n                    if (isRaw) {\n                        localValue += String.fromCharCode(curChar);\n                    }\n                    strOffset++;\n                    curChar = getEscapedCharacter();\n                }\n                if (isRaw) {\n                    localValue = '\\\\' + localValue + String.fromCharCode(curChar);\n                }\n                strOffset++;\n            } else {\n                if (isRaw) {\n                    localValue = '\\\\' + String.fromCharCode(curChar);\n                    strOffset++;\n                } else {\n                    switch (curChar) {\n                        case Char.Backslash:\n                        case Char.SingleQuote:\n                        case Char.DoubleQuote:\n                            localValue = String.fromCharCode(curChar);\n                            strOffset++;\n                            break;\n\n                        case Char.a:\n                            localValue = '\\u0007';\n                            strOffset++;\n                            break;\n\n                        case Char.b:\n                            localValue = '\\b';\n                            strOffset++;\n                            break;\n\n                        case Char.f:\n                            localValue = '\\f';\n                            strOffset++;\n                            break;\n\n                        case Char.n:\n                            localValue = '\\n';\n                            strOffset++;\n                            break;\n\n                        case Char.r:\n                            localValue = '\\r';\n                            strOffset++;\n                            break;\n\n                        case Char.t:\n                            localValue = '\\t';\n                            strOffset++;\n                            break;\n\n                        case Char.v:\n                            localValue = '\\v';\n                            strOffset++;\n                            break;\n\n                        case Char.x:\n                            localValue = scanHexEscape(2);\n                            break;\n\n                        case Char.N: {\n                            let foundIllegalChar = false;\n                            let charCount = 1;\n                            if (getEscapedCharacter(charCount) !== Char.OpenBrace) {\n                                foundIllegalChar = true;\n                            } else {\n                                charCount++;\n                                while (true) {\n                                    const lookaheadChar = getEscapedCharacter(charCount);\n                                    if (lookaheadChar === Char.CloseBrace) {\n                                        break;\n                                    } else if (\n                                        !_isAlphaNumericChar(lookaheadChar) &&\n                                        lookaheadChar !== Char.Hyphen &&\n                                        !_isWhitespaceChar(lookaheadChar)\n                                    ) {\n                                        foundIllegalChar = true;\n                                        break;\n                                    } else {\n                                        charCount++;\n                                    }\n                                }\n                            }\n\n                            if (foundIllegalChar) {\n                                addInvalidEscapeOffset();\n                                localValue = '\\\\' + String.fromCharCode(curChar);\n                                strOffset++;\n                            } else {\n                                // We don't have the Unicode name database handy, so\n                                // assume that the name is valid and use a '-' as a\n                                // replacement character.\n                                localValue = '-';\n                                strOffset += 1 + charCount;\n                            }\n                            break;\n                        }\n\n                        case Char.u:\n                            localValue = scanHexEscape(4);\n                            break;\n\n                        case Char.U:\n                            localValue = scanHexEscape(8);\n                            break;\n\n                        default:\n                            if (_isOctalCharCode(curChar)) {\n                                let octalCode = curChar - Char._0;\n                                strOffset++;\n                                curChar = getEscapedCharacter();\n                                if (_isOctalCharCode(curChar)) {\n                                    octalCode = octalCode * 8 + curChar - Char._0;\n                                    strOffset++;\n                                    curChar = getEscapedCharacter();\n\n                                    if (_isOctalCharCode(curChar)) {\n                                        octalCode = octalCode * 8 + curChar - Char._0;\n                                        strOffset++;\n                                    }\n                                }\n\n                                localValue = String.fromCharCode(octalCode);\n                            } else {\n                                localValue = '\\\\';\n                                addInvalidEscapeOffset();\n                            }\n                            break;\n                    }\n                }\n            }\n\n            output.value += localValue;\n            formatSegment.value += localValue;\n        } else if (curChar === Char.LineFeed || curChar === Char.CarriageReturn) {\n            // Skip over the escaped new line (either one or two characters).\n            if (curChar === Char.CarriageReturn && getEscapedCharacter(1) === Char.LineFeed) {\n                appendOutputChar(curChar);\n                strOffset++;\n                curChar = getEscapedCharacter();\n            }\n\n            appendOutputChar(curChar);\n            strOffset++;\n        } else if (isFormat && curChar === Char.OpenBrace) {\n            if (!formatSegment.isExpression && getEscapedCharacter(1) === Char.OpenBrace) {\n                appendOutputChar(curChar);\n                strOffset += 2;\n            } else {\n                if (formatExpressionNestCount === 0) {\n                    // A single open brace within a format literal indicates that\n                    // an expression is starting.\n                    formatSegment.length = strOffset - formatSegment.offset;\n                    if (formatSegment.length > 0) {\n                        output.formatStringSegments.push(formatSegment);\n                    }\n                    strOffset++;\n\n                    // Start a new segment.\n                    formatSegment = {\n                        offset: strOffset,\n                        length: 0,\n                        value: '',\n                        isExpression: true,\n                    };\n                } else {\n                    appendOutputChar(curChar);\n                    strOffset++;\n                }\n                formatExpressionNestCount++;\n            }\n        } else if (isFormat && curChar === Char.CloseBrace) {\n            if (!formatSegment.isExpression && getEscapedCharacter(1) === Char.CloseBrace) {\n                appendOutputChar(curChar);\n                strOffset += 2;\n            } else if (formatExpressionNestCount === 0) {\n                output.unescapeErrors.push({\n                    offset: strOffset,\n                    length: 1,\n                    errorType: UnescapeErrorType.SingleCloseBraceWithinFormatLiteral,\n                });\n                strOffset++;\n            } else {\n                formatExpressionNestCount--;\n\n                if (formatExpressionNestCount === 0) {\n                    // A close brace within a format expression indicates that\n                    // the expression is complete.\n                    formatSegment.length = strOffset - formatSegment.offset;\n                    output.formatStringSegments.push(formatSegment);\n                    strOffset++;\n\n                    // Start a new segment.\n                    formatSegment = {\n                        offset: strOffset,\n                        length: 0,\n                        value: '',\n                        isExpression: false,\n                    };\n                } else {\n                    appendOutputChar(curChar);\n                    strOffset++;\n                }\n            }\n        } else if (formatSegment.isExpression && (curChar === Char.SingleQuote || curChar === Char.DoubleQuote)) {\n            // We're within an expression, and we've encountered a string literal.\n            // Skip over it.\n            const quoteChar = curChar;\n            appendOutputChar(curChar);\n            const isTriplicate = getEscapedCharacter(1) === quoteChar && getEscapedCharacter(2) === quoteChar;\n            if (isTriplicate) {\n                strOffset += 2;\n                appendOutputChar(curChar);\n                appendOutputChar(curChar);\n                output.value += String.fromCharCode(curChar);\n                output.value += String.fromCharCode(curChar);\n            }\n\n            while (true) {\n                strOffset++;\n                let strChar = getEscapedCharacter();\n                if (strChar === Char.EndOfText) {\n                    break;\n                }\n\n                if (strChar === Char.Backslash) {\n                    appendOutputChar(strChar);\n                    strOffset++;\n                    strChar = getEscapedCharacter();\n                    appendOutputChar(strChar);\n                    continue;\n                }\n\n                if (strChar === Char.LineFeed || strChar === Char.CarriageReturn) {\n                    break;\n                }\n\n                if (strChar === quoteChar) {\n                    if (!isTriplicate) {\n                        strOffset++;\n                        appendOutputChar(strChar);\n                        break;\n                    }\n\n                    if (getEscapedCharacter(1) === quoteChar && getEscapedCharacter(2) === quoteChar) {\n                        strOffset += 3;\n                        appendOutputChar(strChar);\n                        appendOutputChar(strChar);\n                        appendOutputChar(strChar);\n                        break;\n                    }\n                }\n\n                appendOutputChar(strChar);\n            }\n        } else {\n            // There's nothing to unescape, so output the escaped character directly.\n            if (isBytes && curChar >= 128) {\n                output.nonAsciiInBytes = true;\n            }\n\n            appendOutputChar(curChar);\n            strOffset++;\n        }\n    }\n}\n\nfunction _isWhitespaceChar(charCode: number): boolean {\n    return charCode === Char.Space || charCode === Char.Tab;\n}\n\nfunction _isAlphaNumericChar(charCode: number): boolean {\n    if (charCode >= Char._0 && charCode <= Char._9) {\n        return true;\n    }\n\n    if (charCode >= Char.a && charCode <= Char.z) {\n        return true;\n    }\n\n    if (charCode >= Char.A && charCode <= Char.Z) {\n        return true;\n    }\n\n    return false;\n}\n\nfunction _isOctalCharCode(charCode: number): boolean {\n    return charCode >= Char._0 && charCode <= Char._7;\n}\n\nfunction _isHexCharCode(charCode: number): boolean {\n    if (charCode >= Char._0 && charCode <= Char._9) {\n        return true;\n    }\n\n    if (charCode >= Char.a && charCode <= Char.f) {\n        return true;\n    }\n\n    if (charCode >= Char.A && charCode <= Char.F) {\n        return true;\n    }\n\n    return false;\n}\n\nfunction _getHexDigitValue(charCode: number): number {\n    if (charCode >= Char._0 && charCode <= Char._9) {\n        return charCode - Char._0;\n    }\n\n    if (charCode >= Char.a && charCode <= Char.f) {\n        return charCode - Char.a + 10;\n    }\n\n    if (charCode >= Char.A && charCode <= Char.F) {\n        return charCode - Char.A + 10;\n    }\n\n    return 0;\n}\n","/*\n * tokenizer.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Based on code from vscode-python repository:\n *  https://github.com/Microsoft/vscode-python\n *\n * Converts a Python program text stream into a stream of tokens.\n */\n\nimport Char from 'typescript-char';\n\nimport { TextRange } from '../common/textRange';\nimport { TextRangeCollection } from '../common/textRangeCollection';\nimport { isBinary, isDecimal, isHex, isIdentifierChar, isIdentifierStartChar, isOctal } from './characters';\nimport { CharacterStream } from './characterStream';\nimport {\n    Comment,\n    DedentToken,\n    IdentifierToken,\n    IndentToken,\n    KeywordToken,\n    KeywordType,\n    NewLineToken,\n    NewLineType,\n    NumberToken,\n    OperatorFlags,\n    OperatorToken,\n    OperatorType,\n    StringToken,\n    StringTokenFlags,\n    Token,\n    TokenType,\n} from './tokenizerTypes';\n\nconst _keywords: { [key: string]: KeywordType } = {\n    and: KeywordType.And,\n    as: KeywordType.As,\n    assert: KeywordType.Assert,\n    async: KeywordType.Async,\n    await: KeywordType.Await,\n    break: KeywordType.Break,\n    class: KeywordType.Class,\n    continue: KeywordType.Continue,\n    __debug__: KeywordType.Debug,\n    def: KeywordType.Def,\n    del: KeywordType.Del,\n    elif: KeywordType.Elif,\n    else: KeywordType.Else,\n    except: KeywordType.Except,\n    finally: KeywordType.Finally,\n    for: KeywordType.For,\n    from: KeywordType.From,\n    global: KeywordType.Global,\n    if: KeywordType.If,\n    import: KeywordType.Import,\n    in: KeywordType.In,\n    is: KeywordType.Is,\n    lambda: KeywordType.Lambda,\n    nonlocal: KeywordType.Nonlocal,\n    not: KeywordType.Not,\n    or: KeywordType.Or,\n    pass: KeywordType.Pass,\n    raise: KeywordType.Raise,\n    return: KeywordType.Return,\n    try: KeywordType.Try,\n    while: KeywordType.While,\n    with: KeywordType.With,\n    yield: KeywordType.Yield,\n    False: KeywordType.False,\n    None: KeywordType.None,\n    True: KeywordType.True,\n};\n\nconst _operatorInfo: { [key: number]: OperatorFlags } = {\n    [OperatorType.Add]: OperatorFlags.Unary | OperatorFlags.Binary,\n    [OperatorType.AddEqual]: OperatorFlags.Assignment,\n    [OperatorType.Assign]: OperatorFlags.Assignment,\n    [OperatorType.BitwiseAnd]: OperatorFlags.Binary,\n    [OperatorType.BitwiseAndEqual]: OperatorFlags.Assignment,\n    [OperatorType.BitwiseInvert]: OperatorFlags.Unary,\n    [OperatorType.BitwiseOr]: OperatorFlags.Binary,\n    [OperatorType.BitwiseOrEqual]: OperatorFlags.Assignment,\n    [OperatorType.BitwiseXor]: OperatorFlags.Binary,\n    [OperatorType.BitwiseXorEqual]: OperatorFlags.Assignment,\n    [OperatorType.Divide]: OperatorFlags.Binary,\n    [OperatorType.DivideEqual]: OperatorFlags.Assignment,\n    [OperatorType.Equals]: OperatorFlags.Binary | OperatorFlags.Comparison,\n    [OperatorType.FloorDivide]: OperatorFlags.Binary,\n    [OperatorType.FloorDivideEqual]: OperatorFlags.Assignment,\n    [OperatorType.GreaterThan]: OperatorFlags.Binary | OperatorFlags.Comparison,\n    [OperatorType.GreaterThanOrEqual]: OperatorFlags.Binary | OperatorFlags.Comparison,\n    [OperatorType.LeftShift]: OperatorFlags.Binary,\n    [OperatorType.LeftShiftEqual]: OperatorFlags.Assignment,\n    [OperatorType.LessOrGreaterThan]: OperatorFlags.Binary | OperatorFlags.Comparison | OperatorFlags.Deprecated,\n    [OperatorType.LessThan]: OperatorFlags.Binary | OperatorFlags.Comparison,\n    [OperatorType.LessThanOrEqual]: OperatorFlags.Binary | OperatorFlags.Comparison,\n    [OperatorType.MatrixMultiply]: OperatorFlags.Binary,\n    [OperatorType.MatrixMultiplyEqual]: OperatorFlags.Assignment,\n    [OperatorType.Mod]: OperatorFlags.Binary,\n    [OperatorType.ModEqual]: OperatorFlags.Assignment,\n    [OperatorType.Multiply]: OperatorFlags.Binary,\n    [OperatorType.MultiplyEqual]: OperatorFlags.Assignment,\n    [OperatorType.NotEquals]: OperatorFlags.Binary | OperatorFlags.Comparison,\n    [OperatorType.Power]: OperatorFlags.Binary,\n    [OperatorType.PowerEqual]: OperatorFlags.Assignment,\n    [OperatorType.RightShift]: OperatorFlags.Binary,\n    [OperatorType.RightShiftEqual]: OperatorFlags.Assignment,\n    [OperatorType.Subtract]: OperatorFlags.Binary,\n    [OperatorType.SubtractEqual]: OperatorFlags.Assignment,\n\n    [OperatorType.And]: OperatorFlags.Binary,\n    [OperatorType.Or]: OperatorFlags.Binary,\n    [OperatorType.Not]: OperatorFlags.Unary,\n    [OperatorType.Is]: OperatorFlags.Binary,\n    [OperatorType.IsNot]: OperatorFlags.Binary,\n    [OperatorType.In]: OperatorFlags.Binary,\n    [OperatorType.NotIn]: OperatorFlags.Binary,\n};\n\nconst _byteOrderMarker = 0xfeff;\n\nexport interface TokenizerOutput {\n    // List of all tokens.\n    tokens: TextRangeCollection<Token>;\n\n    // List of ranges that comprise the lines.\n    lines: TextRangeCollection<TextRange>;\n\n    // Map of all line numbers that end in a \"type: ignore\" comment.\n    typeIgnoreLines: { [line: number]: boolean };\n\n    // Program starts with a \"type: ignore\" comment.\n    typeIgnoreAll: boolean;\n\n    // Line-end sequence ('/n', '/r', or '/r/n').\n    predominantEndOfLineSequence: string;\n\n    // Tab sequence ('/t or consecutive spaces).\n    predominantTabSequence: string;\n\n    // Does the code mostly use single or double quote\n    // characters for string literals?\n    predominantSingleQuoteCharacter: string;\n}\n\ninterface StringScannerOutput {\n    escapedValue: string;\n    flags: StringTokenFlags;\n}\n\ninterface IndentInfo {\n    tab1Spaces: number;\n    tab8Spaces: number;\n    isSpacePresent: boolean;\n    isTabPresent: boolean;\n}\n\nexport class Tokenizer {\n    private _cs = new CharacterStream('');\n    private _tokens: Token[] = [];\n    private _prevLineStart = 0;\n    private _parenDepth = 0;\n    private _lineRanges: TextRange[] = [];\n    private _indentAmounts: IndentInfo[] = [];\n    private _typeIgnoreAll = false;\n    private _typeIgnoreLines: { [line: number]: boolean } = {};\n    private _comments: Comment[] | undefined;\n\n    // Total times CR, CR/LF, and LF are used to terminate\n    // lines. Used to determine the predominant line ending.\n    private _crCount = 0;\n    private _crLfCount = 0;\n    private _lfCount = 0;\n\n    // Number of times an indent token is emitted.\n    private _indentCount = 0;\n\n    // Number of times an indent token is emitted and a tab character\n    // is present (used to determine predominant tab sequence).\n    private _indentTabCount = 0;\n\n    // Number of spaces that are added for an indent token\n    // (used to determine predominant tab sequence).\n    private _indentSpacesTotal = 0;\n\n    // Number of single or double quote string literals found\n    // in the code.\n    private _singleQuoteCount = 0;\n    private _doubleQuoteCount = 0;\n\n    tokenize(text: string, start?: number, length?: number, initialParenDepth = 0): TokenizerOutput {\n        if (start === undefined) {\n            start = 0;\n        } else if (start < 0 || start > text.length) {\n            throw new Error('Invalid range start');\n        }\n\n        if (length === undefined) {\n            length = text.length;\n        } else if (length < 0 || start + length > text.length) {\n            throw new Error('Invalid range length');\n        } else if (start + length < text.length) {\n            text = text.substr(0, start + length);\n        }\n\n        this._cs = new CharacterStream(text);\n        this._cs.position = start;\n        this._tokens = [];\n        this._prevLineStart = 0;\n        this._parenDepth = initialParenDepth;\n        this._lineRanges = [];\n        this._indentAmounts = [];\n\n        const end = start + length;\n        while (!this._cs.isEndOfStream()) {\n            this._addNextToken();\n\n            if (this._cs.position >= end) {\n                break;\n            }\n        }\n\n        // Insert an implied new line to make parsing easier.\n        if (this._tokens.length === 0 || this._tokens[this._tokens.length - 1].type !== TokenType.NewLine) {\n            this._tokens.push(NewLineToken.create(this._cs.position, 0, NewLineType.Implied, this._getComments()));\n        }\n\n        // Insert any implied dedent tokens.\n        this._setIndent(0, 0, true, false);\n\n        // Add a final end-of-stream token to make parsing easier.\n        this._tokens.push(Token.create(TokenType.EndOfStream, this._cs.position, 0, this._getComments()));\n\n        // Add the final line range.\n        this._addLineRange();\n\n        let predominantEndOfLineSequence = '\\n';\n        if (this._crCount > this._crLfCount && this._crCount > this._lfCount) {\n            predominantEndOfLineSequence = '\\r';\n        } else if (this._crLfCount > this._crCount && this._crLfCount > this._lfCount) {\n            predominantEndOfLineSequence = '\\r\\n';\n        }\n\n        let predominantTabSequence = '    ';\n        // If more than half of the indents use tab sequences,\n        // assume we're using tabs rather than spaces.\n        if (this._indentTabCount > this._indentCount / 2) {\n            predominantTabSequence = '\\t';\n        } else if (this._indentCount > 0) {\n            // Compute the average number of spaces per indent\n            // to estimate the predominant tab value.\n            let averageSpacePerIndent = Math.round(this._indentSpacesTotal / this._indentCount);\n            if (averageSpacePerIndent < 1) {\n                averageSpacePerIndent = 1;\n            } else if (averageSpacePerIndent > 8) {\n                averageSpacePerIndent = 8;\n            }\n            predominantTabSequence = '';\n            for (let i = 0; i < averageSpacePerIndent; i++) {\n                predominantTabSequence += ' ';\n            }\n        }\n\n        return {\n            tokens: new TextRangeCollection(this._tokens),\n            lines: new TextRangeCollection(this._lineRanges),\n            typeIgnoreLines: this._typeIgnoreLines,\n            typeIgnoreAll: this._typeIgnoreAll,\n            predominantEndOfLineSequence,\n            predominantTabSequence,\n            predominantSingleQuoteCharacter: this._singleQuoteCount >= this._doubleQuoteCount ? \"'\" : '\"',\n        };\n    }\n\n    static getOperatorInfo(operatorType: OperatorType): OperatorFlags {\n        return _operatorInfo[operatorType];\n    }\n\n    static isOperatorAssignment(operatorType?: OperatorType): boolean {\n        if (operatorType === undefined || _operatorInfo[operatorType] === undefined) {\n            return false;\n        }\n        return (_operatorInfo[operatorType] & OperatorFlags.Assignment) !== 0;\n    }\n\n    static isOperatorComparison(operatorType?: OperatorType): boolean {\n        if (operatorType === undefined || _operatorInfo[operatorType] === undefined) {\n            return false;\n        }\n        return (_operatorInfo[operatorType] & OperatorFlags.Comparison) !== 0;\n    }\n\n    private _addNextToken(): void {\n        this._cs.skipWhitespace();\n\n        if (this._cs.isEndOfStream()) {\n            return;\n        }\n\n        if (!this._handleCharacter()) {\n            this._cs.moveNext();\n        }\n    }\n\n    private _handleCharacter(): boolean {\n        // f-strings, b-strings, etc\n        const stringPrefixLength = this._getStringPrefixLength();\n\n        if (stringPrefixLength >= 0) {\n            let stringPrefix = '';\n            if (stringPrefixLength > 0) {\n                stringPrefix = this._cs.getText().substr(this._cs.position, stringPrefixLength);\n                // Indeed a string\n                this._cs.advance(stringPrefixLength);\n            }\n\n            const quoteTypeFlags = this._getQuoteTypeFlags(stringPrefix);\n            if (quoteTypeFlags !== StringTokenFlags.None) {\n                this._handleString(quoteTypeFlags, stringPrefixLength);\n                return true;\n            }\n        }\n\n        if (this._cs.currentChar === Char.Hash) {\n            this._handleComment();\n            return true;\n        }\n\n        switch (this._cs.currentChar) {\n            case _byteOrderMarker: {\n                // Skip the BOM if it's at the start of the file.\n                if (this._cs.position === 0) {\n                    return false;\n                }\n                return this._handleInvalid();\n            }\n\n            case Char.CarriageReturn: {\n                const length = this._cs.nextChar === Char.LineFeed ? 2 : 1;\n                const newLineType = length === 2 ? NewLineType.CarriageReturnLineFeed : NewLineType.CarriageReturn;\n                this._handleNewLine(length, newLineType);\n                return true;\n            }\n\n            case Char.LineFeed: {\n                this._handleNewLine(1, NewLineType.LineFeed);\n                return true;\n            }\n\n            case Char.Backslash: {\n                if (this._cs.nextChar === Char.CarriageReturn) {\n                    if (this._cs.lookAhead(2) === Char.LineFeed) {\n                        this._cs.advance(3);\n                    } else {\n                        this._cs.advance(2);\n                    }\n                    this._addLineRange();\n                    return true;\n                } else if (this._cs.nextChar === Char.LineFeed) {\n                    this._cs.advance(2);\n                    this._addLineRange();\n                    return true;\n                }\n                return this._handleInvalid();\n            }\n\n            case Char.OpenParenthesis: {\n                this._parenDepth++;\n                this._tokens.push(Token.create(TokenType.OpenParenthesis, this._cs.position, 1, this._getComments()));\n                break;\n            }\n\n            case Char.CloseParenthesis: {\n                if (this._parenDepth > 0) {\n                    this._parenDepth--;\n                }\n                this._tokens.push(Token.create(TokenType.CloseParenthesis, this._cs.position, 1, this._getComments()));\n                break;\n            }\n\n            case Char.OpenBracket: {\n                this._parenDepth++;\n                this._tokens.push(Token.create(TokenType.OpenBracket, this._cs.position, 1, this._getComments()));\n                break;\n            }\n\n            case Char.CloseBracket: {\n                if (this._parenDepth > 0) {\n                    this._parenDepth--;\n                }\n                this._tokens.push(Token.create(TokenType.CloseBracket, this._cs.position, 1, this._getComments()));\n                break;\n            }\n\n            case Char.OpenBrace: {\n                this._parenDepth++;\n                this._tokens.push(Token.create(TokenType.OpenCurlyBrace, this._cs.position, 1, this._getComments()));\n                break;\n            }\n\n            case Char.CloseBrace: {\n                if (this._parenDepth > 0) {\n                    this._parenDepth--;\n                }\n                this._tokens.push(Token.create(TokenType.CloseCurlyBrace, this._cs.position, 1, this._getComments()));\n                break;\n            }\n\n            case Char.Comma: {\n                this._tokens.push(Token.create(TokenType.Comma, this._cs.position, 1, this._getComments()));\n                break;\n            }\n\n            case Char.Backtick: {\n                this._tokens.push(Token.create(TokenType.Backtick, this._cs.position, 1, this._getComments()));\n                break;\n            }\n\n            case Char.Semicolon: {\n                this._tokens.push(Token.create(TokenType.Semicolon, this._cs.position, 1, this._getComments()));\n                break;\n            }\n\n            case Char.Colon: {\n                if (this._cs.nextChar === Char.Equal) {\n                    this._tokens.push(\n                        OperatorToken.create(this._cs.position, 2, OperatorType.Walrus, this._getComments())\n                    );\n                    this._cs.advance(1);\n                    break;\n                }\n                this._tokens.push(Token.create(TokenType.Colon, this._cs.position, 1, this._getComments()));\n                break;\n            }\n\n            default: {\n                if (this._isPossibleNumber()) {\n                    if (this._tryNumber()) {\n                        return true;\n                    }\n                }\n\n                if (this._cs.currentChar === Char.Period) {\n                    if (this._cs.nextChar === Char.Period && this._cs.lookAhead(2) === Char.Period) {\n                        this._tokens.push(Token.create(TokenType.Ellipsis, this._cs.position, 3, this._getComments()));\n                        this._cs.advance(3);\n                        return true;\n                    }\n                    this._tokens.push(Token.create(TokenType.Dot, this._cs.position, 1, this._getComments()));\n                    break;\n                }\n\n                if (!this._tryIdentifier()) {\n                    if (!this._tryOperator()) {\n                        return this._handleInvalid();\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private _addLineRange() {\n        const lineLength = this._cs.position - this._prevLineStart;\n        if (lineLength > 0) {\n            this._lineRanges.push({ start: this._prevLineStart, length: lineLength });\n        }\n\n        this._prevLineStart = this._cs.position;\n    }\n\n    private _handleNewLine(length: number, newLineType: NewLineType) {\n        if (this._parenDepth === 0 && newLineType !== NewLineType.Implied) {\n            // New lines are ignored within parentheses.\n            // We'll also avoid adding multiple newlines in a row to simplify parsing.\n            if (this._tokens.length === 0 || this._tokens[this._tokens.length - 1].type !== TokenType.NewLine) {\n                this._tokens.push(NewLineToken.create(this._cs.position, length, newLineType, this._getComments()));\n            }\n        }\n        if (newLineType === NewLineType.CarriageReturn) {\n            this._crCount++;\n        } else if (newLineType === NewLineType.CarriageReturnLineFeed) {\n            this._crLfCount++;\n        } else {\n            this._lfCount++;\n        }\n        this._cs.advance(length);\n        this._addLineRange();\n        this._readIndentationAfterNewLine();\n    }\n\n    private _readIndentationAfterNewLine() {\n        let tab1Spaces = 0;\n        let tab8Spaces = 0;\n        let isTabPresent = false;\n        let isSpacePresent = false;\n\n        while (!this._cs.isEndOfStream()) {\n            switch (this._cs.currentChar) {\n                case Char.Space:\n                    tab1Spaces++;\n                    tab8Spaces++;\n                    isSpacePresent = true;\n                    this._cs.moveNext();\n                    break;\n\n                case Char.Tab:\n                    // Translate tabs into spaces assuming both 1-space\n                    // and 8-space tab stops.\n                    tab1Spaces++;\n                    tab8Spaces += 8 - (tab8Spaces % 8);\n                    isTabPresent = true;\n                    this._cs.moveNext();\n                    break;\n\n                case Char.FormFeed:\n                    tab1Spaces = 0;\n                    tab8Spaces = 0;\n                    isTabPresent = false;\n                    isSpacePresent = false;\n                    this._cs.moveNext();\n                    break;\n\n                default:\n                    // Non-blank line. Set the current indent level.\n                    this._setIndent(tab1Spaces, tab8Spaces, isSpacePresent, isTabPresent);\n                    return;\n\n                case Char.Hash:\n                case Char.LineFeed:\n                case Char.CarriageReturn:\n                    // Blank line -- no need to adjust indentation.\n                    return;\n            }\n        }\n    }\n\n    // The caller must specify two space count values. The first assumes\n    // that tabs are translated into one-space tab stops. The second assumes\n    // that tabs are translated into eight-space tab stops.\n    private _setIndent(tab1Spaces: number, tab8Spaces: number, isSpacePresent: boolean, isTabPresent: boolean) {\n        // Indentations are ignored within a parenthesized clause.\n        if (this._parenDepth > 0) {\n            return;\n        }\n\n        // Insert indent or dedent tokens as necessary.\n        if (this._indentAmounts.length === 0) {\n            if (tab8Spaces > 0) {\n                this._indentCount++;\n                if (isTabPresent) {\n                    this._indentTabCount++;\n                }\n                this._indentSpacesTotal += tab8Spaces;\n\n                this._indentAmounts.push({\n                    tab1Spaces,\n                    tab8Spaces,\n                    isSpacePresent,\n                    isTabPresent,\n                });\n                this._tokens.push(IndentToken.create(this._cs.position, 0, tab8Spaces, false, this._getComments()));\n            }\n        } else {\n            const prevTabInfo = this._indentAmounts[this._indentAmounts.length - 1];\n            if (prevTabInfo.tab8Spaces < tab8Spaces) {\n                // The Python spec says that if there is ambiguity about how tabs should\n                // be translated into spaces because the user has intermixed tabs and\n                // spaces, it should be an error. We'll record this condition in the token\n                // so the parser can later report it.\n                const isIndentAmbiguous =\n                    ((prevTabInfo.isSpacePresent && isTabPresent) || (prevTabInfo.isTabPresent && isSpacePresent)) &&\n                    prevTabInfo.tab1Spaces >= tab1Spaces;\n\n                this._indentCount++;\n                if (isTabPresent) {\n                    this._indentTabCount++;\n                }\n                this._indentSpacesTotal += tab8Spaces - this._indentAmounts[this._indentAmounts.length - 1].tab8Spaces;\n\n                this._indentAmounts.push({\n                    tab1Spaces,\n                    tab8Spaces,\n                    isSpacePresent,\n                    isTabPresent,\n                });\n\n                this._tokens.push(\n                    IndentToken.create(this._cs.position, 0, tab8Spaces, isIndentAmbiguous, this._getComments())\n                );\n            } else {\n                // The Python spec says that dedent amounts need to match the indent\n                // amount exactly. An error is generated at runtime if it doesn't.\n                // We'll record that error condition within the token, allowing the\n                // parser to report it later.\n                const dedentPoints: number[] = [];\n                while (\n                    this._indentAmounts.length > 0 &&\n                    this._indentAmounts[this._indentAmounts.length - 1].tab8Spaces > tab8Spaces\n                ) {\n                    dedentPoints.push(\n                        this._indentAmounts.length > 1\n                            ? this._indentAmounts[this._indentAmounts.length - 2].tab8Spaces\n                            : 0\n                    );\n                    this._indentAmounts.pop();\n                }\n\n                dedentPoints.forEach((dedentAmount, index) => {\n                    const matchesIndent = index < dedentPoints.length - 1 || dedentAmount === tab8Spaces;\n                    const actualDedentAmount = index < dedentPoints.length - 1 ? dedentAmount : tab8Spaces;\n                    this._tokens.push(\n                        DedentToken.create(this._cs.position, 0, actualDedentAmount, matchesIndent, this._getComments())\n                    );\n                });\n            }\n        }\n    }\n\n    private _tryIdentifier(): boolean {\n        const start = this._cs.position;\n        if (isIdentifierStartChar(this._cs.currentChar)) {\n            this._cs.moveNext();\n            while (isIdentifierChar(this._cs.currentChar)) {\n                this._cs.moveNext();\n            }\n        }\n        if (this._cs.position > start) {\n            const value = this._cs.getText().substr(start, this._cs.position - start);\n            if (_keywords[value] !== undefined) {\n                this._tokens.push(\n                    KeywordToken.create(start, this._cs.position - start, _keywords[value], this._getComments())\n                );\n            } else {\n                this._tokens.push(IdentifierToken.create(start, this._cs.position - start, value, this._getComments()));\n            }\n            return true;\n        }\n        return false;\n    }\n\n    private _isPossibleNumber(): boolean {\n        if (isDecimal(this._cs.currentChar)) {\n            return true;\n        }\n\n        if (this._cs.currentChar === Char.Period && isDecimal(this._cs.nextChar)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    private _tryNumber(): boolean {\n        const start = this._cs.position;\n\n        if (this._cs.currentChar === Char._0) {\n            let radix = 0;\n            let leadingChars = 0;\n\n            // Try hex => hexinteger: \"0\" (\"x\" | \"X\") ([\"_\"] hexdigit)+\n            if ((this._cs.nextChar === Char.x || this._cs.nextChar === Char.X) && isHex(this._cs.lookAhead(2))) {\n                this._cs.advance(2);\n                leadingChars = 2;\n                while (isHex(this._cs.currentChar)) {\n                    this._cs.moveNext();\n                }\n                radix = 16;\n            }\n\n            // Try binary => bininteger: \"0\" (\"b\" | \"B\") ([\"_\"] bindigit)+\n            if ((this._cs.nextChar === Char.b || this._cs.nextChar === Char.B) && isBinary(this._cs.lookAhead(2))) {\n                this._cs.advance(2);\n                leadingChars = 2;\n                while (isBinary(this._cs.currentChar)) {\n                    this._cs.moveNext();\n                }\n                radix = 2;\n            }\n\n            // Try octal => octinteger: \"0\" (\"o\" | \"O\") ([\"_\"] octdigit)+\n            if ((this._cs.nextChar === Char.o || this._cs.nextChar === Char.O) && isOctal(this._cs.lookAhead(2))) {\n                this._cs.advance(2);\n                leadingChars = 2;\n                while (isOctal(this._cs.currentChar)) {\n                    this._cs.moveNext();\n                }\n                radix = 8;\n            }\n\n            if (radix > 0) {\n                const text = this._cs.getText().substr(start, this._cs.position - start);\n                const value = parseInt(text.substr(leadingChars).replace(/_/g, ''), radix);\n                if (!isNaN(value)) {\n                    this._tokens.push(NumberToken.create(start, text.length, value, true, false, this._getComments()));\n                    return true;\n                }\n            }\n        }\n\n        let isDecimalInteger = false;\n        let mightBeFloatingPoint = false;\n        // Try decimal int =>\n        //    decinteger: nonzerodigit ([\"_\"] digit)* | \"0\" ([\"_\"] \"0\")*\n        //    nonzerodigit: \"1\"...\"9\"\n        //    digit: \"0\"...\"9\"\n        if (this._cs.currentChar >= Char._1 && this._cs.currentChar <= Char._9) {\n            while (isDecimal(this._cs.currentChar)) {\n                mightBeFloatingPoint = true;\n                this._cs.moveNext();\n            }\n            isDecimalInteger =\n                this._cs.currentChar !== Char.Period &&\n                this._cs.currentChar !== Char.e &&\n                this._cs.currentChar !== Char.E;\n        }\n\n        // \"0\" ([\"_\"] \"0\")*\n        if (this._cs.currentChar === Char._0) {\n            mightBeFloatingPoint = true;\n            while (this._cs.currentChar === Char._0 || this._cs.currentChar === Char.Underscore) {\n                this._cs.moveNext();\n            }\n            isDecimalInteger =\n                this._cs.currentChar !== Char.Period &&\n                this._cs.currentChar !== Char.e &&\n                this._cs.currentChar !== Char.E;\n        }\n\n        if (isDecimalInteger) {\n            let text = this._cs.getText().substr(start, this._cs.position - start);\n            const value = parseInt(text.replace(/_/g, ''), 10);\n            if (!isNaN(value)) {\n                let isImaginary = false;\n                if (this._cs.currentChar === Char.j || this._cs.currentChar === Char.J) {\n                    isImaginary = true;\n                    text += String.fromCharCode(this._cs.currentChar);\n                    this._cs.moveNext();\n                }\n                this._tokens.push(\n                    NumberToken.create(start, text.length, value, true, isImaginary, this._getComments())\n                );\n                return true;\n            }\n        }\n\n        // Floating point. Sign and leading digits were already skipped over.\n        this._cs.position = start;\n        if (\n            mightBeFloatingPoint ||\n            (this._cs.currentChar === Char.Period && this._cs.nextChar >= Char._0 && this._cs.nextChar <= Char._9)\n        ) {\n            if (this._skipFloatingPointCandidate()) {\n                let text = this._cs.getText().substr(start, this._cs.position - start);\n                const value = parseFloat(text);\n                if (!isNaN(value)) {\n                    let isImaginary = false;\n                    if (this._cs.currentChar === Char.j || this._cs.currentChar === Char.J) {\n                        isImaginary = true;\n                        text += String.fromCharCode(this._cs.currentChar);\n                        this._cs.moveNext();\n                    }\n                    this._tokens.push(\n                        NumberToken.create(\n                            start,\n                            this._cs.position - start,\n                            value,\n                            false,\n                            isImaginary,\n                            this._getComments()\n                        )\n                    );\n                    return true;\n                }\n            }\n        }\n\n        this._cs.position = start;\n        return false;\n    }\n\n    private _tryOperator(): boolean {\n        let length = 0;\n        const nextChar = this._cs.nextChar;\n        let operatorType: OperatorType;\n\n        switch (this._cs.currentChar) {\n            case Char.Plus:\n                length = nextChar === Char.Equal ? 2 : 1;\n                operatorType = length === 2 ? OperatorType.AddEqual : OperatorType.Add;\n                break;\n\n            case Char.Ampersand:\n                length = nextChar === Char.Equal ? 2 : 1;\n                operatorType = length === 2 ? OperatorType.BitwiseAndEqual : OperatorType.BitwiseAnd;\n                break;\n\n            case Char.Bar:\n                length = nextChar === Char.Equal ? 2 : 1;\n                operatorType = length === 2 ? OperatorType.BitwiseOrEqual : OperatorType.BitwiseOr;\n                break;\n\n            case Char.Caret:\n                length = nextChar === Char.Equal ? 2 : 1;\n                operatorType = length === 2 ? OperatorType.BitwiseXorEqual : OperatorType.BitwiseXor;\n                break;\n\n            case Char.Equal:\n                length = nextChar === Char.Equal ? 2 : 1;\n                operatorType = length === 2 ? OperatorType.Equals : OperatorType.Assign;\n                break;\n\n            case Char.ExclamationMark:\n                if (nextChar !== Char.Equal) {\n                    return false;\n                }\n                length = 2;\n                operatorType = OperatorType.NotEquals;\n                break;\n\n            case Char.Percent:\n                length = nextChar === Char.Equal ? 2 : 1;\n                operatorType = length === 2 ? OperatorType.ModEqual : OperatorType.Mod;\n                break;\n\n            case Char.Tilde:\n                length = 1;\n                operatorType = OperatorType.BitwiseInvert;\n                break;\n\n            case Char.Hyphen:\n                if (nextChar === Char.Greater) {\n                    this._tokens.push(Token.create(TokenType.Arrow, this._cs.position, 2, this._getComments()));\n                    this._cs.advance(2);\n                    return true;\n                }\n\n                length = nextChar === Char.Equal ? 2 : 1;\n                operatorType = length === 2 ? OperatorType.SubtractEqual : OperatorType.Subtract;\n                break;\n\n            case Char.Asterisk:\n                if (nextChar === Char.Asterisk) {\n                    length = this._cs.lookAhead(2) === Char.Equal ? 3 : 2;\n                    operatorType = length === 3 ? OperatorType.PowerEqual : OperatorType.Power;\n                } else {\n                    length = nextChar === Char.Equal ? 2 : 1;\n                    operatorType = length === 2 ? OperatorType.MultiplyEqual : OperatorType.Multiply;\n                }\n                break;\n\n            case Char.Slash:\n                if (nextChar === Char.Slash) {\n                    length = this._cs.lookAhead(2) === Char.Equal ? 3 : 2;\n                    operatorType = length === 3 ? OperatorType.FloorDivideEqual : OperatorType.FloorDivide;\n                } else {\n                    length = nextChar === Char.Equal ? 2 : 1;\n                    operatorType = length === 2 ? OperatorType.DivideEqual : OperatorType.Divide;\n                }\n                break;\n\n            case Char.Less:\n                if (nextChar === Char.Less) {\n                    length = this._cs.lookAhead(2) === Char.Equal ? 3 : 2;\n                    operatorType = length === 3 ? OperatorType.LeftShiftEqual : OperatorType.LeftShift;\n                } else if (nextChar === Char.Greater) {\n                    length = 2;\n                    operatorType = OperatorType.LessOrGreaterThan;\n                } else {\n                    length = nextChar === Char.Equal ? 2 : 1;\n                    operatorType = length === 2 ? OperatorType.LessThanOrEqual : OperatorType.LessThan;\n                }\n                break;\n\n            case Char.Greater:\n                if (nextChar === Char.Greater) {\n                    length = this._cs.lookAhead(2) === Char.Equal ? 3 : 2;\n                    operatorType = length === 3 ? OperatorType.RightShiftEqual : OperatorType.RightShift;\n                } else {\n                    length = nextChar === Char.Equal ? 2 : 1;\n                    operatorType = length === 2 ? OperatorType.GreaterThanOrEqual : OperatorType.GreaterThan;\n                }\n                break;\n\n            case Char.At:\n                length = nextChar === Char.Equal ? 2 : 1;\n                operatorType = length === 2 ? OperatorType.MatrixMultiplyEqual : OperatorType.MatrixMultiply;\n                break;\n\n            default:\n                return false;\n        }\n        this._tokens.push(OperatorToken.create(this._cs.position, length, operatorType, this._getComments()));\n        this._cs.advance(length);\n        return length > 0;\n    }\n\n    private _handleInvalid(): boolean {\n        const start = this._cs.position;\n        while (true) {\n            if (\n                this._cs.currentChar === Char.LineFeed ||\n                this._cs.currentChar === Char.CarriageReturn ||\n                this._cs.isAtWhiteSpace() ||\n                this._cs.isEndOfStream()\n            ) {\n                break;\n            }\n            this._cs.moveNext();\n        }\n        const length = this._cs.position - start;\n        if (length > 0) {\n            this._tokens.push(Token.create(TokenType.Invalid, start, length, this._getComments()));\n            return true;\n        }\n        return false;\n    }\n\n    private _getComments(): Comment[] | undefined {\n        const prevComments = this._comments;\n        this._comments = undefined;\n        return prevComments;\n    }\n\n    private _handleComment(): void {\n        const start = this._cs.position + 1;\n        this._cs.skipToEol();\n\n        const length = this._cs.position - start;\n        const value = this._cs.getText().substr(start, length);\n        const comment = Comment.create(start, length, value);\n\n        // We include \"[\" in the regular expression because mypy supports\n        // ignore comments of the form ignore[errorCode, ...]. We'll treat\n        // these as regular ignore statements (as though no errorCodes were\n        // included).\n        if (value.match(/^\\s*type:\\s*ignore(\\s|\\[|$)/)) {\n            if (this._tokens.findIndex((t) => t.type !== TokenType.NewLine && t && t.type !== TokenType.Indent) < 0) {\n                this._typeIgnoreAll = true;\n            } else {\n                this._typeIgnoreLines[this._lineRanges.length] = true;\n            }\n        }\n\n        if (this._comments) {\n            this._comments.push(comment);\n        } else {\n            this._comments = [comment];\n        }\n    }\n\n    private _getStringPrefixLength(): number {\n        if (this._cs.currentChar === Char.SingleQuote || this._cs.currentChar === Char.DoubleQuote) {\n            // Simple string, no prefix\n            return 0;\n        }\n\n        if (this._cs.nextChar === Char.SingleQuote || this._cs.nextChar === Char.DoubleQuote) {\n            switch (this._cs.currentChar) {\n                case Char.f:\n                case Char.F:\n                case Char.r:\n                case Char.R:\n                case Char.b:\n                case Char.B:\n                case Char.u:\n                case Char.U:\n                    // Single-char prefix like u\"\" or r\"\"\n                    return 1;\n                default:\n                    break;\n            }\n        }\n\n        if (this._cs.lookAhead(2) === Char.SingleQuote || this._cs.lookAhead(2) === Char.DoubleQuote) {\n            const prefix = this._cs.getText().substr(this._cs.position, 2).toLowerCase();\n            switch (prefix) {\n                case 'rf':\n                case 'fr':\n                case 'ur':\n                case 'ru':\n                case 'br':\n                case 'rb':\n                    return 2;\n                default:\n                    break;\n            }\n        }\n        return -1;\n    }\n\n    private _getQuoteTypeFlags(prefix: string): StringTokenFlags {\n        let flags = StringTokenFlags.None;\n\n        prefix = prefix.toLowerCase();\n        for (let i = 0; i < prefix.length; i++) {\n            switch (prefix[i]) {\n                case 'u':\n                    flags |= StringTokenFlags.Unicode;\n                    break;\n\n                case 'b':\n                    flags |= StringTokenFlags.Bytes;\n                    break;\n\n                case 'r':\n                    flags |= StringTokenFlags.Raw;\n                    break;\n\n                case 'f':\n                    flags |= StringTokenFlags.Format;\n                    break;\n            }\n        }\n\n        if (this._cs.currentChar === Char.SingleQuote) {\n            flags |= StringTokenFlags.SingleQuote;\n            if (this._cs.nextChar === Char.SingleQuote && this._cs.lookAhead(2) === Char.SingleQuote) {\n                flags |= StringTokenFlags.Triplicate;\n            }\n        } else if (this._cs.currentChar === Char.DoubleQuote) {\n            flags |= StringTokenFlags.DoubleQuote;\n            if (this._cs.nextChar === Char.DoubleQuote && this._cs.lookAhead(2) === Char.DoubleQuote) {\n                flags |= StringTokenFlags.Triplicate;\n            }\n        }\n\n        return flags;\n    }\n\n    private _handleString(flags: StringTokenFlags, stringPrefixLength: number): void {\n        const start = this._cs.position - stringPrefixLength;\n\n        if (flags & StringTokenFlags.Triplicate) {\n            this._cs.advance(3);\n        } else {\n            this._cs.moveNext();\n\n            if (flags & StringTokenFlags.SingleQuote) {\n                this._singleQuoteCount++;\n            } else {\n                this._doubleQuoteCount++;\n            }\n        }\n\n        const stringLiteralInfo = this._skipToEndOfStringLiteral(flags);\n\n        const end = this._cs.position;\n\n        this._tokens.push(\n            StringToken.create(\n                start,\n                end - start,\n                stringLiteralInfo.flags,\n                stringLiteralInfo.escapedValue,\n                stringPrefixLength,\n                this._getComments()\n            )\n        );\n    }\n\n    private _skipToEndOfStringLiteral(flags: StringTokenFlags): StringScannerOutput {\n        const quoteChar = flags & StringTokenFlags.SingleQuote ? Char.SingleQuote : Char.DoubleQuote;\n        const isTriplicate = (flags & StringTokenFlags.Triplicate) !== 0;\n        let escapedValue = '';\n\n        while (true) {\n            if (this._cs.isEndOfStream()) {\n                // Hit the end of file without a termination.\n                flags |= StringTokenFlags.Unterminated;\n                return { escapedValue, flags };\n            }\n\n            if (this._cs.currentChar === Char.Backslash) {\n                escapedValue += String.fromCharCode(this._cs.currentChar);\n\n                // Move past the escape (backslash) character.\n                this._cs.moveNext();\n\n                if (this._cs.getCurrentChar() === Char.CarriageReturn || this._cs.getCurrentChar() === Char.LineFeed) {\n                    if (this._cs.getCurrentChar() === Char.CarriageReturn && this._cs.nextChar === Char.LineFeed) {\n                        escapedValue += String.fromCharCode(this._cs.getCurrentChar());\n                        this._cs.moveNext();\n                    }\n                    escapedValue += String.fromCharCode(this._cs.getCurrentChar());\n                    this._cs.moveNext();\n                    this._addLineRange();\n                } else {\n                    escapedValue += String.fromCharCode(this._cs.getCurrentChar());\n                    this._cs.moveNext();\n                }\n            } else if (this._cs.currentChar === Char.LineFeed || this._cs.currentChar === Char.CarriageReturn) {\n                if (!isTriplicate) {\n                    // Unterminated single-line string\n                    flags |= StringTokenFlags.Unterminated;\n                    return { escapedValue, flags };\n                }\n\n                // Skip over the new line (either one or two characters).\n                if (this._cs.currentChar === Char.CarriageReturn && this._cs.nextChar === Char.LineFeed) {\n                    escapedValue += String.fromCharCode(this._cs.currentChar);\n                    this._cs.moveNext();\n                }\n\n                escapedValue += String.fromCharCode(this._cs.currentChar);\n                this._cs.moveNext();\n                this._addLineRange();\n            } else if (!isTriplicate && this._cs.currentChar === quoteChar) {\n                this._cs.moveNext();\n                break;\n            } else if (\n                isTriplicate &&\n                this._cs.currentChar === quoteChar &&\n                this._cs.nextChar === quoteChar &&\n                this._cs.lookAhead(2) === quoteChar\n            ) {\n                this._cs.advance(3);\n                break;\n            } else {\n                escapedValue += String.fromCharCode(this._cs.currentChar);\n                this._cs.moveNext();\n            }\n        }\n\n        return { escapedValue, flags };\n    }\n\n    private _skipFloatingPointCandidate(): boolean {\n        // Determine end of the potential floating point number\n        const start = this._cs.position;\n        this._skipFractionalNumber();\n        if (this._cs.position > start) {\n            // Optional exponent sign\n            if (this._cs.currentChar === Char.e || this._cs.currentChar === Char.E) {\n                this._cs.moveNext();\n\n                // Skip exponent value\n                this._skipDecimalNumber(true);\n            }\n        }\n        return this._cs.position > start;\n    }\n\n    private _skipFractionalNumber(): void {\n        this._skipDecimalNumber(false);\n        if (this._cs.currentChar === Char.Period) {\n            // Optional period\n            this._cs.moveNext();\n        }\n        this._skipDecimalNumber(false);\n    }\n\n    private _skipDecimalNumber(allowSign: boolean): void {\n        if (allowSign && (this._cs.currentChar === Char.Hyphen || this._cs.currentChar === Char.Plus)) {\n            // Optional sign\n            this._cs.moveNext();\n        }\n        while (isDecimal(this._cs.currentChar)) {\n            // Skip integer part\n            this._cs.moveNext();\n        }\n    }\n}\n","/*\n * tokenizerTypes.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Based on code from vscode-python repository:\n *  https://github.com/Microsoft/vscode-python\n *\n * Interface, enumeration and class definitions used within\n * the Python tokenizer.\n */\n\nimport { TextRange } from '../common/textRange';\n\nexport const enum TokenType {\n    Invalid,\n    EndOfStream,\n    NewLine,\n    Indent,\n    Dedent,\n    String,\n    Number,\n    Identifier,\n    Keyword,\n    Operator,\n    Colon,\n    Semicolon,\n    Comma,\n    OpenParenthesis,\n    CloseParenthesis,\n    OpenBracket,\n    CloseBracket,\n    OpenCurlyBrace,\n    CloseCurlyBrace,\n    Ellipsis,\n    Dot,\n    Arrow,\n    Backtick,\n}\n\nexport const enum NewLineType {\n    CarriageReturn,\n    LineFeed,\n    CarriageReturnLineFeed,\n    Implied,\n}\n\nexport const enum OperatorType {\n    // These operators are used with tokens\n    // of type TokenType.Operator.\n    Add,\n    AddEqual,\n    Assign,\n    BitwiseAnd,\n    BitwiseAndEqual,\n    BitwiseInvert,\n    BitwiseOr,\n    BitwiseOrEqual,\n    BitwiseXor,\n    BitwiseXorEqual,\n    Divide,\n    DivideEqual,\n    Equals,\n    FloorDivide,\n    FloorDivideEqual,\n    GreaterThan,\n    GreaterThanOrEqual,\n    LeftShift,\n    LeftShiftEqual,\n    LessOrGreaterThan,\n    LessThan,\n    LessThanOrEqual,\n    MatrixMultiply,\n    MatrixMultiplyEqual,\n    Mod,\n    ModEqual,\n    Multiply,\n    MultiplyEqual,\n    NotEquals,\n    Power,\n    PowerEqual,\n    RightShift,\n    RightShiftEqual,\n    Subtract,\n    SubtractEqual,\n    Walrus,\n\n    // These operators are used with tokens\n    // of type TokenType.Keyword.\n    And,\n    Or,\n    Not,\n    Is,\n    IsNot,\n    In,\n    NotIn,\n}\n\nexport const enum OperatorFlags {\n    Unary = 1 << 0,\n    Binary = 1 << 1,\n    Assignment = 1 << 2,\n    Comparison = 1 << 3,\n    Deprecated = 1 << 4,\n}\n\nexport const enum KeywordType {\n    And,\n    As,\n    Assert,\n    Async,\n    Await,\n    Break,\n    Class,\n    Continue,\n    Debug,\n    Def,\n    Del,\n    Elif,\n    Else,\n    Except,\n    False,\n    Finally,\n    For,\n    From,\n    Global,\n    If,\n    Import,\n    In,\n    Is,\n    Lambda,\n    None,\n    Nonlocal,\n    Not,\n    Or,\n    Pass,\n    Raise,\n    Return,\n    True,\n    Try,\n    While,\n    With,\n    Yield,\n}\n\nexport const enum StringTokenFlags {\n    None = 0,\n\n    // Quote types\n    SingleQuote = 1 << 0,\n    DoubleQuote = 1 << 1,\n    Triplicate = 1 << 2,\n\n    // String content format\n    Raw = 1 << 3,\n    Unicode = 1 << 4,\n    Bytes = 1 << 5,\n    Format = 1 << 6,\n\n    // Error conditions\n    Unterminated = 1 << 16,\n}\n\nexport interface Comment extends TextRange {\n    readonly value: string;\n    readonly start: number;\n    readonly length: number;\n}\n\nexport namespace Comment {\n    export function create(start: number, length: number, value: string) {\n        const comment: Comment = {\n            start,\n            length,\n            value,\n        };\n\n        return comment;\n    }\n}\n\nexport interface TokenBase extends TextRange {\n    readonly type: TokenType;\n\n    // Comments prior to the token.\n    readonly comments?: Comment[];\n}\n\nexport interface Token extends TokenBase {}\n\nexport namespace Token {\n    export function create(type: TokenType, start: number, length: number, comments: Comment[] | undefined) {\n        const token: Token = {\n            start,\n            length,\n            type,\n            comments,\n        };\n\n        return token;\n    }\n}\n\nexport interface IndentToken extends Token {\n    readonly type: TokenType.Indent;\n    readonly indentAmount: number;\n    readonly isIndentAmbiguous: boolean;\n}\n\nexport namespace IndentToken {\n    export function create(\n        start: number,\n        length: number,\n        indentAmount: number,\n        isIndentAmbiguous: boolean,\n        comments: Comment[] | undefined\n    ) {\n        const token: IndentToken = {\n            start,\n            length,\n            type: TokenType.Indent,\n            isIndentAmbiguous,\n            comments,\n            indentAmount,\n        };\n\n        return token;\n    }\n}\n\nexport interface DedentToken extends Token {\n    readonly type: TokenType.Dedent;\n    readonly indentAmount: number;\n    readonly matchesIndent: boolean;\n}\n\nexport namespace DedentToken {\n    export function create(\n        start: number,\n        length: number,\n        indentAmount: number,\n        matchesIndent: boolean,\n        comments: Comment[] | undefined\n    ) {\n        const token: DedentToken = {\n            start,\n            length,\n            type: TokenType.Dedent,\n            comments,\n            indentAmount,\n            matchesIndent,\n        };\n\n        return token;\n    }\n}\n\nexport interface NewLineToken extends Token {\n    readonly type: TokenType.NewLine;\n    readonly newLineType: NewLineType;\n}\n\nexport namespace NewLineToken {\n    export function create(start: number, length: number, newLineType: NewLineType, comments: Comment[] | undefined) {\n        const token: NewLineToken = {\n            start,\n            length,\n            type: TokenType.NewLine,\n            comments,\n            newLineType,\n        };\n\n        return token;\n    }\n}\n\nexport interface KeywordToken extends Token {\n    readonly type: TokenType.Keyword;\n    readonly keywordType: KeywordType;\n}\n\nexport namespace KeywordToken {\n    export function create(start: number, length: number, keywordType: KeywordType, comments: Comment[] | undefined) {\n        const token: KeywordToken = {\n            start,\n            length,\n            type: TokenType.Keyword,\n            comments,\n            keywordType,\n        };\n\n        return token;\n    }\n}\n\nexport interface StringToken extends Token {\n    readonly type: TokenType.String;\n    readonly flags: StringTokenFlags;\n\n    // Use StringTokenUtils to convert escaped value to unescaped value.\n    readonly escapedValue: string;\n\n    // Number of characters in token that appear before\n    // the quote marks (e.g. \"r\" or \"UR\").\n    readonly prefixLength: number;\n\n    // Number of characters in token that make up the quote\n    // (either 1 or 3).\n    readonly quoteMarkLength: number;\n}\n\nexport namespace StringToken {\n    export function create(\n        start: number,\n        length: number,\n        flags: StringTokenFlags,\n        escapedValue: string,\n        prefixLength: number,\n        comments: Comment[] | undefined\n    ) {\n        const token: StringToken = {\n            start,\n            length,\n            type: TokenType.String,\n            flags,\n            escapedValue,\n            prefixLength,\n            quoteMarkLength: flags & StringTokenFlags.Triplicate ? 3 : 1,\n            comments,\n        };\n\n        return token;\n    }\n}\n\nexport interface NumberToken extends Token {\n    readonly type: TokenType.Number;\n    readonly value: number;\n    readonly isInteger: boolean;\n    readonly isImaginary: boolean;\n}\n\nexport namespace NumberToken {\n    export function create(\n        start: number,\n        length: number,\n        value: number,\n        isInteger: boolean,\n        isImaginary: boolean,\n        comments: Comment[] | undefined\n    ) {\n        const token: NumberToken = {\n            start,\n            length,\n            type: TokenType.Number,\n            isInteger,\n            isImaginary,\n            value,\n            comments,\n        };\n\n        return token;\n    }\n}\n\nexport interface OperatorToken extends Token {\n    readonly type: TokenType.Operator;\n    readonly operatorType: OperatorType;\n}\n\nexport namespace OperatorToken {\n    export function create(start: number, length: number, operatorType: OperatorType, comments: Comment[] | undefined) {\n        const token: OperatorToken = {\n            start,\n            length,\n            type: TokenType.Operator,\n            operatorType,\n            comments,\n        };\n\n        return token;\n    }\n}\n\nexport interface IdentifierToken extends Token {\n    readonly type: TokenType.Identifier;\n    readonly value: string;\n}\n\nexport namespace IdentifierToken {\n    export function create(start: number, length: number, value: string, comments: Comment[] | undefined) {\n        const token: IdentifierToken = {\n            start,\n            length,\n            type: TokenType.Identifier,\n            value,\n            comments,\n        };\n\n        return token;\n    }\n}\n","/*\n * unicode.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Tables that encode Unicode character codes for various Unicode-\n * defined categories used in the Python spec. These tables were built\n * from the npm package unicode, which contains the same information\n * in a much more verbose form.\n */\n\nexport type UnicodeRangeTable = ([number, number] | number)[];\n\nexport const unicodeLu: UnicodeRangeTable = [\n    [65, 90],\n    [192, 214],\n    [216, 222],\n    256,\n    258,\n    260,\n    262,\n    264,\n    266,\n    268,\n    270,\n    272,\n    274,\n    276,\n    278,\n    280,\n    282,\n    284,\n    286,\n    288,\n    290,\n    292,\n    294,\n    296,\n    298,\n    300,\n    302,\n    304,\n    306,\n    308,\n    310,\n    313,\n    315,\n    317,\n    319,\n    321,\n    323,\n    325,\n    327,\n    330,\n    332,\n    334,\n    336,\n    338,\n    340,\n    342,\n    344,\n    346,\n    348,\n    350,\n    352,\n    354,\n    356,\n    358,\n    360,\n    362,\n    364,\n    366,\n    368,\n    370,\n    372,\n    374,\n    [376, 377],\n    379,\n    381,\n    [385, 386],\n    388,\n    [390, 391],\n    [393, 395],\n    [398, 401],\n    [403, 404],\n    [406, 408],\n    [412, 413],\n    [415, 416],\n    418,\n    420,\n    [422, 423],\n    425,\n    428,\n    [430, 431],\n    [433, 435],\n    437,\n    [439, 440],\n    444,\n    452,\n    455,\n    458,\n    461,\n    463,\n    465,\n    467,\n    469,\n    471,\n    473,\n    475,\n    478,\n    480,\n    482,\n    484,\n    486,\n    488,\n    490,\n    492,\n    494,\n    497,\n    500,\n    [502, 504],\n    506,\n    508,\n    510,\n    512,\n    514,\n    516,\n    518,\n    520,\n    522,\n    524,\n    526,\n    528,\n    530,\n    532,\n    534,\n    536,\n    538,\n    540,\n    542,\n    544,\n    546,\n    548,\n    550,\n    552,\n    554,\n    556,\n    558,\n    560,\n    562,\n    [570, 571],\n    [573, 574],\n    577,\n    [579, 582],\n    584,\n    586,\n    588,\n    590,\n    880,\n    882,\n    886,\n    895,\n    902,\n    [904, 906],\n    908,\n    [910, 911],\n    [913, 929],\n    [931, 939],\n    975,\n    [978, 980],\n    984,\n    986,\n    988,\n    990,\n    992,\n    994,\n    996,\n    998,\n    1000,\n    1002,\n    1004,\n    1006,\n    1012,\n    1015,\n    [1017, 1018],\n    [1021, 1071],\n    1120,\n    1122,\n    1124,\n    1126,\n    1128,\n    1130,\n    1132,\n    1134,\n    1136,\n    1138,\n    1140,\n    1142,\n    1144,\n    1146,\n    1148,\n    1150,\n    1152,\n    1162,\n    1164,\n    1166,\n    1168,\n    1170,\n    1172,\n    1174,\n    1176,\n    1178,\n    1180,\n    1182,\n    1184,\n    1186,\n    1188,\n    1190,\n    1192,\n    1194,\n    1196,\n    1198,\n    1200,\n    1202,\n    1204,\n    1206,\n    1208,\n    1210,\n    1212,\n    1214,\n    [1216, 1217],\n    1219,\n    1221,\n    1223,\n    1225,\n    1227,\n    1229,\n    1232,\n    1234,\n    1236,\n    1238,\n    1240,\n    1242,\n    1244,\n    1246,\n    1248,\n    1250,\n    1252,\n    1254,\n    1256,\n    1258,\n    1260,\n    1262,\n    1264,\n    1266,\n    1268,\n    1270,\n    1272,\n    1274,\n    1276,\n    1278,\n    1280,\n    1282,\n    1284,\n    1286,\n    1288,\n    1290,\n    1292,\n    1294,\n    1296,\n    1298,\n    1300,\n    1302,\n    1304,\n    1306,\n    1308,\n    1310,\n    1312,\n    1314,\n    1316,\n    1318,\n    1320,\n    1322,\n    1324,\n    1326,\n    [1329, 1366],\n    [4256, 4293],\n    4295,\n    4301,\n    [5024, 5109],\n    7680,\n    7682,\n    7684,\n    7686,\n    7688,\n    7690,\n    7692,\n    7694,\n    7696,\n    7698,\n    7700,\n    7702,\n    7704,\n    7706,\n    7708,\n    7710,\n    7712,\n    7714,\n    7716,\n    7718,\n    7720,\n    7722,\n    7724,\n    7726,\n    7728,\n    7730,\n    7732,\n    7734,\n    7736,\n    7738,\n    7740,\n    7742,\n    7744,\n    7746,\n    7748,\n    7750,\n    7752,\n    7754,\n    7756,\n    7758,\n    7760,\n    7762,\n    7764,\n    7766,\n    7768,\n    7770,\n    7772,\n    7774,\n    7776,\n    7778,\n    7780,\n    7782,\n    7784,\n    7786,\n    7788,\n    7790,\n    7792,\n    7794,\n    7796,\n    7798,\n    7800,\n    7802,\n    7804,\n    7806,\n    7808,\n    7810,\n    7812,\n    7814,\n    7816,\n    7818,\n    7820,\n    7822,\n    7824,\n    7826,\n    7828,\n    7838,\n    7840,\n    7842,\n    7844,\n    7846,\n    7848,\n    7850,\n    7852,\n    7854,\n    7856,\n    7858,\n    7860,\n    7862,\n    7864,\n    7866,\n    7868,\n    7870,\n    7872,\n    7874,\n    7876,\n    7878,\n    7880,\n    7882,\n    7884,\n    7886,\n    7888,\n    7890,\n    7892,\n    7894,\n    7896,\n    7898,\n    7900,\n    7902,\n    7904,\n    7906,\n    7908,\n    7910,\n    7912,\n    7914,\n    7916,\n    7918,\n    7920,\n    7922,\n    7924,\n    7926,\n    7928,\n    7930,\n    7932,\n    7934,\n    [7944, 7951],\n    [7960, 7965],\n    [7976, 7983],\n    [7992, 7999],\n    [8008, 8013],\n    8025,\n    8027,\n    8029,\n    8031,\n    [8040, 8047],\n    [8120, 8123],\n    [8136, 8139],\n    [8152, 8155],\n    [8168, 8172],\n    [8184, 8187],\n    8450,\n    8455,\n    [8459, 8461],\n    [8464, 8466],\n    8469,\n    [8473, 8477],\n    8484,\n    8486,\n    8488,\n    [8490, 8493],\n    [8496, 8499],\n    [8510, 8511],\n    8517,\n    8579,\n    [11264, 11310],\n    11360,\n    [11362, 11364],\n    11367,\n    11369,\n    11371,\n    [11373, 11376],\n    11378,\n    11381,\n    [11390, 11392],\n    11394,\n    11396,\n    11398,\n    11400,\n    11402,\n    11404,\n    11406,\n    11408,\n    11410,\n    11412,\n    11414,\n    11416,\n    11418,\n    11420,\n    11422,\n    11424,\n    11426,\n    11428,\n    11430,\n    11432,\n    11434,\n    11436,\n    11438,\n    11440,\n    11442,\n    11444,\n    11446,\n    11448,\n    11450,\n    11452,\n    11454,\n    11456,\n    11458,\n    11460,\n    11462,\n    11464,\n    11466,\n    11468,\n    11470,\n    11472,\n    11474,\n    11476,\n    11478,\n    11480,\n    11482,\n    11484,\n    11486,\n    11488,\n    11490,\n    11499,\n    11501,\n    11506,\n    42560,\n    42562,\n    42564,\n    42566,\n    42568,\n    42570,\n    42572,\n    42574,\n    42576,\n    42578,\n    42580,\n    42582,\n    42584,\n    42586,\n    42588,\n    42590,\n    42592,\n    42594,\n    42596,\n    42598,\n    42600,\n    42602,\n    42604,\n    42624,\n    42626,\n    42628,\n    42630,\n    42632,\n    42634,\n    42636,\n    42638,\n    42640,\n    42642,\n    42644,\n    42646,\n    42648,\n    42650,\n    42786,\n    42788,\n    42790,\n    42792,\n    42794,\n    42796,\n    42798,\n    42802,\n    42804,\n    42806,\n    42808,\n    42810,\n    42812,\n    42814,\n    42816,\n    42818,\n    42820,\n    42822,\n    42824,\n    42826,\n    42828,\n    42830,\n    42832,\n    42834,\n    42836,\n    42838,\n    42840,\n    42842,\n    42844,\n    42846,\n    42848,\n    42850,\n    42852,\n    42854,\n    42856,\n    42858,\n    42860,\n    42862,\n    42873,\n    42875,\n    [42877, 42878],\n    42880,\n    42882,\n    42884,\n    42886,\n    42891,\n    42893,\n    42896,\n    42898,\n    42902,\n    42904,\n    42906,\n    42908,\n    42910,\n    42912,\n    42914,\n    42916,\n    42918,\n    42920,\n    [42922, 42926],\n    [42928, 42932],\n    42934,\n    [65313, 65338],\n    [66560, 66599],\n    [66736, 66771],\n    [68736, 68786],\n    [71840, 71871],\n    [119808, 119833],\n    [119860, 119885],\n    [119912, 119937],\n    119964,\n    [119966, 119967],\n    119970,\n    [119973, 119974],\n    [119977, 119980],\n    [119982, 119989],\n    [120016, 120041],\n    [120068, 120069],\n    [120071, 120074],\n    [120077, 120084],\n    [120086, 120092],\n    [120120, 120121],\n    [120123, 120126],\n    [120128, 120132],\n    120134,\n    [120138, 120144],\n    [120172, 120197],\n    [120224, 120249],\n    [120276, 120301],\n    [120328, 120353],\n    [120380, 120405],\n    [120432, 120457],\n    [120488, 120512],\n    [120546, 120570],\n    [120604, 120628],\n    [120662, 120686],\n    [120720, 120744],\n    120778,\n    [125184, 125217],\n];\n\nexport const unicodeLl: UnicodeRangeTable = [\n    [97, 122],\n    181,\n    [223, 246],\n    [248, 255],\n    257,\n    259,\n    261,\n    263,\n    265,\n    267,\n    269,\n    271,\n    273,\n    275,\n    277,\n    279,\n    281,\n    283,\n    285,\n    287,\n    289,\n    291,\n    293,\n    295,\n    297,\n    299,\n    301,\n    303,\n    305,\n    307,\n    309,\n    [311, 312],\n    314,\n    316,\n    318,\n    320,\n    322,\n    324,\n    326,\n    [328, 329],\n    331,\n    333,\n    335,\n    337,\n    339,\n    341,\n    343,\n    345,\n    347,\n    349,\n    351,\n    353,\n    355,\n    357,\n    359,\n    361,\n    363,\n    365,\n    367,\n    369,\n    371,\n    373,\n    375,\n    378,\n    380,\n    [382, 384],\n    387,\n    389,\n    392,\n    [396, 397],\n    402,\n    405,\n    [409, 411],\n    414,\n    417,\n    419,\n    421,\n    424,\n    [426, 427],\n    429,\n    432,\n    436,\n    438,\n    [441, 442],\n    [445, 447],\n    454,\n    457,\n    460,\n    462,\n    464,\n    466,\n    468,\n    470,\n    472,\n    474,\n    [476, 477],\n    479,\n    481,\n    483,\n    485,\n    487,\n    489,\n    491,\n    493,\n    [495, 496],\n    499,\n    501,\n    505,\n    507,\n    509,\n    511,\n    513,\n    515,\n    517,\n    519,\n    521,\n    523,\n    525,\n    527,\n    529,\n    531,\n    533,\n    535,\n    537,\n    539,\n    541,\n    543,\n    545,\n    547,\n    549,\n    551,\n    553,\n    555,\n    557,\n    559,\n    561,\n    [563, 569],\n    572,\n    [575, 576],\n    578,\n    583,\n    585,\n    587,\n    589,\n    [591, 659],\n    [661, 687],\n    881,\n    883,\n    887,\n    [891, 893],\n    912,\n    [940, 974],\n    [976, 977],\n    [981, 983],\n    985,\n    987,\n    989,\n    991,\n    993,\n    995,\n    997,\n    999,\n    1001,\n    1003,\n    1005,\n    [1007, 1011],\n    1013,\n    1016,\n    [1019, 1020],\n    [1072, 1119],\n    1121,\n    1123,\n    1125,\n    1127,\n    1129,\n    1131,\n    1133,\n    1135,\n    1137,\n    1139,\n    1141,\n    1143,\n    1145,\n    1147,\n    1149,\n    1151,\n    1153,\n    1163,\n    1165,\n    1167,\n    1169,\n    1171,\n    1173,\n    1175,\n    1177,\n    1179,\n    1181,\n    1183,\n    1185,\n    1187,\n    1189,\n    1191,\n    1193,\n    1195,\n    1197,\n    1199,\n    1201,\n    1203,\n    1205,\n    1207,\n    1209,\n    1211,\n    1213,\n    1215,\n    1218,\n    1220,\n    1222,\n    1224,\n    1226,\n    1228,\n    [1230, 1231],\n    1233,\n    1235,\n    1237,\n    1239,\n    1241,\n    1243,\n    1245,\n    1247,\n    1249,\n    1251,\n    1253,\n    1255,\n    1257,\n    1259,\n    1261,\n    1263,\n    1265,\n    1267,\n    1269,\n    1271,\n    1273,\n    1275,\n    1277,\n    1279,\n    1281,\n    1283,\n    1285,\n    1287,\n    1289,\n    1291,\n    1293,\n    1295,\n    1297,\n    1299,\n    1301,\n    1303,\n    1305,\n    1307,\n    1309,\n    1311,\n    1313,\n    1315,\n    1317,\n    1319,\n    1321,\n    1323,\n    1325,\n    1327,\n    [1377, 1415],\n    [5112, 5117],\n    [7296, 7304],\n    [7424, 7467],\n    [7531, 7543],\n    [7545, 7578],\n    7681,\n    7683,\n    7685,\n    7687,\n    7689,\n    7691,\n    7693,\n    7695,\n    7697,\n    7699,\n    7701,\n    7703,\n    7705,\n    7707,\n    7709,\n    7711,\n    7713,\n    7715,\n    7717,\n    7719,\n    7721,\n    7723,\n    7725,\n    7727,\n    7729,\n    7731,\n    7733,\n    7735,\n    7737,\n    7739,\n    7741,\n    7743,\n    7745,\n    7747,\n    7749,\n    7751,\n    7753,\n    7755,\n    7757,\n    7759,\n    7761,\n    7763,\n    7765,\n    7767,\n    7769,\n    7771,\n    7773,\n    7775,\n    7777,\n    7779,\n    7781,\n    7783,\n    7785,\n    7787,\n    7789,\n    7791,\n    7793,\n    7795,\n    7797,\n    7799,\n    7801,\n    7803,\n    7805,\n    7807,\n    7809,\n    7811,\n    7813,\n    7815,\n    7817,\n    7819,\n    7821,\n    7823,\n    7825,\n    7827,\n    [7829, 7837],\n    7839,\n    7841,\n    7843,\n    7845,\n    7847,\n    7849,\n    7851,\n    7853,\n    7855,\n    7857,\n    7859,\n    7861,\n    7863,\n    7865,\n    7867,\n    7869,\n    7871,\n    7873,\n    7875,\n    7877,\n    7879,\n    7881,\n    7883,\n    7885,\n    7887,\n    7889,\n    7891,\n    7893,\n    7895,\n    7897,\n    7899,\n    7901,\n    7903,\n    7905,\n    7907,\n    7909,\n    7911,\n    7913,\n    7915,\n    7917,\n    7919,\n    7921,\n    7923,\n    7925,\n    7927,\n    7929,\n    7931,\n    7933,\n    [7935, 7943],\n    [7952, 7957],\n    [7968, 7975],\n    [7984, 7991],\n    [8000, 8005],\n    [8016, 8023],\n    [8032, 8039],\n    [8048, 8061],\n    [8064, 8071],\n    [8080, 8087],\n    [8096, 8103],\n    [8112, 8116],\n    [8118, 8119],\n    8126,\n    [8130, 8132],\n    [8134, 8135],\n    [8144, 8147],\n    [8150, 8151],\n    [8160, 8167],\n    [8178, 8180],\n    [8182, 8183],\n    8458,\n    [8462, 8463],\n    8467,\n    8495,\n    8500,\n    8505,\n    [8508, 8509],\n    [8518, 8521],\n    8526,\n    8580,\n    [11312, 11358],\n    11361,\n    [11365, 11366],\n    11368,\n    11370,\n    11372,\n    11377,\n    [11379, 11380],\n    [11382, 11387],\n    11393,\n    11395,\n    11397,\n    11399,\n    11401,\n    11403,\n    11405,\n    11407,\n    11409,\n    11411,\n    11413,\n    11415,\n    11417,\n    11419,\n    11421,\n    11423,\n    11425,\n    11427,\n    11429,\n    11431,\n    11433,\n    11435,\n    11437,\n    11439,\n    11441,\n    11443,\n    11445,\n    11447,\n    11449,\n    11451,\n    11453,\n    11455,\n    11457,\n    11459,\n    11461,\n    11463,\n    11465,\n    11467,\n    11469,\n    11471,\n    11473,\n    11475,\n    11477,\n    11479,\n    11481,\n    11483,\n    11485,\n    11487,\n    11489,\n    [11491, 11492],\n    11500,\n    11502,\n    11507,\n    [11520, 11557],\n    11559,\n    11565,\n    42561,\n    42563,\n    42565,\n    42567,\n    42569,\n    42571,\n    42573,\n    42575,\n    42577,\n    42579,\n    2581,\n    42583,\n    42585,\n    42587,\n    42589,\n    42591,\n    42593,\n    42595,\n    42597,\n    42599,\n    42601,\n    42603,\n    42605,\n    42625,\n    42627,\n    42629,\n    42631,\n    42633,\n    42635,\n    42637,\n    42639,\n    42641,\n    42643,\n    42645,\n    42647,\n    42649,\n    42651,\n    42787,\n    42789,\n    42791,\n    42793,\n    42795,\n    42797,\n    [42799, 42801],\n    42803,\n    42805,\n    42807,\n    42809,\n    42811,\n    42813,\n    42815,\n    42817,\n    42819,\n    42821,\n    42823,\n    42825,\n    42827,\n    42829,\n    42831,\n    42833,\n    42835,\n    42837,\n    42839,\n    42841,\n    42843,\n    42845,\n    42847,\n    42849,\n    42851,\n    42853,\n    42855,\n    42857,\n    42859,\n    42861,\n    42863,\n    [42865, 42872],\n    42874,\n    42876,\n    42879,\n    42881,\n    42883,\n    42885,\n    42887,\n    42892,\n    42894,\n    42897,\n    [42899, 42901],\n    42903,\n    42905,\n    42907,\n    42909,\n    42911,\n    42913,\n    42915,\n    42917,\n    42919,\n    42921,\n    42933,\n    42935,\n    43002,\n    [43824, 43866],\n    [43872, 43877],\n    [43888, 43967],\n    [64256, 64262],\n    [64275, 64279],\n    [65345, 65370],\n    [66600, 66639],\n    [66776, 66811],\n    [68800, 68850],\n    [71872, 71903],\n    [119834, 119859],\n    [119886, 119892],\n    [119894, 119911],\n    [119938, 119963],\n    [119990, 119993],\n    119995,\n    [119997, 120003],\n    [120005, 120015],\n    [120042, 120067],\n    [120094, 120119],\n    [120146, 120171],\n    [120198, 120223],\n    [120250, 120275],\n    [120302, 120327],\n    [120354, 120379],\n    [120406, 120431],\n    [120458, 120485],\n    [120514, 120538],\n    [120540, 120545],\n    [120572, 120596],\n    [120598, 120603],\n    [120630, 120654],\n    [120656, 120661],\n    [120688, 120712],\n    [120714, 120719],\n    [120746, 120770],\n    [120772, 120777],\n    120779,\n    [125218, 125251],\n];\n\nexport const unicodeLt: UnicodeRangeTable = [\n    453,\n    456,\n    459,\n    498,\n    [8072, 8079],\n    [8088, 8095],\n    [8104, 8111],\n    8124,\n    8140,\n    8188,\n];\n\nexport const unicodeLo: UnicodeRangeTable = [\n    170,\n    186,\n    443,\n    [448, 451],\n    660,\n    [1488, 1514],\n    [1520, 1522],\n    [1568, 1599],\n    [1601, 1610],\n    [1646, 1647],\n    [1649, 1747],\n    1749,\n    [1774, 1775],\n    [1786, 1788],\n    1791,\n    1808,\n    [1810, 1839],\n    [1869, 1957],\n    1969,\n    [1994, 2026],\n    [2048, 2069],\n    [2112, 2136],\n    [2144, 2154],\n    [2208, 2228],\n    [2230, 2237],\n    [2308, 2361],\n    2365,\n    2384,\n    [2392, 2401],\n    [2418, 2432],\n    [2437, 2444],\n    [2447, 2448],\n    [2451, 2472],\n    [2474, 2480],\n    2482,\n    [2486, 2489],\n    2493,\n    2510,\n    [2524, 2525],\n    [2527, 2529],\n    [2544, 2545],\n    2556,\n    [2565, 2570],\n    [2575, 2576],\n    [2579, 2600],\n    [2602, 2608],\n    [2610, 2611],\n    [2613, 2614],\n    [2616, 2617],\n    [2649, 2652],\n    2654,\n    [2674, 2676],\n    [2693, 2701],\n    [2703, 2705],\n    [2707, 2728],\n    [2730, 2736],\n    [2738, 2739],\n    [2741, 2745],\n    2749,\n    2768,\n    [2784, 2785],\n    2809,\n    [2821, 2828],\n    [2831, 2832],\n    [2835, 2856],\n    [2858, 2864],\n    [2866, 2867],\n    [2869, 2873],\n    2877,\n    [2908, 2909],\n    [2911, 2913],\n    2929,\n    2947,\n    [2949, 2954],\n    [2958, 2960],\n    [2962, 2965],\n    [2969, 2970],\n    2972,\n    [2974, 2975],\n    [2979, 2980],\n    [2984, 2986],\n    [2990, 3001],\n    3024,\n    [3077, 3084],\n    [3086, 3088],\n    [3090, 3112],\n    [3114, 3129],\n    3133,\n    [3160, 3162],\n    [3168, 3169],\n    3200,\n    [3205, 3212],\n    [3214, 3216],\n    [3218, 3240],\n    [3242, 3251],\n    [3253, 3257],\n    3261,\n    3294,\n    [3296, 3297],\n    [3313, 3314],\n    [3333, 3340],\n    [3342, 3344],\n    [3346, 3386],\n    3389,\n    3406,\n    [3412, 3414],\n    [3423, 3425],\n    [3450, 3455],\n    [3461, 3478],\n    [3482, 3505],\n    [3507, 3515],\n    3517,\n    [3520, 3526],\n    [3585, 3632],\n    [3634, 3635],\n    [3648, 3653],\n    [3713, 3714],\n    3716,\n    [3719, 3720],\n    3722,\n    3725,\n    [3732, 3735],\n    [3737, 3743],\n    [3745, 3747],\n    3749,\n    3751,\n    [3754, 3755],\n    [3757, 3760],\n    [3762, 3763],\n    3773,\n    [3776, 3780],\n    [3804, 3807],\n    3840,\n    [3904, 3911],\n    [3913, 3948],\n    [3976, 3980],\n    [4096, 4138],\n    4159,\n    [4176, 4181],\n    [4186, 4189],\n    4193,\n    [4197, 4198],\n    [4206, 4208],\n    [4213, 4225],\n    4238,\n    [4304, 4346],\n    [4349, 4680],\n    [4682, 4685],\n    [4688, 4694],\n    4696,\n    [4698, 4701],\n    [4704, 4744],\n    [4746, 4749],\n    [4752, 4784],\n    [4786, 4789],\n    [4792, 4798],\n    4800,\n    [4802, 4805],\n    [4808, 4822],\n    [4824, 4880],\n    [4882, 4885],\n    [4888, 4954],\n    [4992, 5007],\n    [5121, 5740],\n    [5743, 5759],\n    [5761, 5786],\n    [5792, 5866],\n    [5873, 5880],\n    [5888, 5900],\n    [5902, 5905],\n    [5920, 5937],\n    [5952, 5969],\n    [5984, 5996],\n    [5998, 6000],\n    [6016, 6067],\n    6108,\n    [6176, 6210],\n    [6212, 6263],\n    [6272, 6276],\n    [6279, 6312],\n    6314,\n    [6320, 6389],\n    [6400, 6430],\n    [6480, 6509],\n    [6512, 6516],\n    [6528, 6571],\n    [6576, 6601],\n    [6656, 6678],\n    [6688, 6740],\n    [6917, 6963],\n    [6981, 6987],\n    [7043, 7072],\n    [7086, 7087],\n    [7098, 7141],\n    [7168, 7203],\n    [7245, 7247],\n    [7258, 7287],\n    [7401, 7404],\n    [7406, 7409],\n    [7413, 7414],\n    [8501, 8504],\n    [11568, 11623],\n    [11648, 11670],\n    [11680, 11686],\n    [11688, 11694],\n    [11696, 11702],\n    [11704, 11710],\n    [11712, 11718],\n    [11720, 11726],\n    [11728, 11734],\n    [11736, 11742],\n    12294,\n    12348,\n    [12353, 12438],\n    12447,\n    [12449, 12538],\n    12543,\n    [12549, 12590],\n    [12593, 12686],\n    [12704, 12730],\n    [12784, 12799],\n    [13312, 19893],\n    [19968, 40938],\n    [40960, 40980],\n    [40982, 42124],\n    [42192, 42231],\n    [42240, 42507],\n    [42512, 42527],\n    [42538, 42539],\n    42606,\n    [42656, 42725],\n    42895,\n    42999,\n    [43003, 43009],\n    [43011, 43013],\n    [43015, 43018],\n    [43020, 43042],\n    [43072, 43123],\n    [43138, 43187],\n    [43250, 43255],\n    43259,\n    43261,\n    [43274, 43301],\n    [43312, 43334],\n    [43360, 43388],\n    [43396, 43442],\n    [43488, 43492],\n    [43495, 43503],\n    [43514, 43518],\n    [43520, 43560],\n    [43584, 43586],\n    [43588, 43595],\n    [43616, 43631],\n    [43633, 43638],\n    43642,\n    [43646, 43695],\n    43697,\n    [43701, 43702],\n    [43705, 43709],\n    43712,\n    43714,\n    [43739, 43740],\n    [43744, 43754],\n    43762,\n    [43777, 43782],\n    [43785, 43790],\n    [43793, 43798],\n    [43808, 43814],\n    [43816, 43822],\n    [43968, 44002],\n    [44032, 55203],\n    [55216, 55238],\n    [55243, 55291],\n    [63744, 64109],\n    [64112, 64217],\n    64285,\n    [64287, 64296],\n    [64298, 64310],\n    [64312, 64316],\n    64318,\n    [64320, 64321],\n    [64323, 64324],\n    [64326, 64433],\n    [64467, 64829],\n    [64848, 64911],\n    [64914, 64967],\n    [65008, 65019],\n    [65136, 65140],\n    [65142, 65276],\n    [65382, 65391],\n    [65393, 65437],\n    [65440, 65470],\n    [65474, 65479],\n    [65482, 65487],\n    [65490, 65495],\n    [65498, 65500],\n    [65536, 65547],\n    [65549, 65574],\n    [65576, 65594],\n    [65596, 65597],\n    [65599, 65613],\n    [65616, 65629],\n    [65664, 65786],\n    [66176, 66204],\n    [66208, 66256],\n    [66304, 66335],\n    [66349, 66368],\n    [66370, 66377],\n    [66384, 66421],\n    [66432, 66461],\n    [66464, 66499],\n    [66504, 66511],\n    [66640, 66717],\n    [66816, 66855],\n    [66864, 66915],\n    [67072, 67382],\n    [67392, 67413],\n    [67424, 67431],\n    [67584, 67589],\n    67592,\n    [67594, 67637],\n    [67639, 67640],\n    67644,\n    [67647, 67669],\n    [67680, 67702],\n    [67712, 67742],\n    [67808, 67826],\n    [67828, 67829],\n    [67840, 67861],\n    [67872, 67897],\n    [67968, 68023],\n    [68030, 68031],\n    68096,\n    [68112, 68115],\n    [68117, 68119],\n    [68121, 68147],\n    [68192, 68220],\n    [68224, 68252],\n    [68288, 68295],\n    [68297, 68324],\n    [68352, 68405],\n    [68416, 68437],\n    [68448, 68466],\n    [68480, 68497],\n    [68608, 68680],\n    [69635, 69687],\n    [69763, 69807],\n    [69840, 69864],\n    [69891, 69926],\n    [69968, 70002],\n    70006,\n    [70019, 70066],\n    [70081, 70084],\n    70106,\n    70108,\n    [70144, 70161],\n    [70163, 70187],\n    [70272, 70278],\n    70280,\n    [70282, 70285],\n    [70287, 70301],\n    [70303, 70312],\n    [70320, 70366],\n    [70405, 70412],\n    [70415, 70416],\n    [70419, 70440],\n    [70442, 70448],\n    [70450, 70451],\n    [70453, 70457],\n    70461,\n    70480,\n    [70493, 70497],\n    [70656, 70708],\n    [70727, 70730],\n    [70784, 70831],\n    [70852, 70853],\n    70855,\n    [71040, 71086],\n    [71128, 71131],\n    [71168, 71215],\n    71236,\n    [71296, 71338],\n    [71424, 71449],\n    71935,\n    72192,\n    [72203, 72242],\n    72250,\n    72272,\n    [72284, 72323],\n    [72326, 72329],\n    [72384, 72440],\n    [72704, 72712],\n    [72714, 72750],\n    72768,\n    [72818, 72847],\n    [72960, 72966],\n    [72968, 72969],\n    [72971, 73008],\n    73030,\n    [73728, 74649],\n    [74880, 75075],\n    [77824, 78894],\n    [82944, 83526],\n    [92160, 92728],\n    [92736, 92766],\n    [92880, 92909],\n    [92928, 92975],\n    [93027, 93047],\n    [93053, 93071],\n    [93952, 94020],\n    94032,\n    [94208, 100332],\n    [100352, 101106],\n    [110592, 110878],\n    [110960, 111355],\n    [113664, 113770],\n    [113776, 113788],\n    [113792, 113800],\n    [113808, 113817],\n    [124928, 125124],\n    [126464, 126467],\n    [126469, 126495],\n    [126497, 126498],\n    126500,\n    126503,\n    [126505, 126514],\n    [126516, 126519],\n    126521,\n    126523,\n    126530,\n    126535,\n    126537,\n    126539,\n    [126541, 126543],\n    [126545, 126546],\n    126548,\n    126551,\n    126553,\n    126555,\n    126557,\n    126559,\n    [126561, 126562],\n    126564,\n    [126567, 126570],\n    [126572, 126578],\n    [126580, 126583],\n    [126585, 126588],\n    126590,\n    [126592, 126601],\n    [126603, 126619],\n    [126625, 126627],\n    [126629, 126633],\n    [126635, 126651],\n    [131072, 173782],\n    [173824, 177972],\n    [177984, 178205],\n    [178208, 183969],\n    [183984, 191456],\n    [194560, 195101],\n];\n\nexport const unicodeLm: UnicodeRangeTable = [\n    [688, 705],\n    [710, 721],\n    [736, 740],\n    748,\n    750,\n    884,\n    890,\n    1369,\n    1600,\n    [1765, 1766],\n    [2036, 2037],\n    2042,\n    2074,\n    2084,\n    2088,\n    2417,\n    3654,\n    3782,\n    4348,\n    6103,\n    6211,\n    6823,\n    [7288, 7293],\n    [7468, 7530],\n    7544,\n    [7579, 7615],\n    8305,\n    8319,\n    [8336, 8348],\n    [11388, 11389],\n    11631,\n    11823,\n    12293,\n    [12337, 12341],\n    12347,\n    [12445, 12446],\n    [12540, 12542],\n    40981,\n    [42232, 42237],\n    42508,\n    42623,\n    [42652, 42653],\n    [42775, 42783],\n    42864,\n    42888,\n    [43000, 43001],\n    43471,\n    43494,\n    43632,\n    43741,\n    [43763, 43764],\n    [43868, 43871],\n    65392,\n    [65438, 65439],\n    [92992, 92995],\n    [94099, 94111],\n    [94176, 94177],\n];\n\nexport const unicodeNl: UnicodeRangeTable = [\n    [5870, 5872],\n    [8544, 8578],\n    [8581, 8584],\n    12295,\n    [12321, 12329],\n    [12344, 12346],\n    [42726, 42735],\n    [65856, 65908],\n    66369,\n    66378,\n    [66513, 66517],\n    [74752, 74862],\n];\n\nexport const unicodeMn: UnicodeRangeTable = [\n    [768, 879],\n    [1155, 1159],\n    [1425, 1469],\n    1471,\n    [1473, 1474],\n    [1476, 1477],\n    1479,\n    [1552, 1562],\n    [1611, 1631],\n    1648,\n    [1750, 1756],\n    [1759, 1764],\n    [1767, 1768],\n    [1770, 1773],\n    1809,\n    [1840, 1866],\n    [1958, 1968],\n    [2027, 2035],\n    [2070, 2073],\n    [2075, 2083],\n    [2085, 2087],\n    [2089, 2093],\n    [2137, 2139],\n    [2260, 2273],\n    [2275, 2306],\n    2362,\n    2364,\n    [2369, 2376],\n    2381,\n    [2385, 2391],\n    [2402, 2403],\n    2433,\n    2492,\n    [2497, 2500],\n    2509,\n    [2530, 2531],\n    [2561, 2562],\n    2620,\n    [2625, 2626],\n    [2631, 2632],\n    [2635, 2637],\n    2641,\n    [2672, 2673],\n    2677,\n    [2689, 2690],\n    2748,\n    [2753, 2757],\n    [2759, 2760],\n    2765,\n    [2786, 2787],\n    [2810, 2815],\n    2817,\n    2876,\n    2879,\n    [2881, 2884],\n    2893,\n    2902,\n    [2914, 2915],\n    2946,\n    3008,\n    3021,\n    3072,\n    [3134, 3136],\n    [3142, 3144],\n    [3146, 3149],\n    [3157, 3158],\n    [3170, 3171],\n    3201,\n    3260,\n    3263,\n    3270,\n    [3276, 3277],\n    [3298, 3299],\n    [3328, 3329],\n    [3387, 3388],\n    [3393, 3396],\n    3405,\n    [3426, 3427],\n    3530,\n    [3538, 3540],\n    3542,\n    3633,\n    [3636, 3642],\n    [3655, 3662],\n    3761,\n    [3764, 3769],\n    [3771, 3772],\n    [3784, 3789],\n    [3864, 3865],\n    3893,\n    3895,\n    3897,\n    [3953, 3966],\n    [3968, 3972],\n    [3974, 3975],\n    [3981, 3991],\n    [3993, 4028],\n    4038,\n    [4141, 4144],\n    [4146, 4151],\n    [4153, 4154],\n    [4157, 4158],\n    [4184, 4185],\n    [4190, 4192],\n    [4209, 4212],\n    4226,\n    [4229, 4230],\n    4237,\n    4253,\n    [4957, 4959],\n    [5906, 5908],\n    [5938, 5940],\n    [5970, 5971],\n    [6002, 6003],\n    [6068, 6069],\n    [6071, 6077],\n    6086,\n    [6089, 6099],\n    6109,\n    [6155, 6157],\n    [6277, 6278],\n    6313,\n    [6432, 6434],\n    [6439, 6440],\n    6450,\n    [6457, 6459],\n    [6679, 6680],\n    6683,\n    6742,\n    [6744, 6750],\n    6752,\n    6754,\n    [6757, 6764],\n    [6771, 6780],\n    6783,\n    [6832, 6845],\n    [6912, 6915],\n    6964,\n    [6966, 6970],\n    6972,\n    6978,\n    [7019, 7027],\n    [7040, 7041],\n    [7074, 7077],\n    [7080, 7081],\n    [7083, 7085],\n    7142,\n    [7144, 7145],\n    7149,\n    [7151, 7153],\n    [7212, 7219],\n    [7222, 7223],\n    [7376, 7378],\n    [7380, 7392],\n    [7394, 7400],\n    7405,\n    7412,\n    [7416, 7417],\n    [7616, 7673],\n    [7675, 7679],\n    [8400, 8412],\n    8417,\n    [8421, 8432],\n    [11503, 11505],\n    11647,\n    [11744, 11775],\n    [12330, 12333],\n    [12441, 12442],\n    42607,\n    [42612, 42621],\n    [42654, 42655],\n    [42736, 42737],\n    43010,\n    43014,\n    43019,\n    [43045, 43046],\n    [43204, 43205],\n    [43232, 43249],\n    [43302, 43309],\n    [43335, 43345],\n    [43392, 43394],\n    43443,\n    [43446, 43449],\n    43452,\n    43493,\n    [43561, 43566],\n    [43569, 43570],\n    [43573, 43574],\n    43587,\n    43596,\n    43644,\n    43696,\n    [43698, 43700],\n    [43703, 43704],\n    [43710, 43711],\n    43713,\n    [43756, 43757],\n    43766,\n    44005,\n    44008,\n    44013,\n    64286,\n    [65024, 65039],\n    [65056, 65071],\n    66045,\n    66272,\n    [66422, 66426],\n    [68097, 68099],\n    [68101, 68102],\n    [68108, 68111],\n    [68152, 68154],\n    68159,\n    [68325, 68326],\n    69633,\n    [69688, 69702],\n    [69759, 69761],\n    [69811, 69814],\n    [69817, 69818],\n    [69888, 69890],\n    [69927, 69931],\n    [69933, 69940],\n    70003,\n    [70016, 70017],\n    [70070, 70078],\n    [70090, 70092],\n    [70191, 70193],\n    70196,\n    [70198, 70199],\n    70206,\n    70367,\n    [70371, 70378],\n    [70400, 70401],\n    70460,\n    70464,\n    [70502, 70508],\n    [70512, 70516],\n    [70712, 70719],\n    [70722, 70724],\n    70726,\n    [70835, 70840],\n    70842,\n    [70847, 70848],\n    [70850, 70851],\n    [71090, 71093],\n    [71100, 71101],\n    [71103, 71104],\n    [71132, 71133],\n    [71219, 71226],\n    71229,\n    [71231, 71232],\n    71339,\n    71341,\n    [71344, 71349],\n    71351,\n    [71453, 71455],\n    [71458, 71461],\n    [71463, 71467],\n    [72193, 72198],\n    [72201, 72202],\n    [72243, 72248],\n    [72251, 72254],\n    72263,\n    [72273, 72278],\n    [72281, 72283],\n    [72330, 72342],\n    [72344, 72345],\n    [72752, 72758],\n    [72760, 72765],\n    72767,\n    [72850, 72871],\n    [72874, 72880],\n    [72882, 72883],\n    [72885, 72886],\n    [73009, 73014],\n    73018,\n    [73020, 73021],\n    [73023, 73029],\n    73031,\n    [92912, 92916],\n    [92976, 92982],\n    [94095, 94098],\n    [113821, 113822],\n    [119143, 119145],\n    [119163, 119170],\n    [119173, 119179],\n    [119210, 119213],\n    [119362, 119364],\n    [121344, 121398],\n    [121403, 121452],\n    121461,\n    121476,\n    [121499, 121503],\n    [121505, 121519],\n    [122880, 122886],\n    [122888, 122904],\n    [122907, 122913],\n    [122915, 122916],\n    [122918, 122922],\n    [125136, 125142],\n    [125252, 125258],\n    [917760, 917999],\n];\n\nexport const unicodeMc: UnicodeRangeTable = [\n    2307,\n    2363,\n    [2366, 2368],\n    [2377, 2380],\n    [2382, 2383],\n    [2434, 2435],\n    [2494, 2496],\n    [2503, 2504],\n    [2507, 2508],\n    2519,\n    2563,\n    [2622, 2624],\n    2691,\n    [2750, 2752],\n    2761,\n    [2763, 2764],\n    [2818, 2819],\n    2878,\n    2880,\n    [2887, 2888],\n    [2891, 2892],\n    2903,\n    [3006, 3007],\n    [3009, 3010],\n    [3014, 3016],\n    [3018, 3020],\n    3031,\n    [3073, 3075],\n    [3137, 3140],\n    [3202, 3203],\n    3262,\n    [3264, 3268],\n    [3271, 3272],\n    [3274, 3275],\n    [3285, 3286],\n    [3330, 3331],\n    [3390, 3392],\n    [3398, 3400],\n    [3402, 3404],\n    3415,\n    [3458, 3459],\n    [3535, 3537],\n    [3544, 3551],\n    [3570, 3571],\n    [3902, 3903],\n    3967,\n    [4139, 4140],\n    4145,\n    4152,\n    [4155, 4156],\n    [4182, 4183],\n    [4194, 4196],\n    [4199, 4205],\n    [4227, 4228],\n    [4231, 4236],\n    4239,\n    [4250, 4252],\n    6070,\n    [6078, 6085],\n    [6087, 6088],\n    [6435, 6438],\n    [6441, 6443],\n    [6448, 6449],\n    [6451, 6456],\n    [6681, 6682],\n    6741,\n    6743,\n    6753,\n    [6755, 6756],\n    [6765, 6770],\n    6916,\n    6965,\n    6971,\n    [6973, 6977],\n    [6979, 6980],\n    7042,\n    7073,\n    [7078, 7079],\n    7082,\n    7143,\n    [7146, 7148],\n    7150,\n    [7154, 7155],\n    [7204, 7211],\n    [7220, 7221],\n    7393,\n    [7410, 7411],\n    7415,\n    [12334, 12335],\n    [43043, 43044],\n    43047,\n    [43136, 43137],\n    [43188, 43203],\n    [43346, 43347],\n    43395,\n    [43444, 43445],\n    [43450, 43451],\n    [43453, 43456],\n    [43567, 43568],\n    [43571, 43572],\n    43597,\n    43643,\n    43645,\n    43755,\n    [43758, 43759],\n    43765,\n    [44003, 44004],\n    [44006, 44007],\n    [44009, 44010],\n    44012,\n    69632,\n    69634,\n    69762,\n    [69808, 69810],\n    [69815, 69816],\n    69932,\n    70018,\n    [70067, 70069],\n    [70079, 70080],\n    [70188, 70190],\n    [70194, 70195],\n    70197,\n    [70368, 70370],\n    [70402, 70403],\n    [70462, 70463],\n    [70465, 70468],\n    [70471, 70472],\n    [70475, 70477],\n    70487,\n    [70498, 70499],\n    [70709, 70711],\n    [70720, 70721],\n    70725,\n    [70832, 70834],\n    70841,\n    [70843, 70846],\n    70849,\n    [71087, 71089],\n    [71096, 71099],\n    71102,\n    [71216, 71218],\n    [71227, 71228],\n    71230,\n    71340,\n    [71342, 71343],\n    71350,\n    [71456, 71457],\n    71462,\n    [72199, 72200],\n    72249,\n    [72279, 72280],\n    72343,\n    72751,\n    72766,\n    72873,\n    72881,\n    72884,\n    [94033, 94078],\n    [119141, 119142],\n    [119149, 119154],\n];\n\nexport const unicodeNd: UnicodeRangeTable = [\n    [48, 57],\n    [1632, 1641],\n    [1776, 1785],\n    [1984, 1993],\n    [2406, 2415],\n    [2534, 2543],\n    [2662, 2671],\n    [2790, 2799],\n    [2918, 2927],\n    [3046, 3055],\n    [3174, 3183],\n    [3302, 3311],\n    [3430, 3439],\n    [3558, 3567],\n    [3664, 3673],\n    [3792, 3801],\n    [3872, 3881],\n    [4160, 4169],\n    [4240, 4249],\n    [6112, 6121],\n    [6160, 6169],\n    [6470, 6479],\n    [6608, 6617],\n    [6784, 6793],\n    [6800, 6809],\n    [6992, 7001],\n    [7088, 7097],\n    [7232, 7241],\n    [7248, 7257],\n    [42528, 42537],\n    [43216, 43225],\n    [43264, 43273],\n    [43472, 43481],\n    [43504, 43513],\n    [43600, 43609],\n    [44016, 44025],\n    [65296, 65305],\n    [66720, 66729],\n    [69734, 69743],\n    [69872, 69881],\n    [69942, 69951],\n    [70096, 70105],\n    [70384, 70393],\n    [70736, 70745],\n    [70864, 70873],\n    [71248, 71257],\n    [71360, 71369],\n    [71472, 71481],\n    [71904, 71913],\n    [72784, 72793],\n    [73040, 73049],\n    [92768, 92777],\n    [93008, 93017],\n    [120782, 120831],\n    [125264, 125273],\n];\n\nexport const unicodePc: UnicodeRangeTable = [95, [8255, 8256], 8276, [65075, 65076], [65101, 65103], 65343];\n","/*\n * pyright.ts\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT license.\n * Author: Eric Traut\n *\n * Command-line entry point for pyright type checker.\n */\n\n// Add the start timer at the very top of the file, before we import other modules.\n\n/* eslint-disable */\nimport { timingStats } from './common/timing';\n/* eslint-enable */\n\nimport chalk from 'chalk';\nimport commandLineArgs from 'command-line-args';\nimport { CommandLineOptions, OptionDefinition } from 'command-line-args';\nimport * as process from 'process';\n\nimport { AnalyzerService } from './analyzer/service';\nimport { CommandLineOptions as PyrightCommandLineOptions } from './common/commandLineOptions';\nimport { NullConsole } from './common/console';\nimport { DiagnosticCategory } from './common/diagnostic';\nimport { FileDiagnostics } from './common/diagnosticSink';\nimport { combinePaths, normalizePath } from './common/pathUtils';\nimport { Range } from './common/textRange';\nimport { createFromRealFileSystem } from './common/fileSystem';\n\nconst toolName = 'pyright';\n\nenum ExitStatus {\n    NoErrors = 0,\n    ErrorsReported = 1,\n    FatalError = 2,\n    ConfigFileParseError = 3,\n}\n\ninterface PyrightJsonResults {\n    version: string;\n    time: string;\n    diagnostics: PyrightJsonDiagnostic[];\n    summary: PyrightJsonSummary;\n}\n\ninterface PyrightJsonDiagnostic {\n    file: string;\n    severity: 'error' | 'warning' | 'information';\n    message: string;\n    range: Range;\n}\n\ninterface PyrightJsonSummary {\n    filesAnalyzed: number;\n    errorCount: number;\n    warningCount: number;\n    informationCount: number;\n    timeInSec: number;\n}\n\ninterface DiagnosticResult {\n    errorCount: number;\n    warningCount: number;\n    informationCount: number;\n    diagnosticCount: number;\n}\n\nconst cancellationNone = Object.freeze({\n    isCancellationRequested: false,\n    onCancellationRequested: function () {\n        return {\n            dispose() {\n                /* empty */\n            },\n        };\n    },\n});\n\nfunction processArgs() {\n    const optionDefinitions: OptionDefinition[] = [\n        { name: 'createstub', type: String },\n        { name: 'dependencies', type: Boolean },\n        { name: 'files', type: String, multiple: true, defaultOption: true },\n        { name: 'help', alias: 'h', type: Boolean },\n        { name: 'lib', type: Boolean },\n        { name: 'outputjson', type: Boolean },\n        { name: 'project', alias: 'p', type: String },\n        { name: 'stats' },\n        { name: 'typeshed-path', alias: 't', type: String },\n        { name: 'venv-path', alias: 'v', type: String },\n        { name: 'verbose', type: Boolean },\n        { name: 'version', type: Boolean },\n        { name: 'watch', alias: 'w', type: Boolean },\n    ];\n\n    let args: CommandLineOptions;\n\n    try {\n        args = commandLineArgs(optionDefinitions);\n    } catch (err) {\n        const argErr: { name: string; optionName: string } = err;\n        if (argErr && argErr.optionName) {\n            console.error(`Unexpected option ${argErr.optionName}.\\n${toolName} --help for usage`);\n            return;\n        }\n\n        console.error(`Unexpected error\\n${toolName} --help for usage`);\n        return;\n    }\n\n    if (args.help !== undefined) {\n        printUsage();\n        return;\n    }\n\n    if (args.version !== undefined) {\n        printVersion();\n        return;\n    }\n\n    if (args.outputjson) {\n        const incompatibleArgs = ['watch', 'stats', 'verbose', 'createstub', 'dependencies'];\n        for (const arg of incompatibleArgs) {\n            if (args[arg] !== undefined) {\n                console.error(`'outputjson' option cannot be used with '${arg}' option`);\n                return;\n            }\n        }\n    }\n\n    const options = new PyrightCommandLineOptions(process.cwd(), false);\n\n    // Assume any relative paths are relative to the working directory.\n    if (args.files && Array.isArray(args.files)) {\n        options.fileSpecs = args.files;\n        options.fileSpecs = options.fileSpecs.map((f) => combinePaths(process.cwd(), f));\n    } else {\n        options.fileSpecs = [];\n    }\n\n    if (args.project) {\n        options.configFilePath = combinePaths(process.cwd(), normalizePath(args.project));\n    }\n\n    if (args['venv-path']) {\n        options.venvPath = combinePaths(process.cwd(), normalizePath(args['venv-path']));\n    }\n\n    if (args['typeshed-path']) {\n        options.typeshedPath = combinePaths(process.cwd(), normalizePath(args['typeshed-path']));\n    }\n\n    if (args.createstub) {\n        options.typeStubTargetImportName = args.createstub;\n\n        if (args.watch) {\n            console.error(`Option 'createstub' cannot be used with option 'watch'`);\n            return;\n        }\n    }\n\n    if (args.verbose) {\n        options.verboseOutput = true;\n    }\n    if (args.lib) {\n        options.useLibraryCodeForTypes = true;\n    }\n    options.checkOnlyOpenFiles = false;\n\n    const watch = args.watch !== undefined;\n    options.watchForSourceChanges = watch;\n\n    const output = args.outputjson ? new NullConsole() : undefined;\n    const service = new AnalyzerService('<default>', createFromRealFileSystem(output), output);\n\n    service.setCompletionCallback((results) => {\n        if (results.fatalErrorOccurred) {\n            process.exit(ExitStatus.FatalError);\n        }\n\n        if (results.configParseErrorOccurred) {\n            process.exit(ExitStatus.ConfigFileParseError);\n        }\n\n        let errorCount = 0;\n        if (results.diagnostics.length > 0 && !args.createstub) {\n            if (args.outputjson) {\n                const report = reportDiagnosticsAsJson(\n                    results.diagnostics,\n                    results.filesInProgram,\n                    results.elapsedTime\n                );\n                errorCount += report.errorCount;\n            } else {\n                const report = reportDiagnosticsAsText(results.diagnostics);\n                errorCount += report.errorCount;\n            }\n        }\n\n        if (args.createstub && results.filesRequiringAnalysis === 0) {\n            try {\n                service.writeTypeStub(cancellationNone);\n                service.dispose();\n                console.log(`Type stub was created for '${args.createstub}'`);\n            } catch (err) {\n                let errMessage = '';\n                if (err instanceof Error) {\n                    errMessage = ': ' + err.message;\n                }\n\n                console.error(`Error occurred when creating type stub: ` + errMessage);\n            }\n            process.exit(ExitStatus.NoErrors);\n        }\n\n        if (!args.outputjson) {\n            if (!watch) {\n                // Print the total time.\n                timingStats.printSummary(console);\n            }\n\n            if (args.stats !== undefined) {\n                // Print the stats details.\n                service.printStats();\n                timingStats.printDetails(console);\n            }\n\n            if (args.dependencies) {\n                service.printDependencies(!!args.verbose);\n            }\n        }\n\n        if (!watch) {\n            process.exit(errorCount > 0 ? ExitStatus.ErrorsReported : ExitStatus.NoErrors);\n        } else if (!args.outputjson) {\n            console.log('Watching for file changes...');\n        }\n    });\n\n    // This will trigger the analyzer.\n    service.setOptions(options);\n\n    // Sleep indefinitely.\n    const brokenPromise = new Promise(() => {\n        // Do nothing.\n    });\n    brokenPromise.then().catch();\n}\n\nfunction printUsage() {\n    console.log(\n        'Usage: ' +\n            toolName +\n            ' [options] files...\\n' +\n            '  Options:\\n' +\n            '  --createstub IMPORT              Create type stub file(s) for import\\n' +\n            '  --dependencies                   Emit import dependency information\\n' +\n            '  -h,--help                        Show this help message\\n' +\n            '  --lib                            Use library code to infer types when stubs are missing\\n' +\n            '  --outputjson                     Output results in JSON format\\n' +\n            '  -p,--project FILE OR DIRECTORY   Use the configuration file at this location\\n' +\n            '  --stats                          Print detailed performance stats\\n' +\n            '  -t,--typeshed-path DIRECTORY     Use typeshed type stubs at this location\\n' +\n            '  -v,--venv-path DIRECTORY         Directory that contains virtual environments\\n' +\n            '  --verbose                        Emit verbose diagnostics\\n' +\n            '  --version                        Print Pyright version\\n' +\n            '  -w,--watch                       Continue to run and watch for changes\\n'\n    );\n}\n\nfunction getVersionString() {\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const version = require('package.json').version;\n    return version.toString();\n}\n\nfunction printVersion() {\n    console.log(`${toolName} ${getVersionString()}`);\n}\n\nfunction reportDiagnosticsAsJson(\n    fileDiagnostics: FileDiagnostics[],\n    filesInProgram: number,\n    timeInSec: number\n): DiagnosticResult {\n    const report: PyrightJsonResults = {\n        version: getVersionString(),\n        time: Date.now().toString(),\n        diagnostics: [],\n        summary: {\n            filesAnalyzed: filesInProgram,\n            errorCount: 0,\n            warningCount: 0,\n            informationCount: 0,\n            timeInSec,\n        },\n    };\n\n    let errorCount = 0;\n    let warningCount = 0;\n    let informationCount = 0;\n\n    fileDiagnostics.forEach((fileDiag) => {\n        fileDiag.diagnostics.forEach((diag) => {\n            if (\n                diag.category === DiagnosticCategory.Error ||\n                diag.category === DiagnosticCategory.Warning ||\n                diag.category === DiagnosticCategory.Information\n            ) {\n                report.diagnostics.push({\n                    file: fileDiag.filePath,\n                    severity:\n                        diag.category === DiagnosticCategory.Error\n                            ? 'error'\n                            : DiagnosticCategory.Warning\n                            ? 'warning'\n                            : 'information',\n                    message: diag.message,\n                    range: diag.range,\n                });\n\n                if (diag.category === DiagnosticCategory.Error) {\n                    errorCount++;\n                } else if (diag.category === DiagnosticCategory.Warning) {\n                    warningCount++;\n                } else if (diag.category === DiagnosticCategory.Information) {\n                    informationCount++;\n                }\n            }\n        });\n    });\n\n    report.summary.errorCount = errorCount;\n    report.summary.warningCount = warningCount;\n    report.summary.informationCount = informationCount;\n\n    console.log(JSON.stringify(report, undefined, 4));\n\n    return {\n        errorCount,\n        warningCount,\n        informationCount,\n        diagnosticCount: errorCount + warningCount + informationCount,\n    };\n}\n\nfunction reportDiagnosticsAsText(fileDiagnostics: FileDiagnostics[]): DiagnosticResult {\n    let errorCount = 0;\n    let warningCount = 0;\n    let informationCount = 0;\n\n    fileDiagnostics.forEach((fileDiagnostics) => {\n        // Don't report unused code diagnostics.\n        const fileErrorsAndWarnings = fileDiagnostics.diagnostics.filter(\n            (diag) => diag.category !== DiagnosticCategory.UnusedCode\n        );\n\n        if (fileErrorsAndWarnings.length > 0) {\n            console.log(`${fileDiagnostics.filePath}`);\n            fileErrorsAndWarnings.forEach((diag) => {\n                let message = '  ';\n                if (diag.range) {\n                    message +=\n                        chalk.yellow(`${diag.range.start.line + 1}`) +\n                        ':' +\n                        chalk.yellow(`${diag.range.start.character + 1}`) +\n                        ' - ';\n                }\n\n                message +=\n                    diag.category === DiagnosticCategory.Error\n                        ? chalk.red('error')\n                        : diag.category === DiagnosticCategory.Warning\n                        ? chalk.green('warning')\n                        : chalk.blue('info');\n                message += `: ${diag.message}`;\n\n                const rule = diag.getRule();\n                if (rule) {\n                    message += chalk.gray(` (${rule})`);\n                }\n\n                console.log(message);\n\n                if (diag.category === DiagnosticCategory.Error) {\n                    errorCount++;\n                } else if (diag.category === DiagnosticCategory.Warning) {\n                    warningCount++;\n                } else if (diag.category === DiagnosticCategory.Information) {\n                    informationCount++;\n                }\n            });\n        }\n    });\n\n    console.log(\n        `${errorCount.toString()} ${errorCount === 1 ? 'error' : 'errors'}, ` +\n            `${warningCount.toString()} ${warningCount === 1 ? 'warning' : 'warnings'}, ` +\n            `${informationCount.toString()} ${informationCount === 1 ? 'info' : 'infos'} `\n    );\n\n    return {\n        errorCount,\n        warningCount,\n        informationCount,\n        diagnosticCount: errorCount + warningCount + informationCount,\n    };\n}\n\nexport function main() {\n    processArgs();\n}\n","/*\n * server.ts\n *\n * Implements pyright language server.\n */\n\nimport {\n    CancellationToken,\n    CodeAction,\n    CodeActionKind,\n    CodeActionParams,\n    Command,\n    ExecuteCommandParams,\n} from 'vscode-languageserver/node';\nimport { isMainThread } from 'worker_threads';\n\nimport { AnalysisResults } from './analyzer/analysis';\nimport { BackgroundAnalysis, BackgroundAnalysisRunner } from './backgroundAnalysis';\nimport { BackgroundAnalysisBase } from './backgroundAnalysisBase';\nimport { CommandController } from './commands/commandController';\nimport { getCancellationFolderName } from './common/cancellationUtils';\nimport { LogLevel } from './common/console';\nimport { isDebugMode, isString } from './common/core';\nimport { convertUriToPath, normalizeSlashes } from './common/pathUtils';\nimport { ProgressReporter } from './common/progressReporter';\nimport {\n    LanguageServerBase,\n    ProgressReporterConnection,\n    ServerSettings,\n    WorkspaceServiceInstance,\n} from './languageServerBase';\nimport { CodeActionProvider } from './languageService/codeActionProvider';\n\nconst maxAnalysisTimeInForeground = { openFilesTimeInMs: 50, noOpenFilesTimeInMs: 200 };\n\nclass PyrightServer extends LanguageServerBase {\n    private _controller: CommandController;\n\n    constructor() {\n        // eslint-disable-next-line @typescript-eslint/no-var-requires\n        const version = require('../package.json').version || '';\n\n        // When executed from CLI command (pyright-langserver), __rootDirectory is\n        // already defined. When executed from VSCode extension, rootDirectory should\n        // be __dirname.\n        const rootDirectory = (global as any).__rootDirectory || __dirname;\n        super({\n            productName: 'Pyright',\n            rootDirectory,\n            version,\n            maxAnalysisTimeInForeground,\n            progressReporterFactory: reporterFactory,\n            supportedCodeActions: [CodeActionKind.QuickFix, CodeActionKind.SourceOrganizeImports],\n        });\n\n        this._controller = new CommandController(this);\n    }\n\n    async getSettings(workspace: WorkspaceServiceInstance): Promise<ServerSettings> {\n        const serverSettings: ServerSettings = {\n            watchForSourceChanges: true,\n            watchForLibraryChanges: true,\n            openFilesOnly: true,\n            useLibraryCodeForTypes: false,\n            disableLanguageServices: false,\n            disableOrganizeImports: false,\n            typeCheckingMode: 'basic',\n            diagnosticSeverityOverrides: {},\n            logLevel: LogLevel.Info,\n            autoImportCompletions: true,\n        };\n\n        try {\n            const pythonSection = await this.getConfiguration(workspace.rootUri, 'python');\n            if (pythonSection) {\n                serverSettings.pythonPath = normalizeSlashes(pythonSection.pythonPath);\n                serverSettings.venvPath = normalizeSlashes(pythonSection.venvPath);\n            }\n\n            const pythonAnalysisSection = await this.getConfiguration(workspace.rootUri, 'python.analysis');\n            if (pythonAnalysisSection) {\n                const typeshedPaths = pythonAnalysisSection.typeshedPaths;\n                if (typeshedPaths && Array.isArray(typeshedPaths) && typeshedPaths.length > 0) {\n                    serverSettings.typeshedPath = normalizeSlashes(typeshedPaths[0]);\n                }\n\n                const stubPath = pythonAnalysisSection.stubPath;\n                if (stubPath && isString(stubPath)) {\n                    serverSettings.stubPath = normalizeSlashes(stubPath);\n                }\n\n                const diagnosticSeverityOverrides = pythonAnalysisSection.diagnosticSeverityOverrides;\n                if (diagnosticSeverityOverrides) {\n                    for (const [name, value] of Object.entries(diagnosticSeverityOverrides)) {\n                        const ruleName = this.getDiagnosticRuleName(name);\n                        const severity = this.getSeverityOverrides(value as string);\n                        if (ruleName && severity) {\n                            serverSettings.diagnosticSeverityOverrides![ruleName] = severity!;\n                        }\n                    }\n                }\n\n                if (pythonAnalysisSection.diagnosticMode !== undefined) {\n                    serverSettings.openFilesOnly = this.isOpenFilesOnly(pythonAnalysisSection.diagnosticMode);\n                } else if (pythonAnalysisSection.openFilesOnly !== undefined) {\n                    serverSettings.openFilesOnly = !!pythonAnalysisSection.openFilesOnly;\n                }\n\n                if (pythonAnalysisSection.useLibraryCodeForTypes !== undefined) {\n                    serverSettings.useLibraryCodeForTypes = !!pythonAnalysisSection.useLibraryCodeForTypes;\n                }\n\n                serverSettings.logLevel = this.convertLogLevel(pythonAnalysisSection.logLevel);\n                serverSettings.autoSearchPaths = !!pythonAnalysisSection.autoSearchPaths;\n\n                const extraPaths = pythonAnalysisSection.extraPaths;\n                if (extraPaths && Array.isArray(extraPaths) && extraPaths.length > 0) {\n                    serverSettings.extraPaths = extraPaths.map((p) => normalizeSlashes(p));\n                }\n\n                if (pythonAnalysisSection.typeCheckingMode !== undefined) {\n                    serverSettings.typeCheckingMode = pythonAnalysisSection.typeCheckingMode;\n                }\n\n                if (pythonAnalysisSection.autoImportCompletions !== undefined) {\n                    serverSettings.autoImportCompletions = pythonAnalysisSection.autoImportCompletions;\n                }\n            } else {\n                serverSettings.autoSearchPaths = true;\n            }\n\n            const pyrightSection = await this.getConfiguration(workspace.rootUri, 'pyright');\n            if (pyrightSection) {\n                if (pyrightSection.openFilesOnly !== undefined) {\n                    serverSettings.openFilesOnly = !!pyrightSection.openFilesOnly;\n                }\n\n                if (pyrightSection.useLibraryCodeForTypes !== undefined) {\n                    serverSettings.useLibraryCodeForTypes = !!pyrightSection.useLibraryCodeForTypes;\n                }\n\n                serverSettings.disableLanguageServices = !!pyrightSection.disableLanguageServices;\n                serverSettings.disableOrganizeImports = !!pyrightSection.disableOrganizeImports;\n                if (pyrightSection.typeCheckingMode !== undefined) {\n                    serverSettings.typeCheckingMode = pyrightSection.typeCheckingMode;\n                }\n            }\n        } catch (error) {\n            this.console.error(`Error reading settings: ${error}`);\n        }\n        return serverSettings;\n    }\n\n    createBackgroundAnalysis(): BackgroundAnalysisBase | undefined {\n        if (isDebugMode() || !getCancellationFolderName()) {\n            // Don't do background analysis if we're in debug mode or an old client\n            // is used where cancellation is not supported.\n            return undefined;\n        }\n\n        return new BackgroundAnalysis(this.console);\n    }\n\n    protected executeCommand(params: ExecuteCommandParams, token: CancellationToken): Promise<any> {\n        return this._controller.execute(params, token);\n    }\n\n    protected isLongRunningCommand(command: string): boolean {\n        return this._controller.isLongRunningCommand(command);\n    }\n\n    protected async executeCodeAction(\n        params: CodeActionParams,\n        token: CancellationToken\n    ): Promise<(Command | CodeAction)[] | undefined | null> {\n        this.recordUserInteractionTime();\n\n        const filePath = convertUriToPath(params.textDocument.uri);\n        const workspace = await this.getWorkspaceForFile(filePath);\n        return CodeActionProvider.getCodeActionsForPosition(workspace, filePath, params.range, token);\n    }\n}\n\nfunction reporterFactory(connection: ProgressReporterConnection): ProgressReporter {\n    return {\n        isEnabled(data: AnalysisResults): boolean {\n            return true;\n        },\n\n        begin(): void {\n            connection.sendNotification('pyright/beginProgress');\n        },\n\n        report(message: string): void {\n            connection.sendNotification('pyright/reportProgress', message);\n        },\n\n        end(): void {\n            connection.sendNotification('pyright/endProgress');\n        },\n    };\n}\n\nexport function main() {\n    if (isMainThread) {\n        new PyrightServer();\n    } else {\n        const runner = new BackgroundAnalysisRunner();\n        runner.start();\n    }\n}\n","/*\n * workspaceMap.ts\n *\n * Workspace management related functionality.\n */\n\nimport { createDeferred } from './common/deferred';\nimport { LanguageServerBase, WorkspaceServiceInstance } from './languageServerBase';\n\nexport class WorkspaceMap extends Map<string, WorkspaceServiceInstance> {\n    private _defaultWorkspacePath = '<default>';\n\n    constructor(private _ls: LanguageServerBase) {\n        super();\n    }\n\n    getNonDefaultWorkspaces(): WorkspaceServiceInstance[] {\n        const workspaces: WorkspaceServiceInstance[] = [];\n        this.forEach((workspace) => {\n            if (workspace.rootPath) {\n                workspaces.push(workspace);\n            }\n        });\n\n        return workspaces;\n    }\n\n    getWorkspaceForFile(filePath: string): WorkspaceServiceInstance {\n        let bestRootPath: string | undefined;\n        let bestInstance: WorkspaceServiceInstance | undefined;\n\n        this.forEach((workspace) => {\n            if (workspace.rootPath) {\n                // Is the file is under this workspace folder?\n                if (filePath.startsWith(workspace.rootPath)) {\n                    // Is this the fist candidate? If not, is this workspace folder\n                    // contained within the previous candidate folder? We always want\n                    // to select the innermost folder, since that overrides the\n                    // outer folders.\n                    if (bestRootPath === undefined || workspace.rootPath.startsWith(bestRootPath)) {\n                        bestRootPath = workspace.rootPath;\n                        bestInstance = workspace;\n                    }\n                }\n            }\n        });\n\n        // If there were multiple workspaces or we couldn't find any,\n        // create a default one to use for this file.\n        if (bestInstance === undefined) {\n            let defaultWorkspace = this.get(this._defaultWorkspacePath);\n            if (!defaultWorkspace) {\n                // If there is only one workspace, use that one.\n                const workspaceNames = [...this.keys()];\n                if (workspaceNames.length === 1) {\n                    return this.get(workspaceNames[0])!;\n                }\n\n                // Create a default workspace for files that are outside\n                // of all workspaces.\n                defaultWorkspace = {\n                    workspaceName: '',\n                    rootPath: '',\n                    rootUri: '',\n                    serviceInstance: this._ls.createAnalyzerService(this._defaultWorkspacePath),\n                    disableLanguageServices: false,\n                    disableOrganizeImports: false,\n                    isInitialized: createDeferred<boolean>(),\n                };\n                this.set(this._defaultWorkspacePath, defaultWorkspace);\n                this._ls.updateSettingsForWorkspace(defaultWorkspace).ignoreErrors();\n            }\n\n            return defaultWorkspace;\n        }\n\n        return bestInstance;\n    }\n}\n"],"sourceRoot":""}